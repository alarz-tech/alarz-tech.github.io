<!DOCTYPE html>
<html lang="en">

<head>
	<title>
		Hop Race 3D Playable Ad
	</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		html {
    		font-size: min(4vw, 4vh);
  		}

		#curtain {
			width: 100vw;
			height: 100vh;
			background: black;
			opacity: 0;
			animation-fill-mode: forwards;
		}

		#intro-text {
			top:60%;
			width: 20rem;
			margin-left: -10rem;
			font-size: 1.5rem;
		}

		#progress-counter {
			bottom: 2rem;
			width: 12rem;
			margin-left: -6rem;
		}

		.text {
			position: absolute;
			left:  50%;
			text-align: center;
			user-select: none;
			pointer-events: none;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			color: beige;
			font-size: 2rem;
			background-color: rgb(57, 54, 68);
			border-radius: 20px;
		}

		#buttons {
			position: absolute;
			width: 14rem;
			margin-left: -7rem;
			margin-top: -5rem;
			top: 50%;
			left: 50%;
		}

		.button {
			width: 100%;
		}

		#btn2 {
			padding-bottom: 0.7rem;
		}

		.hidden {
			display: none;
		}

		.visible {
			display: block;
		}

		.overlay {
			position: absolute;
			pointer-events: none;
		}

		.text-scale {
			animation: 1s ease-in 0s infinite alternate text-scale;
		}

		@keyframes text-scale{
			from { transform: scale(.9, .9); }
			to { transform: scale(1.1, 1.1);}
		}

		.screen-change {
			animation-name: screen-change;
			animation-duration: 1s;
		}

		@keyframes screen-change {
			0% { opacity: 0; }
			/* 30% { opacity: 0.1; } */
			100% { opacity: 0.8; }
		}
	</style>
</head>

<body>
	<div id="curtain" class="overlay"></div>
	<div id="intro-text" class="hidden overlay text text-scale"><p>TAP & HOLD TO MOVE<br>DOUBLE TAP TO JUMP</p></div>
	<div id="progress-counter" class="hidden overlay text"><p>00:00</p></div>
	<div id="buttons">
		<input id="btn2" class="hidden button" type="image" src='data:image/png;base64,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'/>
		<input id="btn3" class="hidden button" type="image" src='data:image/png;base64,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'/>
	</div>
	<div id="container" touch-action="none"></div>
<script type="text/javascript">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/Cop.glb":
/*!************************!*\
  !*** ./assets/Cop.glb ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAADQiwEAxBMAAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjk2MjQwfV0sImFzc2V0Ijp7InZlcnNpb24iOiIyLjAiLCJnZW5lcmF0b3IiOiJnbHRmcGFjayAwLjE2In0sImV4dGVuc2lvbnNVc2VkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiJdLCJleHRlbnNpb25zUmVxdWlyZWQiOlsiS0hSX21lc2hfcXVhbnRpemF0aW9uIl0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjAsImJ5dGVMZW5ndGgiOjUxMjMyLCJieXRlU3RyaWRlIjo4LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NTEyMzIsImJ5dGVMZW5ndGgiOjI1NjE2LCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NzY4NDgsImJ5dGVMZW5ndGgiOjE5MzkyLCJ0YXJnZXQiOjM0OTYzfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjI2MywidHlwZSI6IlZFQzMiLCJtaW4iOlsyNzgsNTEyLDQ1MzBdLCJtYXgiOls3NTI5LDQ5MzAsMTE2NDFdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjAsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyNjMsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6NDMyLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyMTA0LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTMwLCJ0eXBlIjoiVkVDMyIsIm1pbiI6Wzc4NiwzMzIxLDI0MzFdLCJtYXgiOls3MDIxLDQ3NjAsMTE0NTFdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjEwNTIsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoxMzAsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0Ijo4NjQsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxODYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjMxNDQsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoyMjU1LCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzQ1MSw0MTAsMTk5XSwibWF4IjpbNzM1NywyMzg3LDE2MTU1XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoxNTcyLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MjI1NSwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjEyMzYsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNDMyLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyMTE4NCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyIsIm1pbiI6Wzg3MCwxNjM3LDE0ODU4XSwibWF4IjpbNjkzNiwyNDE1LDE1NzY1XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoxMDU5MiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6ODEwMCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjMwLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyMTM2MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjM2MzQsInR5cGUiOiJWRUMzIiwibWluIjpbMCwwLDBdLCJtYXgiOls3ODA3LDUwMTMsMTYzODNdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjEwNjgwLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MzYzNCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjgxNjAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50Ijo1NDYwLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0Ijo1MDQzMiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjUwLCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzExMjYsMjYxMSw4MzddLCJtYXgiOls2NjgwLDU0NDAsNjkwMF19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MjUyMTYsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50Ijo1MCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE5MDgwLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6NzgsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjUwODMyLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjQsInR5cGUiOiJWRUMzIiwibWluIjpbMzQ3NCw1MDEzLDU5NjJdLCJtYXgiOls0MzMzLDU0NDAsNjkwMF19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MjU0MTYsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyNCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE5MjM2LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjUxMDI0LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjYsInR5cGUiOiJWRUMzIiwibWluIjpbMjI1Myw1MDEzLDU5NDRdLCJtYXgiOlszNDc0LDU0NDAsNjkwMF19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MjU1MTIsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyNiwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE5MzA4LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6NDIsInR5cGUiOiJTQ0FMQVIifV0sIm1hdGVyaWFscyI6W3sibmFtZSI6IldoaXRlIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC42ODU5NDkwODcsMC42ODU5NDkwODcsMC42ODU5NDkwODcsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJXaW5kb3dzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4wMzU2MDEzMTc5LDAuMDM1NjAxMzE3OSwwLjAzNTYwMTMxNzksMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJHcmV5IiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4yMDE1NTYyOCwwLjIwMTU1NjI4LDAuMjAxNTU2MjgsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJIZWFkbGlnaHRzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC43OTkxMDI3ODMsMC4zNzYyNjIxMjgsMC4xMjc0Mzc3MTEsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJCbGFjayIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMDEzNzAyMDg2MiwwLjAxMzcwMjA4NjIsMC4wMTM3MDIwODYyLDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiVGFpbExpZ2h0cyIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNzk5MTAyNzgzLDAuMDkzMDU4OTczNiwwLjA3NDIxMzU3OTMsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJXaGl0ZUxpZ2h0cyIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuODAwMDAwMDEyLDAuODAwMDAwMDEyLDAuODAwMDAwMDEyLDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiQmx1ZUxpZ2h0cyIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMDUyMjE3NTY5MiwwLjE5NzczNTc0MiwwLjgwMDAwMDA3MiwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9XSwibWVzaGVzIjpbeyJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowLCJOT1JNQUwiOjF9LCJtb2RlIjo0LCJpbmRpY2VzIjoyLCJtYXRlcmlhbCI6MH0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjozLCJOT1JNQUwiOjR9LCJtb2RlIjo0LCJpbmRpY2VzIjo1LCJtYXRlcmlhbCI6MX0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjo2LCJOT1JNQUwiOjd9LCJtb2RlIjo0LCJpbmRpY2VzIjo4LCJtYXRlcmlh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p/amAKb8WQCm/FkApvxZAKb8WQAABH8AAAR/AAAEfwAABH8AAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEwARABAAEwAUABEAEAASABUAFgAVABIAFAAXABgAFAAZABcAFgASABoAGwAWABoAEgAcABoAEgAdABwAHQAeABwAHQAfAB4AHAAeACAAHAAgACEAGgAcACEAIQAgACIAIQAiACMAGgAhACQAJAAhACMAGwAaACQAJAAjACUAJgAbACQAJgAkACUAJwAoACkAJwApACoAKwAsAC0AKwAtAC4ALwAwADEALwAxADIAMwA0ADUAMwA1ADYANwA4ADkANwA5ADoAOwA8AD0AOwA9AD4APwBAAEEAPwBBAEIAQwBEAEUAQwBFAEYARwBIAEkARwBJAEoASwBMAE0ASwBNAE4ATwBQAFEATwBRAFIAUwBUAFUAUwBVAFYAVwBYAFkAVwBZAFoAWwBcAF0AWwBdAF4AXwBgAGEAXwBhAGIAYwBkAGUAYwBlAGYAZwBoAGkAZwBpAGoAawBsAG0AawBtAG4AbwBwAHEAbwBxAHIAcwB0AHUAcwB1AHYAdwB4AHkAdwB5AHoAewB8AH0AewB9AH4AfwCAAIEAfwCBAIIAgwCEAIUAgwCFAIYAhwCIAIkAhwCJAIoAiwCMAI0AiwCNAI4AjwCQAJEAjwCRAJIAkwCUAJUAkwCVAJYAlwCYAJkAlwCZAJoAmwCcAJ0AmwCdAJ4AnwCgAKEAnwChAKIAowCkAKUAowClAKYApwCoAKkApwCpAKoAqwCsAK0AqwCtAK4ArwCwALEArwCxALIAswC0ALUAswC1ALYAtwC4ALkAtwC5ALoAuwC8AL0AuwC9AL4AvwDAAMEAvwDBAMIAwwDEAMUAwwDFAMYAxwDIAMkAxwDJAMoAywDMAM0AywDNAM4AzwDQANEAzwDRANIA0wDUANUA0wDVANYA1wDYANkA1wDZANoA2wDcAN0A2wDdAN4A3wDgAOEA3wDhAOIA4wDkAOUA4wDlAOYA5wDoAOkA5wDpAOoA6wDsAO0A6wDtAO4A7wDwAPEA7wDxAPIA8wD0APUA8wD1APYA9wD4APkA9wD5APoA+wD8AP0A+wD9AP4A/wAAAQEB/wABAQIBAwEEAQUBAwEFAQYBAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHwAgACEAHwAhACIAIwAkACUAJgAnACgAKQAqACsAKQArACwALQAuAC8ALQAvADAAMQAyADMAMQAzADQANQA2ADcANQA3ADgAOQA6ADsAOQA7ADwAPQA+AD8APQA/AEAAQQBCAEMAQQBDAEQARQBGAEcARQBHAEgASQBKAEsASQBLAEwATQBOAE8ATQBPAFAAUQBSAFMAUQBTAFQAVQBWAFcAVQBXAFgAWQBaAFsAWQBbAFwAXQBeAF8AYABhAGIAYABiAGMAZABlAGYAZwBoAGkAagBrAGwAagBsAG0AbgBvAHAAbgBwAHEAcgBzAHQAcgB0AHUAdgB3AHgAdgB4AHkAegB7AHwAegB8AH0AfgB/AIAAfgCAAIEAAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACwAMAA0ADgAPABAADgAQABEAEgATABQAEgAUABUAFgAXABgAFgAYABkAGgAbABwAHQAeAB8AIAAhACIAIAAiACMAJAAlACYAJAAmACcAKAApACoAKAAqACsALAAtAC4ALAAuAC8AMAAxADIAMAAyADMANAA1ADYANAA2ADcAOAA5ADoAOAA6ADsAPAA9AD4APAA+AD8AQABBAEIAQABCAEMARABFAEYARABGAEcASABJAEoASABKAEsATABNAE4ATABOAE8AUABRAFIAUABSAFMAVABVAFYAVABWAFcAWABZAFoAWABaAFsAWgBcAFsAXQBeAFgAXwBdAFgAWwBfAFgAXwBgAF0AWwBhAF8AYQBiAF8AWwBjAGEAZABlAGYAZABmAGcAaABpAGoAaABqAGsAbABtAG4AbABuAG8AcABxAHIAcAByAHMAdAB1AHYAdAB2AHcAeAB5AHoAeAB6AHsAfAB9AH4AfAB+AH8AgACBAIIAgACCAIMAhACFAIYAhACGAIcAiACJAIoAiACKAIsAjACNAI4AjACOAI8AkACRAJIAkACSAJMAlACVAJYAlACWAJcAmACZAJoAmACaAJsAnACdAJ4AnACeAJ8AoAChAKIAoACiAKMApAClAKYApACmAKcAqACpAKoAqACqAKsArACtAK4ArACuAK8AsACxALIAsACyALMAtAC1ALYAtAC2ALcAuAC5ALoAuAC6ALsAvAC9AL4AvAC+AL8AwAC8AMEAwADBAMIAwwDAAMQAwwDEAMUAxgDDAMcAxgDHAMgAyQDKAMsAyQDLAMwAzQDOAM8AzQDPANAA0QDSANMA0QDTANQA1QDWANcA1QDXANgA2QDaANsA2QDbANwA3QDeAN8A3QDfAOAA4QDiAOMA4QDjAOQA5QDmAOcA5QDnAOgA6QDqAOsA6QDrAOwA7QDuAO8A7QDvAPAA8QDyAPMA8QDzAPQA9QD2APcA9QD3APgA+QD6APsA+QD7APwA/QD+AP8A/QD/AAABAQECAQMBAQEDAQQBBQEGAQcBBQEHAQgBCQEKAQsBCQELAQwBDQEOAQ8BDQEPARABEQESARMBEQETARQBFQEWARcBFQEXARgBGQEaARsBGQEbARwBHQEZAR4BHQEeAR8BIAEdASEBIAEhASIBIwEkASUBIwElASYBJwEoASkBJwEpASoBKwEsAS0BKwEtAS4BLwEwATEBLwExATIBMwE0ATUBMwE1ATYBNwE4ATkBNwE5AToBOwE8AT0BOwE9AT4BPwFAAUEBPwFBAUIBQwFEAUUBQwFFAUYBRwFIAUkBRwFJAUoBSwFMAU0BSwFNAU4BTwFQAVEBTwFRAVIBUwFUAVUBUwFVAVYBVwFYAVkBVwFZAVoBWwFcAV0BWwFdAV4BXwFgAWEBXwFhAWIBYwFkAWUBYwFlAWYBZwFoAWkBZwFpAWoBawFsAW0BawFtAW4BbwFwAXEBbwFxAXIBcwF0AXUBcwF1AXYBdwF4AXkBdwF5AXoBewF8AX0BewF9AX4BfwGAAYEBfwGBAYIBgwGEAYUBgwGFAYYBhwGIAYkBhwGJAYoBiwGMAY0BiwGNAY4BjwGQAZEBjwGRAZIBkwGUAZUBkwGVAZYBlwGYAZkBlwGZAZoBmwGcAZ0BmwGdAZ4BnwGgAaEBnwGhAaIBowGkAaUBowGlAaYBpwGoAakBpwGpAaoBqwGsAa0BqwGtAa4BrwGwAbEBrwGxAbIBswG0AbUBswG1AbYBtwG4AbkBtwG5AboBuwG8Ab0BuwG9Ab4BvwHAAcEBvwHBAcIBwwHEAcUBwwHFAcYBxwHIAckBxwHJAcoBywHMAc0BywHNAc4BzwHQAdEBzwHRAdIB0wHUAdUB0wHVAdYB1wHYAdkB1wHZAdoB2wHcAd0B2wHdAd4B3wHgAeEB3wHhAeIB4wHkAeUB4wHlAeYB5wHoAekB5wHpAeoB6wHsAe0B6wHtAe4B7wHwAfEB7wHxAfIB8wH0AfUB8wH1AfYB9wH4AfkB9wH5AfoB+wH8Af0B+wH9Af4B/wEAAgEC/wEBAgICAwIEAgUCAwIFAgYCBwIIAgkCBwIJAgoCCwIMAg0CCwINAg4CDwIQAhECDwIRAhICEwIUAhUCEwIVAhYCFwIYAhkCFwIZAhoCGwIcAh0CGwIdAh4CHwIgAiECHwIhAiICIwIkAiUCIwIlAiYCJwIoAikCJwIpAioCKwIsAi0CKwItAi4CLwIwAjECLwIxAjICMwI0AjUCMwI1AjYCNwI4AjkCNwI5AjoCOwI8Aj0COwI9Aj4CPwJAAkECPwJBAkICQwJEAkUCQwJFAkYCRwJIAkkCRwJJAkoCSwJMAk0CSwJNAk4CTwJQAlECTwJRAlICUwJUAlUCUwJVAlYCVwJYAlkCVwJZAloCWwJcAl0CWwJdAl4CXwJgAmECXwJhAmICYwJkAmUCYwJlAmYCZwJoAmkCZwJpAmoCawJsAm0CawJtAm4CbwJwAnECbwJxAnICcwJ0AnUCcwJ1AnYCdwJ4AnkCdwJ5AnoCewJ8An0CewJ9An4CfwKAAoECfwKBAoICgQKDAoIChAKFAn8ChgKEAn8CggKGAn8ChgKHAoQCggKIAoYCiAKJAoYCggKKAogCiwKMAo0CiwKNAo4CjwKQApECjwKRApICkwKUApUCkwKVApYClwKYApkClwKZApoCmwKcAp0CmwKdAp4CnwKgAqECnwKhAqICowKkAqUCowKlAqYCpwKoAqkCpwKpAqoCqwKsAq0CqwKtAq4CrwKwArECrwKxArICswK0ArUCswK1ArYCtwK4ArkCtwK5AroCuwK8Ar0CuwK9Ar4CvwLAAsECvwLBAsICwwLEAsUCwwLFAsYCxwLIAskCxwLJAsoCywLMAs0CywLNAs4CzwLQAtECzwLRAtIC0wLUAtUC0wLVAtYC1wLYAtkC1wLZAtoC2wLcAt0C2wLdAt4C3wLgAuEC3wLhAuIC4wLkAuUC4wLlAuYC5wLoAukC5wLpAuoC6wLsAu0C6wLtAu4C7wLwAvEC7wLxAvIC8wL0AvUC8wL1AvYC9wL4AvkC9wL5AvoC+wL8Av0C+wL9Av4C/wIAAwED/wIBAwIDAwMEAwUDAwMFAwYDBwMIAwkDBwMJAwoDCwMMAw0DCwMNAw4DDwMQAxEDDwMRAxIDEwMUAxUDEwMVAxYDFwMYAxkDFwMZAxoDGwMcAx0DGwMdAx4DHwMgAyEDHwMhAyIDIwMkAyUDIwMlAyYDJwMoAykDJwMpAyoDKwMsAy0DKwMtAy4DLwMwAzEDLwMxAzIDMwM0AzUDMwM1AzYDNwM4AzkDNwM5AzoDOwM8Az0DOwM9Az4DPwNAA0EDPwNBA0IDQwNEA0UDQwNFA0YDRwNIA0kDRwNJA0oDSwNMA00DSwNNA04DTwNQA1EDTwNRA1IDUwNUA1UDUwNVA1YDVwNYA1kDVwNZA1oDWwNcA10DWwNdA14DXwNgA2EDXwNhA2IDYwNkA2UDYwNlA2YDZwNoA2kDZwNpA2oDawNsA20DawNtA24DbwNwA3EDbwNxA3IDcwN0A3UDcwN1A3YDdwN4A3kDdwN5A3oDewN8A30DewN9A34DfwOAA4EDfwOBA4IDgwOEA4UDgwOFA4YDhwOIA4kDhwOJA4oDiwOMA40DiwONA44DjwOQA5EDjwORA5IDkwOUA5UDkwOVA5YDlwOYA5kDlwOZA5oDmwOcA50DmwOdA54DnwOgA6EDnwOhA6IDowOkA6UDowOlA6YDpwOoA6kDpwOpA6oDqwOsA60DqwOtA64DrwOwA7EDrwOxA7IDswO0A7UDswO1A7YDtwO4A7kDtwO5A7oDuwO8A70DuwO9A74DvwPAA8EDvwPBA8IDwwPEA8UDwwPFA8YDxwPIA8kDxwPJA8oDywPMA80DywPNA84DzwPQA9EDzwPRA9ID0wPUA9UD0wPVA9YD1wPYA9kD1wPZA9oD2wPcA90D2wPdA94D3wPgA+ED3wPhA+ID4wPkA+UD4wPlA+YD5wPoA+kD5wPpA+oD6wPsA+0D6wPtA+4D7wPwA/ED7wPxA/ID8wP0A/UD8wP1A/YD9wP4A/kD9wP5A/oD+wP8A/0D+wP9A/4D/wMABAEE/wMBBAIEAwQEBAUEAwQFBAYEBwQIBAkEBwQJBAoECwQMBA0ECwQNBA4EDwQQBBEEDwQRBBIEEwQUBBUEEwQVBBYEFwQYBBkEFwQZBBoEGwQcBB0EGwQdBB4EHwQgBCEEHwQhBCIEIwQkBCUEIwQlBCYEJwQoBCkEJwQpBCoEKwQsBC0EKwQtBC4ELwQwBDEELwQxBDIEMwQ0BDUEMwQ1BDYENwQ4BDkENwQ5BDoEOwQ8BD0EOwQ9BD4EPwRABEEEPwRBBEIEQwREBEUEQwRFBEYERwRIBEkERwRJBEoESwRMBE0ESwRNBE4ETwRQBFEETwRRBFIEUwRUBFUEUwRVBFYEVwRYBFkEVwRZBFoEWwRcBF0EWwRdBF4EXwRgBGEEXwRhBGIEYwRkBGUEYwRlBGYEZwRoBGkEZwRpBGoEawRsBG0EawRtBG4EbwRwBHEEbwRxBHIEcwR0BHUEcwR1BHYEdwR4BHkEdwR5BHoEewR8BH0EewR9BH4EfwSABIEEfwSBBIIEgwSEBIUEgwSFBIYEhwSIBIkEhwSJBIoEiwSMBI0EiwSNBI4EjwSQBJEEjwSRBJIEkwSUBJUEkwSVBJYElwSYBJkElwSZBJoEmwScBJ0EmwSdBJ4EnwSgBKEEnwShBKIEowSkBKUEowSlBKYEpwSoBKkEpwSpBKoEqwSsBK0EqwStBK4ErQSvBK4EsASxBKsEsgSwBKsErgSyBKsEsgSzBLAErgS0BLIEtAS1BLIErgS2BLQEtwS4BLkEtwS5BLoEuwS8BL0EuwS9BL4EvwTABMEEvwTBBMIEwwTEBMUEwwTFBMYExwTIBMkExwTJBMoEywTMBM0EywTNBM4EzwTQBNEEzwTRBNIE0wTUBNUE0wTVBNYE1wTYBNkE1wTZBNoE2wTcBN0E2wTdBN4E3wTgBOEE3wThBOIE4wTkBOUE4wTlBOYE5wToBOkE5wTpBOoE6wTsBO0E6wTtBO4E7wTwBPEE7wTxBPIE8wT0BPUE8wT1BPYE9wT4BPkE9wT5BPoE+wT8BP0E+wT9BP4E/wQABQEF/wQBBQIFAwUEBQUFAwUFBQYFBwUIBQkFBwUJBQoFCwUMBQ0FCwUNBQ4FDwUQBREFDwURBRIFEwUUBRUFEwUVBRYFFwUYBRkFFwUZBRoFGwUcBR0FGwUdBR4FHwUgBSEFHwUhBSIFIwUkBSUFIwUlBSYFJwUoBSkFJwUpBSoFKwUsBS0FKwUtBS4FLwUwBTEFLwUxBTIFMwU0BTUFMwU1BTYFNwU4BTkFNwU5BToFOwU8BT0FOwU9BT4FPwVABUEFPwVBBUIFQwVEBUUFQwVFBUYFRwVIBUkFRwVJBUoFSwVMBU0FSwVNBU4FTwVQBVEFTwVRBVIFUwVUBVUFUwVVBVYFVwVYBVkFVwVZBVoFWwVcBV0FWwVdBV4FXwVgBWEFXwVhBWIFYwVkBWUFYwVlBWYFZwVoBWkFZwVpBWoFawVsBW0FawVtBW4FbwVwBXEFbwVxBXIFcwV0BXUFcwV1BXYFdwV4BXkFdwV5BXoFewV8BX0FewV9BX4FfwWABYEFfwWBBYIFgwWEBYUFgwWFBYYFhwWIBYkFhwWJBYoFiwWMBY0FiwWNBY4FjwWQBZEFjwWRBZIFkwWUBZUFkwWVBZYFlwWYBZkFlwWZBZoFmwWcBZ0FmwWdBZ4FnwWgBaEFnwWhBaIFowWkBaUFowWlBaYFpwWoBakFpwWpBaoFqwWsBa0FqwWtBa4FrwWwBbEFrwWxBbIFswW0BbUFswW1BbYFtwW4BbkFtwW5BboFuwW8Bb0FuwW9Bb4FvwXABcEFvwXBBcIFwwXEBcUFwwXFBcYFxwXIBckFxwXJBcoFywXMBc0FywXNBc4FzwXQBdEFzwXRBdIF0wXUBdUF0wXVBdYF1wXYBdkF1wXZBdoF2wXcBd0F2wXdBd4F3wXgBeEF3wXhBeIF4wXkBeUF4wXlBeYF5wXoBekF5wXpBeoF6wXsBe0F6wXtBe4F7wXwBfEF7wXxBfIF8wX0BfUF8wX1BfYF9wX4BfkF9wX5BfoF+wX8Bf0F+wX9Bf4F/wUABgEG/wUBBgIGAwYEBgUGAwYFBgYGBwYIBgkGBwYJBgoGCwYMBg0GCwYNBg4GDwYQBhEGDwYRBhIGEwYUBhUGEwYVBhYGFwYYBhkGFwYZBhoGGwYcBh0GGwYdBh4GHwYgBiEGHwYhBiIGIwYkBiUGIwYlBiYGJwYoBikGJwYpBioGKwYsBi0GKwYtBi4GLwYwBjEGLwYxBjIGMwY0BjUGMwY1BjYGNwY4BjkGNwY5BjoGOwY8Bj0GOwY9Bj4GPwZABkEGPwZBBkIGQwZEBkUGQwZFBkYGRwZIBkkGRwZJBkoGSwZMBk0GSwZNBk4GTwZQBlEGTwZRBlIGUwZUBlUGUwZVBlYGVwZYBlkGVwZZBloGWwZcBl0GWwZdBl4GXwZgBmEGXwZhBmIGYwZkBmUGYwZlBmYGZwZoBmkGZwZpBmoGawZsBm0GawZtBm4GbwZwBnEGbwZxBnIGcwZ0BnUGcwZ1BnYGdwZ4BnkGdwZ5BnoGewZ8Bn0GewZ9Bn4GfwaABoEGfwaBBoIGgwaEBoUGgwaFBoYGhwaIBokGhwaJBooGiwaMBo0GiwaNBo4GjwaQBpEGjwaRBpIGkwaUBpUGkwaVBpYGlwaYBpkGlwaZBpoGmwacBp0GmwadBp4GnwagBqEGnwahBqIGowakBqUGowalBqYGpwaoBqkGpwapBqoGqwasBq0GqwatBq4GrwawBrEGrwaxBrIGswa0BrUGswa1BrYGtwa4BrkGtwa5BroGuwa8Br0Guwa9Br4GvwbABsEGvwbBBsIGwwbEBsUGwwbFBsYGxwbIBskGxwbJBsoGywbMBs0GywbNBs4GzwbQBtEGzwbRBtIG0wbUBtUG0wbVBtYG1wbYBtkG1wbZBtoG2QbbBtoG3AbdBtcG3gbcBtcG2gbeBtcG3gbfBtwG2gbgBt4G4AbhBt4G2gbiBuAG4wbkBuUG4wblBuYG5wboBukG5wbpBuoG6wbsBu0G6wbtBu4G7wbwBvEG7wbxBvIG8wb0BvUG8wb1BvYG9wb4BvkG9wb5BvoG+wb8Bv0G+wb9Bv4G/wYABwEH/wYBBwIHAwcEBwUHAwcFBwYHBwcIBwkHBwcJBwoHCwcMBw0HCwcNBw4HDwcQBxEHDwcRBxIHEwcUBxUHEwcVBxYHFwcYBxkHFwcZBxoHGwccBx0HGwcdBx4HHwcgByEHHwchByIHIwckByUHIwclByYHJwcoBykHJwcpByoHKwcsBy0HKwctBy4HLwcwBzEHLwcxBzIHMwc0BzUHMwc1BzYHNwc4BzkHNwc5BzoHOwc8Bz0HOwc9Bz4HPwdAB0EHPwdBB0IHQwdEB0UHQwdFB0YHRwdIB0kHRwdJB0oHSwdMB00HSwdNB04HTwdQB1EHTwdRB1IHUwdUB1UHUwdVB1YHVwdYB1kHVwdZB1oHWwdcB10HWwddB14HXwdgB2EHXwdhB2IHYwdkB2UHYwdlB2YHZwdoB2kHZwdpB2oHawdsB20HawdtB24HbwdwB3EHbwdxB3IHcwd0B3UHcwd1B3YHdwd4B3kHdwd5B3oHewd8B30Hewd9B34HfweAB4EHfweBB4IHgweEB4UHgweFB4YHhweIB4kHhweJB4oHiweMB40HiweNB44HjweQB5EHjweRB5IHkweUB5UHkweVB5YHlweYB5kHlweZB5oHmwecB50HmwedB54HnwegB6EHnwehB6IHowekB6UHowelB6YHpweoB6kHpwepB6oHqwesB60HqwetB64HrwewB7EHrwexB7IHswe0B7UHswe1B7YHtwe4B7kHtwe5B7oHuwe8B70Huwe9B74HvwfAB8EHvwfBB8IHwwfEB8UHwwfFB8YHxwfIB8kHxwfJB8oHywfMB80HywfNB84HzwfQB9EHzwfRB9IH0wfUB9UH0wfVB9YH1wfYB9kH1wfZB9oH2wfcB90H2wfdB94H3wfgB+EH3wfhB+IH4wfkB+UH4wflB+YH5wfoB+kH5wfpB+oH6wfsB+0H6wftB+4H7wfwB/EH7wfxB/IH8wf0B/UH8wf1B/YH9wf4B/kH9wf5B/oH+wf8B/0H+wf9B/4H/wcACAEI/wcBCAIIAwgECAUIAwgFCAYIBwgICAkIBwgJCAoICwgMCA0ICwgNCA4IDwgQCBEIDwgRCBIIEwgUCBUIEwgVCBYIFwgYCBkIFwgZCBoIGwgcCB0IGwgdCB4IHwggCCEIHwghCCIIIwgkCCUIIwglCCYIJwgoCCkIJwgpCCoIKwgsCC0IKwgtCC4ILwgwCDEILwgxCDIIMwg0CDUIMwg1CDYINwg4CDkINwg5CDoIOwg8CD0IOwg9CD4IPwhACEEIPwhBCEIIQwhECEUIQwhFCEYIRwhICEkIRwhJCEoISwhMCE0ISwhNCE4ITwhQCFEITwhRCFIIUwhUCFUIUwhVCFYIVwhYCFkIVwhZCFoIWwhcCF0IWwhdCF4IXwhgCGEIXwhhCGIIYwhkCGUIYwhlCGYIZwhoCGkIZwhpCGoIawhsCG0IawhtCG4IbwhwCHEIbwhxCHIIcwh0CHUIcwh1CHYIdwh4CHkIdwh5CHoIewh8CH0Iewh9CH4IfwiACIEIfwiBCIIIgwiECIUIgwiFCIYIhwiICIkIhwiJCIoIiwiMCI0IiwiNCI4IjwiQCJEIjwiRCJIIkwiUCJUIkwiVCJYIlwiYCJkIlwiZCJoImwicCJ0ImwidCJ4InwigCKEInwihCKIIowikCKUIowilCKYIpwioCKkIpwipCKoIqwisCK0IqwitCK4IrwiwCLEIrwixCLIIswi0CLUIswi1CLYItwi4CLkItwi5CLoIuwi8CL0Iuwi9CL4IvwjACMEIvwjBCMIIwwjECMUIwwjFCMYIxwjICMkIxwjJCMoIywjMCM0IywjNCM4IAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHAAeAB8AIAAhACIAIAAiACMAJAAlACYAJAAmACcAKAApACoAKAAqACsALAAtAC4ALAAuAC8AMAAxADIAMAAyADMANAA1ADYANAA2ADcAOAA5ADoAOAA6ADsAPAA9AD4APAA+AD8AQABBAEIAQABCAEMARABFAEYARABGAEcASABJAEoASABKAEsATABNAE4ATABOAE8AUABRAFIAUABSAFMAVABVAFYAVABWAFcAWABZAFoAWABaAFsAXABdAF4AXABeAF8AYABhAGIAYABiAGMAZABlAGYAZABmAGcAaABpAGoAaABqAGsAbABtAG4AbwBwAHEAbwBxAHIAcwB0AHUAcwB1AHYAdwB4AHkAdwB5AHoAewB8AH0AewB9AH4AfwCAAIEAfwCBAIIAgwCEAIUAgwCFAIYAhwCIAIkAhwCJAIoAiwCMAI0AiwCNAI4AjwCQAJEAjwCRAJIAkwCUAJUAkwCVAJYAlwCYAJkAlwCZAJoAmwCcAJ0AngCfAKAAngCgAKEAogCjAKQAogCkAKUApgCnAKgApgCoAKkAqgCrAKwAqgCsAK0ArgCvALAArgCwALEAsgCzALQAsgC0ALUAtgC3ALgAtgC4ALkAugC7ALwAvQC+AL8AvQC/AMAAwQDCAMMAwQDDAMQAxQDGAMcAxQDHAMgAyQDKAMsAyQDLAMwAzQDOAM8AzQDPANAA0QDSANMA0QDTANQA1QDWANcA1QDXANgA2QDaANsA2QDbANwA3QDeAN8A3QDfAOAA4QDiAOMA4QDjAOQA5QDmAOcA5QDnAOgA6QDqAOsA6QDrAOwA7QDuAO8A7QDvAPAA8QDyAPMA9AD1APYA9wD1APQA9AD2APgA+QD6APsA+QD7APwA/QD+AP8A/QD/AAABAAH/AAEBAgEDAQQBAgEEAQUBBgEHAQgBBgEIAQkBCgELAQwBCgEMAQ0BDgEPARABDgEQAREBEgETARQBEgEUARUBFgEXARgBFgEYARkBGgEbARwBGgEcAR0BHgEfASABHgEgASEBIgEjASQBIgEkASUBJgEnASgBKAEpASYBKQEqASYBKAErASkBLAEtAS4BLAEuAS8BMAExATIBMAEyATMBNAE1ATYBNAE2ATcBOAE5AToBOAE6ATsBPAE9AT4BPAE+AT8BQAFBAUIBQAFCAUMBRAFFAUYBRAFGAUcBSAFJAUoBSAFKAUsBTAFNAU4BTAFOAU8BUAFRAVIBUAFSAVMBVAFVAVYBVAFWAVcBWAFZAVoBWAFaAVsBXAFdAV4BXAFeAV8BYAFhAWIBYAFiAWMBZAFlAWYBZAFmAWcBaAFpAWoBaAFqAWsBbAFtAW4BbAFuAW8BcAFxAXIBcwF0AXUBcwF1AXYBdwF4AXkBdwF5AXoBewF8AX0BewF9AX4BfwGAAYEBfwGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBiQGLAYwBjQGOAY8BjQGPAZABkQGSAZMBkQGTAZQBlQGWAZcBmAGZAZoBmAGaAZsBnAGdAZ4BnAGeAZ8BoAGhAaIBoAGiAaMBpAGlAaYBpAGmAacBqAGpAaoBqAGqAasBrAGtAa4BrAGuAa8BsAGxAbIBsAGyAbMBtAG1AbYBtAG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBwQHDAcQBxQHGAccBxQHHAcgByQHKAcsBzAHNAc4BzAHOAc8B0AHRAdIB0AHSAdMB1AHVAdYB1wHYAdkB1wHZAdoB2wHcAd0B2wHdAd4B3wHgAeEB3wHhAeIB4wHkAeUB4wHlAeYB5wHoAekB5wHpAeoB6wHsAe0B6wHtAe4B7wHwAfEB7wHxAfIB8wH0AfUB8wH1AfYB9wH4AfkB9wH5AfoB+wH8Af0B+wH9Af4B/wEAAgEC/wEBAgICAwIEAgUCAwIFAgYCBwIIAgkCBwIJAgoCCwIMAg0CCwINAg4CDwIQAhECDwIRAhICEwIUAhUCEwIVAhYCFwIYAhkCFwIZAhoCGwIcAh0CGwIdAh4CHwIgAiECIgIjAiQCJQImAicCJQInAigCKQIqAisCKQIrAiwCLQIuAi8CLQIvAjACMQIyAjMCMQIzAjQCNQI2AjcCNQI3AjgCOQI6AjsCOQI7AjwCPQI+Aj8CPQI/AkACQQJCAkMCQQJDAkQCRQJGAkcCRQJHAkgCSQJKAksCSQJLAkwCTQJOAk8CTQJPAlACUQJSAlMCUQJTAlQCVQJWAlcCVQJXAlgCWQJaAlsCWQJbAlwCXQJeAl8CXQJfAmACYQJiAmMCYQJjAmQCZQJmAmcCZQJnAmgCaQJqAmsCaQJrAmwCbQJuAm8CbQJvAnACcQJyAnMCcQJzAnQCdQJ2AncCdQJ3AngCeQJ6AnsCfAJ9An4CfAJ+An8CgAKBAoICgAKCAoMChAKFAoYChAKGAocCiAKJAooCiAKKAosCjAKNAo4CjAKOAo8CkAKRApICkAKSApMClAKVApYClwKYApkClwKZApoCmwKcAp0CmwKdAp4CnwKgAqECnwKhAqICowKkAqUCowKlAqYCpwKoAqkCpwKpAqoCqwKsAq0CqwKtAq4CrwKwArECrwKxArICswK0ArUCtgK3ArgCtgK4ArkCugK7ArwCugK8Ar0CvgK/AsACwQLCAsMCwQLDAsQCxQLGAscCxQLHAsgCyQLKAssCyQLLAswCzQLOAs8CzQLPAtAC0QLSAtMC0QLTAtQC1QLWAtcC1QLXAtgC2QLaAtsC2QLbAtwC3QLeAt8C3QLfAuAC4QLiAuMC4QLjAuQC5QLmAucC5QLnAugC6QLqAusC6QLrAuwC7QLuAu8C7QLvAvAC8QLyAvMC8QLzAvQC9QL2AvcC+AL5AvoC+AL6AvsC/AL9Av4C/AL+Av8CAAMBAwIDAAMCAwMDBAMFAwYDBAMGAwcDCAMJAwoDCAMKAwsDDAMNAw4DDAMOAw8DEAMRAxIDEAMSAxMDFAMVAxYDFAMWAxcDGAMZAxoDGAMaAxsDHAMdAx4DHAMeAx8DIAMhAyIDIAMiAyMDJAMlAyYDJAMmAycDKAMpAyoDKAMqAysDLAMtAy4DLAMuAy8DMAMxAzIDMAMyAzMDNAM1AzYDNgM3AzQDNgM4AzcDOQM6AzsDOQM7AzwDPQM+Az8DPQM/A0ADQQNCA0MDQwNEA0EDQwNFA0QDRgNHA0gDRgNIA0kDSgNLA0wDSgNMA00DTgNPA1ADTgNQA1EDUgNTA1QDUgNUA1UDVgNXA1gDVgNYA1kDWgNbA1wDWgNcA10DXgNfA2ADXgNgA2EDYgNjA2QDYgNkA2UDZgNnA2gDZgNoA2kDagNrA2wDagNsA20DbgNvA3ADbgNwA3EDcgNzA3QDdQN2A3cDdQN3A3gDeQN6A3sDeQN7A3wDfQN+A38DfQN/A4ADgQOCA4MDgQODA4QDhQOGA4cDhQOHA4gDiQOKA4sDiQOLA4wDjQOOA48DjQOPA5ADkQONA5ADkgOTA5QDkgOUA5UDlgOXA5gDlgOYA5kDmgObA5wDmgOcA50DngOfA6ADngOgA6EDogOjA6QDogOkA6UDpgOnA6gDpgOoA6kDqgOrA6wDqgOsA60DrgOvA7ADsQOyA7MDsQOzA7QDtQO2A7cDtQO3A7gDuQO6A7sDvAO9A74DvAO+A78DwAPBA8IDwwPEA8UDxgPHA8gDxgPIA8kDygPLA8wDygPMA80DzgPPA9ADzgPQA9ED0gPTA9QD0gPUA9UD1gPXA9gD1gPYA9kD2gPbA9wD2gPcA90D3gPfA+AD3gPgA+ED4gPjA+QD4gPkA+UD5gPnA+gD5gPoA+kD6gPrA+wD6gPsA+0D7gPvA/AD7gPwA/ED8gPzA/QD8gP0A/UD9gP3A/gD+QP6A/sD+QP7A/wD/QP+A/8D/QP/AwAEAQQCBAMEAQQDBAQEBQQGBAcEBQQHBAgECQQKBAsECQQLBAwEDQQOBA8EEAQRBBIEEwQUBBUEEwQVBBYEFwQYBBkEFwQZBBoEGwQcBB0EGwQdBB4EHwQgBCEEHwQhBCIEIwQkBCUEIwQlBCYEJwQoBCkEJwQpBCoEKwQsBC0ELgQvBDAELgQwBDEEMgQzBDQENQQ2BDcENQQ3BDgEOQQ6BDsEPAQ9BD4EPAQ+BD8EQARBBEIEQARCBEMERARFBEYERARGBEcESARJBEoESARKBEsETARNBE4ETAROBE8EUARRBFIEUARSBFMEVARVBFYEVARWBFcEWARZBFoEWARaBFsEXARdBF4EXAReBF8EYARhBGIEYARiBGMEZARlBGYEZARmBGcEaARpBGoEaARqBGsEbARtBG4EbARuBG8EcARxBHIEcARyBHMEdAR1BHYEdAR2BHcEeAR5BHoEeAR6BHsEfAR9BH4EfwSABIEEfwSBBIIEgwSEBIUEgwSFBIYEhwSIBIkEhwSJBIoEiwSMBI0EiwSNBI4EjwSQBJEEjwSRBJIEkwSUBJUEkwSVBJYElwSYBJkElwSZBJoEmwScBJ0EmwSdBJ4EnwSgBKEEoQSiBJ8EoQSjBKIEpASlBKYEpgSnBKQEpwSoBKQEpgSpBKcEqgSrBKwEqgSsBK0EqgStBK4EqgSuBK8EsASxBLIEsASyBLMEtAS1BLYEtgS3BLQEtwS4BLQEtgS5BLcEugS7BLwEvQS+BL8EvQS/BMAEwQTCBMMEwQTDBMQExQTGBMcEyATJBMoEyATKBMsEzATNBM4EzATOBM8E0ATRBNIE0ATSBNME1ATVBNYE1wTYBNkE1wTZBNoE2wTcBN0E3gTfBOAE3gTgBOEE4gTjBOQE4gTkBOUE5gTnBOgE5gToBOkE6gTrBOwE6gTsBO0E7gTvBPAE7gTwBPEE8gTzBPQE8gT0BPUE9gT3BPgE9gT4BPkE+gT7BPwE+gT8BP0E/gT/BAAF/gQABQEFAgUDBQQFAgUEBQUFBgUHBQgFBgUIBQkFCgULBQwFCgUMBQ0FDgUPBRAFDgUQBREFEgUTBRQFEgUUBRUFFgUXBRgFFgUYBRkFGgUbBRwFGgUcBR0FHgUfBSAFHgUgBSEFIgUjBSQFIgUkBSUFJgUnBSgFJgUoBSkFKgUrBSwFKgUsBS0FLgUvBTAFLgUwBTEFMgUzBTQFMgU0BTUFNgU3BTgFNgU4BTkFOgU7BTwFOgU8BT0FPgU/BUAFPgVABUEFQgVDBUQFQgVEBUUFRgVHBUgFRgVIBUkFSgVLBUwFSgVMBU0FTgVPBVAFTgVQBVEFUgVTBVQFUgVUBVUFVgVXBVgFVgVYBVkFWgVbBVwFWgVcBV0FXgVfBWAFXgVgBWEFYgVjBWQFYgVkBWUFZgVnBWgFZgVoBWkFagVrBWwFagVsBW0FbgVvBXAFbgVwBXEFcgVzBXQFcgV0BXUFdgV3BXgFdgV4BXkFegV7BXwFfQV+BX8FfQV/BYAFgQWCBYMFgQWDBYQFhQWGBYcFhQWHBYgFiQWKBYsFiQWLBYwFjQWOBY8FjQWPBZAFkQWSBZMFkQWTBZQFlQWWBZcFlQWXBZgFmQWaBZsFmQWbBZwFnQWeBZ8FnQWfBaAFoQWiBaMFoQWjBaQFpQWmBacFpQWnBagFqQWqBasFrAWtBa4FrAWuBa8FsAWxBbIFsAWyBbMFtAW1BbYFtAW2BbcFuAW5BboFuAW6BbsFvAW9Bb4FvAW+Bb8FwAXBBcIFwAXCBcMFxAXFBcYFxAXGBccFyAXJBcoFywXMBc0FywXNBc4FzwXQBdEFzwXRBdIF0wXUBdUF0wXVBdYF1wXYBdkF1wXZBdoF2wXcBd0F2wXdBd4F3wXgBeEF3wXhBeIF4wXkBeUF4wXlBeYF5wXoBekF5wXpBeoF6wXsBe0F6wXtBe4F7wXwBfEF7wXxBfIF8wX0BfUF8wX1BfYF9wX4BfkF9wX5BfoF+wX8Bf0F+wX9Bf4F/wUABgEGAgYDBgQGAgYEBgUGBgYCBgUGBwYIBgkGBwYJBgoGCwYMBg0GDAYOBg0GCwYNBg8GEAYRBhIGEAYSBhMGFAYVBhYGFAYWBhcGGAYZBhoGGAYaBhsGHAYdBh4GHAYeBh8GIAYhBiIGIAYiBiMGJAYlBiYGJAYmBicGKAYpBioGKAYqBisGLAYtBi4GLAYuBi8GMAYxBjIGMAYyBjMGNAY1BjYGNgY3BjQGNwY4BjQGNgY5BjcGOgY7BjwGOgY8Bj0GPgY/BkAGPgZABkEGQgZDBkQGQgZEBkUGRgZHBkgGRgZIBkkGSgZLBkwGSgZMBk0GTgZPBlAGTgZQBlEGUgZTBlQGUgZUBlUGVgZXBlgGVgZYBlkGWgZbBlwGWgZcBl0GXgZfBmAGXgZgBmEGYgZjBmQGYgZkBmUGZgZnBmgGZgZoBmkGagZrBmwGagZsBm0GbgZvBnAGbgZwBnEGcgZzBnQGcgZ0BnUGdgZ3BngGdgZ4BnkGegZ7BnwGegZ8Bn0GfgZ/BoAGgQaCBoMGgQaDBoQGhQaGBocGhQaHBogGiQaKBosGiQaLBowGjQaOBo8GjQaPBpAGkQaSBpMGlAaVBpYGlwaYBpkGlwaZBpoGmwacBp0GmwadBp4GnwagBqEGnwahBqIGowakBqUGpganBqgGpgaoBqkGqgarBqwGqgasBq0GrgavBrAGrgawBrEGsgazBrQGsga0BrUGtga3BrgGtga4BrkGuga7BrwGuga8Br0Gvga/BsAGvgbABsEGwgbDBsQGwgbEBsUGxgbHBsgGyQbKBssGzAbNBs4GzwbQBtEGzwbRBtIG0wbUBtUG0wbVBtYG1wbYBtkG2gbbBtwG2gbcBt0G3gbfBuAG3gbgBuEG4gbjBuQG5QbmBucG5QbnBugG6QbqBusG6QbrBuwG7QbuBu8G7QbvBvAG8QbyBvMG8QbzBvQG9Qb2BvcG9Qb3BvgG+Qb6BvsG+Qb7BvwG/Qb+Bv8G/Qb/BgAHAQcCBwMHAQcDBwQHBQcGBwcHBQcHBwgHCQcKBwsHCQcLBwwHDQcOBw8HDQcPBxAHEQcSBxMHEQcTBxQHFQcWBxcHFQcXBxgHGQcaBxsHGQcbBxwHHQceBx8HHQcfByAHIQciByMHIQcjByQHJQcmBycHJQcnBygHKQcqBysHKQcrBywHLQcuBy8HMAcxBzIHMwc0BzUHMwc1BzYHNwc4BzkHNwc5BzoHOwc8Bz0HOwc9Bz4HPwdAB0EHPwdBB0IHQwdEB0UHQwdFB0YHRwdIB0kHRwdJB0oHSwdMB00HSwdNB04HTwdQB1EHTwdRB1IHUwdUB1UHUwdVB1YHVwdYB1kHVwdZB1oHWwdcB10HWwddB14HXwdgB2EHXwdhB2IHYwdkB2UHYwdlB2YHZwdoB2kHZwdpB2oHawdsB20HawdtB24HbwdwB3EHbwdxB3IHcwd0B3UHcwd1B3YHdwd4B3kHdwd5B3oHewd8B30Hewd9B34HfweAB4EHfweBB4IHgweEB4UHgweFB4YHhweIB4kHigeLB4wHigeMB40HjgePB5AHjgeQB5EHkgeTB5QHkgeUB5UHlgeXB5gHlgeYB5kHmgebB5wHmgecB50HngefB6AHngegB6EHogejB6QHpQemB6cHpQenB6gHqQeqB6sHqQerB6wHrQeuB68HrQevB7AHsQeyB7MHsQezB7QHtQe2B7cHtQe3B7gHuQe6B7sHuQe7B7wHvQe+B78HvQe/B8AHwQfCB8MHxAfFB8YHxAfGB8cHyAfJB8oHyAfKB8sHzAfNB84HzwfQB9EHzwfRB9IH0wfUB9UH0wfVB9YH1wfYB9kH1wfZB9oH2wfcB90H2wfdB94H3wfgB+EH3wfhB+IH4wfkB+UH4wflB+YH5wfoB+kH5wfpB+oH6wfsB+0H6wftB+4H7wfwB/EH7wfxB/IH8wf0B/UH8wf1B/YH9wf4B/kH9wf5B/oH+wf8B/0H+wf9B/4H/wcACAEI/wcBCAIIAwgECAUIBggHCAgIBggICAkICggLCAwICggMCA0IDggPCBAIDggQCBEIEggTCBQIEggUCBUIFggXCBgIFggYCBkIGggbCBwIGggcCB0IHggfCCAIHgggCCEIIggjCCQIIggkCCUIJggnCCgIJggoCCkIKggrCCwIKggsCC0ILggvCDAILggwCDEIMggzCDQIMgg0CDUINgg3CDgINgg4CDkIOgg7CDwIOgg8CD0IPgg/CEAIPghACEEIQghDCEQIRAhFCEIIRAhGCEUIRwhICEkIRwhJCEoISwhMCE0ISwhNCE4ITwhQCFEIUQhSCE8IUQhTCFIIVAhVCFYIVAhWCFcIWAhZCFoIWAhaCFsIXAhdCF4IXAheCF8IYAhhCGIIYAhiCGMIZAhlCGYIZAhmCGcIaAhpCGoIaAhqCGsIbAhtCG4IbAhuCG8IcAhxCHIIcAhyCHMIdAh1CHYIdAh2CHcIeAh5CHoIeAh6CHsIfAh9CH4IfAh+CH8IgAiBCIIIgwiECIUIgwiFCIYIhwiICIkIhwiJCIoIiwiMCI0IiwiNCI4IjwiQCJEIjwiRCJIIkwiUCJUIkwiVCJYIlwiYCJkIlwiZCJoImwicCJ0ImwidCJ4InwigCKEInwihCKIIowikCKUIowilCKYIpwioCKkIpwipCKoIqwisCK0IqwitCK4IrwiwCLEIrwixCLIIswi0CLUIswi1CLYItwi4CLkItwi5CLoIuwi8CL0Ivgi/CMAIvgjACMEIwgjDCMQIwgjECMUIxgjHCMgIyQjKCMsIyQjLCMwIzQjOCM8I0AjRCNII0wjUCNUI0wjVCNYI1wjYCNkI1wjZCNoI2wjcCN0I2wjdCN4I3wjgCOEI3wjhCOII4wjkCOUI4wjlCOYI5wjoCOkI5wjpCOoI6wjsCO0I6wjtCO4I7wjwCPEI7wjxCPII8wj0CPUI8wj1CPYI9wj4CPkI9wj5CPoI+wj8CP0I+wj9CP4I/wgACQEJ/wgBCQIJAwkECQUJBgkHCQgJBgkICQkJCgkLCQwJCgkMCQ0JDgkPCRAJDgkQCREJEgkTCRQJEgkUCRUJFgkXCRgJFgkYCRkJGgkbCRwJHQkeCR8JIAkhCSIJIAkiCSMJJAklCSYJJAkmCScJKAkpCSoJKAkqCSsJLAktCS4JLAkuCS8JMAkxCTIJMAkyCTMJNAk1CTYJNAk2CTcJOAk5CToJOwk8CT0JOwk9CT4JPwlACUEJQglDCUQJQglECUUJRglHCUgJSQlKCUsJSQlLCUwJTQlOCU8JTQlPCVAJUQlSCVMJUQlTCVQJVQlWCVcJVQlXCVgJWQlaCVsJWQlbCVwJXQleCV8JXQlfCWAJYQliCWMJYQljCWQJZQlmCWcJZQlnCWgJaQlqCWsJaQlrCWwJbQluCW8JbQlvCXAJcQlyCXMJcQlzCXQJdQl2CXcJdQl3CXgJeQl6CXsJeQl7CXwJfQl+CX8JfQl/CYAJgQmCCYMJgQmDCYQJhQmGCYcJhQmHCYgJiQmKCYsJjAmNCY4JjwmQCZEJjwmRCZIJkwmUCZUJkwmVCZYJlwmYCZkJlwmZCZoJmwmcCZ0JmwmdCZ4JnwmgCaEJnwmhCaIJowmkCaUJowmlCaYJpwmoCakJpwmpCaoJqwmsCa0JqwmtCa4JrwmwCbEJsQmyCa8JsQmzCbIJtAm1CbYJtgm3CbQJtgm4CbcJuQm6CbsJuQm7CbwJvQm+Cb8JvwnACb0JwAnBCb0JvwnCCcAJwwnECcUJxgnHCcgJyQnKCcsJyQnLCcwJzQnOCc8JzQnPCdAJ0QnSCdMJ1AnVCdYJ1AnWCdcJ2AnZCdoJ2AnaCdsJ3AndCd4J3AneCd8J4AnhCeIJ4wnkCeUJ4wnlCeYJ5wnoCekJ6gnrCewJ6gnsCe0J7gnvCfAJ7gnwCfEJ8gnzCfQJ8gn0CfUJ9gn3CfgJ9gn4CfkJ+gn7CfwJ+gn8Cf0J/gn/CQAK/gkACgEKAgoDCgQKAgoECgUKBgoHCggKBgoICgkKCgoLCgwKCgoMCg0KDgoPChAKDgoQChEKEgoTChQKEgoUChUKFgoXChgKFgoYChkKGgobChwKGgocCh0KHgofCiAKHgogCiEKIgojCiQKIgokCiUKJgonCigKJgooCikKKgorCiwKKgosCi0KLgovCjAKLgowCjEKMgozCjQKMgo0CjUKNgo3CjgKNgo4CjkKOgo7CjwKOgo8Cj0KPgo/CkAKPgpACkEKQgpDCkQKQgpECkUKRgpHCkgKRgpICkkKSgpLCkwKSgpMCk0KTgpPClAKTgpQClEKUApSClEKUwpUCk4KVQpTCk4KUQpVCk4KVQpWClMKUQpXClUKVwpYClUKUQpZClcKWgpbClwKWwpdClwKWwpeCl0KWgpcCl8KYApaCl8KYApfCmEKYgpgCmEKYgphCmMKZApiCmMKZApjCmUKZgpkCmUKZgplCmcKaAppCmoKaApqCmsKbAptCm4KbApuCm8KcApxCnIKcApyCnMKdAp1CnYKdAp2CncKeAp5CnoKeAp6CnsKfAp9Cn4KfAp+Cn8KgAqBCoIKgAqCCoMKhAqFCoYKhAqGCocKiAqJCooKiAqKCosKjAqNCo4KjAqOCo8KkAqRCpIKkAqSCpMKlAqVCpYKlAqWCpcKmAqZCpoKmAqaCpsKmQqcCpoKmQqdCpwKngqfCqAKngqgCqEKogqjCqQKogqkCqUKpgqnCqgKpgqoCqkKqgqrCqwKqgqsCq0KrgqvCrAKrgqwCrEKsgqzCrQKsgq0CrUKtgq3CrgKtgq4CrkKugq7CrwKugq8Cr0Kvgq/CsAKvgrACsEKwgrDCsQKwgrECsUKxgrHCsgKxgrICskKygrLCswKygrMCs0KzgrPCtAKzgrQCtEK0grTCtQK0grUCtUK1grXCtgK1grYCtkK2grbCtwK2grcCt0K3grfCuAK3grgCuEK4grjCuQK4grkCuUK5grnCugK5groCukK6grrCuwK6grsCu0K7grvCvAK7grwCvEK8grzCvQK8gr0CvUK9gr3CvgK9gr4CvkK+gr7CvwK+gr8Cv0K/gr/CgAL/goACwELAgsDCwQLAgsECwULBgsHCwgLBgsICwkLCgsLCwwLCgsMCw0LDgsPCxALDgsQCxELEgsTCxQLEgsUCxULFgsXCxgLFgsYCxkLGgsbCxwLGgscCx0LHgsfCyALHgsgCyELIgsjCyQLIgskCyULJgsnCygLJgsoCykLKgsrCywLKgssCy0LLgsvCzALLgswCzELMgszCzQLMgs0CzULNgs3CzgLNgs4CzkLOgs7CzwLOgs8Cz0LPgs/C0ALPgtAC0ELQgtDC0QLQgtEC0ULRgtHC0gLRgtIC0kLSgtLC0wLSgtMC00LTgtPC1ALTgtQC1ELUAtSC1ELUwtUC04LVQtTC04LUQtVC04LVQtWC1MLUQtXC1ULVwtYC1ULUQtZC1cLWgtbC1wLWgtcC10LXgtfC2ALXgtgC2ELYgtjC2QLYgtkC2ULZgtnC2gLZgtoC2kLagtrC2wLagtsC20LbgtvC3ALbgtwC3ELcgtzC3QLcgt0C3ULdgt3C3gLdgt4C3kLegt7C3wLegt8C30Lfgt/C4ALfguAC4ELgguDC4QLgguEC4ULhguHC4gLhguIC4kLiguLC4wLiguMC40LjguPC5ALjguQC5ELkguTC5QLkguUC5ULlQuUC5YLlQuWC5cLlwuWC5gLlwuYC5kLmQuYC5oLmQuaC5sLnAudC54LnAueC58LoAuhC6ILoAuiC6MLpAulC6YLpAumC6cLqAupC6oLqAuqC6sLrAutC64LrAuuC68LsAuxC7ILsAuyC7MLtAu1C7YLtAu2C7cLuAu5C7oLuAu6C7sLvAu9C74LvAu+C78LwAvBC8ILwAvCC8MLxAvFC8YLxAvGC8cLyAvJC8oLyAvKC8sLzAvNC84LzAvOC88L0AvRC9IL0AvSC9ML1AvVC9YL1AvWC9cL2AvZC9oL2AvaC9sL3AvdC94L3AveC98L4AvhC+IL4AviC+ML5AvlC+YL5AvmC+cL6AvpC+oL6AvqC+sL7AvtC+4L7AvuC+8L8AvxC/IL8AvyC/ML9Av1C/YL9Av2C/cL+Av5C/oL+Av6C/sL/Av9C/4L/Av+C/8LAAwBDAIMAAwCDAMMBAwFDAYMBAwGDAcMCAwJDAoMCAwKDAsMDAwNDA4MDAwODA8MEAwRDBIMEAwSDBMMFAwVDBYMFAwWDBcMGAwZDBoMGAwaDBsMHAwdDB4MHAweDB8MIAwhDCIMIAwiDCMMJAwlDCYMJAwmDCcMKAwpDCoMKAwqDCsMLAwtDC4MLAwuDC8MMAwxDDIMMAwyDDMMNAw1DDYMNAw2DDcMOAw5DDoMOAw6DDsMPAw9DD4MPAw+DD8MQAxBDEIMQAxCDEMMRAxFDEYMRAxGDEcMSAxJDEoMSAxKDEsMTAxNDE4MTAxODE8MUAxRDFIMUAxSDFMMVAxVDFYMVAxWDFcMVgxYDFcMWQxaDFQMWwxZDFQMVwxbDFQMWwxcDFkMVwxdDFsMXQxeDFsMVwxfDF0MYAxhDGIMYAxiDGMMZAxlDGYMZAxmDGcMaAxpDGoMaAxqDGsMbAxtDG4MbAxuDG8McAxxDHIMcAxyDHMMdAx1DHYMdAx2DHcMeAx5DHoMeAx6DHsMfAx9DH4MfAx+DH8MgAyBDIIMgAyCDIMMhAyFDIYMhAyGDIcMiAyJDIoMiAyKDIsMjAyNDI4MjAyODI8MkAyRDJIMkAySDJMMlAyVDJYMlAyWDJcMmAyZDJoMmAyaDJsMnAydDJ4MnAyeDJ8MoAycDJ8MoAyfDKEMogyjDKQMogykDKUMpgynDKgMpgyoDKkMqgyrDKwMqwytDKwMqwyuDK0MqgysDK8MsAyqDK8MsAyvDLEMsgyzDLQMsgy0DLUMtgy3DLgMtgy4DLkMugy7DLwMugy8DL0Mvgy/DMAMvgzADMEMwgzDDMQMwgzEDMUMxgzHDMgMxgzIDMkMygzLDMwMygzMDM0MzgzPDNAMzgzQDNEM0gzTDNQM0gzUDNUM1gzXDNgM1gzYDNkM2gzbDNwM2gzcDN0M3gzfDOAM3gzgDOEM4gzjDOQM4gzkDOUM5gznDOgM5gzoDOkM6gzrDOwM6gzsDO0M7gzvDPAM7gzwDPEM8gzzDPQM8gz0DPUM9gz3DPgM9gz4DPkM+gz7DPwM+gz8DP0M/gz/DAAN/gwADQENAg0DDQQNAg0EDQUNBg0HDQgNBg0IDQkNCg0LDQwNCg0MDQ0NDg0PDRANDg0QDRENEg0TDRQNEg0UDRUNFg0XDRgNFg0YDRkNGg0bDRwNGg0cDR0NHg0fDSANHg0gDSENIg0jDSQNIg0kDSUNJg0nDSgNJg0oDSkNKg0rDSwNKg0sDS0NLg0vDTANLg0wDTENMg0zDTQNMg00DTUNNg03DTgNNg04DTkNOg07DTwNOg08DT0NPg0/DUANPg1ADUENQg1DDUQNQg1EDUUNRg1HDUgNRg1IDUkNSg1LDUwNSg1MDU0NTg1PDVANTg1QDVENUg1TDVQNUg1UDVUNVg1XDVgNVg1YDVkNWg1bDVwNWg1cDV0NXA1eDV0NXw1gDVoNYQ1fDVoNXQ1hDVoNYQ1iDV8NXQ1jDWENYw1kDWENXQ1lDWMNZg1nDWgNZg1oDWkNag1rDWwNag1sDW0Nbg1vDXANbg1wDXENcg1zDXQNcg10DXUNdg13DXgNdg14DXkNeg17DXwNeg18DX0Nfg1/DYANfg2ADYENgg2DDYQNgg2EDYUNhg2HDYgNhg2IDYkNig2LDYwNig2MDY0Njg2PDZANjg2QDZENkg2TDZQNkg2UDZUNlg2XDZgNlg2YDZkNmg2bDZwNmg2cDZ0Nng2fDaANng2gDaENog2jDaQNog2kDaUNpg2nDagNpg2oDakNqg2rDawNqg2sDa0Nrg2vDbANrg2wDbENsg2zDbQNsg20DbUNtg23DbgNtg24DbkNug27DbwNug28Db0Nvg2/DcANvg3ADcENwg3DDcQNwg3EDcUNxg3HDcgNxg3IDckNyg3LDcwNyg3MDc0Nzg3PDdANzg3QDdEN0g3TDdQN0g3UDdUN1g3XDdgN1g3YDdkN2g3bDdwN2g3cDd0N3g3fDeAN3g3gDeEN4g3jDeQN4g3kDeUN5g3nDegN5g3oDekN6g3rDewN6g3sDe0N7g3vDfAN7g3wDfEN8g3zDfQN8g30DfUN9g33DfgN9g34DfkN+g37DfwN+g38Df0N/g3/DQAO/g0ADgEOAg4DDgQOAg4EDgUOBg4HDggOBg4IDgkOCg4LDgwOCg4MDg0ODg4PDhAODg4QDhEOEg4TDhQOEg4UDhUOFg4XDhgOFg4YDhkOGg4bDhwOGg4cDh0OHg4fDiAOHg4gDiEOIg4jDiQOIg4kDiUOJg4nDigOJg4oDikOKg4rDiwOKg4sDi0OLg4vDjAOLg4wDjEOAAABAAIAAAACAAMABAAFAAYABgAHAAQABwAIAAQABgAJAAcACgALAAwACgAMAA0ADgAPABAADgAQABEAEgATABQAEgAUABUAFgAXABgAFgAYABkAGgAbABwAGgAcAB0AHgAfACAAHgAgACEAIgAjACQAIgAkACUAJgAnACgAJgAoACkAKgArACwAKgAsAC0ALgAvADAALgAwADEAAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAAAABAAIAAAACAAMABAAFAAYABgAHAAQABwAIAAQABgAJAAcACgALAAwACgAMAA0ADgAPABAADgAQABEAEgATABQAEgAUABUAFgAXABgAFgAYABkA\");\n\n//# sourceURL=webpack:///./assets/Cop.glb?");

/***/ }),

/***/ "./assets/NormalCar1.glb":
/*!*******************************!*\
  !*** ./assets/NormalCar1.glb ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAADsZgEAdA8AAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjg3OTAwfV0sImFzc2V0Ijp7InZlcnNpb24iOiIyLjAiLCJnZW5lcmF0b3IiOiJnbHRmcGFjayAwLjE2In0sImV4dGVuc2lvbnNVc2VkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiJdLCJleHRlbnNpb25zUmVxdWlyZWQiOlsiS0hSX21lc2hfcXVhbnRpemF0aW9uIl0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjAsImJ5dGVMZW5ndGgiOjQ2Nzg0LCJieXRlU3RyaWRlIjo4LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NDY3ODQsImJ5dGVMZW5ndGgiOjIzMzkyLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NzAxNzYsImJ5dGVMZW5ndGgiOjE3NzI0LCJ0YXJnZXQiOjM0OTYzfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIyOTksInR5cGUiOiJWRUMzIiwibWluIjpbMCw2MzksMF0sIm1heCI6WzcwMTUsNDU2NywxNjM4M119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjIyOTksInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzQ0NCwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MTgzOTIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxMzAsInR5cGUiOiJWRUMzIiwibWluIjpbNjE2LDI5NjYsMjk0N10sIm1heCI6WzY0MDAsNDM4NywxMTUzM119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6OTE5NiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjEzMCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjY4ODgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxODYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjE5NDMyLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTEzOCwidHlwZSI6IlZFQzMiLCJtaW4iOls0NjMsMCwyMzM3XSwibWF4IjpbNjU1OSwzMDY2LDEzODM4XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0Ijo5NzE2LCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MTEzOCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjcyNjAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxNzcwLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyODUzNiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIyMzksInR5cGUiOiJWRUMzIiwibWluIjpbNTEyLDM0NSwyNjBdLCJtYXgiOls2NTEwLDIxOTEsMTYzMDddfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjE0MjY4LCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MjIzOSwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjEwODAwLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzQwOCwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6NDY0NDgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoyOCwidHlwZSI6IlZFQzMiLCJtaW4iOls3NzQsMTU5NiwxNTU1OV0sIm1heCI6WzYyNDEsMjA0MSwxNjE5NF19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MjMyMjQsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyOCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE3NjE2LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjQ2NjcyLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTQsInR5cGUiOiJWRUMzIiwibWluIjpbMTAwMSwyMzk4LDUyMl0sIm1heCI6WzYwMTUsMjkxOSwxMTM1XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoyMzMzNiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjE0LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MTc2ODgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxOCwidHlwZSI6IlNDQUxBUiJ9XSwibWF0ZXJpYWxzIjpbeyJuYW1lIjoiQmx1ZSIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMzQ3ODY3MTYxLDAuNTM5NjI2NTk4LDAuODAwMDAwMDcyLDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiV2luZG93cyIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMDM1NjAxMzE3OSwwLjAzNTYwMTMxNzksMC4wMzU2MDEzMTc5LDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiQmxhY2siLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjAxMzcwMjA4NjIsMC4wMTM3MDIwODYyLDAuMDEzNzAyMDg2MiwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkdyZXkiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjIwMTU1NjI4LDAuMjAxNTU2MjgsMC4yMDE1NTYyOCwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkhlYWRsaWdodHMiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjc5OTEwMjc4MywwLjM3NjI2MjEyOCwwLjEyNzQzNzcxMSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IlRhaWxMaWdodHMiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjc5OTEwMjc4MywwLjA5MzA1ODk3MzYsMC4wNzQyMTM1NzkzLDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX1dLCJtZXNoZXMiOlt7InByaW1pdGl2ZXMiOlt7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjAsIk5PUk1BTCI6MX0sIm1vZGUiOjQsImluZGljZXMiOjIsIm1hdGVyaWFsIjowfSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjMsIk5PUk1BTCI6NH0sIm1vZGUiOjQsImluZGljZXMiOjUsIm1hdGVyaWFsIjoxfSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjYsIk5PUk1BTCI6N30sIm1vZGUiOjQsImluZGljZXMiOjgsIm1hdGVyaWFsIjoyfSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjksIk5PUk1BTCI6MTB9LCJt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0QLXA6YKAAAyAtcDpgoAADQCJwOFDQAArwInA4UNAADRAs0BSA4AADICzQFIDgAAMgIRBm4OAADRAhEGbg4AANECTQUzDwAAMgJNBTMPAAA0AsoErwwAAK8CygSvDAAA0QIkBusLAAAyAiQG6wsAADQC3wMBDgAArwLfAwEOAADRAtcDjQ8AADIC1wONDwAANALfAzMMAACvAt8DMwwAAK8CjgNIDAAANAKOA0gMAAA0AoAE3Q0AAK8CgATdDQAArwK8BKINAAA0ArwEog0AADQCjgNIDAAArwKOA0gMAADRAsoC7goAADICygLuCgAANAK8BKINAACvArwEog0AANECEQZuDgAAMgIRBm4OAAAyAoUB+AwAANEChQH4DAAA0QLNAesLAAAyAs0B6wsAADICTQUBCwAA0QJNBQELAADRAhEGxgsAADICEQbGCwAAMgLXA6YKAADRAtcDpgoAAK8C3wMzDAAANALfAzMMAAAyAk0FMw8AANECTQUzDwAArwKABN0NAAA0AoAE3Q0AADQCJwOvDAAArwInA68MAACvAhEDAA0AADQCEQMADQAANAK8BJIMAACvArwEkgwAAK8CgARXDAAANAKABFcMAAAyAs0B6wsAANECzQHrCwAArwInA68MAAA0AicDrwwAADICEQbGCwAA0QIRBsYLAACvArwEkgwAADQCvASSDAAAMgKkAjMPAADRAqQCMw8AANEC4AFuDgAAMgLgAW4OAAAyAhoEpgoAANECGgSmCgAA0QInBe4KAAAyAicF7goAADQCEQMADQAArwIRAwANAADRAoUB+AwAADIChQH4DAAAMgInBUUPAADRAicFRQ8AANECGgSNDwAAMgIaBI0PAAA0AoAEVwwAAK8CgARXDAAA0QJNBQELAAAyAk0FAQsAADQCNQOiDQAArwI1A6INAACvAnED3Q0AADQCcQPdDQAANAJjBEgMAACvAmMESAwAAK8CEgQzDAAANAISBDMMAAA0AhIEAQ4AAK8CEgQBDgAArwJjBOsNAAA0AmME6w0AADQCcQPdDQAArwJxA90NAADRAqQCMw8AADICpAIzDwAAMgInBe4KAADRAicF7goAAK8CYwRIDAAANAJjBEgMAAAyAhoEjQ8AANECGgSNDwAArwISBAEOAAA0AhIEAQ4AADIC4AHGCwAA0QLgAcYLAADRAqQC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QxlJBc8vAABOGVcEcjEAAEEZYwREMQAAQxknBeovAABDGfkDdS8AAEMZSQXPLwAAQxknBeovAABDGRoEoi8AAE4Z+QNZMQAAQxn5A3UvAABDGRoEoi8AAEEZEgQuMQAAQxnNAUQzAABDGYUBNzIAAKQYhQE3MgAApBjNAUQzAABDGakCzy8AAEMZ+QN1LwAAQxnXA6IvAABDGcoC6i8AAE4ZmgNyMQAAQxmpAs8vAABDGcoC6i8AAEEZjgNEMQAAQxn5A3UvAABOGfkDWTEAAEEZ3wMuMQAAQxnXA6IvAABDGSQGRDMAAEEZygSAMgAAxhjKBIAyAACkGCQGRDMAAE4ZmgNyMQAAThlVA7cxAABBGTUDjjEAAEEZcQNSMQAAQxmpAs8vAABOGZoDcjEAAEEZcQNSMQAAQxmkAvwvAABDGbMBxTAAAEMZqQLPLwAAQxmkAvwvAABDGeABwTAAAEMZpAL8LwAAQRlxA1IxAADGGHEDUjEAAKQYpAL8LwAAQxmzAcUwAABOGVUDtzEAAEEZJwOrMQAAQxnNAecwAABDGVkBFTIAAEMZswHFMAAAQxnNAecwAABDGYUB9DEAAE4ZPAMVMgAAQxlZARUyAABDGYUB9DEAAEEZEQP8MQAAQRnKBIAyAABBGeAELzIAAMYY4AQvMgAAxhjKBIAyAABOGTwDFTIAAE4ZVQNzMgAAQRknA4AyAABBGREDLzIAAEMZswFlMwAAQxlZARUyAABDGYUBNzIAAEMZzQFEMwAAThlVA3MyAABDGbMBZTMAAEMZzQFEMwAAQRknA4AyAABBGXEDUjEAAEEZNQOOMQAAxhg1A44xAADGGHEDUjEAAEMZqQJbNAAAQxmzAWUzAABDGeABaTMAAEMZpAIuNAAAThmaA7gyAABDGakCWzQAAEMZpAIuNAAAQRlxA9gyAABDGbMBZTMAAE4ZVQNzMgAAQRk1A50yAABDGeABaTMAAEMZhQE3MgAAQRkRAy8yAADGGBEDLzIAAKQYhQE3MgAAQxlsBvQxAABBGeAE/DEAAMYY4AT8MQAApBhsBvQxAABDGcoCQTQAAEEZjgPnMgAAxhiOA+cyAACkGMoCQTQAAEMZygLqLwAAQxnXA6IvAACkGNcDoi8AAKQYygLqLwAAQRknA4AyAABDGc0BRDMAAKQYzQFEMwAAxhgnA4AyAABDGREG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nQCoAKQApACoAKcAnQCpAKgAqACqAKcAqACrAKoApwCqAKwApwCsAK0ArgCvALAArgCwALEAsgCzALQAsgC0ALUAtgC3ALgAtgC4ALkAugC7ALwAugC8AL0AvgC/AMAAvgDAAMEAwgDDAMQAwgDEAMUAxgDHAMgAxgDIAMkAygDLAMwAygDMAM0AzgDPANAAzgDQANEA0gDTANQA0gDUANUA1gDXANgA1gDYANkA2gDbANwA2gDcAN0A3gDdANwA3gDcAN8A4ADhAOIA4ADiAOMA5ADlAOYA5ADmAOcA6ADpAOoA6ADqAOsA7ADtAO4A7wDwAPEA7wDxAPIA8wD0APUA8wD1APYA9wD4APkA9wD5APoA+wD8AP0A+wD9AP4A/wAAAQEB/wABAQIBAwEEAQUBAwEFAQYBBwEIAQkBBwEJAQoBCwEMAQ0BCwENAQ4BDwEQAREBEgETARQBEgEUARUBFgEXARgBFgEYARkBGgEbARwBGgEcAR0BHgEfASABHgEgASEBIgEjASQBIgEkASUBJgEnASgBJgEoASkBKgErASwBKgEsAS0BLgEvATABLgEwATEBMgEzATQBMgE0ATUBNgE3ATgBNgE4ATkBOgE7ATwBOgE8AT0BPgE/AUABPgFAAUEBQgFDAUQBRQFGAUcBRQFHAUgBSQFGAUUBSgFLAUkBSgFJAUwBSgFMAU0BSgFNAU4BTgFNAU8BTQFQAU8BUAFRAU8BUAFSAVEBTgFPAVMBVAFOAVMBVQFUAVMBVQFTAVYBVwFYAUsBWQFYAVcBWQFaAVgBWwFcAV0BWwFdAV4BXwFgAWEBXwFhAWIBYwFkAWUBYwFlAWYBZwFoAWkBZwFpAWoBawFsAW0BawFtAW4BbwFwAXEBbwFxAXIBcwF0AXUBcwF1AXYBdwF4AXkBdwF5AXoBewF8AX0BewF9AX4BfwGAAYEBfwGBAYIBgwGEAYUBgwGFAYYBhwGIAYkBhwGJAYoBiwGMAY0BiwGNAY4BjwGQAZEBjwGRAZIBkwGUAZUBkwGVAZYBlwGYAZkBlwGZAZoBmwGcAZ0BmwGdAZ4BnwGgAaEBnwGhAaIBowGkAaUBowGlAaYBpwGoAakBpwGpAaoBqwGsAa0BqwGtAa4BrwGwAbEBrwGxAbIBswG0AbUBswG1AbYBtwG4AbkBtwG5AboBuwG8Ab0BuwG9Ab4BvwHAAcEBvwHBAcIBwwHEAcUBwwHFAcYBxwHIAckBxwHJAcoBywHMAc0BywHNAc4BzwHQAdEBzwHRAdIB0wHUAdUB0wHVAdYB1wHYAdkB1wHZAdoB2wHcAd0B2wHdAd4B3wHgAeEB4gHjAeQB4gHkAeUB5gHnAegB5gHoAekB6gHrAewB6gHsAe0B7gHvAfAB7gHwAfEB8gHzAfQB8gH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wEAAgEC/wEBAgICAwIEAgUCAwIFAgYCBwIIAgkCCgILAgwCDQIOAg8CDQIPAhACEQISAhMCEQITAhQCFQIWAhcCFQIXAhgCGQIaAhsCGQIbAhwCHQIeAh8CHQIfAiACIQIiAiMCIQIjAiQCJQImAicCJQInAigCKQIqAisCKQIrAiwCLQIuAi8CMAIxAjICMwI0AjUCNgI3AjgCNgI4AjkCOgI7AjwCOgI8Aj0CPgI/AkACQQJCAkMCQQJDAkQCRQJGAkcCRQJHAkgCSQJKAksCTAJNAk4CTAJOAk8CUAJRAlICUAJSAlMCVAJVAlYCVAJWAlcCWAJZAloCWAJaAlsCXAJdAl4CXAJeAl8CYAJhAmICYAJiAmMCZAJlAmYCZAJmAmcCaAJpAmoCaAJqAmsCbAJtAm4CbAJuAm8CcAJxAnICcAJyAnMCdAJ1AnYCdAJ2AncCeAJ5AnoCeAJ6AnsCfAJ9An4CfAJ+An8CgAKBAoICgAKCAoMChAKFAoYChAKGAocCiAKJAooCiAKKAosCjAKNAo4CjAKOAo8CkAKRApICkAKSApMClAKVApYClAKWApcCmAKZApoCmAKaApsCnAKdAp4CnAKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCqQKrAqwCrQKuAq8CrQKvArACsQKyArMCtAK1ArYCtAK2ArcCuAK5AroCuAK6ArsCvAK9Ar4CvAK+Ar8CwALBAsICwALCAsMCxALFAsYCxALGAscCyALJAsoCyALKAssCzALNAs4CzALOAs8C0ALRAtIC0ALSAtMC1ALVAtYC1ALWAtcC2ALZAtoC2ALaAtsC3ALdAt4C3ALeAt8C4ALhAuIC4ALiAuMC5ALlAuYC5ALmAucC6ALpAuoC6ALqAusC7ALtAu4C7ALuAu8C8ALxAvIC8ALyAvMC9AL1AvYC9AL2AvcC+AL5AvoC+AL6AvsC/AL9Av4C/AL+Av8CAAMBAwIDAAMCAwMDBAMFAwYDBAMGAwcDCAMJAwoDCAMKAwsDDAMNAw4DDAMOAw8DEAMRAxIDEAMSAxMDFAMVAxYDFAMWAxcDGAMZAxoDGAMaAxsDHAMdAx4DHAMeAx8DIAMhAyIDIAMiAyMDJAMlAyYDJAMmAycDKAMpAyoDKAMqAysDLAMtAy4DLAMuAy8DMAMxAzIDMAMyAzMDNAM1AzYDNAM2AzcDOAM5AzoDOAM6AzsDPAM9Az4DPAM+Az8DQANBA0IDQANCA0MDRANFA0YDRANGA0cDSANJA0oDSANKA0sDTANNA04DTANOA08DUANRA1IDUwNUA1UDUwNVA1YDVwNYA1kDVwNZA1oDWwNcA10DWwNdA14DXwNgA2EDXwNhA2IDYwNkA2UDYwNlA2YDZwNoA2kDZwNpA2oDawNsA20DawNtA24DbwNwA3EDbwNxA3IDcwN0A3UDcwN1A3YDdwN4A3kDdwN5A3oDewN8A30DewN9A34DfwOAA4EDfwOBA4IDgwOEA4UDgwOFA4YDhwOIA4kDhwOJA4oDiwOIA4cDiwOMA4gDjQOOA48DjQOPA5ADkQOSA5MDkQOTA5QDlQOWA5cDlwOYA5UDlwOZA5gDmgObA5wDmgOcA50DngOfA6ADngOgA6EDogOjA6QDpAOlA6IDpAOmA6UDpwOoA6kDpwOpA6oDqwOsA60DqwOtA64DrwOwA7EDrwOxA7IDswO0A7UDswO1A7YDtwO4A7kDtwO5A7oDuwO8A70DuwO9A74DvwPAA8EDvwPBA8IDwwPEA8UDwwPFA8YDxwPIA8kDxwPJA8oDywPMA80DywPNA84DzwPQA9EDzwPRA9ID0wPUA9UD1gPXA9gD1gPYA9kD2gPbA9wD2gPcA90D3gPfA+AD3gPgA+ED4gPjA+QD4gPkA+UD5gPnA+gD5gPoA+kD6gPrA+wD6gPsA+0D7gPvA/AD7gPwA/ED8gPzA/QD8gP0A/UD9gP3A/gD9gP4A/kD+gP7A/wD+gP8A/0D/gP/AwAE/gMABAEEAgQDBAQEAgQEBAUEBgQHBAgEBgQIBAkECgQLBAwEDQQOBA8EDQQPBBAEEQQSBBMEEQQTBBQEFQQWBBcEFQQXBBgEGQQaBBsEGQQbBBwEHQQeBB8EHQQfBCAEIQQiBCMEIQQjBCQEJQQmBCcEJQQnBCgEKQQqBCsEKQQrBCwELQQuBC8ELQQvBDAEMQQyBDMEMQQzBDQENQQ2BDcENQQ3BDgEOQQ6BDsEOQQ7BDwEPQQ+BD8EPQQ/BEAEQQRCBEMEQQRDBEQERQRGBEcERQRHBEgESQRKBEsESQRLBEwETQROBE8ETQRPBFAEUQRSBFMEUQRTBFQEVQRWBFcEVQRXBFgEWQRaBFsEWQRbBFwEXQReBF8EXQRfBGAEYQRiBGMEZARlBGYEZARmBGcEaARpBGoEawRsBG0EawRtBG4EbwRwBHEEbwRxBHIEcwR0BHUEcwR1BHYEdwR4BHkEegR7BHwEegR8BH0EfgR/BIAEfgSABIEEggSDBIQEggSEBIUEhgSHBIgEhgSIBIkEigSLBIwEigSMBI0EjgSPBJAEjgSQBJEEkgSTBJQEkgSUBJUElgSXBJgElgSYBJkEmgSbBJwEmgScBJ0EmgSeBJsEmgSfBJ4EoASeBJ8EnwShBKAEoQSiBKAEnwSjBKEEpASlBKYEpASmBKcEqASpBKoEqASqBKsErAStBK4ErgSvBKwErgSwBK8EsQSyBLMEsQSzBLQEtQS2BLcEtQS3BLgEuQS6BLsEuQS7BLwEvQS+BL8EvQS/BMAEwQTCBMMEwQTDBMQExQTGBMcExQTHBMgEyQTKBMsEyQTLBMwEzQTOBM8EzQTPBNAE0QTSBNME0QTTBNQE1QTWBNcE2ATZBNoE2ATaBNsE3ATdBN4E3ATeBN8E4AThBOIE4ATiBOME5ATlBOYE5ATmBOcE6ATpBOoE6ATqBOsE7ATtBO4E7ATuBO8E8ATxBPIE8ATyBPME9AT1BPYE9AT2BPcE+AT5BPoE+wT8BP0E+wT9BP4E/wQABQEF/wQBBQIFAwUEBQUFAwUFBQYFBwUIBQkFBwUJBQoFCwUMBQ0FCwUNBQ4FDwUQBREFDwURBRIFEwUUBRUFEwUVBRYFFwUYBRkFGgUbBRwFGgUcBR0FHgUfBSAFHgUgBSEFIgUjBSQFJQUmBScFJQUnBSgFKQUqBSsFKQUrBSwFLQUuBS8FLQUvBTAFMQUyBTMFMQUzBTQFNQU2BTcFNQU3BTgFOQU6BTsFOQU7BTwFPQU+BT8FPQU/BUAFQQVCBUMFQQVDBUQFRQVGBUcFRQVHBUgFSQVKBUsFSQVLBUwFTQVOBU8FTQVPBVAFUQVSBVMFUQVTBVQFVQVWBVcFVQVXBVgFWQVaBVsFWQVbBVwFXQVeBV8FYAVhBWIFYAViBWMFZAVlBWYFZAVmBWcFaAVpBWoFaAVqBWsFbAVtBW4FbAVuBW8FcAVxBXIFcAVyBXMFdAV1BXYFdAV2BXcFeAV5BXoFeAV6BXsFfAV9BX4FfAV+BX8FgAWBBYIFgwWEBYUFgwWFBYYFhwWIBYkFhwWJBYoFiwWMBY0FiwWNBY4FjwWQBZEFjwWRBZIFkwWUBZUFkwWVBZYFlwWYBZkFlwWZBZoFmwWcBZ0FmwWdBZ4FnwWgBaEFnwWhBaIFowWkBaUFowWlBaYFpwWoBakFpwWpBaoFqwWsBa0FqwWtBa4FrwWwBbEFrwWxBbIFswW0BbUFtgW3BbgFtgW4BbkFugW7BbwFugW8Bb0FvgW/BcAFvgXABcEFwgXDBcQFwgXEBcUFxgXHBcgFxgXIBckFygXLBcwFygXMBc0FzgXPBdAFzgXQBdEF0gXTBdQF0gXUBdUF1gXXBdgF1gXYBdkF2gXbBdwF2gXcBd0F3gXfBeAF3gXgBeEF4gXjBeQF4gXkBeUF5gXnBegF5gXoBekF6gXrBewF6gXsBe0F7gXvBfAF7gXwBfEF8gXzBfQF8gX0BfUF9gX3BfgF9gX4BfkF+gX7BfwF+gX8Bf0F/gX/BQAG/gUABgEGAgYDBgQGAgYEBgUGBgYHBggGBgYIBgkGCgYLBgwGCgYMBg0GDgYPBhAGDgYQBhEGEgYTBhQGEgYUBhUGFgYXBhgGFgYYBhkGGgYbBhwGGgYcBh0GHgYfBiAGHgYgBiEGIgYjBiQGIgYkBiUGJgYnBigGJgYoBikGKgYrBiwGKgYsBi0GLgYvBjAGLgYwBjEGMgYzBjQGMgY0BjUGNgY3BjgGOQY6BjsGOQY7BjwGPQY+Bj8GPQY/BkAGQQZCBkMGQQZDBkQGRQZGBkcGRQZHBkgGSQZKBksGSQZLBkwGTQZOBk8GUAZRBlIGUwZUBlUGVgZXBlgGVgZYBlkGWgZbBlwGWgZcBl0GXgZfBmAGYQZiBmMGZAZlBmYGZAZmBmcGaAZpBmoGaAZqBmsGbAZtBm4GbAZuBm8GcAZxBnIGcAZyBnMGdAZ1BnYGdAZ2BncGeAZ5BnoGeAZ6BnsGfAZ9Bn4GfAZ+Bn8GgAaBBoIGgAaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GjQaPBpAGkQaSBpMGkQaTBpQGlQaWBpcGmAaZBpoGmAaaBpsGnAadBp4GnAaeBp8GoAahBqIGowakBqUGowalBqYGpwaoBqkGpwapBqoGqwasBq0GqwatBq4GrwawBrEGrwaxBrIGswa0BrUGswa1BrYGtwa4BrkGtwa5BroGuwa8Br0Guwa9Br4GvwbABsEGvwbBBsIGwwbEBsUGwwbFBsYGxwbIBskGxwbJBsoGywbMBs0GywbNBs4GzwbQBtEGzwbRBtIG0wbUBtUG0wbVBtYG1wbYBtkG1wbZBtoG2wbcBt0G2wbdBt4G3wbgBuEG3wbhBuIG4wbkBuUG4wblBuYG5wboBukG5wbpBuoG6wbsBu0G6wbtBu4G7wbwBvEG7wbxBvIG8wb0BvUG8wb1BvYG9wb4BvkG+gb7BvwG/Qb+Bv8GAAcBBwIHAAcCBwMHBAcFBwYHBAcGBwcHCAcJBwoHCwcMBw0HCwcNBw4HDwcQBxEHDwcRBxIHEwcUBxUHEwcVBxYHFwcYBxkHFwcZBxoHGwccBx0HGwcdBx4HHwcgByEHHwchByIHIwckByUHIwclByYHJwcoBykHJwcpByoHKwcsBy0HKwctBy4HLwcwBzEHLwcxBzIHMwc0BzUHMwc1BzYHNwc4BzkHNwc5BzoHOwc8Bz0HOwc9Bz4HPwdAB0EHPwdBB0IHQwdEB0UHQwdFB0YHRwdIB0kHRwdJB0oHSwdMB00HSwdNB04HTwdQB1EHTwdRB1IHUwdUB1UHUwdVB1YHVwdYB1kHVwdZB1oHWwdcB10HWwddB14HXwdgB2EHXwdhB2IHYwdkB2UHYwdlB2YHZwdoB2kHZwdpB2oHawdsB20HawdtB24HbwdwB3EHbwdxB3IHcwd0B3UHcwd1B3YHdwd4B3kHdwd5B3oHewd8B30Hewd9B34HfweAB4EHfweBB4IHgweEB4UHgweFB4YHhweIB4kHhweJB4oHiweMB40HiweNB44HjweQB5EHjweRB5IHkweUB5UHkweVB5YHlweYB5kHlweZB5oHmwecB50HmwedB54HnwegB6EHnwehB6IHowekB6UHowelB6YHpweoB6kHqgerB6wHqgesB60HrgevB7AHrgewB7EHsgezB7QHsge0B7UHtge3B7gHtge4B7kHuge7B7wHuge8B70Hvge/B8AHvgfAB8EHwgfDB8QHwgfEB8UHxgfHB8gHxgfIB8kHygfLB8wHygfMB80HzgfPB9AHzgfQB9EH0gfTB9QH0gfUB9UH1gfXB9gH1gfYB9kH2gfbB9wH2gfcB90H3gffB+AH3gfgB+EH4gfeB+EH4gfhB+MH5AflB+YH5AfmB+cH6AfpB+oH6AfqB+sH7AftB+4H7gfvB+wH7gfwB+8H8QfyB/MH8QfzB/QH9Qf2B/cH9Qf3B/gH+Qf6B/sH+wf8B/kH+wf9B/wH/gf/BwAI/gcACAEIAggDCAQIAggECAUIBggHCAgIBggICAkICggLCAwICggMCA0IDggPCBAIDggQCBEIEggTCBQIEggUCBUIFggXCBgIFggYCBkIGggbCBwIGggcCB0IHggfCCAIHgggCCEIIggjCCQIIggkCCUIJggnCCgIJggoCCkIKggrCCwILQguCC8ILQgvCDAIMQgyCDMIMQgzCDQINQg2CDcINQg3CDgIOQg6CDsIOQg7CDwIPQg+CD8IPQg/CEAIQQhCCEMIQQhDCEQIRQhGCEcIRQhHCEgISQhKCEsISQhLCEwITQhOCE8ITQhPCFAIUQhSCFMIUQhTCFQIVQhWCFcIVQhXCFgIWQhaCFsIWQhbCFwIXQheCF8IXQhfCGAIYQhiCGMIZAhlCGYIZAhmCGcIaAhpCGoIaAhqCGsIbAhtCG4IbAhuCG8IcAhxCHIIcAhyCHMIdAh1CHYIdAh2CHcIeAh5CHoIeAh6CHsIfAh9CH4IfAh+CH8IgAiBCIIIgAiCCIMIhAiFCIYIhAiGCIcIiAiJCIoIiAiKCIsIjAiNCI4IjAiOCI8IkAiRCJIIkAiSCJMIlAiVCJYIlAiWCJcImAiZCJoImAiaCJsInAidCJ4InAieCJ8IoAihCKIIoAiiCKMIpAilCKYIpAimCKcIqAipCKoIqAiqCKsIrAitCK4IrAiuCK8IsAixCLIIsAiyCLMItAi1CLYItAi2CLcIuAi5CLoIuwi8CL0Iuwi9CL4IvwjACMEIwgjDCMQIwgjECMUIxgjHCMgIxgjICMkIygjLCMwIygjMCM0IzgjPCNAIzgjQCNEI0gjTCNQI0gjUCNUI1gjXCNgI2QjaCNsI2QjbCNwI3QjeCN8I3QjfCOAI4QjiCOMI4QjjCOQI5QjmCOcI5QjnCOgI6QjqCOsI6QjrCOwI7QjuCO8I7QjvCPAI8QjyCPMI8QjzCPQI9Qj2CPcI+Aj5CPoIAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHwAgACEAHwAhACIAIwAkACUAIwAlACYAJwAoACkAKgArACwAKgAsAC0ALgAvADAALgAwADEAMgAzADQAMgA0ADUANgA3ADgANgA4ADkAOgA7ADwAPQA+AD8APQA/AEAAQQBCAEMAQQBDAEQARQBGAEcARQBHAEgASQBKAEsASQBLAEwATQBOAE8ATQBPAFAAUQBSAFMAUQBTAFQAVQBWAFcAVQBXAFgAWQBaAFsAWQBbAFwAXQBeAF8AYABhAGIAYABiAGMAZABlAGYAZABmAGcAaABpAGoAawBsAG0AawBtAG4AbwBwAHEAbwBxAHIAcwB0AHUAcwB1AHYAdwB4AHkAdwB5AHoAewB8AH0AfgB/AIAAfgCAAIEAAAABAAIAAwAEAAUAAwAFAAYABwAIAAkABwAJAAoACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAEwAVABYAFwAYABkAFwAZABoAGwAcAB0AHgAfACAAHgAgACEAIgAjACQAIgAkACUAJgAnACgAKQAqACsALAAtAC4ALAAuAC8AMAAxADIAMAAyADMANAA1ADYANAA2ADcAOAA5ADoAOAA6ADsAPAA9AD4APAA+AD8AQABBAEIAQABCAEMARABFAEYARwBIAEkARwBJAEoASwBMAE0ASwBNAE4ATwBQAFEAUgBTAFQAUgBUAFUAVgBXAFgAVgBYAFkAWgBbAFwAWgBcAF0AXgBfAGAAXgBgAGEAYgBjAGQAYgBkAGUAZgBnAGgAZgBoAGkAagBrAGwAagBsAG0AbgBvAHAAbgBwAHEAcgBzAHQAcgB0AHUAdgB3AHgAdgB4AHkAegB7AHwAegB8AH0AfgB/AIAAfgCAAIEAggCDAIQAggCEAIUAhgCHAIgAhgCIAIkAiACKAIkAiwCMAIYAjQCLAIYAiQCNAIYAjQCOAIsAiQCPAI0AjwCQAI0AiQCRAI8AkgCTAJQAkgCUAJUAlgCXAJgAlgCYAJkAmgCbAJwAmgCcAJ0AngCfAKAAngCgAKEAogCjAKQAogCkAKUApgCnAKgApgCoAKkAqgCrAKwAqgCsAK0ArgCvALAArgCwALEAsgCzALQAsgC0ALUAtgC3ALgAtgC4ALkAugC7ALwAugC8AL0AvgC/AMAAvgDAAMEAwgDDAMQAwgDEAMUAxgDHAMgAxgDIAMkAygDLAMwAygDMAM0AzgDPANAAzgDQANEA0gDOANEA0gDRANMA1ADSANMA1ADTANUA1gDXANgA1gDYANkA2gDbANwA2gDcAN0A3gDfAOAA3wDhAOAA3wDiAOEA3gDgAOMA5ADeAOMA5ADjAOUA5gDnAOgA5gDoAOkA6gDrAOwA6gDsAO0A7gDvAPAA7gDwAPEA8gDzAPQA8gD0APUA9gD3APgA9gD4APkA+gD7APwA+gD8AP0A/gD/AAAB/gAAAQEBAgEDAQQBAgEEAQUBBgEHAQgBBgEIAQkBCgELAQwBCgEMAQ0BDgEPARABDgEQAREBEgETARQBEgEUARUBFgEXARgBFgEYARkBGgEbARwBGgEcAR0BHgEfASABHgEgASEBIgEjASQBIgEkASUBJgEnASgBJgEoASkBKgErASwBKgEsAS0BLgEvATABLgEwATEBMgEzATQBMgE0ATUBNgE3ATgBNgE4ATkBOgE7ATwBOgE8AT0BPgE/AUABPgFAAUEBQgFDAUQBQgFEAUUBRgFHAUgBRgFIAUkBSgFLAUwBSgFMAU0BTgFPAVABTgFQAVEBUgFTAVQBUgFUAVUBVgFXAVgBVgFYAVkBWgFbAVwBWgFcAV0BXgFfAWABXgFgAWEBYgFjAWQBYgFkAWUBZgFnAWgBZgFoAWkBagFrAWwBagFsAW0BbgFvAXABbgFwAXEBcgFzAXQBcgF0AXUBdgF3AXgBdgF4AXkBegF7AXwBegF8AX0BfgF/AYABfgGAAYEBggGDAYQBggGEAYUBhgGHAYgBhgGIAYkBigGLAYwBigGMAY0BjAGOAY0BjwGQAYoBkQGPAYoBjQGRAYoBkQGSAY8BjQGTAZEBkwGUAZEBjQGVAZMBlgGXAZgBlgGYAZkBmgGbAZwBmgGcAZ0BngGfAaABngGgAaEBogGjAaQBogGkAaUBpgGnAagBpgGoAakBqgGrAawBqgGsAa0BrgGvAbABrgGwAbEBsgGzAbQBsgG0AbUBtgG3AbgBtgG4AbkBugG7AbwBugG8Ab0BvgG/AcABvgHAAcEBwgHDAcQBwgHEAcUBxgHHAcgBxgHIAckBygHLAcwBygHMAc0BzgHPAdABzgHQAdEB0gHTAdQB0gHUAdUB1gHTAdIB1gHXAdMB2AHXAdYB2AHZAdcB2gHbAdwB2gHcAd0B3gHfAeAB3gHgAeEB4gHjAeQB4gHkAeUB5QHkAeYB5QHmAecB6AHpAeoB6AHqAesB7AHtAe4B7AHuAe8B8AHxAfIB8AHyAfMB9AH1AfYB9AH2AfcB+AH5AfoB+AH6AfsB/AH9Af4B/AH+Af8BAAIBAgICAAICAgMCBAIFAgYCBAIGAgcCCAIJAgoCCAIKAgsCDAINAg4CDAIOAg8CEAIRAhICEAISAhMCFAIVAhYCFAIWAhcCGAIZAhoCGAIaAhsCHAIdAh4CHAIeAh8CIAIhAiICIAIiAiMCJAIlAiYCJAImAicCKAIpAioCKAIqAisCLAItAi4CLAIuAi8CMAIxAjICMAIyAjMCNAI1AjYCNAI2AjcCOAI5AjoCOAI6AjsCPAI9Aj4CPAI+Aj8CQAJBAkICQAJCAkMCRAJFAkYCRAJGAkcCSAJJAkoCSAJKAksCTAJNAk4CTAJOAk8CUAJRAlICUAJSAlMCVAJVAlYCVAJWAlcCWAJZAloCWAJaAlsCXAJdAl4CXAJeAl8CYAJhAmICYAJiAmMCZAJlAmYCZAJmAmcCaAJpAmoCaAJqAmsCbAJtAm4CbAJuAm8CcAJxAnICcAJyAnMCdAJ1AnYCdAJ2AncCeAJ5AnoCeAJ6AnsCfAJ9An4CfAJ+An8CgAKBAoICgAKCAoMChAKFAoYChAKGAocCiAKJAooCiAKKAosCjAKNAo4CjAKOAo8CkAKRApICkAKSApMCkgKUApMClQKWApAClwKVApACkwKXApAClwKYApUCkwKZApcCmQKaApcCkwKbApkCnAKdAp4CnAKeAp8CoAKcAp8CoAKfAqECogKjAqQCogKkAqUCpgKnAqgCpgKoAqkCqgKrAqwCqgKsAq0CrgKvArACrgKwArECsgKzArQCsgK0ArUCtgK3ArgCtgK4ArkCugK7ArwCugK8Ar0CvgK/AsACvgLAAsECwgLDAsQCwgLEAsUCxgLHAsgCxgLIAskCygLLAswCygLMAs0CzgLPAtACzgLQAtEC0gLTAtQC0gLUAtUC1gLXAtgC1gLYAtkC2gLbAtwC2gLcAt0C3gLfAuAC3gLgAuEC4gLjAuQC4gLkAuUC5gLnAugC5gLoAukC6gLrAuwC6gLsAu0C7gLvAvAC7gLwAvEC8gLzAvQC8gL0AvUC9gL3AvgC9gL4AvkC+gL7AvwC+gL8Av0C/gL/AgAD/gIAAwEDAgMDAwQDAgMEAwUDBgMHAwgDBgMIAwkDCgMLAwwDCgMMAw0DDgMPAxADDgMQAxEDEgMTAxQDEgMUAxUDFgMXAxgDFgMYAxkDGgMbAxwDGgMcAx0DHgMfAyADHgMgAyEDIgMjAyQDIgMkAyUDJgMnAygDJgMoAykDKgMrAywDKgMsAy0DLgMvAzADLgMwAzEDMgMzAzQDMgM0AzUDNgM3AzgDNgM4AzkDOgM7AzwDOgM8Az0DPgM/A0ADPgNAA0EDQgNDA0QDQgNEA0UDRgNHA0gDRgNIA0kDSgNLA0wDSgNMA00DTgNPA1ADTgNQA1EDUgNTA1QDUgNUA1UDVgNXA1gDVgNYA1kDWgNbA1wDWgNcA10DXgNfA2ADXgNgA2EDYgNjA2QDYgNkA2UDZgNnA2gDZgNoA2kDagNrA2wDagNsA20DbgNvA3ADbgNwA3EDcgNzA3QDcgN0A3UDdgN3A3gDdgN4A3kDegN7A3wDegN8A30DfgN/A4ADfgOAA4EDggODA4QDggOEA4UDhgOHA4gDhgOIA4kDigOLA4wDigOMA40DjgOPA5ADjgOQA5EDkgOTA5QDkgOUA5UDlgOXA5gDlgOYA5kDmgObA5wDmgOcA50DnAOeA50DnwOgA5oDoQOfA5oDnQOhA5oDoQOiA58DnQOjA6EDowOkA6EDnQOlA6MDpgOnA6gDpgOoA6kDqgOrA6wDqgOsA60DrgOvA7ADrgOwA7EDsgOzA7QDsgO0A7UDtgO3A7gDtgO4A7kDugO7A7wDugO8A70DvgO/A8ADvgPAA8EDwgPDA8QDwgPEA8UDxgPHA8gDxgPIA8kDygPLA8wDygPMA80DzgPPA9ADzgPQA9ED0gPTA9QD0gPUA9UD1gPXA9gD1gPYA9kD2gPbA9wD2gPcA90D3gPfA+AD3gPgA+ED4gPjA+QD4gPkA+UD5gPnA+gD5gPoA+kD6gPrA+wD6gPsA+0D7gPvA/AD7gPwA/ED8gPzA/QD8gP0A/UD9gP3A/gD9gP4A/kD+gP7A/wD+gP8A/0D/gP/AwAE/gMABAEEAgQDBAQEAgQEBAUEBgQHBAgEBgQIBAkECgQLBAwECgQMBA0EDgQPBBAEDgQQBBEEEgQTBBQEEgQUBBUEFgQXBBgEFgQYBBkEGgQbBBwEGgQcBB0EHgQfBCAEHgQgBCEEIgQjBCQEIgQkBCUEJgQnBCgEJgQoBCkEKgQrBCwEKgQsBC0ELgQvBDAELgQwBDEEMgQzBDQEMgQ0BDUENgQ3BDgENgQ4BDkEOgQ7BDwEOgQ8BD0EPgQ/BEAEPgRABEEEQgRDBEQEQgREBEUERgRHBEgERgRIBEkESgRLBEwESgRMBE0ETgRPBFAETgRQBFEEUgRTBFQEUgRUBFUEVgRXBFgEVgRYBFkEWgRbBFwEWgRcBF0EXgRfBGAEXgRgBGEEYgRjBGQEYgRkBGUEZgRnBGgEZgRoBGkEagRrBGwEagRsBG0EbgRvBHAEbgRwBHEEAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHAAeAB8AIAAhACIAIAAiACMAJAAlACYAJAAmACcAKAApACoAKAAqACsALAAtAC4ALAAuAC8AMAAxADIAMAAyADMANAA1ADYANAA2ADcAOAA5ADoAOAA6ADsAPAA9AD4APAA+AD8AQABBAEIAQABCAEMARABFAEYARABGAEcARgBIAEcASQBKAEQASwBJAEQARwBLAEQASwBMAEkARwBNAEsATQBOAEsARwBPAE0AUABRAFIAUABSAFMAVABVAFYAVABWAFcAWABZAFoAWABaAFsAXABdAF4AXABeAF8AYABhAGIAYABiAGMAZABlAGYAZABmAGcAaABpAGoAaABqAGsAbABtAG4AbABuAG8AcABxAHIAcAByAHMAdAB1AHYAdAB2AHcAeAB5AHoAeAB6AHsAfAB9AH4AfAB+AH8AgACBAIIAgACCAIMAhACFAIYAhACGAIcAiACJAIoAiACKAIsAjACNAI4AjACOAI8AkACRAJIAkACSAJMAlACVAJYAlACWAJcAmACZAJoAmACaAJsAnACdAJ4AnACeAJ8AoAChAKIAoACiAKMApAClAKYApACmAKcAqACpAKoAqACqAKsArACtAK4ArACuAK8AsACxALIAsACyALMAtAC1ALYAtAC2ALcAuAC5ALoAuAC6ALsAvAC9AL4AvAC+AL8AwADBAMIAwADCAMMAxADFAMYAxADGAMcAyADJAMoAyADKAMsAzADNAM4AzADOAM8A0ADRANIA0ADSANMA1ADVANYA1ADWANcA2ADZANoA2ADaANsA3ADdAN4A3ADeAN8A4ADhAOIA4ADiAOMA5ADlAOYA5ADmAOcA6ADpAOoA6ADqAOsA7ADtAO4A7ADuAO8A8ADxAPIA8ADyAPMA9AD1APYA9AD2APcA+AD5APoA+AD6APsA/AD9AP4A/AD+AP8AAAEBAQIBAAECAQMBBAEFAQYBBAEGAQcBCAEJAQoBCAEKAQsBDAEIAQ0BDAENAQ4BDwEQAREBDwERARIBEwEUARUBEwEVARYBFwEYARkBFwEZARoBGwEcAR0BGwEdAR4BHwEgASEBHwEhASIBIwEkASUBIwElASYBJwEoASkBJwEpASoBKwEsAS0BKwEtAS4BLwEwATEBLwExATIBMwE0ATUBMwE1ATYBNwE4ATkBNwE5AToBOwE8AT0BOwE9AT4BPwFAAUEBPwFBAUIBQwFEAUUBQwFFAUYBRwFIAUkBRwFJAUoBSwFMAU0BSwFNAU4BTwFQAVEBTwFRAVIBUwFUAVUBUwFVAVYBVwFYAVkBVwFZAVoBWwFcAV0BWwFdAV4BXwFgAWEBXwFhAWIBYwFkAWUBYwFlAWYBZwFoAWkBZwFpAWoBawFsAW0BawFtAW4BbwFwAXEBbwFxAXIBcwF0AXUBcwF1AXYBdwF4AXkBdwF5AXoBewF8AX0BewF9AX4BfwGAAYEBfwGBAYIBgwGEAYUBgwGFAYYBhwGIAYkBhwGJAYoBiwGMAY0BiwGNAY4BjwGQAZEBjwGRAZIBkwGUAZUBkwGVAZYBlwGYAZkBlwGZAZoBmwGcAZ0BmwGdAZ4BnwGgAaEBnwGhAaIBowGkAaUBowGlAaYBpwGoAakBpwGpAaoBqwGsAa0BqwGtAa4BrwGwAbEBrwGxAbIBswG0AbUBswG1AbYBtwG4AbkBtwG5AboBuwG8Ab0BuwG9Ab4BvwHAAcEBvwHBAcIBwwHEAcUBwwHFAcYBxwHIAckBxwHJAcoBywHMAc0BywHNAc4BzwHQAdEBzwHRAdIB0wHUAdUB0wHVAdYB1wHYAdkB1wHZAdoB2wHcAd0B2wHdAd4B3wHgAeEB3wHhAeIB4wHkAeUB4wHlAeYB5wHoAekB5wHpAeoB6wHsAe0B6wHtAe4B7wHwAfEB7wHxAfIB8wH0AfUB8wH1AfYB9wH4AfkB9wH5AfoB+wH8Af0B+wH9Af4B/wEAAgEC/wEBAgICAwIEAgUCAwIFAgYCBwIIAgkCBwIJAgoCCwIMAg0CCwINAg4CDwIQAhECDwIRAhICEwIUAhUCEwIVAhYCFwIYAhkCFwIZAhoCGwIcAh0CGwIdAh4CHwIgAiECHwIhAiICIwIkAiUCIwIlAiYCJwIoAikCJwIpAioCKwIsAi0CKwItAi4CLwIwAjECLwIxAjICMwI0AjUCMwI1AjYCNwI4AjkCNwI5AjoCOwI8Aj0COwI9Aj4CPwJAAkECPwJBAkICQwJEAkUCQwJFAkYCRwJIAkkCRwJJAkoCSwJMAk0CSwJNAk4CTwJQAlECTwJRAlICUwJUAlUCUwJVAlYCVwJYAlkCVwJZAloCWwJcAl0CWwJdAl4CXwJgAmECXwJhAmICYwJkAmUCYwJlAmYCZwJoAmkCZwJpAmoCawJsAm0CawJtAm4CbwJwAnECbwJxAnICcQJzAnICdAJ1Am8CdgJ0Am8CcgJ2Am8CdgJ3AnQCcgJ4AnYCeAJ5AnYCcgJ6AngCewJ8An0CewJ9An4CfwKAAoECfwKBAoICgwKEAoUCgwKFAoYChwKIAokChwKJAooCiwKMAo0CiwKNAo4CjwKQApECjwKRApICkwKUApUCkwKVApYClwKYApkClwKZApoCmwKcAp0CmwKdAp4CnwKgAqECnwKhAqICowKkAqUCowKlAqYCpwKoAqkCpwKpAqoCqwKsAq0CqwKtAq4CrwKwArECrwKxArICswK0ArUCswK1ArYCtwK4ArkCtwK5AroCuwK8Ar0CuwK9Ar4CvwLAAsECvwLBAsICwwLEAsUCwwLFAsYCxwLIAskCxwLJAsoCywLMAs0CywLNAs4CzwLQAtECzwLRAtIC0wLUAtUC0wLVAtYC1wLYAtkC1wLZAtoC2wLcAt0C2wLdAt4C3wLgAuEC3wLhAuIC4wLkAuUC4wLlAuYC5wLoAukC5wLpAuoC6wLsAu0C6wLtAu4C7wLwAvEC7wLxAvIC8wL0AvUC8wL1AvYC9wL4AvkC9wL5AvoC+wL8Av0C+wL9Av4C/wIAAwED/wIBAwIDAwMEAwUDAwMFAwYDBwMIAwkDBwMJAwoDCwMMAw0DCwMNAw4DDwMQAxEDDwMRAxIDEwMUAxUDEwMVAxYDFwMYAxkDFwMZAxoDGwMcAx0DGwMdAx4DHwMgAyEDHwMhAyIDIwMkAyUDIwMlAyYDJwMoAykDJwMpAyoDKwMsAy0DKwMtAy4DLwMwAzEDLwMxAzIDMwM0AzUDMwM1AzYDNwM4AzkDNwM5AzoDOwM8Az0DOwM9Az4DPwNAA0EDPwNBA0IDQwNEA0UDQwNFA0YDRwNIA0kDRwNJA0oDSwNMA00DSwNNA04DTwNQA1EDTwNRA1IDUwNUA1UDUwNVA1YDVwNYA1kDVwNZA1oDWwNcA10DWwNdA14DXwNgA2EDXwNhA2IDYwNkA2UDYwNlA2YDZwNoA2kDZwNpA2oDawNsA20DawNtA24DbwNwA3EDbwNxA3IDcwN0A3UDcwN1A3YDdwN4A3kDdwN5A3oDewN8A30DewN9A34DfwOAA4EDfwOBA4IDgwOEA4UDgwOFA4YDhwOIA4kDhwOJA4oDiwOMA40DiwONA44DjwOQA5EDjwORA5IDkwOUA5UDkwOVA5YDlwOYA5kDlwOZA5oDmwOcA50DmwOdA54DnwOgA6EDnwOhA6IDowOkA6UDowOlA6YDpwOoA6kDpwOpA6oDqwOsA60DqwOtA64DrwOwA7EDrwOxA7IDswO0A7UDswO1A7YDtwO4A7kDtwO5A7oDuwO8A70DuwO9A74DvwPAA8EDvwPBA8IDwwPEA8UDwwPFA8YDxwPIA8kDxwPJA8oDywPMA80DywPNA84DzwPQA9EDzwPRA9ID0wPUA9UD0wPVA9YD1wPYA9kD1wPZA9oD2wPcA90D2wPdA94D3wPgA+ED3wPhA+ID4wPkA+UD4wPlA+YD5wPoA+kD5wPpA+oD6wPsA+0D6wPtA+4D7wPwA/ED7wPxA/ID8wP0A/UD8wP1A/YD9wP4A/kD9wP5A/oD+wP8A/0D+wP9A/4D/wMABAEE/wMBBAIEAwQEBAUEAwQFBAYEBwQIBAkEBwQJBAoECwQMBA0ECwQNBA4EDwQQBBEEDwQRBBIEEwQUBBUEEwQVBBYEFwQYBBkEFwQZBBoEGwQcBB0EGwQdBB4EHwQgBCEEHwQhBCIEIwQkBCUEIwQlBCYEJwQoBCkEJwQpBCoEKwQsBC0EKwQtBC4ELwQwBDEELwQxBDIEMwQ0BDUEMwQ1BDYENwQ4BDkENwQ5BDoEOwQ8BD0EOwQ9BD4EPwRABEEEPwRBBEIEQwREBEUEQwRFBEYERwRIBEkERwRJBEoESwRMBE0ESwRNBE4ETwRQBFEETwRRBFIEUwRUBFUEUwRVBFYEVwRYBFkEVwRZBFoEWwRcBF0EWwRdBF4EXwRgBGEEXwRhBGIEYwRkBGUEYwRlBGYEZwRoBGkEZwRpBGoEawRsBG0EawRtBG4EbwRwBHEEbwRxBHIEcwR0BHUEcwR1BHYEdwR4BHkEdwR5BHoEewR8BH0EewR9BH4EfwSABIEEfwSBBIIEgwSEBIUEgwSFBIYEhwSIBIkEhwSJBIoEiwSMBI0EiwSNBI4EjwSQBJEEjwSRBJIEkwSUBJUEkwSVBJYElwSYBJkElwSZBJoEmwScBJ0EmwSdBJ4EnQSfBJ4EoAShBJsEogSgBJsEngSiBJsEogSjBKAEngSkBKIEpASlBKIEngSmBKQEpwSoBKkEpwSpBKoEqwSsBK0EqwStBK4ErwSwBLEErwSxBLIEswS0BLUEswS1BLYEtwS4BLkEtwS5BLoEuwS8BL0EuwS9BL4EvwTABMEEvwTBBMIEwwTEBMUEwwTFBMYExwTIBMkExwTJBMoEywTMBM0EywTNBM4EzwTQBNEEzwTRBNIE0wTUBNUE0wTVBNYE1wTYBNkE1wTZBNoE2wTcBN0E2wTdBN4E3wTgBOEE3wThBOIE4wTkBOUE4wTlBOYE5wToBOkE5wTpBOoE6wTsBO0E6wTtBO4E7wTwBPEE7wTxBPIE8wT0BPUE8wT1BPYE9wT4BPkE9wT5BPoE+wT8BP0E+wT9BP4E/wQABQEF/wQBBQIFAwUEBQUFAwUFBQYFBwUIBQkFBwUJBQoFCwUMBQ0FCwUNBQ4FDwUQBREFDwURBRIFEwUUBRUFEwUVBRYFFwUYBRkFFwUZBRoFGwUcBR0FGwUdBR4FHwUgBSEFHwUhBSIFIwUkBSUFIwUlBSYFJwUoBSkFJwUpBSoFKwUsBS0FKwUtBS4FLwUwBTEFLwUxBTIFMwU0BTUFMwU1BTYFNwU4BTkFNwU5BToFOwU8BT0FOwU9BT4FPwVABUEFPwVBBUIFQwVEBUUFQwVFBUYFRwVIBUkFRwVJBUoFSwVMBU0FSwVNBU4FTwVQBVEFTwVRBVIFUwVUBVUFUwVVBVYFVwVYBVkFVwVZBVoFWwVcBV0FWwVdBV4FXwVgBWEFXwVhBWIFYwVkBWUFYwVlBWYFZwVoBWkFZwVpBWoFawVsBW0FawVtBW4FbwVwBXEFbwVxBXIFcwV0BXUFcwV1BXYFdwV4BXkFdwV5BXoFewV8BX0FewV9BX4FfwWABYEFfwWBBYIFgwWEBYUFgwWFBYYFhwWIBYkFhwWJBYoFiwWMBY0FiwWNBY4FjwWQBZEFjwWRBZIFkwWUBZUFkwWVBZYFlwWYBZkFlwWZBZoFmwWcBZ0FmwWdBZ4FnwWgBaEFnwWhBaIFowWkBaUFowWlBaYFpwWoBakFpwWpBaoFqwWsBa0FqwWtBa4FrwWwBbEFrwWxBbIFswW0BbUFswW1BbYFtwW4BbkFtwW5BboFuwW8Bb0FuwW9Bb4FvwXABcEFvwXBBcIFwwXEBcUFwwXFBcYFxwXIBckFxwXJBcoFywXMBc0FywXNBc4FzwXQBdEFzwXRBdIF0wXUBdUF0wXVBdYF1wXYBdkF1wXZBdoF2wXcBd0F2wXdBd4F3wXgBeEF3wXhBeIF4wXkBeUF4wXlBeYF5wXoBekF5wXpBeoF6wXsBe0F6wXtBe4F7wXwBfEF7wXxBfIF8wX0BfUF8wX1BfYF9wX4BfkF9wX5BfoF+wX8Bf0F+wX9Bf4F/wUABgEG/wUBBgIGAwYEBgUGAwYFBgYGBwYIBgkGBwYJBgoGCwYMBg0GCwYNBg4GDwYQBhEGDwYRBhIGEwYUBhUGEwYVBhYGFwYYBhkGFwYZBhoGGwYcBh0GGwYdBh4GHwYgBiEGHwYhBiIGIwYkBiUGIwYlBiYGJwYoBikGJwYpBioGKwYsBi0GKwYtBi4GLwYwBjEGLwYxBjIGMwY0BjUGMwY1BjYGNwY4BjkGNwY5BjoGOwY8Bj0GOwY9Bj4GPwZABkEGPwZBBkIGQwZEBkUGQwZFBkYGRwZIBkkGRwZJBkoGSwZMBk0GSwZNBk4GTwZQBlEGTwZRBlIGUwZUBlUGUwZVBlYGVwZYBlkGVwZZBloGWwZcBl0GWwZdBl4GXwZgBmEGXwZhBmIGYwZkBmUGYwZlBmYGZwZoBmkGZwZpBmoGawZsBm0GawZtBm4GbwZwBnEGbwZxBnIGcwZ0BnUGcwZ1BnYGdwZ4BnkGdwZ5BnoGewZ8Bn0GewZ9Bn4GfwaABoEGfwaBBoIGgwaEBoUGgwaFBoYGhwaIBokGhwaJBooGiwaMBo0GiwaNBo4GjwaQBpEGjwaRBpIGkwaUBpUGkwaVBpYGlwaYBpkGlwaZBpoGmwacBp0GmwadBp4GnwagBqEGnwahBqIGowakBqUGowalBqYGpwaoBqkGpwapBqoGqwasBq0GqwatBq4GrwawBrEGrwaxBrIGswa0BrUGswa1BrYGtwa4BrkGtwa5BroGuwa8Br0Guwa9Br4GvwbABsEGvwbBBsIGwwbEBsUGwwbFBsYGxwbIBskGxwbJBsoGyQbLBsoGzAbNBscGzgbMBscGygbOBscGzgbPBswGygbQBs4G0AbRBs4GygbSBtAG0wbUBtUG0wbVBtYG1wbYBtkG1wbZBtoG2wbcBt0G2wbdBt4G3wbgBuEG3wbhBuIG4wbkBuUG4wblBuYG5wboBukG5wbpBuoG6wbsBu0G6wbtBu4G7wbwBvEG7wbxBvIG8wb0BvUG8wb1BvYG9wb4BvkG9wb5BvoG+wb8Bv0G+wb9Bv4G/wYABwEH/wYBBwIHAwcEBwUHAwcFBwYHBwcIBwkHBwcJBwoHCwcMBw0HCwcNBw4HDwcQBxEHDwcRBxIHEwcUBxUHEwcVBxYHFwcYBxkHFwcZBxoHGwccBx0HGwcdBx4HHwcgByEHHwchByIHIwckByUHIwclByYHJwcoBykHJwcpByoHKwcsBy0HKwctBy4HLwcwBzEHLwcxBzIHMwc0BzUHMwc1BzYHNwc4BzkHNwc5BzoHOwc8Bz0HOwc9Bz4HPwdAB0EHPwdBB0IHQwdEB0UHQwdFB0YHRwdIB0kHRwdJB0oHSwdMB00HSwdNB04HTwdQB1EHTwdRB1IHUwdUB1UHUwdVB1YHVwdYB1kHVwdZB1oHWwdcB10HWwddB14HXwdgB2EHXwdhB2IHYwdkB2UHYwdlB2YHZwdoB2kHZwdpB2oHawdsB20HawdtB24HbwdwB3EHbwdxB3IHcwd0B3UHcwd1B3YHdwd4B3kHdwd5B3oHewd8B30Hewd9B34HfweAB4EHfweBB4IHgweEB4UHgweFB4YHhweIB4kHhweJB4oHiweMB40HiweNB44HjweQB5EHjweRB5IHkweUB5UHkweVB5YHlweYB5kHlweZB5oHmwecB50HmwedB54HnwegB6EHnwehB6IHowekB6UHowelB6YHpweoB6kHpwepB6oHqwesB60HqwetB64HrwewB7EHrwexB7IHswe0B7UHswe1B7YHtwe4B7kHtwe5B7oHuwe8B70Huwe9B74HvwfAB8EHvwfBB8IHwwfEB8UHwwfFB8YHxwfIB8kHxwfJB8oHywfMB80HywfNB84HzwfQB9EHzwfRB9IH0wfUB9UH0wfVB9YH1wfYB9kH1wfZB9oH2wfcB90H2wfdB94H3wfgB+EH3wfhB+IH4wfkB+UH4wflB+YH5wfoB+kH5wfpB+oH6wfsB+0H6wftB+4H7wfwB/EH7wfxB/IH8wf0B/UH8wf1B/YH9wf4B/kH9wf5B/oH+wf8B/0H+wf9B/4H/wcACAEI/wcBCAIIAwgECAUIAwgFCAYIBwgICAkIBwgJCAoICwgMCA0ICwgNCA4IDwgQCBEIDwgRCBIIEwgUCBUIEwgVCBYIFwgYCBkIFwgZCBoIGwgcCB0IGwgdCB4IHwggCCEIHwghCCIIIwgkCCUIIwglCCYIJwgoCCkIJwgpCCoIKwgsCC0IKwgtCC4ILwgwCDEILwgxCDIIMwg0CDUIMwg1CDYINwg4CDkINwg5CDoIOwg8CD0IOwg9CD4IPwhACEEIPwhBCEIIQwhECEUIQwhFCEYIRwhICEkIRwhJCEoISwhMCE0ISwhNCE4ITwhQCFEITwhRCFIIUwhUCFUIUwhVCFYIVwhYCFkIVwhZCFoIWwhcCF0IWwhdCF4IXwhgCGEIXwhhCGIIYwhkCGUIYwhlCGYIZwhoCGkIZwhpCGoIawhsCG0IawhtCG4IbwhwCHEIbwhxCHIIcwh0CHUIcwh1CHYIdwh4CHkIdwh5CHoIewh8CH0Iewh9CH4IfwiACIEIfwiBCIIIgwiECIUIgwiFCIYIhwiICIkIhwiJCIoIiwiMCI0IiwiNCI4IjwiQCJEIjwiRCJIIkwiUCJUIkwiVCJYIlwiYCJkIlwiZCJoImwicCJ0ImwidCJ4InwigCKEInwihCKIIowikCKUIowilCKYIpwioCKkIpwipCKoIqwisCK0IqwitCK4IrwiwCLEIrwixCLIIswi0CLUIswi1CLYItwi4CLkItwi5CLoIuwi8CL0Iuwi9CL4IAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACwAMAA0ADgAPABAADgAQABEAEgATABQAEgAUABUAFgAXABgAGQAaABsAAAABAAIAAAACAAMABAAFAAYABwAIAAkABwAJAAoACwAMAA0A\");\n\n//# sourceURL=webpack:///./assets/NormalCar1.glb?");

/***/ }),

/***/ "./assets/NormalCar2.glb":
/*!*******************************!*\
  !*** ./assets/NormalCar2.glb ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAABkfAEALBIAAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjkyNzAwfV0sImFzc2V0Ijp7InZlcnNpb24iOiIyLjAiLCJnZW5lcmF0b3IiOiJnbHRmcGFjayAwLjE2In0sImV4dGVuc2lvbnNVc2VkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiIsIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0Il0sImV4dGVuc2lvbnNSZXF1aXJlZCI6WyJLSFJfbWVzaF9xdWFudGl6YXRpb24iXSwiYnVmZmVyVmlld3MiOlt7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6MCwiYnl0ZUxlbmd0aCI6NDkzMDQsImJ5dGVTdHJpZGUiOjgsInRhcmdldCI6MzQ5NjJ9LHsiYnVmZmVyIjowLCJieXRlT2Zmc2V0Ijo0OTMwNCwiYnl0ZUxlbmd0aCI6MjQ2NTIsImJ5dGVTdHJpZGUiOjQsInRhcmdldCI6MzQ5NjJ9LHsiYnVmZmVyIjowLCJieXRlT2Zmc2V0Ijo3Mzk1NiwiYnl0ZUxlbmd0aCI6MTg3NDQsInRhcmdldCI6MzQ5NjN9XSwiYWNjZXNzb3JzIjpbeyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTkzNCwidHlwZSI6IlZFQzMiLCJtaW4iOlswLDg2Miw3OF0sIm1heCI6WzgxMTAsNTY3MSwxNjI3NV19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjE5MzQsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6Mjg1MCwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MTU0NzIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxMzAsInR5cGUiOiJWRUMzIiwibWluIjpbODE1LDM4NDgsMjEyMl0sIm1heCI6WzcyOTUsNTUwOSwxMTk1M119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6NzczNiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjEzMCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjU3MDAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxODYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjE2NTEyLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTA4OCwidHlwZSI6IlZFQzMiLCJtaW4iOlszNTMsMCwyMjEwXSwibWF4IjpbNzc2Myw1NTg0LDE0NTM5XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0Ijo4MjU2LCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MTA4OCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjYwNzIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxNzQwLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyNTIxNiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIyMTksInR5cGUiOiJWRUMzIiwibWluIjpbNDEyLDQxNSwyMThdLCJtYXgiOls3NzA0LDI3NzcsMTYxNDhdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjEyNjA4LCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MjIxOSwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjk1NTIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNDA4LCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0Ijo0Mjk2OCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzkzOCwxOTg4LDE1MjMwXSwibWF4IjpbNzE3MywyNjg2LDE1OTM5XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoyMTQ4NCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MTYzNjgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozMCwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6NDMxNDQsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50Ijo3NTgsInR5cGUiOiJWRUMzIiwibWluIjpbMjkxLDg0NywwXSwibWF4IjpbNzgxOSwxNjgwLDE2MzgzXX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoyMTU3MiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjc1OCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE2NDI4LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTE0NiwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6NDkyMDgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxMiwidHlwZSI6IlZFQzMiLCJtaW4iOlsxMTM0LDI4MjQsODc1XSwibWF4IjpbNjk3NiwzNzU0LDEzNjRdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjI0NjA0LCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MTIsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjoxODcyMCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjEyLCJ0eXBlIjoiU0NBTEFSIn1dLCJtYXRlcmlhbHMiOlt7Im5hbWUiOiJMaWdodEJsdWUiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjU3MzYyNjY5NywwLjY4NDkwNTI5MSwwLjgwMDAwMDA3MiwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IldpbmRvd3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjAzNTYwMTMxNzksMC4wMzU2MDEzMTc5LDAuMDM1NjAxMzE3OSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkJsYWNrIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4wMTM3MDIwODYyLDAuMDEzNzAyMDg2MiwwLjAxMzcwMjA4NjIsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJHcmV5IiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4yMDE1NTYyOCwwLjIwMTU1NjI4LDAuMjAxNTU2MjgsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJIZWFkbGlnaHRzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC43OTkxMDI3ODMsMC4zNzYyNjIxMjgsMC4xMjc0Mzc3MTEsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJNYXRlcmlhbC4wMDciLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjIwMDAwMDAwMywwLjIwMDAwMDAwMywwLjIwMDAwMDAwMywxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC4xNzA0ODM0NTV9LCJkb3VibGVTaWRlZCI6dHJ1ZSwiZXh0ZW5zaW9ucyI6eyJLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdCI6eyJjbGVhcmNvYXRGYWN0b3IiOjAuMjUxOTA4MzYyLCJjbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IiOjF9fX0seyJuYW1lIjoiVGFpbExpZ2h0cyIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNzk5MTAyNzgzLDAuMDkzMDU4OTczNiwwLjA3NDIxMzU3OTMsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfV0sIm1lc2hlcyI6W3sicHJpbWl0aXZlcyI6W3siYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MCwiTk9STUFMIjoxfSwibW9kZSI6NCwiaW5kaWNlcyI6MiwibWF0ZXJpYWwiOjB9LHsiYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MywiTk9STUFMIjo0fSwibW9kZSI6NCwiaW5kaWNlcyI6NSwibWF0ZXJpYWwiOjF9LHsiYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6NiwiTk9STUFMIjo3fSwibW9kZSI6NCwiaW5kaWNlcyI6OCwibWF0ZXJpYWwiOjJ9LHsiYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6OSwiTk9STUFMIjoxMH0sIm1vZGUiOjQsImluZGljZXMiOjExLCJtYXRlcmlhbCI6M30seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjoxMiwiTk9STUFMIjoxM30sIm1vZGUiOjQsImluZGljZXMiOjE0LCJtYXRlcmlhbCI6NH0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjoxNSwiTk9STUFMIjoxNn0sIm1vZGUiOjQsImluZGljZXMiOjE3LCJtYXRlcmlhbCI6NX0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjoxOCwiTk9STUFMIjoxOX0sIm1vZGUiOjQsImluZGljZXMiOjIwLCJtYXRlcmlhbCI6Nn1dfV0sIm5vZGVzIjpbeyJtZXNoIjowLCJ0cmFuc2xhdGlvbiI6Wy0wLjgxOTIyNDA2LC0wLjAyODM0MjU1OTksLTEuNjQ5Mjg4ODldLCJzY2FsZSI6WzAuMDAwMjAyMDE1Njk3LDAuMDAwMjAyMDE1Njk3LDAuMDAwMjAyMDE1Njk3XX1dLCJzY2VuZXMiOlt7Im5hbWUiOiJTY2VuZSIsIm5vZGVzIjpbMF19XSwic2NlbmUiOjB9IBxqAQBCSU4Aghi+B/QBAACCGB8LywIAAM0biwoPBQAAzRu+ByoFAABDHr4HcRUAAEMeTQyEFQAAQx4TDLgeAABDHr4Hwx4AANcPJA6ENQAAUhUpDnM1AAAwFqkO/TEAANcPnA42MgAA/h22Cl43AAC9G+UNCjcAAG8bSAxeOwAAgx2+ChU5AAAJFQAP7AUAAAkVUQ9fAwAA1w9RDw8DAADXDwAPrgUAALQbAA/QBgAAYR3sCT0KAADuHKEIowgAAIAbUQ9PBQAAzRuLCg8FAADXD1YLJgEAAAkVVguhAQAAeBTxCnwBAADXD/EKHAEAAAkVvgfJAAAACRVWC6EBAACCGB8LywIAAIIYvgf0AQAArxQgDPk8AAA8F5oK1j0AABIbtArkPAAAbxtIDF47AAC9G+UNCjcAAAkVnA2sOAAArxQgDPk8AABvG0gMXjsAAEMevgfDHgAAQx4TDLgeAACJHiIMuB4AAIkezQfDHgAAQx6+ByQkAABDHgwMWSQAACMe8As7LgAAIx6pBxsuAAAJFQAP7AUAANcPAA+uBQAA1w/FDzsIAAABFcUPdQgAANAaGxLSKAAAaxz2DuMtAABHHFAPQiwAAOAaDxLUJwAALxyeDrYxAAAwFqkO/TEAAFIVKQ5zNQAA3xtZDlM0AABDHgwMWSQAANYc9g7rJAAAaxz2DuMtAAAjHvALOy4AAEMe1QozMQAALxyeDrYxAADfG1kOUzQAACceDwtNMwAA1w/hDpYvAACMFuEOfC8AALYWQQ+3LgAA1w9BD88uAAAjHvALOy4AAGsc9g7jLQAALxyeDrYxAABDHtUKMzEAAGsc9g7jLQAAjBbhDnwvAAAwFqkO/TEAAC8cng62MQAAIx6pBxsuAAAjHvALOy4AAEMe1QozMQAAQx6+B8guAABDHk0MhBUAAEMeOAzKFAAA1hz2DrQUAADWHPYOahUAADkeuQeHEwAAOR7XC/ARAABDHjgMyhQAAEMevge0FAAARxs5Es8dAADWHPYOYh4AAKUceg/VHQAAPhtTEksdAABDHjgMyhQAADke1wvwEQAAHBz2DhENAADWHPYOtBQAAGsc9g7jLQAA0BobEtIoAABKGhkS2SgAALQbQQ9QLQAAYR3sCT0KAADzHWYLQw4AAOkdKQohDgAAXh1xCYUKAADuHMUG7gcAAO4coQijCAAAAR1YCDoJAAABHcUGqQgAACQZhBXsHAAARxs5Es8dAAA+G1MSSx0AAIcZJBV3HAAA8x1mC0MOAABhHewJPQoAABwc9g4RDQAA1hz2DmIeAABHGzkSzx0AAD4bKRKdHgAApRxQDx4fAACvFCAM+TwAANcPGAz5PAAA1w+LCo4+AAAJFYsKYT4AAIMdvgoVOQAAbxtIDF47AAD2G3kJiDsAAFMbtwcoPQAAaRx3CBM8AAAuHIcIKjwAADEb2QcmPQAACRVOBGU/AAAJFb4HZT8AADsUNQdsPwAAOxTWBGw/AABqFRcEqA8AAGoVXgOIEwAA1w9eA4gTAADXDxcEyQ8AAPMdZgtDDgAAOR7XC/ARAAAmHp4IZREAAOkdKQohDgAArhkXBAoQAAD6GawDoxIAAGoVXgOIEwAAahUXBKgPAABjHb4HijkAAPkdKwpeNwAA/h22Cl43AACDHb4KFTkAAN8bWQ5TNAAAUhUpDnM1AAAJFZwNrDgAAL0b5Q0KNwAAJx4PC00zAADfG1kOUzQAAL0b5Q0KNwAA/h22Cl43AADXD7kN+DgAAAkVnA2sOAAAUhUpDnM1AADXDyQOhDUAAP4dtgpeNwAA+R0rCl43AAAnHg8LTTMAAPkdKwpeNwAAYx2+B4o5AAB3HUMHpTgAAPUdEgn6NgAAQx7VCjMxAAAnHg8LTTMAABYe8glKMwAANB4RCZkwAABDHr4HyC4AAEMe1QozMQAANB4RCZkwAAA0HkMHoi8AACceDwtNMwAA+R0rCl43AAD1HRIJ+jYAABYe8glKMwAAQx5gBBguAABDHr4HyC4AADQeQweiLwAANB5JBA4vAABTHUkEGjkAAEsdZwMxOQAAihlnAzE5AACSGUkEGjkAAPUdEgn6NgAAdx1DB6U4AAC2GUMHpTgAADQaEgn6NgAANB5JBA4vAAA0HkMHoi8AAHMaQweiLwAAcxpJBA4vAAA0HhEJmTAAABYe8glKMwAAuhoMCkozAABzGhEJmTAAABYe8glKMwAA9R0SCfo2AAA0GhIJ+jYAALoaDApKMwAANB5DB6IvAAA0HhEJmTAAAHMaEQmZMAAAcxpDB6IvAACSGUkEGjkAAHMaSQQOLwAAcxpDB6IvAAC2GUMHpTgAADQaEgn6NgAAcxoRCZkwAAC6GgwKSjMAALYZQwelOAAAcxpDB6IvAABzGhEJmTAAADQaEgn6NgAA1w9nA+8tAAAJFWcD7y0AABkVZwMuOgAA1w9nAy46AACWCmcDLjoAAKUKZwPvLQAAJQZnAzE5AAA8BWcD7C4AAAkVZwPvLQAAcxpnA+wuAACKGWcDMTkAABkVZwMuOgAAJBmEFewcAAAKFScW8RwAAAoVqxV3JAAAFhkOFSQkAACMFuEOfC8AAGsc9g7jLQAAtBtBD1AtAAC2FkEPty4AAAoVJxbxHAAA1w8nFvEcAADXD/UVhSQAAAoVqxV3JAAA0BobEtIoAAAWGQ4VJCQAALAYrRTrJAAAShoZEtkoAAA5GTAVlhUAADsZJBUCFQAAChX4FSwVAAAKFQEWwRUAAAoVARbBFQAAChX4FSwVAADXDxAWLBUAANcPGBbCFQAAOxkkFQIVAACOGQkVtQ4AAAoV0BXYDgAAChX4FSwVAAAKFfgVLBUAAAoV0BXYDgAA1w/QFdgOAADXDxAWLBUAAI4ZCRW1DgAApBp8EiIMAABeGnAS/gsAAFAZ1BRODgAA1hz2DmoVAADWHPYOtBQAAKAcfw8MFQAApRx6D68VAAAcHPYOEQ0AAPgacxHeDQAAAxumEZwOAAADHHoP3A0AANYc9g7rJAAA1hz2DmIeAAClHFAPHh8AAKUcUA9pJAAAFhkOFSQkAADQGhsS0igAAOAaDxLUJwAARxmeFPAjAADXD1EPDwMAAAkVUQ9fAwAACRVWC6EBAADXD1YLJgEAAAkVUQ9fAwAAtxhRD3kEAACCGB8LywIAAAkVVguhAQAAghgfC8sCAAC3GFEPeQQAAA8Zvw5fBAAA5xiNCxgDAADXD0EPzy4AALYWQQ+3LgAAtBYID5ouAADXDwgPsS4AALQbQQ9QLQAAShoZEtkoAABHGt8RuygAALEbCA8yLQAAsBitFOskAAA0FUoVByYAADEVEBXqJQAArRhzFM4kAAA0FUoVByYAANcPlBV7JgAA1w9aFV4mAAAxFRAV6iUAAAoVqxV3JAAA1w/1FYUkAADXD5QVeyYAADQVShUHJgAAFhkOFSQkAAAKFasVdyQAADQVShUHJgAAsBitFOskAABHHFAPQiwAAKUcUA9pJAAAfhw2D2YkAAAgHDYPPywAAKUcUA8eHwAAPhspEp0eAAAXGxASmh4AAH4cNg8bHwAApRxQD2kkAAClHFAPHh8AAH4cNg8bHwAAfhw2D2YkAABHGZ4U8CMAAOAaDxLUJwAAuRr2EdEnAAAgGYUU7SMAAGsc9g7jLQAA1hz2DuskAAClHFAPaSQAAEccUA9CLAAAJBmEFewcAAAWGQ4VJCQAAEcZnhTwIwAAahn2FNcdAABHGzkSzx0AACQZhBXsHAAAahn2FNcdAAA+GykSnR4AAIcZJBV3HAAAPhtTEksdAAAYGz0STx0AAGUZBxV7HAAAoBx/DwwVAAADHHoP3A0AAN0bZA/fDQAAfxxkDw0VAAADG6YRnA4AAMQZsRPgEQAAoRmWE+QRAADdGpARnw4AAPgacxHeDQAAjhkJFbUOAADEGbET4BEAAAMbphGcDgAAjhkJFbUOAAA7GSQVAhUAAJEZXxQhFQAAxBmxE+ARAAA5GTAVlhUAACQZhBXsHAAAhxkkFXccAACQGW4UqxUAANYc9g60FAAAHBz2DhENAAADHHoP3A0AAKAcfw8MFQAAZRndBI4JAACuGRcEChAAAGoVFwSoDwAAahXdBPkIAAA5HtcL8BEAADkeuQeHEwAAJh4FB3wSAAAmHp4IZREAAGoV3QT5CAAAahUXBKgPAADXDxcEyQ8AANcP3QS7CAAAOR7XC/ARAADzHWYLQw4AABwc9g4RDQAA7hyhCKMIAABhHewJPQoAAF4dcQmFCgAAAR1YCDoJAADuHIsFqAcAAO4cxQbuBwAAAR3FBqkIAAABHXkFYwgAALQbAA/QBgAACRUAD+wFAAABFcUPdQgAAMcaRRBmCQAA+BpzEd4NAACkGnwSIgwAAI4ZCRW1DgAA+BpzEd4NAAAcHPYOEQ0AAAgbaRCpCQAAzRu+ByoFAADNG4sKDwUAAO4coQijCAAA7hzFBu4HAAABHcUGqQgAAAEdWAg6CQAAfRlZCD0JAABpGS0GvggAACYenghlEQAAJh4FB3wSAAAOGgMHaBIAAPoZnghjEQAA6R0pCiEOAAAmHp4IZREAAPoZnghjEQAAyxkpCiEOAABeHXEJhQoAAOkdKQohDgAAyxkpCiEOAACcGXEJhgoAAAEdeQVjCAAAAR3FBqkIAABpGS0GvggAAEoZdQVoCAAAAR1YCDoJAABeHXEJhQoAAJwZcQmGCgAAfRlZCD0JAABKGXUFaAgAAGkZLQa+CAAAlBkQB0gKAABuGW4FsQkAAPoZnghjEQAAnBlxCYYKAADLGSkKIQ4AAA4aAwdoEgAA7hkQB4QQAADwGYEHqxAAAH0ZWQg9CQAAnBlxCYYKAACYGcUImQoAAPAZgQerEAAA7hkQB4QQAACUGRAHSAoAAJgZxQiZCgAA8BmBB6sQAAD6GZ4IYxEAAA4aAwdoEgAAuhnNBCEQAADuGRAHhBAAAA4aAwdoEgAA/hloBK0SAACYGcUImQoAAJQZEAdICgAAaRktBr4IAAB9GVkIPQkAAJgZxQiZCgAAnBlxCYYKAAD6GZ4IYxEAAPAZgQerEAAAbhluBbEJAACUGRAHSAoAAO4ZEAeEEAAAuhnNBCEQAABKGhkS2SgAALAYrRTrJAAArRhzFM4kAABHGt8RuygAALYWQQ+3LgAAtBtBD1AtAACxGwgPMi0AALQWCA+aLgAAPhspEp0eAABqGfYU1x0AAEgZ1RTUHQAAFxsQEpoeAABqGfYU1x0AAEcZnhTwIwAAIBmFFO0jAABIGdUU1B0AAOAaDxLUJwAARxxQD0IsAAAgHDYPPywAALka9hHRJwAABRu6EScVAABvGUIUJBUAAJEZXxQhFQAAJhvVESUVAAAHG8MRwBUAAH8cZA+zFQAApRx6D68VAAAoG94RvxUAAJAZbhSrFQAAhxkkFXccAABlGQcVexwAAG4ZURSuFQAAPhtTEksdAAClHHoP1R0AAH8cZA/ZHQAAGBs9Ek8dAAADHHoP3A0AAAMbphGcDgAA3RqQEZ8OAADdG2QP3w0AAMQZsRPgEQAAkRlfFCEVAABvGUIUJBUAAKEZlhPkEQAAUBnUFE4OAABeGnAS/gsAAF0aTxINDAAAUBmzFF0OAAABFcUPdQgAANcPxQ87CAAA1w+kD0oIAAAAFaQPgwgAANcPpxVvDgAAGhWnFW8OAAAaFYUVfQ4AANcPhRV9DgAAxxpFEGYJAAABFcUPdQgAAAAVpA+DCAAAxhokEHQJAACkGnwSIgwAAAgbaRCpCQAAxxpFEGYJAABeGnAS/gsAAMcaRRBmCQAACBtpEKkJAAC0GwAP0AYAAAgbaRCpCQAApBp8EiIMAAD4GnMR3g0AAAgbaRCpCQAAHBz2DhENAAC0GwAP0AYAAGkcdwgTPAAAUxu3Byg9AAA9G1EEWz0AACYcVwRZOwAAYx2+B4o5AACDHb4KFTkAAPYbeQmIOwAAaRx3CBM8AABjHb4HijkAAGkcdwgTPAAAJhxXBFk7AAA4HWAEEjoAAGUZ3QSOCQAAbhluBbEJAAC6Gc0EIRAAAK4ZFwQKEAAArhkXBAoQAAC6Gc0EIRAAAP4ZaAStEgAA+hmsA6MSAABDGfYEXQgAAEoZdQVoCAAAbhluBbEJAABlGd0EjgkAACYeBQd8EgAAJh6EBMISAAD+GWgErRIAAA4aAwdoEgAAzRu+ByoFAADuHMUG7gcAAO4ciwWoBwAAzRtUBioFAACKGWcDMTkAAHMaZwPsLgAAcxpJBA4vAACSGUkEGjkAAHcdQwelOAAAUx1JBBo5AACSGUkEGjkAALYZQwelOAAAYx2+B4o5AAA4HWAEEjoAAFMdSQQaOQAAdx1DB6U4AAA5HrkHhxMAADkeQwSQEwAAJh6EBMISAAAmHgUHfBIAAAkVvgfJAAAAghi+B/QBAACCGI8G9AEAAAkVjwbJAAAAIx6pBxsuAABDHr4HyC4AAEMeYAQYLgAAIx5KBM0sAABDHk4EDx4AAEMevgfDHgAAiR7NB8MeAAB+Hk0EDR4AAEMevgckJAAAIx6pBxsuAAAjHkoEzSwAAEMeTgRRIwAA1w++B04AAAAJFb4HyQAAAAkVjwbJAAAA1w+PBk4AAABDHr4HcRUAAEMevgfDHgAAQx5OBA8eAABDHk4EZBUAADkeuQeHEwAAQx6+B7QUAABDHk4EtBQAADkeQwSQEwAAghi+B/QBAADNG74HKgUAAM0bVAYqBQAAghiPBvQBAADXD5wONjIAADAWqQ79MQAAjBbhDnwvAADXD+EOli8AANcPGAz5PAAArxQgDPk8AAAJFZwNrDgAANcPuQ34OAAAPRtRBFs9AABTG7cHKD0AANYZtgdRPgAAvRlOBH0+AACOHNENly0AAI4cVQ6XLQAAXBxVDjgtAABcHNENOC0AAPsc0Q3LLAAA+xxVDsssAAAHHXgOLSwAAAcdrg0tLAAAjx54DkssAACuH3gO2SoAAFofQQ82KwAAjx5hD0ssAAAsHdENKS0AACwdVQ4pLQAAjhxVDpctAACOHNENly0AAPsc0Q3LLAAABx2uDS0sAACMHa4NEC0AACwd0Q0pLQAA+xxVDsssAABcHFUOOC0AAI4cVQ6XLQAALB1VDiktAAChHq4NhioAAAkfeA4UKgAArh94DtkqAABHH64NSysAAAoerg1nKwAACh54DmcrAAAJH3gOFCoAAKEerg2GKgAAjx54DkssAACPHq4NSywAAEcfrg1LKwAArh94DtkqAACPHq4NSywAAAoerg1nKwAAoR6uDYYqAABHH64NSysAAIwdrg0QLQAABx2uDS0sAAAKHmEPZysAAI8eYQ9LLAAAWh9BDzYrAAC0HkEPcioAAK4feA7ZKgAACR94DhQqAAC0HkEPcioAAFofQQ82KwAAjB00DxAtAACMHXgOEC0AAI8eeA5LLAAAxB17D+UsAACPHmEPSywAAAcdeA4tLAAAjB14DhAtAACMHTQPEC0AAAcdNA8tLAAACR94DhQqAAAKHngOZysAAAoeYQ9nKwAAtB5BD3IqAAAKHmEPZysAAAoeeA5nKwAABx14Di0sAABAHXsPAiwAAAcdNA8tLAAAjB14DhAtAACMHa4NEC0AAI8erg1LLAAAjx54DkssAAAHHa4NLSwAAAcdeA4tLAAACh54DmcrAAAKHq4NZysAAAcdeA4tLAAA+xxVDsssAAAsHVUOKS0AAIwdeA4QLQAAXBzRDTgtAAD7HNENyywAACwd0Q0pLQAAjhzRDZctAACMHa4NEC0AAIwdeA4QLQAALB1VDiktAAAsHdENKS0AAFwc0Q04LQAAXBxVDjgtAAD7HFUOyywAAPsc0Q3LLAAABx00Dy0sAACMHTQPEC0AAMQdew/lLAAAQB17DwIsAABAHXsPAiwAAMQdew/lLAAAjx5hD0ssAAAKHmEPZysAAF4acBL+CwAAxxpFEGYJAADGGiQQdAkAAF0aTxINDAAAGhWnFW8OAABQGdQUTg4AAFAZsxRdDgAAGhWFFX0OAAD2G3kJiDsAAG8bSAxeOwAAEhu0CuQ8AADWGbYHUT4AAF8XugffPgAACRVOBGU/AAC9GU4EfT4AAPYbeQmIOwAAEhu0CuQ8AAD2GpIK5zwAAMYbcwmrOwAARBfyCRI+AABVF40Ikz4AAI4XmwhxPgAAfxfiCfs9AADWHPYO6yQAAEMeDAxZJAAAiR4iDLgeAAAcHQUPYh4AAEMevgckJAAAQx5OBFEjAAB+Hk0EDR4AAIkezQfDHgAAQx4TDLgeAADWHPYOYh4AABwdBQ9iHgAAiR4iDLgeAADWHPYOYh4AANYc9g7rJAAAHB0FD2IeAABDHgwMWSQAAEMevgckJAAAiR7NB8MeAACJHiIMuB4AANcPiwqOPgAA1w++B5M/AAAJFb4HZT8AAAkViwphPgAAQx6+B7QUAABDHr4HcRUAAEMeTgRkFQAAQx5OBLQUAAA7GSQVAhUAADkZMBWWFQAAkBluFKsVAACRGV8UIRUAAKUceg/VHQAApRx6D68VAAB/HGQPsxUAAH8cZA/ZHQAA1hz2DmIeAADWHPYOahUAAKUceg+vFQAApRx6D9UdAAAKFScW8RwAAAoVARbBFQAA1w8YFsIVAADXDycW8RwAACQZhBXsHAAAORkwFZYVAAAKFQEWwRUAAAoVJxbxHAAAQx4TDLgeAABDHk0MhBUAANYc9g5qFQAA1hz2DmIeAABDHr4HtBQAAEMeOAzKFAAAQx5NDIQVAABDHr4HcRUAAKUceg+vFQAAoBx/DwwVAAAmG9URJRUAACgb3hG/FQAAKBveEb8VAAAmG9URJRUAAJEZXxQhFQAAkBluFKsVAAB/HGQPDRUAAAUbuhEnFQAAJhvVESUVAACgHH8PDBUAAG4ZURSuFQAABxvDEcAVAAAoG94RvxUAAJAZbhSrFQAAHBz2DhENAABhHewJPQoAALQbAA/QBgAAtBsAD9AGAACAG1EPTwUAALcYUQ95BAAACRUAD+wFAABfF7oH3z4AAFUXjQiTPgAACRW+B2U/AADWGdgHND4AADEb2QcmPQAABxvFB/k8AACsGcQHBz4AAFUXjQiTPgAAXxe6B98+AADWGbYHUT4AAEQX8gkSPgAAEhu0CuQ8AAA8F5oK1j0AAH8X4gn7PQAAjhebCHE+AABlF4gIQz4AAFUXzgnOPQAA9hqSCuc8AAB/F+IJ+z0AAFUXzgnOPQAAzBp+Cro8AADWGbYHUT4AAFMbtwcoPQAAMRvZByY9AADWGdgHND4AAFUXjQiTPgAA1hm2B1E+AADWGdgHND4AAI4XmwhxPgAAaRx3CBM8AAD2G3kJiDsAAMYbcwmrOwAALhyHCCo8AAASG7QK5DwAAEQX8gkSPgAAfxfiCfs9AAD2GpIK5zwAAMYbcwmrOwAA9hqSCuc8AADMGn4KujwAAJwbXwl+OwAAjhebCHE+AADWGdgHND4AAKwZxAcHPgAAZReICEM+AAAxG9kHJj0AAC4chwgqPAAABRx0CPw7AAAHG8UH+TwAAC4chwgqPAAAxhtzCas7AACcG18JfjsAAAUcdAj8OwAACRW+B2U/AABVF40Ikz4AAEQX8gkSPgAACRWLCmE+AAAJFYsKYT4AAEQX8gkSPgAAPBeaCtY9AAA8F5oK1j0AAK8UIAz5PAAACRWLCmE+AAAJFU4EZT8AAF8XugffPgAACRW+B2U/AAAuG78OAgUAAGgbHQvRBAAAQBsICyQFAAAGG6oOVAUAAM0biwoPBQAAghgfC8sCAADnGI0LGAMAAGgbHQvRBAAACRUAD+wFAAC3GFEPeQQAAAkVUQ9fAwAA5xiNCxgDAAAPGb8OXwQAAOcYqg6yBAAAvxh4C2sDAACAG1EPTwUAAM0biwoPBQAAaBsdC9EEAAAuG78OAgUAALcYUQ95BAAAgBtRD08FAAAuG78OAgUAAA8Zvw5fBAAAaBsdC9EEAADnGI0LGAMAAL8YeAtrAwAAQBsICyQFAAAPGb8OXwQAAC4bvw4CBQAABhuqDlQFAADnGKoOsgQAANcP8QocAQAAeBTxCnwBAABvFNkK4wEAANcP2QqCAQAACRW+B8kAAADXD74HTgAAANcPIwhzAAAAeBQjCNMAAAAJFVYLoQEAAAkVvgfJAAAAeBQjCNMAAAB4FPEKfAEAAHgUIwjTAAAA1w8jCHMAAADXDwsI2gAAAG8UCwg6AQAAeBTxCnwBAAB4FCMI0wAAAG8UCwg6AQAAbxTZCuMBAAAJFb4HZT8AANcPvgeTPwAA1w81B4w/AAA7FDUHbD8AADsU1gRsPwAAOxQ1B2w/AAA3FDUH9T4AADcU1gT1PgAAOxQ1B2w/AADXDzUHjD8AANcPNQcUPwAANxQ1B/U+AAAsB74H9AEAAOIDvgcqBQAA4gOLCg8FAAAsBx8LywIAAGsBvgdxFQAAawG+B8MeAABrARMMuB4AAGsBTQyEFQAA1w8kDoQ1AADXD5wONjIAAH4JqQ79MQAAXAopDnM1AACxAbYKXjcAACwCvgoVOQAAPwRIDF47AADxA+UNCjcAAKUKAA/sBQAA1w8AD64FAADXD1EPDwMAAKUKUQ9fAwAAwAKhCKMIAABOAuwJPQoAAPoDAA/QBgAA4gOLCg8FAAAvBFEPTwUAANcPVgsmAQAA1w/xChwBAAA3C/EKfAEAAKUKVguhAQAApQq+B8kAAAAsB74H9AEAACwHHwvLAgAApQpWC6EBAAD/CiAM+TwAAD8ESAxeOwAAnQS0CuQ8AAByCJoK1j0AAPED5Q0KNwAAPwRIDF47AAD/CiAM+TwAAKUKnA2sOAAAawG+B8MeAAAlAc0Hwx4AACUBIgy4HgAAawETDLgeAABrAb4HJCQAAIsBqQcbLgAAiwHwCzsuAABrAQwMWSQAAKUKAA/sBQAArgrFD3UIAADXD8UPOwgAANcPAA+uBQAA3wQbEtIoAADPBA8S1CcAAGcDUA9CLAAARAP2DuMtAACAA54OtjEAANADWQ5TNAAAXAopDnM1AAB+CakO/TEAAGsBDAxZJAAAiwHwCzsuAABEA/YO4y0AANgC9g7rJAAAawHVCjMxAACHAQ8LTTMAANADWQ5TNAAAgAOeDrYxAADXD+EOli8AANcPQQ/PLgAA+AhBD7cuAAAiCeEOfC8AAIsB8As7LgAAawHVCjMxAACAA54OtjEAAEQD9g7jLQAARAP2DuMtAACAA54OtjEAAH4JqQ79MQAAIgnhDnwvAACLAakHGy4AAGsBvgfILgAAawHVCjMxAACLAfALOy4AAGsBTQyEFQAA2AL2DmoVAADYAvYOtBQAAGsBOAzKFAAAdgG5B4cTAABrAb4HtBQAAGsBOAzKFAAAdgHXC/ARAABnBDkSzx0AAHEEUxJLHQAACQN6D9UdAADYAvYOYh4AAGsBOAzKFAAA2AL2DrQUAACTA/YOEQ0AAHYB1wvwEQAARAP2DuMtAAD6A0EPUC0AAGQFGRLZKAAA3wQbEtIoAABOAuwJPQoAAFECcQmFCgAAxgEpCiEOAAC7AWYLQw4AAMACxQbuBwAArgLFBqkIAACuAlgIOgkAAMACoQijCAAAiwaEFewcAAAoBiQVdxwAAHEEUxJLHQAAZwQ5Es8dAAC7AWYLQw4AAJMD9g4RDQAATgLsCT0KAADYAvYOYh4AAAkDUA8eHwAAcQQpEp0eAABnBDkSzx0AAP8KIAz5PAAApQqLCmE+AADXD4sKjj4AANcPGAz5PAAALAK+ChU5AAC5A3kJiDsAAD8ESAxeOwAAXAS3Byg9AAB+BNkHJj0AAIADhwgqPAAARgN3CBM8AAClCk4EZT8AAHQL1gRsPwAAdAs1B2w/AAClCr4HZT8AAEQKFwSoDwAA1w8XBMkPAADXD14DiBMAAEQKXgOIEwAAuwFmC0MOAADGASkKIQ4AAIgBnghlEQAAdgHXC/ARAAABBhcEChAAAEQKFwSoDwAARApeA4gTAAC0BawDoxIAAEwCvgeKOQAALAK+ChU5AACxAbYKXjcAALYBKwpeNwAA0ANZDlM0AADxA+UNCjcAAKUKnA2sOAAAXAopDnM1AACHAQ8LTTMAALEBtgpeNwAA8QPlDQo3AADQA1kOUzQAANcPuQ34OAAA1w8kDoQ1AABcCikOczUAAKUKnA2sOAAAsQG2Cl43AACHAQ8LTTMAALYBKwpeNwAAtgErCl43AAC5ARIJ+jYAADcCQwelOAAATAK+B4o5AABrAdUKMzEAAHsBEQmZMAAAmQHyCUozAACHAQ8LTTMAAGsBvgfILgAAewFDB6IvAAB7AREJmTAAAGsB1QozMQAAhwEPC00zAACZAfIJSjMAALkBEgn6NgAAtgErCl43AABrAWAEGC4AAHsBSQQOLwAAewFDB6IvAABrAb4HyC4AAFsCSQQaOQAAHAZJBBo5AAAlBmcDMTkAAGQCZwMxOQAAuQESCfo2AAB6BRIJ+jYAAPgFQwelOAAANwJDB6U4AAB7AUkEDi8AADwFSQQOLwAAPAVDB6IvAAB7AUMHoi8AAHsBEQmZMAAAPAURCZkwAAD0BAwKSjMAAJkB8glKMwAAmQHyCUozAAD0BAwKSjMAAHoFEgn6NgAAuQESCfo2AAB7AUMHoi8AADwFQweiLwAAPAURCZkwAAB7AREJmTAAABwGSQQaOQAA+AVDB6U4AAA8BUMHoi8AADwFSQQOLwAAegUSCfo2AAD0BAwKSjMAADwFEQmZMAAA+AVDB6U4AAB6BRIJ+jYAADwFEQmZMAAAPAVDB6IvAACLBoQV7BwAAJgGDhUkJAAApQqrFXckAAClCicW8RwAACIJ4Q58LwAA+AhBD7cuAAD6A0EPUC0AAEQD9g7jLQAApQonFvEcAAClCqsVdyQAANcP9RWFJAAA1w8nFvEcAADfBBsS0igAAGQFGRLZKAAA/watFOskAACYBg4VJCQAAHYGMBWWFQAApQoBFsEVAAClCvgVLBUAAHQGJBUCFQAApQoBFsEVAADXDxgWwhUAANcPEBYsFQAApQr4FSwVAAB0BiQVAhUAAKUK+BUsFQAApQrQFdgOAAAgBgkVtQ4AAKUK+BUsFQAA1w8QFiwVAADXD9AV2A4AAKUK0BXYDgAAIAYJFbUOAABeBtQUTg4AAFEFcBL+CwAACgV8EiIMAADYAvYOahUAAAkDeg+vFQAADgN/DwwVAADYAvYOtBQAAJMD9g4RDQAArAN6D9wNAACrBKYRnA4AALcEcxHeDQAA2AL2DuskAAAJA1APaSQAAAkDUA8eHwAA2AL2DmIeAACYBg4VJCQAAGcGnhTwIwAAzwQPEtQnAADfBBsS0igAANcPUQ8PAwAA1w9WCyYBAAClClYLoQEAAKUKUQ9fAwAApQpRD18DAAClClYLoQEAACwHHwvLAgAA+AZRD3kEAAAsBx8LywIAAMgGjQsYAwAAoAa/Dl8EAAD4BlEPeQQAANcPQQ/PLgAA1w8ID7EuAAD7CAgPmi4AAPgIQQ+3LgAA+gNBD1AtAAD9AwgPMi0AAGcF3xG7KAAAZAUZEtkoAAD/Bq0U6yQAAAEHcxTOJAAAfQoQFeolAAB6CkoVByYAAHoKShUHJgAAfQoQFeolAADXD1oVXiYAANcPlBV7JgAApQqrFXckAAB6CkoVByYAANcPlBV7JgAA1w/1FYUkAACYBg4VJCQAAP8GrRTrJAAAegpKFQcmAAClCqsVdyQAAGcDUA9CLAAAjgM2Dz8sAAAwAzYPZiQAAAkDUA9pJAAACQNQDx4fAAAwAzYPGx8AAJgEEBKaHgAAcQQpEp0eAAAJA1APaSQAADADNg9mJAAAMAM2DxsfAAAJA1APHh8AAGcGnhTwIwAAjgaFFO0jAAD2BPYR0ScAAM8EDxLUJwAARAP2DuMtAABnA1APQiwAAAkDUA9pJAAA2AL2DuskAACLBoQV7BwAAEQG9hTXHQAAZwaeFPAjAACYBg4VJCQAAGcEORLPHQAAcQQpEp0eAABEBvYU1x0AAIsGhBXsHAAAKAYkFXccAABKBgcVexwAAJcEPRJPHQAAcQRTEksdAAAOA38PDBUAAC8DZA8NFQAA0gNkD98NAACsA3oP3A0AAKsEphGcDgAA0QSQEZ8OAAAOBpYT5BEAAOoFsRPgEQAAtwRzEd4NAACrBKYRnA4AAOoFsRPgEQAAIAYJFbUOAAAgBgkVtQ4AAOoFsRPgEQAAHgZfFCEVAAB0BiQVAhUAAHYGMBWWFQAAHgZuFKsVAAAoBiQVdxwAAIsGhBXsHAAA2AL2DrQUAAAOA38PDBUAAKwDeg/cDQAAkwP2DhENAABKBt0EjgkAAEQK3QT5CAAARAoXBKgPAAABBhcEChAAAHYB1wvwEQAAiAGeCGURAACIAQUHfBIAAHYBuQeHEwAARArdBPkIAADXD90EuwgAANcPFwTJDwAARAoXBKgPAAB2AdcL8BEAAJMD9g4RDQAAuwFmC0MOAADAAqEIowgAAK4CWAg6CQAAUQJxCYUKAABOAuwJPQoAAMACiwWoBwAArgJ5BWMIAACuAsUGqQgAAMACxQbuBwAA+gMAD9AGAADoBEUQZgkAAK4KxQ91CAAApQoAD+wFAAC3BHMR3g0AACAGCRW1DgAACgV8EiIMAAC3BHMR3g0AAKYEaRCpCQAAkwP2DhENAADiA74HKgUAAMACxQbuBwAAwAKhCKMIAADiA4sKDwUAAK4CxQapCAAARQYtBr4IAAAyBlkIPQkAAK4CWAg6CQAAiAGeCGURAAC0BZ4IYxEAAKAFAwdoEgAAiAEFB3wSAADGASkKIQ4AAOMFKQohDgAAtAWeCGMRAACIAZ4IZREAAFECcQmFCgAAEgZxCYYKAADjBSkKIQ4AAMYBKQohDgAArgJ5BWMIAABkBnUFaAgAAEUGLQa+CAAArgLFBqkIAACuAlgIOgkAADIGWQg9CQAAEgZxCYYKAABRAnEJhQoAAGQGdQVoCAAAQQZuBbEJAAAbBhAHSAoAAEUGLQa+CAAAtAWeCGMRAADjBSkKIQ4AABIGcQmGCgAAoAUDB2gSAAC/BYEHqxAAAMEFEAeEEAAAMgZZCD0JAAAWBsUImQoAABIGcQmGCgAAvwWBB6sQAAAWBsUImQoAABsGEAdICgAAwQUQB4QQAAC/BYEHqxAAAKAFAwdoEgAAtAWeCGMRAAD1Bc0EIRAAALAFaAStEgAAoAUDB2gSAADBBRAHhBAAABYGxQiZCgAAMgZZCD0JAABFBi0GvggAABsGEAdICgAAFgbFCJkKAAC/BYEHqxAAALQFnghjEQAAEgZxCYYKAABBBm4FsQkAAPUFzQQhEAAAwQUQB4QQAAAbBhAHSAoAAGQFGRLZKAAAZwXfEbsoAAABB3MUziQAAP8GrRTrJAAA+AhBD7cuAAD7CAgPmi4AAP0DCA8yLQAA+gNBD1AtAABxBCkSnR4AAJgEEBKaHgAAZwbVFNQdAABEBvYU1x0AAEQG9hTXHQAAZwbVFNQdAACOBoUU7SMAAGcGnhTwIwAAzwQPEtQnAAD2BPYR0ScAAI4DNg8/LAAAZwNQD0IsAACpBLoRJxUAAIgE1RElFQAAHgZfFCEVAABABkIUJBUAAKgEwxHAFQAAhwTeEb8VAAAJA3oPrxUAAC8DZA+zFQAAHgZuFKsVAABABlEUrhUAAEoGBxV7HAAAKAYkFXccAABxBFMSSx0AAJcEPRJPHQAALwNkD9kdAAAJA3oP1R0AAKwDeg/cDQAA0gNkD98NAADRBJARnw4AAKsEphGcDgAA6gWxE+ARAAAOBpYT5BEAAEAGQhQkFQAAHgZfFCEVAABeBtQUTg4AAF8GsxRdDgAAUQVPEg0MAABRBXAS/gsAAK4KxQ91CAAArgqkD4MIAADXD6QPSggAANcPxQ87CAAA1w+nFW8OAADXD4UVfQ4AAJUKhRV9DgAAlAqnFW8OAADoBEUQZgkAAOgEJBB0CQAArgqkD4MIAACuCsUPdQgAAAoFfBIiDAAAUQVwEv4LAADoBEUQZgkAAKYEaRCpCQAA6ARFEGYJAAD6AwAP0AYAAKYEaRCpCQAApgRpEKkJAAC3BHMR3g0AAAoFfBIiDAAApgRpEKkJAAD6AwAP0AYAAJMD9g4RDQAARgN3CBM8AACIA1cEWTsAAHIEUQRbPQAAXAS3Byg9AABMAr4HijkAAEYDdwgTPAAAuQN5CYg7AAAsAr4KFTkAAEwCvgeKOQAAdwJgBBI6AACIA1cEWTsAAEYDdwgTPAAASgbdBI4JAAABBhcEChAAAPUFzQQhEAAAQQZuBbEJAAABBhcEChAAALQFrAOjEgAAsAVoBK0SAAD1Bc0EIRAAAGsG9gRdCAAASgbdBI4JAABBBm4FsQkAAGQGdQVoCAAAiAEFB3wSAACgBQMHaBIAALAFaAStEgAAiAGEBMISAADiA74HKgUAAOIDVAYqBQAAwAKLBagHAADAAsUG7gcAACUGZwMxOQAAHAZJBBo5AAA8BUkEDi8AADwFZwPsLgAANwJDB6U4AAD4BUMHpTgAABwGSQQaOQAAWwJJBBo5AABMAr4HijkAADcCQwelOAAAWwJJBBo5AAB3AmAEEjoAAHYBuQeHEwAAiAEFB3wSAACIAYQEwhIAAHYBQwSQEwAApQq+B8kAAAClCo8GyQAAACwHjwb0AQAALAe+B/QBAACLAakHGy4AAIsBSgTNLAAAawFgBBguAABrAb4HyC4AAGsBTgQPHgAAMQFNBA0eAAAlAc0Hwx4AAGsBvgfDHgAAawG+ByQkAABrAU4EUSMAAIsBSgTNLAAAiwGpBxsuAADXD74HTgAAANcPjwZOAAAApQqPBskAAAClCr4HyQAAAGsBvgdxFQAAawFOBGQVAABrAU4EDx4AAGsBvgfDHgAAdgG5B4cTAAB2AUMEkBMAAGsBTgS0FAAAawG+B7QUAAAsB74H9AEAACwHjwb0AQAA4gNUBioFAADiA74HKgUAANcPnA42MgAA1w/hDpYvAAAiCeEOfC8AAH4JqQ79MQAA1w8YDPk8AADXD7kN+DgAAKUKnA2sOAAA/wogDPk8AAByBFEEWz0AAPIFTgR9PgAA2AW2B1E+AABcBLcHKD0AACED0Q2XLQAAUwPRDTgtAABTA1UOOC0AACEDVQ6XLQAAtALRDcssAACnAq4NLSwAAKcCeA4tLAAAtAJVDsssAAAgAXgOSywAACABYQ9LLAAAVQBBDzYrAAAAAHgO2SoAAIIC0Q0pLQAAIQPRDZctAAAhA1UOly0AAIICVQ4pLQAAtALRDcssAACCAtENKS0AACMCrg0QLQAApwKuDS0sAAC0AlUOyywAAIICVQ4pLQAAIQNVDpctAABTA1UOOC0AAA0Brg2GKgAAZwCuDUsrAAAAAHgO2SoAAKYAeA4UKgAApAGuDWcrAAANAa4NhioAAKYAeA4UKgAApAF4DmcrAAAgAXgOSywAAAAAeA7ZKgAAZwCuDUsrAAAgAa4NSywAACABrg1LLAAAZwCuDUsrAAANAa4NhioAAKQBrg1nKwAAIwKuDRAtAACnAq4NLSwAAKQBYQ9nKwAA+wBBD3IqAABVAEEPNisAACABYQ9LLAAAAAB4DtkqAABVAEEPNisAAPsAQQ9yKgAApgB4DhQqAAAgAXgOSywAACMCeA4QLQAAIwI0DxAtAAAgAWEPSywAAOoBew/lLAAApwJ4Di0sAACnAjQPLSwAACMCNA8QLQAAIwJ4DhAtAACmAHgOFCoAAPsAQQ9yKgAApAFhD2crAACkAXgOZysAAKcCeA4tLAAApAF4DmcrAACkAWEPZysAAKcCNA8tLAAAbwJ7DwIsAAAjAngOEC0AACABeA5LLAAAIAGuDUssAAAjAq4NEC0AAKcCrg0tLAAApAGuDWcrAACkAXgOZysAAKcCeA4tLAAApwJ4Di0sAAAjAngOEC0AAIICVQ4pLQAAtAJVDsssAABTA9ENOC0AACED0Q2XLQAAggLRDSktAAC0AtENyywAACMCrg0QLQAAggLRDSktAACCAlUOKS0AACMCeA4QLQAAUwPRDTgtAAC0AtENyywAALQCVQ7LLAAAUwNVDjgtAACnAjQPLSwAAG8Cew8CLAAA6gF7D+UsAAAjAjQPEC0AAG8Cew8CLAAApAFhD2crAAAgAWEPSywAAOoBew/lLAAAUQVwEv4LAABRBU8SDQwAAOgEJBB0CQAA6ARFEGYJAACUCqcVbw4AAJUKhRV9DgAAXwazFF0OAABeBtQUTg4AALkDeQmIOwAAnQS0CuQ8AAA/BEgMXjsAANgFtgdRPgAA8gVOBH0+AAClCk4EZT8AAE8IugffPgAAuQN5CYg7AADpA3MJqzsAALkEkgrnPAAAnQS0CuQ8AABqCPIJEj4AADAI4gn7PQAAIAibCHE+AABZCI0Ikz4AANgC9g7rJAAAkgIFD2IeAAAlASIMuB4AAGsBDAxZJAAAawG+ByQkAAAlAc0Hwx4AADEBTQQNHgAAawFOBFEjAABrARMMuB4AACUBIgy4HgAAkgIFD2IeAADYAvYOYh4AANgC9g5iHgAAkgIFD2IeAADYAvYO6yQAAGsBDAxZJAAAJQEiDLgeAAAlAc0Hwx4AAGsBvgckJAAA1w+LCo4+AAClCosKYT4AAKUKvgdlPwAA1w++B5M/AABrAb4HtBQAAGsBTgS0FAAAawFOBGQVAABrAb4HcRUAAHQGJBUCFQAAHgZfFCEVAAAeBm4UqxUAAHYGMBWWFQAACQN6D9UdAAAvA2QP2R0AAC8DZA+zFQAACQN6D68VAADYAvYOYh4AAAkDeg/VHQAACQN6D68VAADYAvYOahUAAKUKJxbxHAAA1w8nFvEcAADXDxgWwhUAAKUKARbBFQAAiwaEFewcAAClCicW8RwAAKUKARbBFQAAdgYwFZYVAABrARMMuB4AANgC9g5iHgAA2AL2DmoVAABrAU0MhBUAAGsBvge0FAAAawG+B3EVAABrAU0MhBUAAGsBOAzKFAAACQN6D68VAACHBN4RvxUAAIgE1RElFQAADgN/DwwVAACHBN4RvxUAAB4GbhSrFQAAHgZfFCEVAACIBNURJRUAAC8DZA8NFQAADgN/DwwVAACIBNURJRUAAKkEuhEnFQAAQAZRFK4VAAAeBm4UqxUAAIcE3hG/FQAAqATDEcAVAACTA/YOEQ0AAPoDAA/QBgAATgLsCT0KAAD6AwAP0AYAAKUKAA/sBQAA+AZRD3kEAAAvBFEPTwUAAE8IugffPgAApQq+B2U/AABZCI0Ikz4AANgF2Ac0PgAAAgbEBwc+AACnBMUH+TwAAH4E2QcmPQAAWQiNCJM+AADYBbYHUT4AAE8IugffPgAAagjyCRI+AAByCJoK1j0AAJ0EtArkPAAAMAjiCfs9AABZCM4Jzj0AAEoIiAhDPgAAIAibCHE+AAC5BJIK5zwAAOMEfgq6PAAAWQjOCc49AAAwCOIJ+z0AANgFtgdRPgAA2AXYBzQ+AAB+BNkHJj0AAFwEtwcoPQAAWQiNCJM+AAAgCJsIcT4AANgF2Ac0PgAA2AW2B1E+AABGA3cIEzwAAIADhwgqPAAA6QNzCas7AAC5A3kJiDsAAJ0EtArkPAAAuQSSCuc8AAAwCOIJ+z0AAGoI8gkSPgAA6QNzCas7AAATBF8JfjsAAOMEfgq6PAAAuQSSCuc8AAAgCJsIcT4AAEoIiAhDPgAAAgbEBwc+AADYBdgHND4AAH4E2QcmPQAApwTFB/k8AACqA3QI/DsAAIADhwgqPAAAgAOHCCo8AACqA3QI/DsAABMEXwl+OwAA6QNzCas7AAClCr4HZT8AAKUKiwphPgAAagjyCRI+AABZCI0Ikz4AAKUKiwphPgAAcgiaCtY9AABqCPIJEj4AAHIImgrWPQAApQqLCmE+AAD/CiAM+TwAAKUKTgRlPwAApQq+B2U/AABPCLoH3z4AAIEEvw4CBQAAqQSqDlQFAABuBAgLJAUAAEYEHQvRBAAA4gOLCg8FAABGBB0L0QQAAMgGjQsYAwAALAcfC8sCAAClCgAP7AUAAKUKUQ9fAwAA+AZRD3kEAADIBo0LGAMAAPAGeAtrAwAAyAaqDrIEAACgBr8OXwQAAC8EUQ9PBQAAgQS/DgIFAABGBB0L0QQAAOIDiwoPBQAA+AZRD3kEAACgBr8OXwQAAIEEvw4CBQAALwRRD08FAABGBB0L0QQAAG4ECAskBQAA8AZ4C2sDAADIBo0LGAMAAKAGvw5fBAAAyAaqDrIEAACpBKoOVAUAAIEEvw4CBQAA1w/xChwBAADXD9kKggEAAD8L2QrjAQAANwvxCnwBAAClCr4HyQAAADcLIwjTAAAA1w8jCHMAAADXD74HTgAAAKUKVguhAQAANwvxCnwBAAA3CyMI0wAAAKUKvgfJAAAANwsjCNMAAAA/CwsIOgEAANcPCwjaAAAA1w8jCHMAAAA3C/EKfAEAAD8L2QrjAQAAPwsLCDoBAAA3CyMI0wAAAKUKvgdlPwAAdAs1B2w/AADXDzUHjD8AANcPvgeTPwAAdAvWBGw/AAB3C9YE9T4AAHcLNQf1PgAAdAs1B2w/AAB0CzUHbD8AAHcLNQf1PgAA1w81BxQ/AADXDzUHjD8AANcPCA+xLgAAtBYID5ouAAA9Ft8RIyoAANcP3xE6KgAAtBYID5ouAACxGwgPMi0AAEca3xG7KAAAPRbfESMqAACtGHMUziQAADEVEBXqJQAAPRbfESMqAABHGt8RuygAADEVEBXqJQAA1w9aFV4mAADXD98ROioAAD0W3xEjKgAAfhw2D2YkAAB+HDYPGx8AABcbEBKaHgAACBsbElgjAAAgHDYPPywAAH4cNg9mJAAACBsbElgjAAC5GvYR0ScAAAgbGxJYIwAAFxsQEpoeAABIGdUU1B0AACAZhRTtIwAAuRr2EdEnAAAIGxsSWCMAACAZhRTtIwAAfxxkDw0VAADdG2QP3w0AAN0akBGfDgAABRu6EScVAAAFG7oRJxUAAN0akBGfDgAAoRmWE+QRAAChGZYT5BEAAG8ZQhQkFQAABRu6EScVAABdGk8SDQwAABoVTxK3CwAAGhWFFX0OAABQGbMUXQ4AABoVTxK3CwAA1w9PEpMLAADXD4UVfQ4AABoVhRV9DgAAABWkD4MIAADXD6QPSggAANcPTxKTCwAAGhVPErcLAADGGiQQdAkAAAAVpA+DCAAAGhVPErcLAABdGk8SDQwAABgbPRJPHQAABxvDEcAVAABuGVEUrhUAAGUZBxV7HAAAfxxkD9kdAAB/HGQPsxUAAAcbwxHAFQAAGBs9Ek8dAADXDwgPsS4AANcP3xE6KgAAcgnfESMqAAD7CAgPmi4AAPsICA+aLgAAcgnfESMqAABnBd8RuygAAP0DCA8yLQAAAQdzFM4kAABnBd8RuygAAHIJ3xEjKgAAfQoQFeolAAB9ChAV6iUAAHIJ3xEjKgAA1w/fEToqAADXD1oVXiYAADADNg9mJAAApgQbElgjAACYBBASmh4AADADNg8bHwAAjgM2Dz8sAAD2BPYR0ScAAKYEGxJYIwAAMAM2D2YkAACmBBsSWCMAAI4GhRTtIwAAZwbVFNQdAACYBBASmh4AAPYE9hHRJwAAjgaFFO0jAACmBBsSWCMAAC8DZA8NFQAAqQS6EScVAADRBJARnw4AANIDZA/fDQAAqQS6EScVAAAOBpYT5BEAANEEkBGfDgAADgaWE+QRAACpBLoRJxUAAEAGQhQkFQAAUQVPEg0MAABfBrMUXQ4AAJUKhRV9DgAAlQpPErcLAACVCk8StwsAAJUKhRV9DgAA1w+FFX0OAADXD08SkwsAAK4KpA+DCAAAlQpPErcLAADXD08SkwsAANcPpA9KCAAA6AQkEHQJAABRBU8SDQwAAJUKTxK3CwAArgqkD4MIAACXBD0STx0AAEoGBxV7HAAAQAZRFK4VAACoBMMRwBUAAC8DZA/ZHQAAlwQ9Ek8dAACoBMMRwBUAAC8DZA+zFQAAGhWnFW8OAADXD6cVbw4AANcPdhVnDQAAGhV2FWcNAACOGQkVtQ4AAFAZ1BRODgAAUBnUFGcNAACOGQkVZw0AAAoV0BVnDQAAjhkJFWcNAABQGdQUZw0AABoVdhVnDQAA1w/QFWcNAAAKFdAVZw0AABoVdhVnDQAA1w92FWcNAAAKFdAV2A4AAI4ZCRW1DgAAjhkJFWcNAAAKFdAVZw0AANcP0BXYDgAAChXQFdgOAAAKFdAVZw0AANcP0BVnDQAApQrQFWcNAAClCtAV2A4AAFAZ1BRODgAAGhWnFW8OAAAaFXYVZw0AAFAZ1BRnDQAAlAqnFW8OAACUCnYVZw0AANcPdhVnDQAA1w+nFW8OAAAgBgkVtQ4AACAGCRVnDQAAXgbUFGcNAABeBtQUTg4AAKUK0BVnDQAAlAp2FWcNAABeBtQUZw0AACAGCRVnDQAA1w/QFWcNAADXD3YVZw0AAJQKdhVnDQAApQrQFWcNAAClCtAV2A4AAKUK0BVnDQAAIAYJFWcNAAAgBgkVtQ4AAF4G1BRODgAAXgbUFGcNAACUCnYVZw0AAJQKpxVvDgAA1hrJBKIIAADLHckEoggAAMsdZQJGCQAA1hplAkYJAADWGmUCRgkAAMsdZQJGCQAAyx2kAAYLAADWGqQABgsAANYapAAGCwAAyx2kAAYLAADLHQAAaw0AANYaAABrDQAA1hoAAGsNAADLHQAAaw0AAMsdpADPDwAA1hqkAM8PAADWGqQAzw8AAMsdpADPDwAAyx1lApARAADWGmUCkBEAANYaZQKQEQAAyx1lApARAADLHckENBIAANYayQQ0EgAA1hrJBDQSAADLHckENBIAAMsdLgeQEQAA1houB5ARAADWGi4HkBEAAMsdLgeQEQAAyx3uCM8PAADWGu4Izw8AANYa7gjPDwAAyx3uCM8PAADLHZIJaw0AANYakglrDQAA1hqSCWsNAADLHZIJaw0AAMsd7ggGCwAA1hruCAYLAADLHckENBIAAMsdZQKQEQAAUx75Ao4QAABTHskEChEAANYa7ggGCwAAyx3uCAYLAADLHS4HRgkAANYaLgdGCQAA1houB0YJAADLHS4HRgkAAMsdyQSiCAAA1hrJBKIIAADWGi4HRgkAANYayQSiCAAA1hplAkYJAADWGgAAaw0AANYapAAGCwAA1hqSCWsNAADWGu4IBgsAANYaLgeQEQAA1hruCM8PAADWGmUCkBEAANYayQQ0EgAA1hqkAM8PAABTHskEChEAAFMe+QKOEAAAUx40AygQAABTHskElRAAAFMeDAIADwAAUx6mATsPAABTHp8Baw0AAFMeKgFrDQAAUx4MAtYLAABTHqYBmwsAAFMeNAOtCgAAUx75AkcKAABTHskEQQoAAFMeyQTLCQAAyx1lApARAADLHaQAzw8AAFMepgE7DwAAUx75Ao4QAADLHaQAzw8AAMsdAABrDQAAUx4qAWsNAABTHqYBOw8AAMsdyQSiCAAAyx0uB0YJAABTHpkGRwoAAFMeyQTLCQAAyx1lAkYJAADLHckEoggAAFMeyQTLCQAAUx75AkcKAADLHQAAaw0AAMsdpAAGCwAAUx6mAZsLAABTHioBaw0AAMsdLgdGCQAAyx3uCAYLAABTHu0HmwsAAFMemQZHCgAAyx2kAAYLAADLHWUCRgkAAFMe+QJHCgAAUx6mAZsLAADLHe4IBgsAAMsdkglrDQAAUx5pCGsNAABTHu0HmwsAAMsdkglrDQAAyx3uCM8PAABTHu0HOw8AAFMeaQhrDQAAyx3uCM8PAADLHS4HkBEAAFMemQaOEAAAUx7tBzsPAADLHS4HkBEAAMsdyQQ0EgAAUx7JBAoRAABTHpkGjhAAAFMe8wdrDQAAUx6HBwAPAADkHYcHAA8AAOQd8wdrDQAAUx7tB5sLAABTHmkIaw0AAFMe8wdrDQAAUx6HBwAPAABTHocH1gsAAFMemQZHCgAAUx5eBq0KAABTHu0HOw8AAFMeXgYoEAAAUx6ZBo4QAABTHpkGjhAAAFMeyQQKEQAAUx7JBJUQAABTHl4GKBAAAFMeyQTLCQAAUx6ZBkcKAABTHl4GrQoAAFMeyQRBCgAAUx7JBJUQAABTHjQDKBAAAOQdNAMoEAAA5B3JBJUQAABTHp8Baw0AAFMeDALWCwAA5B0MAtYLAADkHZ8Baw0AAFMehwfWCwAAUx7zB2sNAADkHfMHaw0AAOQdhwfWCwAAUx5eBigQAABTHskElRAAAOQdyQSVEAAA5B1eBigQAABTHgwCAA8AAFMenwFrDQAA5B2fAWsNAADkHQwCAA8AAFMeXgatCgAAUx6HB9YLAADkHYcH1gsAAOQdXgatCgAAUx40A60KAABTHskEQQoAAOQdyQRBCgAA5B00A60KAABTHocHAA8AAFMeXgYoEAAA5B1eBigQAADkHYcHAA8AAFMeNAMoEAAAUx4MAgAPAADkHQwCAA8AAOQdNAMoEAAAUx7JBEEKAABTHl4GrQoAAOQdXgatCgAA5B3JBEEKAABTHgwC1gsAAFMeNAOtCgAA5B00A60KAADkHQwC1gsAACQdoQRfEAAAJB1dAwgQAABOHUkEZw4AAE4dqgSBDgAAJB02BggQAAAkHfIEXxAAAE4d6ASBDgAATh1KBWcOAAAkHVAHBQ8AACQdYwbyDwAATh1tBVYOAABOHbQFDg4AACQdvgeTDQAAJB1nB9cOAABOHcYF7A0AAE4d4AWKDQAAJB1jBuQKAAAkHVAH0QsAAE4dtAXHDAAATh1tBYAMAAAkHWcH/gsAACQdvgdCDQAATh3gBUwNAABOHcYF6gwAACQd8gR2CgAAJB02Bs0KAABOHUoFbgwAAE4d6ARUDAAAJB1dA80KAAAkHaEEdgoAAE4dqgRUDAAATh1JBG4MAAAkHUIC0QsAACQdLwPkCgAATh0mBIAMAABOHd4DxwwAACQd1QFCDQAAJB0sAv4LAABOHc0D6gwAAE4dswNMDQAAJB0sAtcOAAAkHdUBkw0AAE4dswOKDQAATh3NA+wNAAAkHS8D8g8AACQdQgIFDwAATh3eAw4OAABOHSYEVg4AAKgdUAQWDgAAqB0eBOQNAADAHUoEyw0AAMAdaQTqDQAAqB0eBPEMAACoHVAEvwwAAMAdaQTsDAAAwB1KBAsNAACoHUMFvwwAAKgddQXxDAAAwB1IBQsNAADAHSkF7AwAAKgddQXkDQAAqB1DBRYOAADAHSkF6g0AAMAdSAXLDQAA3gTJBKIIAADeBGUCRgkAAOkBZQJGCQAA6QHJBKIIAADeBGUCRgkAAN4EpAAGCwAA6QGkAAYLAADpAWUCRgkAAN4EpAAGCwAA3gQAAGsNAADpAQAAaw0AAOkBpAAGCwAA3gQAAGsNAADeBKQAzw8AAOkBpADPDwAA6QEAAGsNAADeBKQAzw8AAN4EZQKQEQAA6QFlApARAADpAaQAzw8AAN4EZQKQEQAA3gTJBDQSAADpAckENBIAAOkBZQKQEQAA3gTJBDQSAADeBC4HkBEAAOkBLgeQEQAA6QHJBDQSAADeBC4HkBEAAN4E7gjPDwAA6QHuCM8PAADpAS4HkBEAAN4E7gjPDwAA3gSSCWsNAADpAZIJaw0AAOkB7gjPDwAA3gSSCWsNAADeBO4IBgsAAOkB7ggGCwAA6QGSCWsNAADpAckENBIAAGEByQQKEQAAYQH5Ao4QAADpAWUCkBEAAN4E7ggGCwAA3gQuB0YJAADpAS4HRgkAAOkB7ggGCwAA3gQuB0YJAADeBMkEoggAAOkByQSiCAAA6QEuB0YJAADeBGUCRgkAAN4EyQSiCAAA3gQuB0YJAADeBJIJaw0AAN4E7ggGCwAA3gQAAGsNAADeBKQABgsAAN4EZQKQEQAA3gSkAM8PAADeBC4HkBEAAN4EyQQ0EgAA3gTuCM8PAABhAckEChEAAGEByQSVEAAAYQE0AygQAABhAfkCjhAAAOkBZQKQEQAAYQH5Ao4QAABhAaYBOw8AAOkBpADPDwAA6QGkAM8PAABhAaYBOw8AAGEBKgFrDQAA6QEAAGsNAADpAckEoggAAGEByQTLCQAAYQGZBkcKAADpAS4HRgkAAOkBZQJGCQAAYQH5AkcKAABhAckEywkAAOkByQSiCAAA6QEAAGsNAABhASoBaw0AAGEBpgGbCwAA6QGkAAYLAADpAS4HRgkAAGEBmQZHCgAAYQHtB5sLAADpAe4IBgsAAOkBpAAGCwAAYQGmAZsLAABhAfkCRwoAAOkBZQJGCQAA6QHuCAYLAABhAe0HmwsAAGEBaQhrDQAA6QGSCWsNAADpAZIJaw0AAGEBaQhrDQAAYQHtBzsPAADpAe4Izw8AAOkB7gjPDwAAYQHtBzsPAABhAZkGjhAAAOkBLgeQEQAA6QEuB5ARAABhAZkGjhAAAGEByQQKEQAA6QHJBDQSAABhAfMHaw0AANAB8wdrDQAA0AGHBwAPAABhAYcHAA8AAGEBKgFrDQAAYQGfAWsNAABhAQwC1gsAAGEBpgGbCwAAYQGmATsPAABhAQwCAA8AAGEB+QKOEAAAYQE0AygQAABhAe0HmwsAAGEBhwfWCwAAYQHzB2sNAABhAZkGRwoAAGEBXgatCgAAYQFpCGsNAABhAYcHAA8AAGEB7Qc7DwAAYQGZBo4QAABhAV4GKBAAAGEByQSVEAAAYQHJBAoRAABhAfkCRwoAAGEBNAOtCgAAYQHJBEEKAABhAckEywkAAGEB7Qc7DwAAYQGHBwAPAABhAV4GKBAAAGEBmQaOEAAAYQHJBMsJAABhAckEQQoAAGEBXgatCgAAYQGZBkcKAABhAaYBmwsAAGEBDALWCwAAYQE0A60KAABhAfkCRwoAAGEByQSVEAAA0AHJBJUQAADQATQDKBAAAGEBNAMoEAAAYQGfAWsNAADQAZ8Baw0AANABDALWCwAAYQEMAtYLAABhAYcH1gsAANABhwfWCwAA0AHzB2sNAABhAfMHaw0AAGEBXgYoEAAA0AFeBigQAADQAckElRAAAGEByQSVEAAAYQEMAgAPAADQAQwCAA8AANABnwFrDQAAYQGfAWsNAABhAV4GrQoAANABXgatCgAA0AGHB9YLAABhAYcH1gsAAGEBNAOtCgAA0AE0A60KAADQAckEQQoAAGEByQRBCgAAYQGHBwAPAADQAYcHAA8AANABXgYoEAAAYQFeBigQAABhATQDKBAAANABNAMoEAAA0AEMAgAPAABhAQwCAA8AAGEByQRBCgAA0AHJBEEKAADQAV4GrQoAAGEBXgatCgAAYQEMAtYLAADQAQwC1gsAANABNAOtCgAAYQE0A60KAACQAqEEXxAAAGYCqgSBDgAAZgJJBGcOAACQAl0DCBAAAJACNgYIEAAAZgJKBWcOAABmAugEgQ4AAJAC8gRfEAAAkAJQBwUPAABmArQFDg4AAGYCbQVWDgAAkAJjBvIPAACQAr4Hkw0AAGYC4AWKDQAAZgLGBewNAACQAmcH1w4AAJACYwbkCgAAZgJtBYAMAABmArQFxwwAAJACUAfRCwAAkAJnB/4LAABmAsYF6gwAAGYC4AVMDQAAkAK+B0INAACQAvIEdgoAAGYC6ARUDAAAZgJKBW4MAACQAjYGzQoAAJACXQPNCgAAZgJJBG4MAABmAqoEVAwAAJACoQR2CgAAkAJCAtELAABmAt4DxwwAAGYCJgSADAAAkAIvA+QKAACQAtUBQg0AAGYCswNMDQAAZgLNA+oMAACQAiwC/gsAAJACLALXDgAAZgLNA+wNAABmArMDig0AAJAC1QGTDQAAkAIvA/IPAABmAiYEVg4AAGYC3gMODgAAkAJCAgUPAAALAlAEFg4AAPQBaQTqDQAA9AFKBMsNAAALAh4E5A0AAAsCHgTxDAAA9AFKBAsNAAD0AWkE7AwAAAsCUAS/DAAACwJDBb8MAAD0ASkF7AwAAPQBSAULDQAACwJ1BfEMAAALAnUF5A0AAPQBSAXLDQAA9AEpBeoNAAALAkMFFg4AANYayQQ5LwAAyx3JBDkvAADLHWUC3S8AANYaZQLdLwAA1hplAt0vAADLHWUC3S8AAMsdpACdMQAA1hqkAJ0xAADWGqQAnTEAAMsdpACdMQAAyx0AAAI0AADWGgAAAjQAANYaAAACNAAAyx0AAAI0AADLHaQAZzYAANYapABnNgAA1hqkAGc2AADLHaQAZzYAAMsdZQInOAAA1hplAic4AADWGmUCJzgAAMsdZQInOAAAyx3JBMs4AADWGskEyzgAANYayQTLOAAAyx3JBMs4AADLHS4HJzgAANYaLgcnOAAA1houByc4AADLHS4HJzgAAMsd7ghnNgAA1hruCGc2AADWGu4IZzYAAMsd7ghnNgAAyx2SCQI0AADWGpIJAjQAANYakgkCNAAAyx2SCQI0AADLHe4InTEAANYa7gidMQAAyx3JBMs4AADLHWUCJzgAAFMe+QIlNwAAUx7JBKI3AADWGu4InTEAAMsd7gidMQAAyx0uB90vAADWGi4H3S8AANYaLgfdLwAAyx0uB90vAADLHckEOS8AANYayQQ5LwAA1houB90vAADWGskEOS8AANYaZQLdLwAA1hoAAAI0AADWGqQAnTEAANYakgkCNAAA1hruCJ0xAADWGi4HJzgAANYa7ghnNgAA1hplAic4AADWGskEyzgAANYapABnNgAAUx7JBKI3AABTHvkCJTcAAFMeNAO/NgAAUx7JBCw3AADLHWUCJzgAAMsdpABnNgAAUx6mAdI1AABTHvkCJTcAAMsdpABnNgAAyx0AAAI0AABTHioBAjQAAFMepgHSNQAAyx3JBDkvAADLHS4H3S8AAFMemQbfMAAAUx7JBGIwAADLHWUC3S8AAMsdyQQ5LwAAUx7JBGIwAABTHvkC3zAAAMsdAAACNAAAyx2kAJ0xAABTHqYBMjIAAFMeKgECNAAAyx0uB90vAADLHe4InTEAAFMe7QcyMgAAUx6ZBt8wAADLHaQAnTEAAMsdZQLdLwAAUx75At8wAABTHqYBMjIAAMsd7gidMQAAyx2SCQI0AABTHmkIAjQAAFMe7QcyMgAAyx2SCQI0AADLHe4IZzYAAFMe7QfSNQAAUx5pCAI0AADLHe4IZzYAAMsdLgcnOAAAUx6ZBiU3AABTHu0H0jUAAMsdLgcnOAAAyx3JBMs4AABTHskEojcAAFMemQYlNwAAUx7zBwI0AABTHocHlzUAAOQdhweXNQAA5B3zBwI0AABTHioBAjQAAFMepgEyMgAAUx4MAm0yAABTHjQDRTEAAFMenwECNAAAUx6mAdI1AABTHgwClzUAAFMe+QLfMAAAUx7JBNgwAABTHskEYjAAAFMe7QcyMgAAUx5pCAI0AABTHvMHAjQAAFMehwdtMgAAUx6ZBt8wAABTHl4GRTEAAFMemQYlNwAAUx7JBKI3AABTHskELDcAAFMeXga/NgAAUx7tB9I1AABTHocHlzUAAFMe+QIlNwAAUx6mAdI1AABTHgwClzUAAFMeNAO/NgAAUx7JBGIwAABTHpkG3zAAAFMeXgZFMQAAUx7JBNgwAABTHmkIAjQAAFMe7QfSNQAAUx6HB5c1AABTHvMHAjQAAFMeyQQsNwAAUx40A782AADkHTQDvzYAAOQdyQQsNwAAUx6fAQI0AABTHgwCbTIAAOQdDAJtMgAA5B2fAQI0AABTHocHbTIAAFMe8wcCNAAA5B3zBwI0AADkHYcHbTIAAFMeXga/NgAAUx7JBCw3AADkHckELDcAAOQdXga/NgAAUx4MApc1AABTHp8BAjQAAOQdnwECNAAA5B0MApc1AABTHl4GRTEAAFMehwdtMgAA5B2HB20yAADkHV4GRTEAAFMeNANFMQAAUx7JBNgwAADkHckE2DAAAOQdNANFMQAAUx6HB5c1AABTHl4GvzYAAOQdXga/NgAA5B2HB5c1AABTHjQDvzYAAFMeDAKXNQAA5B0MApc1AADkHTQDvzYAAFMeyQTYMAAAUx5eBkUxAADkHV4GRTEAAOQdyQTYMAAAUx4MAm0yAABTHjQDRTEAAOQdNANFMQAA5B0MAm0yAAAkHaEE9jYAACQdXQOgNgAATh1JBP40AABOHaoEGTUAACQdNgagNgAAJB3yBPY2AABOHegEGTUAAE4dSgX+NAAAJB1QB5w1AAAkHWMGiTYAAE4dbQXtNAAATh20BaY0AAAkHb4HKjQAACQdZwduNQAATh3GBYM0AABOHeAFITQAACQdYwZ7MQAAJB1QB2gyAABOHbQFXjMAAE4dbQUXMwAAJB1nB5YyAAAkHb4H2jMAAE4d4AXjMwAATh3GBYEzAAAkHfIEDjEAACQdNgZkMQAATh1KBQYzAABOHegE6zIAACQdXQNkMQAAJB2hBA4xAABOHaoE6zIAAE4dSQQGMwAAJB1CAmgyAAAkHS8DezEAAE4dJgQXMwAATh3eA14zAAAkHdUB2jMAACQdLAKWMgAATh3NA4EzAABOHbMD4zMAACQdLAJuNQAAJB3VASo0AABOHbMDITQAAE4dzQODNAAAJB0vA4k2AAAkHUICnDUAAE4d3gOmNAAATh0mBO00AACoHVAErTQAAKgdHgR8NAAAwB1KBGI0AADAHWkEgTQAAKgdHgSIMwAAqB1QBFczAADAHWkEgzMAAMAdSgSiMwAAqB1DBVczAACoHXUFiDMAAMAdSAWiMwAAwB0pBYMzAACoHXUFfDQAAKgdQwWtNAAAwB0pBYE0AADAHUgFYjQAAN4EyQQ5LwAA3gRlAt0vAADpAWUC3S8AAOkByQQ5LwAA3gRlAt0vAADeBKQAnTEAAOkBpACdMQAA6QFlAt0vAADeBKQAnTEAAN4EAAACNAAA6QEAAAI0AADpAaQAnTEAAN4EAAACNAAA3gSkAGc2AADpAaQAZzYAAOkBAAACNAAA3gSkAGc2AADeBGUCJzgAAOkBZQInOAAA6QGkAGc2AADeBGUCJzgAAN4EyQTLOAAA6QHJBMs4AADpAWUCJzgAAN4EyQTLOAAA3gQuByc4AADpAS4HJzgAAOkByQTLOAAA3gQuByc4AADeBO4IZzYAAOkB7ghnNgAA6QEuByc4AADeBO4IZzYAAN4EkgkCNAAA6QGSCQI0AADpAe4IZzYAAN4EkgkCNAAA3gTuCJ0xAADpAe4InTEAAOkBkgkCNAAA6QHJBMs4AABhAckEojcAAGEB+QIlNwAA6QFlAic4AADeBO4InTEAAN4ELgfdLwAA6QEuB90vAADpAe4InTEAAN4ELgfdLwAA3gTJBDkvAADpAckEOS8AAOkBLgfdLwAA3gRlAt0vAADeBMkEOS8AAN4ELgfdLwAA3gSSCQI0AADeBO4InTEAAN4EAAACNAAA3gSkAJ0xAADeBGUCJzgAAN4EpABnNgAA3gQuByc4AADeBMkEyzgAAN4E7ghnNgAAYQHJBKI3AABhAckELDcAAGEBNAO/NgAAYQH5AiU3AADpAWUCJzgAAGEB+QIlNwAAYQGmAdI1AADpAaQAZzYAAOkBpABnNgAAYQGmAdI1AABhASoBAjQAAOkBAAACNAAA6QHJBDkvAABhAckEYjAAAGEBmQbfMAAA6QEuB90vAADpAWUC3S8AAGEB+QLfMAAAYQHJBGIwAADpAckEOS8AAOkBAAACNAAAYQEqAQI0AABhAaYBMjIAAOkBpACdMQAA6QEuB90vAABhAZkG3zAAAGEB7QcyMgAA6QHuCJ0xAADpAaQAnTEAAGEBpgEyMgAAYQH5At8wAADpAWUC3S8AAOkB7gidMQAAYQHtBzIyAABhAWkIAjQAAOkBkgkCNAAA6QGSCQI0AABhAWkIAjQAAGEB7QfSNQAA6QHuCGc2AADpAe4IZzYAAGEB7QfSNQAAYQGZBiU3AADpAS4HJzgAAOkBLgcnOAAAYQGZBiU3AABhAckEojcAAOkByQTLOAAAYQHzBwI0AADQAfMHAjQAANABhweXNQAAYQGHB5c1AABhASoBAjQAAGEBnwECNAAAYQEMAm0yAABhAaYBMjIAAGEB7QcyMgAAYQGHB20yAABhAfMHAjQAAGEBmQbfMAAAYQFeBkUxAABhAWkIAjQAAGEBhweXNQAAYQHtB9I1AABhAZkGJTcAAGEBXga/NgAAYQHJBCw3AABhAckEojcAAGEBpgHSNQAAYQEMApc1AABhAZ8BAjQAAGEBKgECNAAAYQH5At8wAABhATQDRTEAAGEByQTYMAAAYQHJBGIwAABhAe0H0jUAAGEBhweXNQAAYQFeBr82AABhAZkGJTcAAGEB+QIlNwAAYQE0A782AABhAQwClzUAAGEBpgHSNQAAYQHJBGIwAABhAckE2DAAAGEBXgZFMQAAYQGZBt8wAABhAaYBMjIAAGEBDAJtMgAAYQE0A0UxAABhAfkC3zAAAGEByQQsNwAA0AHJBCw3AADQATQDvzYAAGEBNAO/NgAAYQGfAQI0AADQAZ8BAjQAANABDAJtMgAAYQEMAm0yAABhAYcHbTIAANABhwdtMgAA0AHzBwI0AABhAfMHAjQAAGEBXga/NgAA0AFeBr82AADQAckELDcAAGEByQQsNwAAYQEMApc1AADQAQwClzUAANABnwECNAAAYQGfAQI0AABhAV4GRTEAANABXgZFMQAA0AGHB20yAABhAYcHbTIAAGEBNANFMQAA0AE0A0UxAADQAckE2DAAAGEByQTYMAAAYQGHB5c1AADQAYcHlzUAANABXga/NgAAYQFeBr82AABhATQDvzYAANABNAO/NgAA0AEMApc1AABhAQwClzUAAGEByQTYMAAA0AHJBNgwAADQAV4GRTEAAGEBXgZFMQAAYQEMAm0yAADQAQwCbTIAANABNANFMQAAYQE0A0UxAACQAqEE9jYAAGYCqgQZNQAAZgJJBP40AACQAl0DoDYAAJACNgagNgAAZgJKBf40AABmAugEGTUAAJAC8gT2NgAAkAJQB5w1AABmArQFpjQAAGYCbQXtNAAAkAJjBok2AACQAr4HKjQAAGYC4AUhNAAAZgLGBYM0AACQAmcHbjUAAJACYwZ7MQAAZgJtBRczAABmArQFXjMAAJACUAdoMgAAkAJnB5YyAABmAsYFgTMAAGYC4AXjMwAAkAK+B9ozAACQAvIEDjEAAGYC6ATrMgAAZgJKBQYzAACQAjYGZDEAAJACXQNkMQAAZgJJBAYzAABmAqoE6zIAAJACoQQOMQAAkAJCAmgyAABmAt4DXjMAAGYCJgQXMwAAkAIvA3sxAACQAtUB2jMAAGYCswPjMwAAZgLNA4EzAACQAiwCljIAAJACLAJuNQAAZgLNA4M0AABmArMDITQAAJAC1QEqNAAAkAIvA4k2AABmAiYE7TQAAGYC3gOmNAAAkAJCApw1AAALAlAErTQAAPQBaQSBNAAA9AFKBGI0AAALAh4EfDQAAAsCHgSIMwAA9AFKBKIzAAD0AWkEgzMAAAsCUARXMwAACwJDBVczAAD0ASkFgzMAAPQBSAWiMwAACwJ1BYgzAAALAnUFfDQAAPQBSAViNAAA9AEpBYE0AAALAkMFrTQAANcPCwjaAAAA1w/ZCoIBAABvFNkK4wEAAG8UCwg6AQAANxQ1B/U+AADXDzUHFD8AANcP1gQUPwAANxTWBPU+AADXDwsI2gAAAD8LCwg6AQAAPwvZCuMBAADXD9kKggEAAHcLNQf1PgAAdwvWBPU+AADXD9YEFD8AANcPNQcUPwAA8R0FBPkMAADkHQwC1gsAAOQdQgLRCwAA4R3eA8cMAADxHckEiAwAAPEdOwWmDAAAGB4QBfAMAAAYHskE3QwAAOQdhwcADwAA8R2OBdwNAADhHcYF7A0AAOQdZwfXDgAA5B3JBJUQAADkHTQDKBAAAOQdXQMIEAAA5B2hBF8QAADkHUICBQ8AAOQdLwPyDwAA5B0MAgAPAADkHV4GKBAAAOQd8gRfEAAA5B02BggQAADkHYcHAA8AAOQdYwbyDwAA5B1QBwUPAADkHfMHaw0AAOQdZwfXDgAA5B2+B5MNAADkHYcH1gsAAOQdvgdCDQAA5B1nB/4LAADkHV4GrQoAAOQdUAfRCwAA5B1jBuQKAADkHckEQQoAAOQdNgbNCgAA5B3yBHYKAADxHQUE+QwAAPEd5gNrDQAA4R2zA0wNAADhHc0D6gwAAPEdjgX5DAAA5B2HB9YLAADkHWcH/gsAAOEdxgXqDAAA8R3JBE4OAADxHTsFLw4AAOEdSgVnDgAA4R3oBIEOAADkHZ8Baw0AAPEd5gNrDQAA4R2zA4oNAADkHdUBkw0AAPEdjgX5DAAA8R07BaYMAADhHW0FgAwAAOEdtAXHDAAA8R3JBIgMAADxHVgEpgwAAOEdSQRuDAAA4R2qBFQMAADxHY4F3A0AAOQdhwcADwAA5B1QBwUPAADhHbQFDg4AAPEdBQTcDQAA8R1YBC8OAADhHSYEVg4AAOEd3gMODgAA8R07BaYMAADxHckEiAwAAOEd6ARUDAAA4R1KBW4MAAAYHk8EJA0AABgegwTwDAAAGB7JBN0MAAAYHkQFJA0AABgeEAXwDAAAGB5PBLINAAAYHjwEaw0AABgeyQT4DQAAGB6DBOUNAAAYHkQFsg0AABgeEAXlDQAAGB5XBWsNAADxHVgEpgwAABgegwTwDAAAEB5pBOwMAAD4HVAEvwwAAPEdrAVrDQAA8R2OBdwNAAAYHkQFsg0AABgeVwVrDQAA8R3JBE4OAADxHVgELw4AABgegwTlDQAAGB7JBPgNAADxHeYDaw0AAPEdBQT5DAAAGB5PBCQNAAAYHjwEaw0AAPEdjgX5DAAA8R2sBWsNAAAYHlcFaw0AABgeRAUkDQAA8R07BS8OAADxHckETg4AABgeyQT4DQAAGB4QBeUNAADxHQUE3A0AAPEd5gNrDQAAGB48BGsNAAAYHk8Esg0AABgeEAXwDAAA8R07BaYMAAD4HUMFvwwAABAeKQXsDAAA8R1YBKYMAADxHckEiAwAABgeyQTdDAAAGB6DBPAMAADxHTsFLw4AABgeEAXlDQAAEB4pBeoNAAD4HUMFFg4AAPEdWAQvDgAA8R0FBNwNAAD4HR4E5A0AAPgdUAQWDgAA4R1JBGcOAADhHaoEgQ4AAE4dqgSBDgAATh1JBGcOAADxHckETg4AAOQdyQSVEAAA5B2hBF8QAADhHaoEgQ4AAPEdWAQvDgAA8R3JBE4OAADhHaoEgQ4AAOEdSQRnDgAA5B00AygQAADxHVgELw4AAOEdSQRnDgAA5B1dAwgQAADhHeAFTA0AAOEdxgXqDAAATh3GBeoMAABOHeAFTA0AAOQdyQSVEAAA8R3JBE4OAADhHegEgQ4AAOQd8gRfEAAA8R07BS8OAADkHV4GKBAAAOQdNgYIEAAA4R1KBWcOAADhHbMDig0AAOEdzQPsDQAATh3NA+wNAABOHbMDig0AAOQdXgYoEAAA8R07BS8OAADhHW0FVg4AAOQdYwbyDwAA8R07BS8OAADxHY4F3A0AAOEdtAUODgAA4R1tBVYOAADhHeAFig0AAOQdvgeTDQAAJB2+B5MNAABOHeAFig0AAPEdjgXcDQAA8R2sBWsNAADhHeAFig0AAOEdxgXsDQAA8R2sBWsNAADkHfMHaw0AAOQdvgeTDQAA4R3gBYoNAADkHaEEXxAAAOQdXQMIEAAAJB1dAwgQAAAkHaEEXxAAAOQdhwfWCwAA8R2OBfkMAADhHbQFxwwAAOQdUAfRCwAA8R07BaYMAADkHV4GrQoAAOQdYwbkCgAA4R1tBYAMAADhHd4DxwwAAOQdQgLRCwAAJB1CAtELAABOHd4DxwwAAOQd8wdrDQAA8R2sBWsNAADhHeAFTA0AAOQdvgdCDQAA8R2sBWsNAADxHY4F+QwAAOEdxgXqDAAA4R3gBUwNAADkHWcH/gsAAOQdvgdCDQAAJB2+B0INAAAkHWcH/gsAAOQdXgatCgAA8R07BaYMAADhHUoFbgwAAOQdNgbNCgAA8R3JBIgMAADkHckEQQoAAOQd8gR2CgAA4R3oBFQMAADkHSwC1w4AAOQd1QGTDQAAJB3VAZMNAAAkHSwC1w4AAOQdNAOtCgAA5B3JBEEKAADkHaEEdgoAAOQdXQPNCgAA8R1YBKYMAADkHTQDrQoAAOQdXQPNCgAA4R1JBG4MAADkHckEQQoAAPEdyQSIDAAA4R2qBFQMAADkHaEEdgoAAOQdZwfXDgAA4R3GBewNAABOHcYF7A0AACQdZwfXDgAA8R1YBKYMAADxHQUE+QwAAOEd3gPHDAAA4R0mBIAMAADkHTQDrQoAAPEdWASmDAAA4R0mBIAMAADkHS8D5AoAAOQdDALWCwAA5B00A60KAADkHS8D5AoAAOQdQgLRCwAA5B2fAWsNAADkHSwC/gsAAOQd1QFCDQAA5B0vA+QKAADhHSYEgAwAAE4dJgSADAAAJB0vA+QKAADkHQwC1gsAAPEdBQT5DAAA4R3NA+oMAADkHSwC/gsAAPEd5gNrDQAA5B2fAWsNAADkHdUBQg0AAOEdswNMDQAA4R3GBewNAADhHeAFig0AAE4d4AWKDQAATh3GBewNAADxHeYDaw0AAPEdBQTcDQAA4R3NA+wNAADhHbMDig0AAOQdDAIADwAA5B2fAWsNAADkHdUBkw0AAOQdLALXDgAA8R0FBNwNAADkHQwCAA8AAOQdLALXDgAA4R3NA+wNAADhHSYEgAwAAOEd3gPHDAAATh3eA8cMAABOHSYEgAwAAPEdWAQvDgAA5B00AygQAADkHS8D8g8AAOEdJgRWDgAA5B0MAgAPAADxHQUE3A0AAOEd3gMODgAA5B1CAgUPAADkHdUBkw0AAOEdswOKDQAATh2zA4oNAAAkHdUBkw0AAOQdvgdCDQAA4R3gBUwNAABOHeAFTA0AACQdvgdCDQAA5B1dAwgQAADhHUkEZw4AAE4dSQRnDgAAJB1dAwgQAADkHV0DzQoAAOQdoQR2CgAAJB2hBHYKAAAkHV0DzQoAAOEdzQPsDQAA5B0sAtcOAAAkHSwC1w4AAE4dzQPsDQAA5B1QBwUPAADkHWMG8g8AACQdYwbyDwAAJB1QBwUPAADhHcYF6gwAAOQdZwf+CwAAJB1nB/4LAABOHcYF6gwAAOEdqgSBDgAA5B2hBF8QAAAkHaEEXxAAAE4dqgSBDgAA4R2qBFQMAADhHUkEbgwAAE4dSQRuDAAATh2qBFQMAADhHW0FVg4AAOEdtAUODgAATh20BQ4OAABOHW0FVg4AAOEdSQRuDAAA5B1dA80KAAAkHV0DzQoAAE4dSQRuDAAA4R20BQ4OAADkHVAHBQ8AACQdUAcFDwAATh20BQ4OAADkHdUBQg0AAOQdLAL+CwAAJB0sAv4LAAAkHdUBQg0AAOQdYwbkCgAA5B1QB9ELAAAkHVAH0QsAACQdYwbkCgAA5B2hBHYKAADhHaoEVAwAAE4dqgRUDAAAJB2hBHYKAADkHWMG8g8AAOEdbQVWDgAATh1tBVYOAAAkHWMG8g8AAOEdzQPqDAAA4R2zA0wNAABOHbMDTA0AAE4dzQPqDAAA4R20BccMAADhHW0FgAwAAE4dbQWADAAATh20BccMAADkHSwC/gsAAOEdzQPqDAAATh3NA+oMAAAkHSwC/gsAAOQdUAfRCwAA4R20BccMAABOHbQFxwwAACQdUAfRCwAA5B0vA/IPAADkHUICBQ8AACQdQgIFDwAAJB0vA/IPAADkHfIEdgoAAOQdNgbNCgAAJB02Bs0KAAAkHfIEdgoAAOEdswNMDQAA5B3VAUINAAAkHdUBQg0AAE4dswNMDQAA5B02BggQAADkHfIEXxAAACQd8gRfEAAAJB02BggQAADhHW0FgAwAAOQdYwbkCgAAJB1jBuQKAABOHW0FgAwAAOEd3gMODgAA4R0mBFYOAABOHSYEVg4AAE4d3gMODgAA4R1KBW4MAADhHegEVAwAAE4d6ARUDAAATh1KBW4MAADhHegEgQ4AAOEdSgVnDgAATh1KBWcOAABOHegEgQ4AAOEdJgRWDgAA5B0vA/IPAAAkHS8D8g8AAE4dJgRWDgAA5B02Bs0KAADhHUoFbgwAAE4dSgVuDAAAJB02Bs0KAADkHfIEXxAAAOEd6ASBDgAATh3oBIEOAAAkHfIEXxAAAOQdQgLRCwAA5B0vA+QKAAAkHS8D5AoAACQdQgLRCwAA5B1CAgUPAADhHd4DDg4AAE4d3gMODgAAJB1CAgUPAADkHb4Hkw0AAOQdZwfXDgAAJB1nB9cOAAAkHb4Hkw0AAOEd6ARUDAAA5B3yBHYKAAAkHfIEdgoAAE4d6ARUDAAA4R1KBWcOAADkHTYGCBAAACQdNgYIEAAATh1KBWcOAAD4HVAEFg4AAPgdHgTkDQAAqB0eBOQNAACoHVAEFg4AABgegwTlDQAA8R1YBC8OAAD4HVAEFg4AABAeaQTqDQAA8R0FBNwNAAAYHk8Esg0AABAeSgTLDQAA+B0eBOQNAAAYHk8Esg0AABgegwTlDQAAEB5pBOoNAAAQHkoEyw0AAPgdQwUWDgAAEB4pBeoNAADAHSkF6g0AAKgdQwUWDgAAGB6DBPAMAAAYHk8EJA0AABAeSgQLDQAAEB5pBOwMAADxHQUE+QwAAPEdWASmDAAA+B1QBL8MAAD4HR4E8QwAABgeTwQkDQAA8R0FBPkMAAD4HR4E8QwAABAeSgQLDQAA+B11BfEMAAAQHkgFCw0AAMAdSAULDQAAqB11BfEMAAAYHkQFJA0AABgeEAXwDAAAEB4pBewMAAAQHkgFCw0AAPEdjgX5DAAAGB5EBSQNAAAQHkgFCw0AAPgddQXxDAAA8R07BaYMAADxHY4F+QwAAPgddQXxDAAA+B1DBb8MAAAQHkgFyw0AAPgddQXkDQAAqB11BeQNAADAHUgFyw0AABgeEAXlDQAAGB5EBbINAAAQHkgFyw0AABAeKQXqDQAA8R2OBdwNAADxHTsFLw4AAPgdQwUWDgAA+B11BeQNAAAYHkQFsg0AAPEdjgXcDQAA+B11BeQNAAAQHkgFyw0AAPgdHgTxDAAA+B1QBL8MAACoHVAEvwwAAKgdHgTxDAAAEB5KBMsNAAAQHmkE6g0AAMAdaQTqDQAAwB1KBMsNAAD4HUMFvwwAAPgddQXxDAAAqB11BfEMAACoHUMFvwwAABAeaQTsDAAAEB5KBAsNAADAHUoECw0AAMAdaQTsDAAA+B11BeQNAAD4HUMFFg4AAKgdQwUWDgAAqB11BeQNAAAQHmkE6g0AAPgdUAQWDgAAqB1QBBYOAADAHWkE6g0AABAeSAULDQAAEB4pBewMAADAHSkF7AwAAMAdSAULDQAA+B1QBL8MAAAQHmkE7AwAAMAdaQTsDAAAqB1QBL8MAAAQHikF6g0AABAeSAXLDQAAwB1IBcsNAADAHSkF6g0AAPgdHgTkDQAAEB5KBMsNAADAHUoEyw0AAKgdHgTkDQAAEB4pBewMAAD4HUMFvwwAAKgdQwW/DAAAwB0pBewMAAAQHkoECw0AAPgdHgTxDAAAqB0eBPEMAADAHUoECw0AAMMBBQT5DAAA0wHeA8cMAADQAUIC0QsAANABDALWCwAAwwHJBIgMAACcAckE3QwAAJwBEAXwDAAAwwE7BaYMAADQAYcHAA8AANABZwfXDgAA0wHGBewNAADDAY4F3A0AANAByQSVEAAA0AGhBF8QAADQAV0DCBAAANABNAMoEAAA0AFCAgUPAADQAQwCAA8AANABLwPyDwAA0AFeBigQAADQAfIEXxAAANABNgYIEAAAwwEFBPkMAADTAc0D6gwAANMBswNMDQAAwwHmA2sNAADDAY4F+QwAANMBxgXqDAAA0AFnB/4LAADQAYcH1gsAAMMByQRODgAA0wHoBIEOAADTAUoFZw4AAMMBOwUvDgAA0AGfAWsNAADQAdUBkw0AANMBswOKDQAAwwHmA2sNAADDAY4F+QwAANMBtAXHDAAA0wFtBYAMAADDATsFpgwAAMMByQSIDAAA0wGqBFQMAADTAUkEbgwAAMMBWASmDAAAwwGOBdwNAADTAbQFDg4AANABUAcFDwAA0AGHBwAPAADDAQUE3A0AANMB3gMODgAA0wEmBFYOAADDAVgELw4AAMMBOwWmDAAA0wFKBW4MAADTAegEVAwAAMMByQSIDAAAnAHJBN0MAACcAYME8AwAAJwBTwQkDQAAnAFPBLINAACcATwEaw0AAJwBRAUkDQAAnAEQBfAMAACcAUQFsg0AAJwBVwVrDQAAnAHJBPgNAACcARAF5Q0AAJwBgwTlDQAAwwFYBKYMAAC7AVAEvwwAAKQBaQTsDAAAnAGDBPAMAADDAawFaw0AAJwBVwVrDQAAnAFEBbINAADDAY4F3A0AAMMByQRODgAAnAHJBPgNAACcAYME5Q0AAMMBWAQvDgAAwwHmA2sNAACcATwEaw0AAJwBTwQkDQAAwwEFBPkMAADDAY4F+QwAAJwBRAUkDQAAnAFXBWsNAADDAawFaw0AAMMBOwUvDgAAnAEQBeUNAACcAckE+A0AAMMByQRODgAAwwEFBNwNAACcAU8Esg0AAJwBPARrDQAAwwHmA2sNAACcARAF8AwAAKQBKQXsDAAAuwFDBb8MAADDATsFpgwAAMMBWASmDAAAnAGDBPAMAACcAckE3QwAAMMByQSIDAAAwwE7BS8OAAC7AUMFFg4AAKQBKQXqDQAAnAEQBeUNAADDAVgELw4AALsBUAQWDgAAuwEeBOQNAADDAQUE3A0AANMBSQRnDgAAZgJJBGcOAABmAqoEgQ4AANMBqgSBDgAAwwHJBE4OAADTAaoEgQ4AANABoQRfEAAA0AHJBJUQAADDAVgELw4AANMBSQRnDgAA0wGqBIEOAADDAckETg4AANABNAMoEAAA0AFdAwgQAADTAUkEZw4AAMMBWAQvDgAA0wHgBUwNAABmAuAFTA0AAGYCxgXqDAAA0wHGBeoMAADQAckElRAAANAB8gRfEAAA0wHoBIEOAADDAckETg4AAMMBOwUvDgAA0wFKBWcOAADQATYGCBAAANABXgYoEAAA0wGzA4oNAABmArMDig0AAGYCzQPsDQAA0wHNA+wNAADQAV4GKBAAANABYwbyDwAA0wFtBVYOAADDATsFLw4AAMMBOwUvDgAA0wFtBVYOAADTAbQFDg4AAMMBjgXcDQAA0AGHBwAPAADQAVAHBQ8AANABYwbyDwAA0AFeBigQAADTAeAFig0AAGYC4AWKDQAAkAK+B5MNAADQAb4Hkw0AAMMBjgXcDQAA0wHGBewNAADTAeAFig0AAMMBrAVrDQAA0AHzB2sNAADQAb4Hkw0AANABZwfXDgAA0AGHBwAPAADQAYcH1gsAANABvgdCDQAA0AFnB/4LAADQAV4GrQoAANABUAfRCwAA0AFjBuQKAADDAawFaw0AANMB4AWKDQAA0AG+B5MNAADQAfMHaw0AANABoQRfEAAAkAKhBF8QAACQAl0DCBAAANABXQMIEAAA0AGHB9YLAADQAVAH0QsAANMBtAXHDAAAwwGOBfkMAADDATsFpgwAANMBbQWADAAA0AFjBuQKAADQAV4GrQoAANMB3gPHDAAAZgLeA8cMAACQAkIC0QsAANABQgLRCwAA0AHzB2sNAADQAb4HQg0AANMB4AVMDQAAwwGsBWsNAADDAawFaw0AANMB4AVMDQAA0wHGBeoMAADDAY4F+QwAANABZwf+CwAAkAJnB/4LAACQAr4HQg0AANABvgdCDQAA0AFeBq0KAADQATYGzQoAANMBSgVuDAAAwwE7BaYMAADQAckEQQoAANAB8gR2CgAA0AE2Bs0KAADQAV4GrQoAAMMByQSIDAAA0wHoBFQMAADQAfIEdgoAANAByQRBCgAA0AEsAtcOAACQAiwC1w4AAJAC1QGTDQAA0AHVAZMNAADQATQDrQoAANABXQPNCgAA0AGhBHYKAADQAckEQQoAAMMBWASmDAAA0wFJBG4MAADQAV0DzQoAANABNAOtCgAA0AHJBEEKAADQAaEEdgoAANMBqgRUDAAAwwHJBIgMAADQAWcH1w4AAJACZwfXDgAAZgLGBewNAADTAcYF7A0AAMMBWASmDAAA0wEmBIAMAADTAd4DxwwAAMMBBQT5DAAA0AE0A60KAADQAS8D5AoAANMBJgSADAAAwwFYBKYMAADQAQwC1gsAANABQgLRCwAA0AEvA+QKAADQATQDrQoAANABLwPkCgAAkAIvA+QKAABmAiYEgAwAANMBJgSADAAA0AEMAtYLAADQASwC/gsAANMBzQPqDAAAwwEFBPkMAADQAZ8Baw0AANAB1QFCDQAA0AEsAv4LAADQAQwC1gsAAMMB5gNrDQAA0wGzA0wNAADQAdUBQg0AANABnwFrDQAA0wHGBewNAABmAsYF7A0AAGYC4AWKDQAA0wHgBYoNAADDAeYDaw0AANMBswOKDQAA0wHNA+wNAADDAQUE3A0AANABDAIADwAA0AEsAtcOAADQAdUBkw0AANABnwFrDQAAwwEFBNwNAADTAc0D7A0AANABLALXDgAA0AEMAgAPAADTASYEgAwAAGYCJgSADAAAZgLeA8cMAADTAd4DxwwAAMMBWAQvDgAA0wEmBFYOAADQAS8D8g8AANABNAMoEAAA0AEMAgAPAADQAUICBQ8AANMB3gMODgAAwwEFBNwNAADQAdUBkw0AAJAC1QGTDQAAZgKzA4oNAADTAbMDig0AANABvgdCDQAAkAK+B0INAABmAuAFTA0AANMB4AVMDQAA0AFdAwgQAACQAl0DCBAAAGYCSQRnDgAA0wFJBGcOAADQAV0DzQoAAJACXQPNCgAAkAKhBHYKAADQAaEEdgoAANMBzQPsDQAAZgLNA+wNAACQAiwC1w4AANABLALXDgAA0AFQBwUPAACQAlAHBQ8AAJACYwbyDwAA0AFjBvIPAADTAcYF6gwAAGYCxgXqDAAAkAJnB/4LAADQAWcH/gsAANMBqgSBDgAAZgKqBIEOAACQAqEEXxAAANABoQRfEAAA0wGqBFQMAABmAqoEVAwAAGYCSQRuDAAA0wFJBG4MAADTAW0FVg4AAGYCbQVWDgAAZgK0BQ4OAADTAbQFDg4AANMBSQRuDAAAZgJJBG4MAACQAl0DzQoAANABXQPNCgAA0wG0BQ4OAABmArQFDg4AAJACUAcFDwAA0AFQBwUPAADQAdUBQg0AAJAC1QFCDQAAkAIsAv4LAADQASwC/gsAANABYwbkCgAAkAJjBuQKAACQAlAH0QsAANABUAfRCwAA0AGhBHYKAACQAqEEdgoAAGYCqgRUDAAA0wGqBFQMAADQAWMG8g8AAJACYwbyDwAAZgJtBVYOAADTAW0FVg4AANMBzQPqDAAAZgLNA+oMAABmArMDTA0AANMBswNMDQAA0wG0BccMAABmArQFxwwAAGYCbQWADAAA0wFtBYAMAADQASwC/gsAAJACLAL+CwAAZgLNA+oMAADTAc0D6gwAANABUAfRCwAAkAJQB9ELAABmArQFxwwAANMBtAXHDAAA0AEvA/IPAACQAi8D8g8AAJACQgIFDwAA0AFCAgUPAADQAfIEdgoAAJAC8gR2CgAAkAI2Bs0KAADQATYGzQoAANMBswNMDQAAZgKzA0wNAACQAtUBQg0AANAB1QFCDQAA0AE2BggQAACQAjYGCBAAAJAC8gRfEAAA0AHyBF8QAADTAW0FgAwAAGYCbQWADAAAkAJjBuQKAADQAWMG5AoAANMB3gMODgAAZgLeAw4OAABmAiYEVg4AANMBJgRWDgAA0wFKBW4MAABmAkoFbgwAAGYC6ARUDAAA0wHoBFQMAADTAegEgQ4AAGYC6ASBDgAAZgJKBWcOAADTAUoFZw4AANMBJgRWDgAAZgImBFYOAACQAi8D8g8AANABLwPyDwAA0AE2Bs0KAACQAjYGzQoAAGYCSgVuDAAA0wFKBW4MAADQAfIEXxAAAJAC8gRfEAAAZgLoBIEOAADTAegEgQ4AANABQgLRCwAAkAJCAtELAACQAi8D5AoAANABLwPkCgAA0AFCAgUPAACQAkICBQ8AAGYC3gMODgAA0wHeAw4OAADQAb4Hkw0AAJACvgeTDQAAkAJnB9cOAADQAWcH1w4AANMB6ARUDAAAZgLoBFQMAACQAvIEdgoAANAB8gR2CgAA0wFKBWcOAABmAkoFZw4AAJACNgYIEAAA0AE2BggQAAC7AVAEFg4AAAsCUAQWDgAACwIeBOQNAAC7AR4E5A0AAJwBgwTlDQAApAFpBOoNAAC7AVAEFg4AAMMBWAQvDgAAwwEFBNwNAAC7AR4E5A0AAKQBSgTLDQAAnAFPBLINAACcAU8Esg0AAKQBSgTLDQAApAFpBOoNAACcAYME5Q0AALsBQwUWDgAACwJDBRYOAAD0ASkF6g0AAKQBKQXqDQAAnAGDBPAMAACkAWkE7AwAAKQBSgQLDQAAnAFPBCQNAADDAQUE+QwAALsBHgTxDAAAuwFQBL8MAADDAVgEpgwAAJwBTwQkDQAApAFKBAsNAAC7AR4E8QwAAMMBBQT5DAAAuwF1BfEMAAALAnUF8QwAAPQBSAULDQAApAFIBQsNAACcAUQFJA0AAKQBSAULDQAApAEpBewMAACcARAF8AwAAMMBjgX5DAAAuwF1BfEMAACkAUgFCw0AAJwBRAUkDQAAwwE7BaYMAAC7AUMFvwwAALsBdQXxDAAAwwGOBfkMAACkAUgFyw0AAPQBSAXLDQAACwJ1BeQNAAC7AXUF5A0AAJwBEAXlDQAApAEpBeoNAACkAUgFyw0AAJwBRAWyDQAAwwGOBdwNAAC7AXUF5A0AALsBQwUWDgAAwwE7BS8OAACcAUQFsg0AAKQBSAXLDQAAuwF1BeQNAADDAY4F3A0AALsBHgTxDAAACwIeBPEMAAALAlAEvwwAALsBUAS/DAAApAFKBMsNAAD0AUoEyw0AAPQBaQTqDQAApAFpBOoNAAC7AUMFvwwAAAsCQwW/DAAACwJ1BfEMAAC7AXUF8QwAAKQBaQTsDAAA9AFpBOwMAAD0AUoECw0AAKQBSgQLDQAAuwF1BeQNAAALAnUF5A0AAAsCQwUWDgAAuwFDBRYOAACkAWkE6g0AAPQBaQTqDQAACwJQBBYOAAC7AVAEFg4AAKQBSAULDQAA9AFIBQsNAAD0ASkF7AwAAKQBKQXsDAAAuwFQBL8MAAALAlAEvwwAAPQBaQTsDAAApAFpBOwMAACkASkF6g0AAPQBKQXqDQAA9AFIBcsNAACkAUgFyw0AALsBHgTkDQAACwIeBOQNAAD0AUoEyw0AAKQBSgTLDQAApAEpBewMAAD0ASkF7AwAAAsCQwW/DAAAuwFDBb8MAACkAUoECw0AAPQBSgQLDQAACwIeBPEMAAC7AR4E8QwAAPEdBQSRMwAA5B0MAm0yAADkHUICaDIAAOEd3gNeMwAA8R3JBB8zAADxHTsFPTMAABgeEAWHMwAAGB7JBHUzAADkHYcHlzUAAPEdjgVzNAAA4R3GBYM0AADkHWcHbjUAAOQdyQQsNwAA5B00A782AADkHV0DoDYAAOQdoQT2NgAA5B1eBr82AADkHfIE9jYAAOQdNgagNgAA5B2HB5c1AADkHWMGiTYAAOQdUAecNQAA5B3zBwI0AADkHWcHbjUAAOQdvgcqNAAA5B2HB20yAADkHb4H2jMAAOQdZweWMgAA5B1eBkUxAADkHVAHaDIAAOQdYwZ7MQAA5B3JBNgwAADkHTYGZDEAAOQd8gQOMQAA5B00A0UxAADkHaEEDjEAAOQdXQNkMQAA8R0FBJEzAADxHeYDAjQAAOEdswPjMwAA4R3NA4EzAADxHY4FkTMAAOQdhwdtMgAA5B1nB5YyAADhHcYFgTMAAPEdyQTlNAAA8R07Bcc0AADhHUoF/jQAAOEd6AQZNQAA5B2fAQI0AADxHeYDAjQAAOEdswMhNAAA5B3VASo0AADxHY4FkTMAAPEdOwU9MwAA4R1tBRczAADhHbQFXjMAAPEdyQQfMwAA8R1YBD0zAADhHUkEBjMAAOEdqgTrMgAA8R2OBXM0AADkHYcHlzUAAOQdUAecNQAA4R20BaY0AADxHQUEczQAAPEdWATHNAAA4R0mBO00AADhHd4DpjQAAPEdOwU9MwAA8R3JBB8zAADhHegE6zIAAOEdSgUGMwAAGB5PBLszAAAYHoMEhzMAABgeyQR1MwAAGB5EBbszAAAYHhAFhzMAABgeTwRJNAAAGB48BAI0AAAYHskEjzQAABgegwR9NAAAGB5EBUk0AAAYHhAFfTQAABgeVwUCNAAA8R1YBD0zAAAYHoMEhzMAABAeaQSDMwAA+B1QBFczAADxHawFAjQAAPEdjgVzNAAAGB5EBUk0AAAYHlcFAjQAAPEdyQTlNAAA8R1YBMc0AAAYHoMEfTQAABgeyQSPNAAA8R3mAwI0AADxHQUEkTMAABgeTwS7MwAAGB48BAI0AADxHY4FkTMAAPEdrAUCNAAAGB5XBQI0AAAYHkQFuzMAAPEdOwXHNAAA8R3JBOU0AAAYHskEjzQAABgeEAV9NAAA8R0FBHM0AADxHeYDAjQAABgePAQCNAAAGB5PBEk0AAAYHhAFhzMAAPEdOwU9MwAA+B1DBVczAAAQHikFgzMAAPEdWAQ9MwAA8R3JBB8zAAAYHskEdTMAABgegwSHMwAA8R07Bcc0AAAYHhAFfTQAABAeKQWBNAAA+B1DBa00AADxHVgExzQAAPEdBQRzNAAA+B0eBHw0AAD4HVAErTQAAOEdSQT+NAAA4R2qBBk1AABOHaoEGTUAAE4dSQT+NAAA8R3JBOU0AADkHckELDcAAOQdoQT2NgAA4R2qBBk1AADxHVgExzQAAPEdyQTlNAAA4R2qBBk1AADhHUkE/jQAAOQdNAO/NgAA8R1YBMc0AADhHUkE/jQAAOQdXQOgNgAA4R3gBeMzAADhHcYFgTMAAE4dxgWBMwAATh3gBeMzAADkHckELDcAAPEdyQTlNAAA4R3oBBk1AADkHfIE9jYAAPEdOwXHNAAA5B1eBr82AADkHTYGoDYAAOEdSgX+NAAA4R2zAyE0AADhHc0DgzQAAE4dzQODNAAATh2zAyE0AADkHV4GvzYAAPEdOwXHNAAA4R1tBe00AADkHWMGiTYAAPEdOwXHNAAA8R2OBXM0AADhHbQFpjQAAOEdbQXtNAAA4R3gBSE0AADkHb4HKjQAACQdvgcqNAAATh3gBSE0AADxHY4FczQAAPEdrAUCNAAA4R3gBSE0AADhHcYFgzQAAPEdrAUCNAAA5B3zBwI0AADkHb4HKjQAAOEd4AUhNAAA5B2hBPY2AADkHV0DoDYAACQdXQOgNgAAJB2hBPY2AADkHYcHbTIAAPEdjgWRMwAA4R20BV4zAADkHVAHaDIAAPEdOwU9MwAA5B1eBkUxAADkHWMGezEAAOEdbQUXMwAA4R3eA14zAADkHUICaDIAACQdQgJoMgAATh3eA14zAADkHfMHAjQAAPEdrAUCNAAA4R3gBeMzAADkHb4H2jMAAPEdrAUCNAAA8R2OBZEzAADhHcYFgTMAAOEd4AXjMwAA5B1nB5YyAADkHb4H2jMAACQdvgfaMwAAJB1nB5YyAADkHV4GRTEAAPEdOwU9MwAA4R1KBQYzAADkHTYGZDEAAPEdyQQfMwAA5B3JBNgwAADkHfIEDjEAAOEd6ATrMgAA5B0sAm41AADkHdUBKjQAACQd1QEqNAAAJB0sAm41AADxHVgEPTMAAOQdNANFMQAA5B1dA2QxAADhHUkEBjMAAOQdyQTYMAAA8R3JBB8zAADhHaoE6zIAAOQdoQQOMQAA5B1nB241AADhHcYFgzQAAE4dxgWDNAAAJB1nB241AADxHVgEPTMAAPEdBQSRMwAA4R3eA14zAADhHSYEFzMAAOQdNANFMQAA8R1YBD0zAADhHSYEFzMAAOQdLwN7MQAA5B0MAm0yAADkHTQDRTEAAOQdLwN7MQAA5B1CAmgyAADkHS8DezEAAOEdJgQXMwAATh0mBBczAAAkHS8DezEAAOQdDAJtMgAA8R0FBJEzAADhHc0DgTMAAOQdLAKWMgAA5B2fAQI0AADkHQwCbTIAAOQdLAKWMgAA5B3VAdozAADxHeYDAjQAAOQdnwECNAAA5B3VAdozAADhHbMD4zMAAOEdxgWDNAAA4R3gBSE0AABOHeAFITQAAE4dxgWDNAAA8R3mAwI0AADxHQUEczQAAOEdzQODNAAA4R2zAyE0AADkHQwClzUAAOQdnwECNAAA5B3VASo0AADkHSwCbjUAAPEdBQRzNAAA5B0MApc1AADkHSwCbjUAAOEdzQODNAAA4R0mBBczAADhHd4DXjMAAE4d3gNeMwAATh0mBBczAADkHTQDvzYAAOQdDAKXNQAA5B1CApw1AADkHS8DiTYAAPEdWATHNAAA5B00A782AADkHS8DiTYAAOEdJgTtNAAA5B0MApc1AADxHQUEczQAAOEd3gOmNAAA5B1CApw1AADkHdUBKjQAAOEdswMhNAAATh2zAyE0AAAkHdUBKjQAAOQdvgfaMwAA4R3gBeMzAABOHeAF4zMAACQdvgfaMwAA5B1dA6A2AADhHUkE/jQAAE4dSQT+NAAAJB1dA6A2AADkHV0DZDEAAOQdoQQOMQAAJB2hBA4xAAAkHV0DZDEAAOEdzQODNAAA5B0sAm41AAAkHSwCbjUAAE4dzQODNAAA5B1QB5w1AADkHWMGiTYAACQdYwaJNgAAJB1QB5w1AADhHcYFgTMAAOQdZweWMgAAJB1nB5YyAABOHcYFgTMAAOEdqgQZNQAA5B2hBPY2AAAkHaEE9jYAAE4dqgQZNQAA4R2qBOsyAADhHUkEBjMAAE4dSQQGMwAATh2qBOsyAADhHW0F7TQAAOEdtAWmNAAATh20BaY0AABOHW0F7TQAAOEdSQQGMwAA5B1dA2QxAAAkHV0DZDEAAE4dSQQGMwAA4R20BaY0AADkHVAHnDUAACQdUAecNQAATh20BaY0AADkHdUB2jMAAOQdLAKWMgAAJB0sApYyAAAkHdUB2jMAAOQdYwZ7MQAA5B1QB2gyAAAkHVAHaDIAACQdYwZ7MQAA5B2hBA4xAADhHaoE6zIAAE4dqgTrMgAAJB2hBA4xAADkHWMGiTYAAOEdbQXtNAAATh1tBe00AAAkHWMGiTYAAOEdzQOBMwAA4R2zA+MzAABOHbMD4zMAAE4dzQOBMwAA4R20BV4zAADhHW0FFzMAAE4dbQUXMwAATh20BV4zAADkHSwCljIAAOEdzQOBMwAATh3NA4EzAAAkHSwCljIAAOQdUAdoMgAA4R20BV4zAABOHbQFXjMAACQdUAdoMgAA5B0vA4k2AADkHUICnDUAACQdQgKcNQAAJB0vA4k2AADkHfIEDjEAAOQdNgZkMQAAJB02BmQxAAAkHfIEDjEAAOEdswPjMwAA5B3VAdozAAAkHdUB2jMAAE4dswPjMwAA5B02BqA2AADkHfIE9jYAACQd8gT2NgAAJB02BqA2AADhHW0FFzMAAOQdYwZ7MQAAJB1jBnsxAABOHW0FFzMAAOEd3gOmNAAA4R0mBO00AABOHSYE7TQAAE4d3gOmNAAA4R1KBQYzAADhHegE6zIAAE4d6ATrMgAATh1KBQYzAADhHegEGTUAAOEdSgX+NAAATh1KBf40AABOHegEGTUAAOEdJgTtNAAA5B0vA4k2AAAkHS8DiTYAAE4dJgTtNAAA5B02BmQxAADhHUoFBjMAAE4dSgUGMwAAJB02BmQxAADkHfIE9jYAAOEd6AQZNQAATh3oBBk1AAAkHfIE9jYAAOQdQgJoMgAA5B0vA3sxAAAkHS8DezEAACQdQgJoMgAA5B1CApw1AADhHd4DpjQAAE4d3gOmNAAAJB1CApw1AADkHb4HKjQAAOQdZwduNQAAJB1nB241AAAkHb4HKjQAAOEd6ATrMgAA5B3yBA4xAAAkHfIEDjEAAE4d6ATrMgAA4R1KBf40AADkHTYGoDYAACQdNgagNgAATh1KBf40AAD4HVAErTQAAPgdHgR8NAAAqB0eBHw0AACoHVAErTQAABgegwR9NAAA8R1YBMc0AAD4HVAErTQAABAeaQSBNAAA8R0FBHM0AAAYHk8ESTQAABAeSgRiNAAA+B0eBHw0AAAYHk8ESTQAABgegwR9NAAAEB5pBIE0AAAQHkoEYjQAAPgdQwWtNAAAEB4pBYE0AADAHSkFgTQAAKgdQwWtNAAAGB6DBIczAAAYHk8EuzMAABAeSgSiMwAAEB5pBIMzAADxHQUEkTMAAPEdWAQ9MwAA+B1QBFczAAD4HR4EiDMAABgeTwS7MwAA8R0FBJEzAAD4HR4EiDMAABAeSgSiMwAA+B11BYgzAAAQHkgFojMAAMAdSAWiMwAAqB11BYgzAAAYHkQFuzMAABgeEAWHMwAAEB4pBYMzAAAQHkgFojMAAPEdjgWRMwAAGB5EBbszAAAQHkgFojMAAPgddQWIMwAA8R07BT0zAADxHY4FkTMAAPgddQWIMwAA+B1DBVczAAAQHkgFYjQAAPgddQV8NAAAqB11BXw0AADAHUgFYjQAABgeEAV9NAAAGB5EBUk0AAAQHkgFYjQAABAeKQWBNAAA8R2OBXM0AADxHTsFxzQAAPgdQwWtNAAA+B11BXw0AAAYHkQFSTQAAPEdjgVzNAAA+B11BXw0AAAQHkgFYjQAAPgdHgSIMwAA+B1QBFczAACoHVAEVzMAAKgdHgSIMwAAEB5KBGI0AAAQHmkEgTQAAMAdaQSBNAAAwB1KBGI0AAD4HUMFVzMAAPgddQWIMwAAqB11BYgzAACoHUMFVzMAABAeaQSDMwAAEB5KBKIzAADAHUoEojMAAMAdaQSDMwAA+B11BXw0AAD4HUMFrTQAAKgdQwWtNAAAqB11BXw0AAAQHmkEgTQAAPgdUAStNAAAqB1QBK00AADAHWkEgTQAABAeSAWiMwAAEB4pBYMzAADAHSkFgzMAAMAdSAWiMwAA+B1QBFczAAAQHmkEgzMAAMAdaQSDMwAAqB1QBFczAAAQHikFgTQAABAeSAViNAAAwB1IBWI0AADAHSkFgTQAAPgdHgR8NAAAEB5KBGI0AADAHUoEYjQAAKgdHgR8NAAAEB4pBYMzAAD4HUMFVzMAAKgdQwVXMwAAwB0pBYMzAAAQHkoEojMAAPgdHgSIMwAAqB0eBIgzAADAHUoEojMAAMMBBQSRMwAA0wHeA14zAADQAUICaDIAANABDAJtMgAAwwHJBB8zAACcAckEdTMAAJwBEAWHMwAAwwE7BT0zAADQAYcHlzUAANABZwduNQAA0wHGBYM0AADDAY4FczQAANAByQQsNwAA0AGhBPY2AADQAV0DoDYAANABNAO/NgAAwwEFBJEzAADTAc0DgTMAANMBswPjMwAAwwHmAwI0AADDAY4FkTMAANMBxgWBMwAA0AFnB5YyAADQAYcHbTIAAMMByQTlNAAA0wHoBBk1AADTAUoF/jQAAMMBOwXHNAAA0AGfAQI0AADQAdUBKjQAANMBswMhNAAAwwHmAwI0AADDAY4FkTMAANMBtAVeMwAA0wFtBRczAADDATsFPTMAAMMByQQfMwAA0wGqBOsyAADTAUkEBjMAAMMBWAQ9MwAAwwGOBXM0AADTAbQFpjQAANABUAecNQAA0AGHB5c1AADDAQUEczQAANMB3gOmNAAA0wEmBO00AADDAVgExzQAAMMBOwU9MwAA0wFKBQYzAADTAegE6zIAAMMByQQfMwAAnAHJBHUzAACcAYMEhzMAAJwBTwS7MwAAnAFPBEk0AACcATwEAjQAAJwBRAW7MwAAnAEQBYczAACcAUQFSTQAAJwBVwUCNAAAnAHJBI80AACcARAFfTQAAJwBgwR9NAAAwwFYBD0zAAC7AVAEVzMAAKQBaQSDMwAAnAGDBIczAADDAawFAjQAAJwBVwUCNAAAnAFEBUk0AADDAY4FczQAAMMByQTlNAAAnAHJBI80AACcAYMEfTQAAMMBWATHNAAAwwHmAwI0AACcATwEAjQAAJwBTwS7MwAAwwEFBJEzAADDAY4FkTMAAJwBRAW7MwAAnAFXBQI0AADDAawFAjQAAMMBOwXHNAAAnAEQBX00AACcAckEjzQAAMMByQTlNAAAwwEFBHM0AACcAU8ESTQAAJwBPAQCNAAAwwHmAwI0AACcARAFhzMAAKQBKQWDMwAAuwFDBVczAADDATsFPTMAAMMBWAQ9MwAAnAGDBIczAACcAckEdTMAAMMByQQfMwAAwwE7Bcc0AAC7AUMFrTQAAKQBKQWBNAAAnAEQBX00AADDAVgExzQAALsBUAStNAAAuwEeBHw0AADDAQUEczQAANMBSQT+NAAAZgJJBP40AABmAqoEGTUAANMBqgQZNQAAwwHJBOU0AADTAaoEGTUAANABoQT2NgAA0AHJBCw3AADDAVgExzQAANMBSQT+NAAA0wGqBBk1AADDAckE5TQAANABNAO/NgAA0AFdA6A2AADTAUkE/jQAAMMBWATHNAAA0wHgBeMzAABmAuAF4zMAAGYCxgWBMwAA0wHGBYEzAADQAckELDcAANAB8gT2NgAA0wHoBBk1AADDAckE5TQAANABXga/NgAA0AE2BqA2AADQAfIE9jYAANAByQQsNwAAwwE7Bcc0AADTAUoF/jQAANABNgagNgAA0AFeBr82AADTAbMDITQAAGYCswMhNAAAZgLNA4M0AADTAc0DgzQAANABXga/NgAA0AFjBok2AADTAW0F7TQAAMMBOwXHNAAAwwE7Bcc0AADTAW0F7TQAANMBtAWmNAAAwwGOBXM0AADQAYcHlzUAANABUAecNQAA0AFjBok2AADQAV4GvzYAANMB4AUhNAAAZgLgBSE0AACQAr4HKjQAANABvgcqNAAAwwGOBXM0AADTAcYFgzQAANMB4AUhNAAAwwGsBQI0AADQAfMHAjQAANABvgcqNAAA0AFnB241AADQAYcHlzUAANABhwdtMgAA0AG+B9ozAADQAWcHljIAANABXgZFMQAA0AFQB2gyAADQAWMGezEAAMMBrAUCNAAA0wHgBSE0AADQAb4HKjQAANAB8wcCNAAA0AGhBPY2AACQAqEE9jYAAJACXQOgNgAA0AFdA6A2AADQAYcHbTIAANABUAdoMgAA0wG0BV4zAADDAY4FkTMAAMMBOwU9MwAA0wFtBRczAADQAWMGezEAANABXgZFMQAA0wHeA14zAABmAt4DXjMAAJACQgJoMgAA0AFCAmgyAADQAfMHAjQAANABvgfaMwAA0wHgBeMzAADDAawFAjQAAMMBrAUCNAAA0wHgBeMzAADTAcYFgTMAAMMBjgWRMwAA0AFnB5YyAACQAmcHljIAAJACvgfaMwAA0AG+B9ozAADQAV4GRTEAANABNgZkMQAA0wFKBQYzAADDATsFPTMAANAByQTYMAAA0AHyBA4xAADQATYGZDEAANABXgZFMQAAwwHJBB8zAADTAegE6zIAANAB8gQOMQAA0AHJBNgwAADQASwCbjUAAJACLAJuNQAAkALVASo0AADQAdUBKjQAANABNANFMQAA0AFdA2QxAADQAaEEDjEAANAByQTYMAAAwwFYBD0zAADTAUkEBjMAANABXQNkMQAA0AE0A0UxAADQAckE2DAAANABoQQOMQAA0wGqBOsyAADDAckEHzMAANABZwduNQAAkAJnB241AABmAsYFgzQAANMBxgWDNAAAwwFYBD0zAADTASYEFzMAANMB3gNeMwAAwwEFBJEzAADQATQDRTEAANABLwN7MQAA0wEmBBczAADDAVgEPTMAANABDAJtMgAA0AFCAmgyAADQAS8DezEAANABNANFMQAA0AEvA3sxAACQAi8DezEAAGYCJgQXMwAA0wEmBBczAADQAQwCbTIAANABLAKWMgAA0wHNA4EzAADDAQUEkTMAANABnwECNAAA0AHVAdozAADQASwCljIAANABDAJtMgAAwwHmAwI0AADTAbMD4zMAANAB1QHaMwAA0AGfAQI0AADTAcYFgzQAAGYCxgWDNAAAZgLgBSE0AADTAeAFITQAAMMB5gMCNAAA0wGzAyE0AADTAc0DgzQAAMMBBQRzNAAA0AEMApc1AADQASwCbjUAANAB1QEqNAAA0AGfAQI0AADDAQUEczQAANMBzQODNAAA0AEsAm41AADQAQwClzUAANMBJgQXMwAAZgImBBczAABmAt4DXjMAANMB3gNeMwAA0AE0A782AADQAS8DiTYAANABQgKcNQAA0AEMApc1AADDAVgExzQAANMBJgTtNAAA0AEvA4k2AADQATQDvzYAANABDAKXNQAA0AFCApw1AADTAd4DpjQAAMMBBQRzNAAA0AHVASo0AACQAtUBKjQAAGYCswMhNAAA0wGzAyE0AADQAb4H2jMAAJACvgfaMwAAZgLgBeMzAADTAeAF4zMAANABXQOgNgAAkAJdA6A2AABmAkkE/jQAANMBSQT+NAAA0AFdA2QxAACQAl0DZDEAAJACoQQOMQAA0AGhBA4xAADTAc0DgzQAAGYCzQODNAAAkAIsAm41AADQASwCbjUAANABUAecNQAAkAJQB5w1AACQAmMGiTYAANABYwaJNgAA0wHGBYEzAABmAsYFgTMAAJACZweWMgAA0AFnB5YyAADTAaoEGTUAAGYCqgQZNQAAkAKhBPY2AADQAaEE9jYAANMBqgTrMgAAZgKqBOsyAABmAkkEBjMAANMBSQQGMwAA0wFtBe00AABmAm0F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vgC/AMAAvgDAAMEAwgDDAMQAwgDEAMUAxgDHAMgAxgDIAMkAygDLAMwAygDMAM0AzgDPANAAzgDQANEA0gDTANQA0gDUANUA1gDXANgA1gDYANkA2gDbANwA3QDeAN8A3QDfAOAA4QDiAOMA4QDjAOQA4QDkAOUA4QDlAOYA5gDlAOcA5gDnAOgA6QDqAOsA6QDrAOwA7QDuAO8A7QDvAPAA8QDyAPMA8QDzAPQA9QD2APcA9QD3APgA+QD6APsA+QD7APwA/QD+AP8A/QD/AAABAQECAQMBAQEDAQQBBQEGAQcBBQEHAQgBCQEKAQsBCQELAQwBDQEOAQ8BDQEPARABEQESARMBEQETARQBFQEWARcBFQEXARgBGQEaARsBGQEbARwBHQEeAR8BHQEfASABIQEiASMBIQEjASQBJQEmAScBJQEnASgBKQEqASsBKQErASwBLQEuAS8BLQEvATABMQEyATMBMQEzATQBNQE2ATcBNQE3ATgBOQE6ATsBOQE7ATwBPQE+AT8BPQE/AUABQQFCAUMBQQFDAUQBRQFGAUcBRQFHAUgBSQFKAUsBSQFLAUwBTQFOAU8BTQFPAVABUQFSAVMBUQFTAVQBVQFWAVcBVQFXAVgBWQFaAVsBWQFbAVwBXQFeAV8BXQFfAWABYQFiAWMBYQFjAWQBZQFmAWcBZQFnAWgBaQFqAWsBaQFrAWwBbQFuAW8BbQFvAXABcQFyAXMBcQFzAXQBdQF2AXcBdQF3AXgBeQF6AXsBeQF7AXwBfQF+AX8BfQF/AYABgQGCAYMBgQGDAYQBhQGGAYcBhQGHAYgBiQGKAYsBjAGNAY4BjAGOAY8BkAGRAZIBkAGSAZMBlAGVAZYBlAGWAZcBmAGZAZoBmwGcAZ0BngGfAaABngGgAaEBogGjAaQBogGkAaUBpgGnAagBpgGoAakBqgGrAawBqgGsAa0BrgGvAbABrgGwAbEBsgGzAbQBsgG0AbUBtgG3AbgBtgG4AbkBugG7AbwBugG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBxwHJAcoBywHMAc0BzgHPAdABzgHQAdEB0gHTAdQB0gHUAdUB1gHXAdgB1gHYAdkB2gHbAdwB2gHcAd0B3gHfAeAB3gHgAeEB4gHjAeQB4gHkAeUB5gHnAegB5gHoAekB6gHrAewB6gHsAe0B7gHvAfAB7gHwAfEB8gHzAfQB8gH0AfUB9gH3AfgB9gH4AfkB+gH7AfwB+gH8Af0B/gH/AQAC/gEAAgECAgIDAgQCAgIEAgUCBgIHAggCBgIIAgkCCgILAgwCCgIMAg0CDgIPAhACDgIQAhECEgITAhQCEgIUAhUCFgIXAhgCFgIYAhkCGgIbAhwCGgIcAh0CHgIfAiACIQIiAiMCJAIlAiYCJwIoAikCJwIpAioCKwIsAi0CKwItAi4CLwIwAjECLwIxAjICMwI0AjUCMwI1AjYCNwI4AjkCNwI5AjoCOwI8Aj0COwI9Aj4CPwJAAkECPwJBAkICQwJEAkUCQwJFAkYCRwJIAkkCRwJJAkoCSwJMAk0CSwJNAk4CTwJQAlECTwJRAlICUwJUAlUCUwJVAlYCVwJYAlkCVwJZAloCWwJcAl0CWwJdAl4CXwJgAmECXwJhAmICYwJkAmUCYwJlAmYCZwJoAmkCZwJpAmoCawJsAm0CawJtAm4CbwJwAnECbwJxAnICcwJ0AnUCcwJ1AnYCdwJ4AnkCdwJ5AnoCewJ8An0CewJ9An4CfwKAAoECfwKBAoICgwKEAoUCgwKFAoYChwKIAokChwKJAooCiwKMAo0CiwKNAo4CjwKQApECjwKRApICkwKUApUCkwKVApYClwKYApkClwKZApoCmwKcAp0CmwKdAp4CnwKgAqECnwKhAqICowKkAqUCowKlAqYCpwKoAqkCpwKpAqoCqwKoAqcCqwKsAqgCrQKuAq8CrQKvArACsQKyArMCsQKzArQCtQK2ArcCtwK4ArUCtwK5ArgCugK7ArwCugK8Ar0CvgK/AsACvgLAAsECwgLDAsQCxALFAsICxALGAsUCxwLIAskCxwLJAsoCywLMAs0CywLNAs4CzwLQAtECzwLRAtIC0wLUAtUC0wLVAtYC1wLYAtkC1wLZAtoC2wLcAt0C2wLdAt4C3wLgAuEC3wLhAuIC4wLkAuUC4wLlAuYC5wLoAukC5wLpAuoC6wLsAu0C6wLtAu4C7wLwAvEC8gLzAvQC8gL0AvUC9gL3AvgC9gL4AvkC+gL7AvwC+gL8Av0C/gL/AgAD/gIAAwEDAgMDAwQDAgMEAwUDBgMHAwgDBgMIAwkDCgMLAwwDDQMOAw8DDQMPAxADEQMSAxMDEQMTAxQDFQMWAxcDFQMXAxgDGQMaAxsDGQMbAxwDHQMeAx8DHQMfAyADIQMiAyMDIQMjAyQDJQMmAycDJQMnAygDKQMqAysDKQMrAywDLQMuAy8DLQMvAzADMQMyAzMDMQMzAzQDNQM2AzcDNQM3AzgDOQM6AzsDOQM7AzwDPQM+Az8DPQM/A0ADQQNCA0MDQQNDA0QDRQNGA0cDSANJA0oDSANKA0sDTANNA04DTwNQA1EDTwNRA1IDUwNUA1UDVgNXA1gDWQNaA1sDWQNbA1wDXQNeA18DXQNfA2ADYQNiA2MDYQNjA2QDZQNmA2cDZQNnA2gDaQNqA2sDaQNrA2wDbQNuA28DbQNvA3ADcQNyA3MDcQNzA3QDdQN2A3cDdQN3A3gDeQN6A3sDeQN7A3wDfQN+A38DfQN/A4ADgQOCA4MDgQODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADjgOQA5EDkgOTA5QDkgOUA5UDlgOXA5gDmQOaA5sDmQObA5wDnQOeA58DnQOfA6ADoQOiA6MDoQOjA6QDpQOmA6cDpQOnA6gDqQOqA6sDqQOrA6wDrQOuA68DrQOvA7ADsQOyA7MDsQOzA7QDtQO2A7cDtQO3A7gDuQO6A7sDuQO7A7wDvQO+A78DvQO/A8ADwQPCA8MDwQPDA8QDxQPGA8cDxQPHA8gDyQPKA8sDyQPLA8wDzQPOA88DzQPPA9AD0QPSA9MD0QPTA9QD1QPWA9cD1QPXA9gD2QPaA9sD2QPbA9wD3QPeA98D3QPfA+AD4QPiA+MD4wPkA+ED4wPlA+QD5gPnA+gD5gPoA+kD6gPrA+wD6gPsA+0D7gPvA/AD7gPwA/ED8gPzA/QD8gP0A/UD9gP3A/gD9gP4A/kD+gP7A/wD+gP8A/0D/gP/AwAE/gMABAEEAgQDBAQEAgQEBAUEBgQHBAgEBgQIBAkECgQLBAwECgQMBA0EDgQPBBAEDgQQBBEEEgQTBBQEEgQUBBUEFgQXBBgEFgQYBBkEGgQbBBwEGgQcBB0EHgQfBCAEHgQgBCEEIgQjBCQEIgQkBCUEJgQnBCgEJgQoBCkEKgQrBCwEKgQsBC0ELgQvBDAELgQwBDEEMgQzBDQEMgQ0BDUENgQ3BDgENgQ4BDkEOgQ7BDwEOgQ8BD0EPgQ/BEAEPgRABEEEQgRDBEQERQRGBEcERQRHBEgESQRKBEsESQRLBEwETQROBE8EUARRBFIEUARSBFMEVARVBFYEVARWBFcEWARZBFoEWARaBFsEXARdBF4EXAReBF8EYARhBGIEYARiBGMEZARlBGYEZARmBGcEaARpBGoEaARqBGsEbARtBG4EbARuBG8EcARxBHIEcARyBHMEdAR1BHYEdwR4BHkEdwR5BHoEewR8BH0EewR9BH4EfwSABIEEfwSBBIIEgwSEBIUEgwSFBIYEhwSIBIkEhwSJBIoEiwSMBI0EiwSNBI4EjwSQBJEEjwSRBJIEkwSUBJUEkwSVBJYElwSYBJkElwSZBJoEmwScBJ0EmwSdBJ4EnwSgBKEEnwShBKIEowSkBKUEowSlBKYEpwSoBKkEqgSrBKwEqgSsBK0ErgSvBLAErgSwBLEEsgSzBLQEsgS0BLUEtgS3BLgEtgS4BLkEugS7BLwEugS8BL0EvgS/BMAEvgTABMEEwgTDBMQEwgTEBMUExgTHBMgExgTIBMkEygTLBMwEygTMBM0EzgTPBNAEzgTQBNEE0gTTBNQE0gTUBNUE1gTXBNgE1gTYBNkE2gTbBNwE2gTcBN0E3gTfBOAE3gTgBOEE4gTjBOQE4gTkBOUE5gTnBOgE5gToBOkE6gTrBOwE6gTsBO0E7gTvBPAE7gTwBPEE8gTzBPQE8gT0BPUE9gT3BPgE9gT4BPkE+gT7BPwE+gT8BP0E/gT/BAAF/gQABQEFAgUDBQQFAgUEBQUFBgUHBQgFBgUIBQkFCgULBQwFCgUMBQ0FDgUPBRAFDgUQBREFEgUTBRQFEgUUBRUFFgUXBRgFFgUYBRkFGgUbBRwFGgUcBR0FHgUfBSAFHgUgBSEFIgUjBSQFIgUkBSUFJgUnBSgFJgUoBSkFKgUrBSwFKgUsBS0FLgUvBTAFLgUwBTEFMgUzBTQFMgU0BTUFNgU3BTgFNgU4BTkFOgU7BTwFOgU8BT0FPgU/BUAFPgVABUEFQgVDBUQFQgVEBUUFRgVHBUgFRgVIBUkFSgVLBUwFTQVOBU8FTQVPBVAFUQVSBVMFUQVTBVQFVQVWBVcFVQVXBVgFWQVaBVsFXAVdBV4FXwVgBWEFXwVhBWIFYwVkBWUFYwVlBWYFZwVoBWkFZwVpBWoFawVsBW0FawVtBW4FbwVwBXEFbwVxBXIFcwV0BXUFcwV1BXYFdwV4BXkFdwV5BXoFewV8BX0FewV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiAWKBYsFjAWNBY4FjwWQBZEFjwWRBZIFkwWUBZUFkwWVBZYFlwWYBZkFlwWZBZoFmwWcBZ0FmwWdBZ4FnwWgBaEFnwWhBaIFowWkBaUFowWlBaYFpwWoBakFpwWpBaoFqwWsBa0FqwWtBa4FrwWwBbEFrwWxBbIFswW0BbUFswW1BbYFtwW4BbkFtwW5BboFuwW8Bb0FuwW9Bb4FvwXABcEFvwXBBcIFwwXEBcUFwwXFBcYFxwXIBckFxwXJBcoFywXMBc0FywXNBc4FzwXQBdEFzwXRBdIF0wXUBdUF0wXVBdYF1wXYBdkF1wXZBdoF2wXcBd0F2wXdBd4F3wXgBeEF4gXjBeQF5QXmBecF6AXpBeoF6AXqBesF7AXtBe4F7AXuBe8F8AXxBfIF8AXyBfMF9AX1BfYF9AX2BfcF+AX5BfoF+AX6BfsF/AX9Bf4F/AX+Bf8FAAYBBgIGAAYCBgMGBAYFBgYGBAYGBgcGCAYJBgoGCAYKBgsGDAYNBg4GDAYOBg8GEAYRBhIGEAYSBhMGFAYVBhYGFAYWBhcGGAYZBhoGGAYaBhsGHAYdBh4GHAYeBh8GIAYhBiIGIAYiBiMGJAYlBiYGJAYmBicGKAYpBioGKAYqBisGLAYtBi4GLAYuBi8GMAYxBjIGMAYyBjMGNAY1BjYGNAY2BjcGOAY5BjoGOAY6BjsGPAY9Bj4GPAY+Bj8GQAZBBkIGQAZCBkMGRAZFBkYGRAZGBkcGSAZJBkoGSAZKBksGTAZNBk4GTAZOBk8GUAZRBlIGUAZSBlMGVAZVBlYGVAZWBlcGWAZZBloGWAZaBlsGXAZdBl4GXAZeBl8GYAZhBmIGYAZiBmMGZAZlBmYGZAZmBmcGaAZpBmoGaAZqBmsGbAZoBmsGbAZrBm0GbgZvBnAGbgZwBnEGcgZzBnQGcgZ0BnUGdgZ3BngGeAZ5BnYGeAZ6BnkGewZ8Bn0GewZ9Bn4GfwaABoEGfwaBBoIGgwaEBoUGhQaGBoMGhQaHBoYGiAaJBooGiAaKBosGjAaNBo4GjAaOBo8GkAaRBpIGkAaSBpMGlAaVBpYGlAaWBpcGmAaZBpoGmAaaBpsGnAadBp4GnAaeBp8GoAahBqIGoAaiBqMGpAalBqYGpAamBqcGqAapBqoGqAaqBqsGrAatBq4GrAauBq8GsAaxBrIGswa0BrUGswa1BrYGtwa4BrkGtwa5BroGuwa8Br0Guwa9Br4GvwbABsEGvwbBBsIGwwbEBsUGwwbFBsYGxwbIBskGxwbJBsoGywbMBs0GzgbPBtAGzgbQBtEG0gbTBtQG0gbUBtUG1gbXBtgG1gbYBtkG2gbbBtwG2gbcBt0G3gbfBuAG3gbgBuEG4gbjBuQG4gbkBuUG5gbnBugG5gboBukG6gbrBuwG6gbsBu0G7gbvBvAG7gbwBvEG8gbzBvQG8gb0BvUG9gb3BvgG9gb4BvkG+gb7BvwG+gb8Bv0G/gb/BgAH/gYABwEHAgcDBwQHAgcEBwUHBgcHBwgHCQcKBwsHCQcLBwwHDQcOBw8HEAcRBxIHEAcSBxMHFAcVBxYHFwcYBxkHGgcbBxwHGgccBx0HHgcfByAHHgcgByEHIgcjByQHIgckByUHJgcnBygHJgcoBykHKgcrBywHKgcsBy0HLgcvBzAHLgcwBzEHMgczBzQHMgc0BzUHNgc3BzgHNgc4BzkHOgc7BzwHOgc8Bz0HPgc/B0AHPgdAB0EHQgdDB0QHQgdEB0UHRgdHB0gHSQdKB0sHTAdNB04HTwdQB1EHTwdRB1IHUwdUB1UHUwdVB1YHVwdYB1kHWgdbB1wHWgdcB10HXgdfB2AHXgdgB2EHYgdjB2QHYgdkB2UHZgdnB2gHZgdoB2kHagdrB2wHagdsB20HbgdvB3AHbgdwB3EHcgdzB3QHcgd0B3UHdgd3B3gHdgd4B3kHegd7B3wHegd8B30Hfgd/B4AHfgeAB4EHggeDB4QHggeEB4UHhgeHB4gHhgeIB4kHigeLB4wHigeMB40HAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHwAgACEAHwAhACIAIwAkACUAJgAnACgAKQAqACsAKQArACwALQAuAC8ALQAvADAAMQAyADMAMQAzADQANQA2ADcANQA3ADgAOQA6ADsAOQA7ADwAPQA+AD8APQA/AEAAQQBCAEMAQQBDAEQARQBGAEcARQBHAEgASQBKAEsASQBLAEwATQBOAE8ATQBPAFAAUQBSAFMAUQBTAFQAVQBWAFcAVQBXAFgAWQBaAFsAWQBbAFwAXQBeAF8AYABhAGIAYABiAGMAZABlAGYAZwBoAGkAagBrAGwAagBsAG0AbgBvAHAAbgBwAHEAcgBzAHQAcgB0AHUAdgB3AHgAdgB4AHkAegB7AHwAegB8AH0AfgB/AIAAfgCAAIEAAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAFAAXABgAFAAYABkAGgAbABwAGgAcAB0AHgAfACAAHgAgACEAIgAjACQAIgAkACUAJgAnACgAJgAoACkAKgArACwAKgAsAC0ALgAvADAALgAwADEAMgAzADQAMgA0ADUANgA3ADgANgA4ADkAOgA7ADwAOgA8AD0APgA/AEAAPgBAAEEAQgBDAEQAQgBEAEUARgBHAEgARgBIAEkASgBLAEwASgBMAE0ATgBPAFAATgBQAFEAUgBTAFQAUgBUAFUAVgBXAFgAVgBYAFkAWgBbAFwAWgBcAF0AXgBfAGAAXgBgAGEAYgBjAGQAYgBkAGUAZgBnAGgAZgBoAGkAagBrAGwAagBsAG0AbABuAG0AbwBwAGoAcQBvAGoAbQBxAGoAcQByAG8AbQBzAHEAcwB0AHEAbQB1AHMAdgB3AHgAdgB4AHkAdwB6AHgAdwB7AHoAewB8AHoAewB9AHwAfQB+AHwAfQB/AH4AfwCAAH4AfwCBAIAAgQCCAIAAgQCDAIIAhACFAIYAhACGAIcAiACJAIoAiACKAIsAjACNAI4AjACOAI8AkACRAJIAkACSAJMAlACVAJYAlACWAJcAmACZAJoAmACaAJsAnACdAJ4AnACeAJ8AoAChAKIAoACiAKMApAClAKYApACmAKcAqACpAKoAqACqAKsArACtAK4ArACuAK8AsACxALIAsACyALMAtAC1ALYAtQC3ALYAtAC2ALgAuQC0ALgAuQC4ALoAtQC7ALcAuwC8ALcAuwC9ALwAvgC/AMAAvgDAAMEAwgDDAMQAwgDEAMUAxgDHAMgAxgDIAMkAygDLAMwAygDMAM0AzgDPANAAzgDQANEA0gDTANQA0gDUANUA1gDXANgA1gDYANkA2gDbANwA2gDcAN0A3gDfAOAA3gDgAOEA4gDjAOQA4gDkAOUA5gDnAOgA5gDoAOkA6gDrAOwA6gDsAO0A7gDvAPAA7gDwAPEA8gDzAPQA8gD0APUA9gD3APgA9gD4APkA+gD7APwA+gD8AP0A/gD/AAAB/gAAAQEBAgEDAQQBAgEEAQUBBgEHAQgBBgEIAQkBCgELAQwBCgEMAQ0BDgEPARABDgEQAREBEgETARQBEgEUARUBFgEXARgBFgEYARkBGgEbARwBGgEcAR0BHgEfASABHgEgASEBIgEjASQBIgEkASUBJgEnASgBJgEoASkBKgErASwBKgEsAS0BLgEvATABLgEwATEBMgEzATQBMgE0ATUBNgE3ATgBNgE4ATkBOgE7ATwBOgE8AT0BPgE/AUABPgFAAUEBQgFDAUQBQgFEAUUBRgFHAUgBRgFIAUkBSgFLAUwBSgFMAU0BTgFPAVABTgFQAVEBUgFTAVQBUgFUAVUBVgFXAVgBVgFYAVkBWgFbAVwBWgFcAV0BXgFfAWABXgFgAWEBYgFjAWQBYgFkAWUBZgFnAWgBZgFoAWkBaAFqAWkBawFsAWYBbQFrAWYBaQFtAWYBbQFuAWsBaQFvAW0BbwFwAW0BaQFxAW8BcgFzAXQBcgF0AXUBdgF3AXgBdgF4AXkBegF7AXwBegF8AX0BfgF/AYABfgGAAYEBggGDAYQBggGEAYUBhgGHAYgBhgGIAYkBigGLAYwBigGMAY0BjgGPAZABjgGQAZEBkgGTAZQBkgGUAZUBlgGXAZgBlgGYAZkBmgGbAZwBmgGcAZ0BngGfAaABngGgAaEBogGjAaQBogGkAaUBpgGnAagBpgGoAakBqgGnAaYBqgGrAacBrAGrAaoBrAGtAasBrgGvAbABsQGvAa4BsQGyAa8BrgGwAbMBswGwAbQBswG0AbUBtgG3AbgBtgG4AbkBugG7AbwBugG8Ab0BvgG/AcABvgHAAcEBwgHDAcQBwgHEAcUBxgHHAcgBxgHIAckBygHLAcwBygHMAc0BzgHPAdABzgHQAdEB0gHTAdQB0gHUAdUB1gHXAdgB1gHYAdkB2gHbAdwB2gHcAd0B3gHfAeAB3gHgAeEB4gHjAeQB4gHkAeUB5gHnAegB5gHoAekB6gHrAewB6gHsAe0B7gHvAfAB7gHwAfEB8gHzAfQB8gH0AfUB9gH3AfgB9gH4AfkB+gH7AfwB+gH8Af0B/gH/AQAC/gEAAgECAgIDAgQCAgIEAgUCBgIHAggCBgIIAgkCCgILAgwCCgIMAg0CDgIPAhACDgIQAhECEgITAhQCEgIUAhUCFgIXAhgCFgIYAhkCGgIbAhwCGgIcAh0CHgIfAiACHgIgAiECIgIjAiQCIgIkAiUCJgInAigCJgIoAikCKgIrAiwCKgIsAi0CLgIvAjACLgIwAjECMgIzAjQCMgI0AjUCNgI3AjgCNgI4AjkCOgI7AjwCOgI8Aj0CPgI/AkACPgJAAkECQgJDAkQCQgJEAkUCRgJHAkgCRgJIAkkCSgJLAkwCSgJMAk0CTgJPAlACTgJQAlECUgJTAlQCUgJUAlUCVgJXAlgCVgJYAlkCWgJbAlwCWgJcAl0CXgJfAmACXgJgAmECYgJjAmQCYgJkAmUCZgJnAmgCZgJoAmkCagJrAmwCagJsAm0CbAJuAm0CbwJwAmoCcQJvAmoCbQJxAmoCcQJyAm8CbQJzAnECcwJ0AnECbQJ1AnMCdgJ3AngCdgJ4AnkCegJ7AnwCegJ8An0CfgJ/AoACfgKAAoECggKDAoQCggKEAoUChgKHAogChgKIAokCigKLAowCigKMAo0CjgKPApACjgKQApECkgKTApQCkgKUApUClgKXApgClgKYApkCmgKbApwCmgKcAp0CngKfAqACngKgAqECogKjAqQCogKkAqUCpgKnAqgCpgKoAqkCqgKrAqwCqwKtAqwCqgKsAq4CrwKqAq4CrwKuArACqwKxAq0CsQKyAq0CsQKzArICtAK1ArYCtAK2ArcCuAK0ArcCuAK3ArkCugK7ArwCugK8Ar0CvgK6Ar0CvgK9Ar8CwALBAsICwALCAsMCxALFAsYCxALGAscCyALJAsoCyALKAssCzALNAs4CzALOAs8C0ALRAtIC0ALSAtMC1ALVAtYC1ALWAtcC2ALZAtoC2ALaAtsC3ALdAt4C3ALeAt8C4ALhAuIC4ALiAuMC5ALlAuYC5ALmAucC6ALpAuoC6ALqAusC7ALtAu4C7ALuAu8C8ALxAvIC8ALyAvMC9AL1AvYC9AL2AvcC+AL5AvoC+AL6AvsC/AL9Av4C/AL+Av8CAAMBAwIDAAMCAwMDBAMFAwYDBAMGAwcDCAMJAwoDCAMKAwsDDAMNAw4DDAMOAw8DEAMRAxIDEAMSAxMDFAMVAxYDFAMWAxcDGAMZAxoDGAMaAxsDHAMdAx4DHAMeAx8DIAMhAyIDIAMiAyMDJAMlAyYDJAMmAycDKAMpAyoDKAMqAysDLAMtAy4DLAMuAy8DMAMxAzIDMAMyAzMDNAM1AzYDNAM2AzcDOAM5AzoDOAM6AzsDPAM9Az4DPAM+Az8DQANBA0IDQANCA0MDRANFA0YDRANGA0cDSANJA0oDSANKA0sDTANNA04DTANOA08DUANRA1IDUANSA1MDVANVA1YDVANWA1cDWANZA1oDWANaA1sDXANdA14DXANeA18DYANhA2IDYANiA2MDZANlA2YDZANmA2cDaANpA2oDaANqA2sDbANtA24DbANuA28DbgNwA28DcQNyA2wDcwNxA2wDbwNzA2wDcwN0A3EDbwN1A3MDdQN2A3MDbwN3A3UDeAN5A3oDeAN6A3sDfAN9A34DfAN+A38DgAOBA4IDgAOCA4MDhAOFA4YDhAOGA4cDiAOJA4oDiAOKA4sDjAONA44DjAOOA48DkAORA5IDkAOSA5MDlAOVA5YDlAOWA5cDmAOZA5oDmAOaA5sDnAOdA54DnAOeA58DoAOhA6IDoAOiA6MDpAOlA6YDpAOmA6cDqAOpA6oDqAOqA6sDrAOtA64DrAOuA68DsAOxA7IDswOxA7ADswO0A7EDsAOyA7UDtQOyA7YDtQO2A7cDuAO5A7oDuAO6A7sDvAO9A74DvAO+A78DwAPBA8IDwAPCA8MDxAPFA8YDxAPGA8cDyAPJA8oDyAPKA8sDzAPNA84DzAPOA88D0APRA9ID0APSA9MD1APVA9YD1APWA9cD2APZA9oD2APaA9sD3APdA94D3APeA98D4APhA+ID4APiA+MD5APlA+YD5APmA+cD6APpA+oD6APqA+sD7APtA+4D7APuA+8D8APxA/ID8APyA/MD9AP1A/YD9AP2A/cD+AP5A/oD+AP6A/sD/AP9A/4D/AP+A/8DAAQBBAIEAAQCBAMEBAQFBAYEBAQGBAcECAQJBAoECAQKBAsEDAQNBA4EDAQOBA8EEAQRBBIEEAQSBBMEFAQVBBYEFAQWBBcEGAQZBBoEGAQaBBsEHAQdBB4EHAQeBB8EIAQhBCIEIAQiBCMEJAQlBCYEJAQmBCcEKAQpBCoEKAQqBCsELAQtBC4ELAQuBC8EMAQxBDIEMAQyBDMENAQ1BDYENAQ2BDcEOAQ5BDoEOAQ6BDsEPAQ9BD4EPAQ+BD8EAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHAAeAB8AHQAgACEAHQAiACAAIwAcACQAIwAkACUAJgAjACcAJgAnACgAKQAmACoAKQAqACsALAApAC0ALAAtAC4ALwAsADAALwAwADEAMgAvADMAMgAzADQANQA2ADcANQA3ADgAOQA6ADsAOQA7ADwAPQA+AD8APQA/AEAAQQBCAEMAQQBDAEQARQBGAEcARQBHAEgASQBKAEsASQBLAEwATQBOAE8ATQBPAFAAUQBSAFMAUQBTAFQAVQBWAFcAVQBXAFgAWQBaAFsAWQBbAFwAWwBdAFwAXgBfAFkAYABeAFkAXABgAFkAYABhAF4AXABiAGAAYgBjAGAAXABkAGIAZQBmAGcAZQBnAGgAaQBqAGsAaQBrAGwAbQBuAG8AbQBvAHAAcQByAHMAcQBzAHQAdQB2AHcAdQB3AHgAeQB6AHsAeQB7AHwAfQB+AH8AfQB/AIAAgQCCAIMAgQCDAIQAhQCGAIcAhQCHAIgAiQCKAIsAiQCLAIwAjQCOAI8AjQCPAJAAkQCSAJMAkQCTAJQAlQCWAJcAlQCXAJgAmQCaAJsAmQCbAJwAnQCeAJ8AnQCfAKAAoQCiAKMAoQCjAKQApQCmAKcApQCnAKgAqQCqAKsAqQCrAKwArQCuAK8ArQCvALAAsQCyALMAsQCzALQAtQC2ALcAtQC3ALgAuQC6ALsAuQC7ALwAvQC+AL8AvQC/AMAAwQDCAMMAwQDDAMQAxQDGAMcAxQDHAMgAyQDKAMsAyQDLAMwAzQDOAM8AzQDPANAA0QDSANMA0QDTANQA1QDWANcA1QDXANgA2QDaANsA2QDbANwA3QDeAN8A3QDfAOAA4QDiAOMA4QDjAOQA5QDmAOcA5QDnAOgA6QDqAOsA6QDrAOwA7QDuAO8A7QDvAPAA8QDyAPMA8QDzAPQA9QD2APcA9QD3APgA+QD6APsA+QD7APwA/QD+AP8A/QD/AAABAQECAQMBAQEDAQQBBQEGAQcBBQEHAQgBCQEFAQoBCQEKAQsBDAENAQ4BDAEOAQ8BEAERARIBEAESARMBFAEVARYBFAEWARcBGAEZARoBGAEaARsBHAEdAR4BHAEeAR8BIAEhASIBIAEiASMBJAElASYBJAEmAScBKAEpASoBKAEqASsBLAEtAS4BLAEuAS8BMAExATIBMAEyATMBNAE1ATYBNAE2ATcBOAE5AToBOAE6ATsBPAE9AT4BPAE+AT8BQAFBAUIBQAFCAUMBRAFFAUYBRAFGAUcBSAFJAUoBSAFKAUsBTAFNAU4BTAFOAU8BUAFRAVIBUAFSAVMBVAFVAVYBVAFWAVcBWAFZAVoBWAFaAVsBXAFdAV4BXAFeAV8BYAFhAWIBYAFiAWMBZAFlAWYBZAFmAWcBaAFpAWoBaAFqAWsBbAFtAW4BbAFuAW8BcAFxAXIBcAFyAXMBdAF1AXYBdAF2AXcBeAF5AXoBeAF6AXsBfAF9AX4BfAF+AX8BgAGBAYIBgAGCAYMBhAGFAYYBhAGGAYcBiAGJAYoBiAGKAYsBjAGNAY4BjAGOAY8BkAGRAZIBkAGSAZMBlAGVAZYBlAGWAZcBmAGZAZoBmAGaAZsBnAGdAZ4BnAGeAZ8BoAGhAaIBoAGiAaMBpAGlAaYBpAGmAacBqAGpAaoBqAGqAasBrAGtAa4BrAGuAa8BsAGxAbIBsAGyAbMBtAG1AbYBtAG2AbcBuAG5AboBuAG6AbsBvAG9Ab4BvAG+Ab8BwAHBAcIBwAHCAcMBxAHFAcYBxAHGAccByAHJAcoByAHKAcsBzAHNAc4BzAHOAc8B0AHRAdIB0AHSAdMB1AHVAdYB1AHWAdcB2AHZAdoB2AHaAdsB3AHdAd4B3AHeAd8B4AHhAeIB4AHiAeMB5AHlAeYB5AHmAecB6AHpAeoB6AHqAesB7AHtAe4B7AHuAe8B8AHxAfIB8AHyAfMB9AH1AfYB9AH2AfcB+AH5AfoB+AH6AfsB/AH9Af4B/AH+Af8BAAIBAgICAAICAgMCBAIFAgYCBAIGAgcCCAIJAgoCCAIKAgsCDAINAg4CDAIOAg8CEAIRAhICEAISAhMCFAIVAhYCFAIWAhcCGAIZAhoCGAIaAhsCHAIdAh4CHAIeAh8CIAIhAiICIAIiAiMCJAIlAiYCJAImAicCKAIpAioCKAIqAisCLAItAi4CLAIuAi8CMAIxAjICMAIyAjMCNAI1AjYCNAI2AjcCOAI5AjoCOAI6AjsCPAI9Aj4CPAI+Aj8CQAJBAkICQAJCAkMCQwJEAkUCQwJGAkQCRwJIAkACRwJJAkgCSgJLAkwCSgJMAk0CTgJPAlACTgJQAlECUgJTAlQCUgJUAlUCVgJXAlgCVgJYAlkCWgJbAlwCWgJcAl0CXgJfAmACXgJgAmECYgJjAmQCYgJkAmUCZgJnAmgCZgJoAmkCagJrAmwCagJsAm0CbgJvAnACbgJwAnECcAJyAnECcwJ0Am4CdQJzAm4CcQJ1Am4CdQJ2AnMCcQJ3AnUCdwJ4AnUCcQJ5AncCegJ7AnwCegJ8An0CfgJ/AoACfgKAAoECggKDAoQCggKEAoUChgKHAogChgKIAokCigKLAowCigKMAo0CjgKPApACjgKQApECkgKTApQCkgKUApUClgKXApgClgKYApkCmgKbApwCmgKcAp0CngKfAqACngKgAqECogKjAqQCogKkAqUCpgKnAqgCpgKoAqkCqgKrAqwCqgKsAq0CrgKvArACrgKwArECsgKzArQCsgK0ArUCtgK3ArgCtgK4ArkCugK7ArwCugK8Ar0CvgK/AsACvgLAAsECwgLDAsQCwgLEAsUCxgLHAsgCxgLIAskCygLLAswCygLMAs0CzgLPAtACzgLQAtEC0gLTAtQC0gLUAtUC1gLXAtgC1gLYAtkC2gLbAtwC2gLcAt0C3gLfAtoC3gLgAt8C4QLiAt4C4QLjAuIC5ALlAuYC5ALmAucC6ALpAuoC6ALqAusC7ALtAu4C7ALuAu8C8ALxAvIC8ALyAvMC9AL1AvYC9AL2AvcC+AL5AvoC+AL6AvsC/AL9Av4C/AL+Av8CAAMBAwIDAAMCAwMDBAMFAwYDBAMGAwcDCAMJAwoDCAMKAwsDDAMNAw4DDAMOAw8DEAMRAxIDEAMSAxMDFAMVAxYDFAMWAxcDGAMZAxoDGAMaAxsDHAMdAx4DHAMeAx8DIAMhAyIDIAMiAyMDJAMlAyYDJAMmAycDKAMpAyoDKAMqAysDLAMtAy4DLAMuAy8DMAMxAzIDMAMyAzMDNAM1AzYDNAM2AzcDOAM5AzoDOAM6AzsDPAM9Az4DPAM+Az8DQANBA0IDQANCA0MDRANFA0YDRANGA0cDSANJA0oDSANKA0sDTANNA04DTANOA08DUANRA1IDUANSA1MDVANVA1YDVANWA1cDWANZA1oDWANaA1sDXANdA14DXANeA18DYANhA2IDYANiA2MDZANlA2YDZANmA2cDaANpA2oDaANqA2sDbANtA24DbANuA28DcANxA3IDcANyA3MDdAN1A3YDdAN2A3cDeAN5A3oDeAN6A3sDfAN9A34DfAN+A38DgAOBA4IDgAOCA4MDhAOFA4YDhAOGA4cDiAOJA4oDiAOKA4sDjAONA44DjAOOA48DkAORA5IDkAOSA5MDlAOVA5YDlAOWA5cDmAOZA5oDmAOaA5sDnAOdA54DnAOeA58DoAOhA6IDoAOiA6MDpAOlA6YDpAOmA6cDqAOpA6oDqAOqA6sDrAOtA64DrAOuA68DsAOxA7IDsAOyA7MDtAO1A7YDtAO2A7cDuAO5A7oDuAO6A7sDvAO9A74DvAO+A78DwAPBA8IDwAPCA8MDxAPFA8YDxAPGA8cDyAPJA8oDyAPKA8sDzAPNA84DzAPOA88D0APRA9ID0APSA9MD1APVA9YD1APWA9cD2APZA9oD2APaA9sD3APdA94D3APeA98D4APhA+ID4APiA+MD5APlA+YD5APmA+cD6APpA+oD6APqA+sD7APtA+4D7APuA+8D8APxA/ID8APyA/MD9AP1A/YD9AP2A/cD+AP5A/oD+AP6A/sD/AP9A/4D/AP+A/8DAAQBBAIEAAQCBAMEBAQFBAYEBAQGBAcECAQJBAoECAQKBAsEDAQNBA4EDAQOBA8EEAQRBBIEEAQSBBMEFAQVBBYEFAQWBBcEGAQZBBoEGAQaBBsEHAQdBB4EHAQeBB8EIAQhBCIEIAQiBCMEJAQlBCYEJAQmBCcEKAQpBCoEKAQqBCsELAQtBC4ELAQuBC8EMAQxBDIEMAQyBDMENAQ1BDYENAQ2BDcEOAQ5BDoEOAQ6BDsEPAQ9BD4EPAQ+BD8EQARBBEIEQARCBEMERARFBEYERARGBEcESARJBEoESARKBEsETARNBE4ETAROBE8EUARRBFIEUARSBFMEVARVBFYEVARWBFcEWARZBFoEWARaBFsEXARdBF4EXAReBF8EYARhBGIEYARiBGMEZARlBGYEZARmBGcEaARpBGoEaARqBGsEbARoBG0EbARtBG4EbwRsBHAEbwRwBHEEcgRvBHMEcgRzBHQEdQRyBHYEdQR2BHcEeAR1BHkEeAR5BHoEewR4BHwEewR8BH0EfgR7BH8EfgR/BIAEgQSCBIMEgQSDBIQEhQSGBIcEhQSHBIgEiQSKBIsEiQSLBIwEjQSOBI8EjQSPBJAEkQSSBJMEkQSTBJQElQSWBJcElQSXBJgEmQSaBJsEmQSbBJwEnQSeBJ8EnQSfBKAEoQSiBKMEoQSjBKQEpQSmBKcEpQSnBKgEpwSpBKgEqgSrBKUErASqBKUEqASsBKUErAStBKoEqASuBKwErgSvBKwEqASwBK4EsQSyBLMEsQSzBLQEtQS2BLcEtQS3BLgEuQS6BLsEuQS7BLwEvQS+BL8EvQS/BMAEwQTCBMMEwQTDBMQExQTGBMcExQTHBMgEyQTKBMsEyQTLBMwEzQTOBM8EzQTPBNAE0QTSBNME0QTTBNQE1QTWBNcE1QTXBNgE2QTaBNsE2QTbBNwE3QTeBN8E3QTfBOAE4QTiBOME4QTjBOQE5QTmBOcE5QTnBOgE6QTqBOsE6QTrBOwE7QTuBO8E7QTvBPAE8QTyBPME8QTzBPQE9QT2BPcE9QT3BPgE+QT6BPsE+QT7BPwE/QT+BP8E/QT/BAAFAQUCBQMFAQUDBQQFBQUGBQcFBQUHBQgFCQUKBQsFCQULBQwFDQUOBQ8FDQUPBRAFEQUSBRMFEQUTBRQFFQUWBRcFFQUXBRgFGQUaBRsFGQUbBRwFHQUeBR8FHQUfBSAFIQUiBSMFIQUjBSQFJQUmBScFJQUnBSgFKQUqBSsFKQUrBSwFLQUuBS8FLQUvBTAFMQUyBTMFMQUzBTQFNQU2BTcFNQU3BTgFOQU6BTsFOQU7BTwFPQU+BT8FPQU/BUAFQQVCBUMFQQVDBUQFRQVGBUcFRQVHBUgFSQVKBUsFSQVLBUwFTQVOBU8FTQVPBVAFUQVSBVMFUQVTBVQFVQVWBVcFVQVXBVgFWQVaBVsFWQVbBVwFXQVeBV8FXQVfBWAFYQViBWMFYQVjBWQFZQVmBWcFZQVnBWgFaQVqBWsFaQVrBWwFbQVuBW8FbQVvBXAFcQVyBXMFcQVzBXQFdQV2BXcFdQV3BXgFeQV6BXsFeQV7BXwFfQV+BX8FfQV/BYAFgQWCBYMFgQWDBYQFhQWGBYcFhQWHBYgFiQWKBYsFiQWLBYwFjQWOBY8FjQWPBZAFkQWSBZMFkQWTBZQFlQWWBZcFlQWXBZgFmQWaBZsFmQWbBZwFnQWeBZ8FnQWfBaAFoQWiBaMFoQWjBaQFpQWmBacFpQWnBagFqQWqBasFqQWrBawFrQWuBa8FrQWvBbAFsQWyBbMFsQWzBbQFtQW2BbcFtQW3BbgFuQW6BbsFuQW7BbwFvQW+Bb8FvQW/BcAFwQXCBcMFwQXDBcQFxQXGBccFxQXHBcgFyQXKBcsFyQXLBcwFzQXOBc8FzQXPBdAF0QXSBdMF0QXTBdQF1QXWBdcF1QXXBdgF2QXaBdsF2QXbBdwF3QXeBd8F3QXfBeAF4QXiBeMF4QXjBeQF5QXmBecF5QXnBegF6QXqBesF6QXrBewF7QXuBe8F7QXvBfAF8QXyBfMF8QXzBfQF9QX2BfcF9QX3BfgF+QX6BfsF+QX7BfwF/QX+Bf8F/QX/BQAGAQYCBgMGAQYDBgQGBQYGBgcGBQYHBggGCQYKBgsGCQYLBgwGDQYOBg8GDQYPBhAGEQYSBhMGEQYTBhQGFQYWBhcGFQYXBhgGGQYaBhsGGQYbBhwGHQYeBh8GHQYfBiAGIQYiBiMGIQYjBiQGJQYmBicGJQYnBigGKQYqBisGKQYrBiwGLQYuBi8GLQYvBjAGMQYyBjMGMQYzBjQGNQY2BjcGNQY3BjgGOQY6BjsGOQY7BjwGPQY+Bj8GPQY/BkAGQQZCBkMGQQZDBkQGRQZGBkcGRQZHBkgGSQZKBksGSQZLBkwGTQZOBk8GTQZPBlAGUQZSBlMGUQZTBlQGVQZWBlcGVQZXBlgGWQZaBlsGWQZbBlwGXQZeBl8GXQZfBmAGYQZiBmMGYQZjBmQGZQZmBmcGZQZnBmgGaQZqBmsGaQZrBmwGbQZuBm8GbQZvBnAGcQZyBnMGcQZzBnQGdQZ2BncGdQZ3BngGeQZ6BnsGeQZ7BnwGfQZ+Bn8GfQZ/BoAGgQaCBoMGgQaDBoQGhQaGBocGhQaHBogGiQaKBosGiQaLBowGjQaOBo8GjQaPBpAGkQaSBpMGkQaTBpQGlQaWBpcGlQaXBpgGmQaaBpsGmQabBpwGnQaeBp8GnQafBqAGoQaiBqMGoQajBqQGpQamBqcGpQanBqgGqQaqBqsGqQarBqwGrQauBq8GrQavBrAGsQayBrMGsQazBrQGtQa2BrcGtQa3BrgGtwa5BrgGuga7BrUGvAa6BrUGuAa8BrUGvAa9BroGuAa+BrwGvga/BrwGuAbABr4GwQbCBsMGwQbDBsQGxQbGBscGxQbHBsgGyQbKBssGyQbLBswGzQbOBs8GzQbPBtAG0QbSBtMG0QbTBtQG1QbWBtcG1QbXBtgG2QbaBtsG2QbbBtwG3QbeBt8G3QbfBuAG4QbiBuMG4QbjBuQG5QbmBucG5QbnBugG6QbqBusG6QbrBuwG7QbuBu8G7QbvBvAG8QbyBvMG8QbzBvQG9Qb2BvcG9Qb3BvgG+Qb6BvsG+Qb7BvwG/Qb+Bv8G/Qb/BgAHAQcCBwMHAQcDBwQHBQcGBwcHBQcHBwgHCQcKBwsHCQcLBwwHDQcOBw8HDQcPBxAHEQcSBxMHEQcTBxQHFQcWBxcHFQcXBxgHGQcaBxsHGQcbBxwHHQceBx8HHQcfByAHIQciByMHIQcjByQHJQcmBycHJQcnBygHKQcqByUHKQcrByoHLActBykHLAcuBy0HLwcwBzEHLwcxBzIHMwc0BzUHMwc1BzYHNwc4BzkHNwc5BzoHOwc8Bz0HOwc9Bz4HPwdAB0EHPwdBB0IHQwdEB0UHQwdFB0YHRwdIB0kHRwdJB0oHSwdMB00HSwdNB04HTwdQB1EHTwdRB1IHUwdUB1UHUwdVB1YHVwdYB1kHVwdZB1oHWwdcB10HWwddB14HXwdgB2EHXwdhB2IHYwdkB2UHYwdlB2YHZwdoB2kHZwdpB2oHawdsB20HawdtB24HbwdwB3EHbwdxB3IHcwd0B3UHcwd1B3YHdwd4B3kHdwd5B3oHewd8B30Hewd9B34HfweAB4EHfweBB4IHgweEB4UHgweFB4YHhweIB4kHhweJB4oHiweMB40HiweNB44HjweQB5EHjweRB5IHkweUB5UHkweVB5YHlweYB5kHlweZB5oHmwecB50HmwedB54HnwegB6EHnwehB6IHowekB6UHowelB6YHpweoB6kHpwepB6oHqwesB60HqwetB64HrwewB7EHrwexB7IHswe0B7UHswe1B7YHtwe4B7kHtwe5B7oHuwe8B70Huwe9B74HvwfAB8EHvwfBB8IHwwfEB8UHwwfFB8YHxwfIB8kHxwfJB8oHywfMB80HywfNB84HzwfQB9EHzwfRB9IH0wfUB9UH0wfVB9YH1wfYB9kH1wfZB9oH2wfcB90H2wfdB94H3wfgB+EH3wfhB+IH4wfkB+UH4wflB+YH5wfoB+kH5wfpB+oH6wfsB+0H6wftB+4H7wfwB/EH7wfxB/IH8wf0B/UH8wf1B/YH9wf4B/kH9wf5B/oH+wf8B/0H+wf9B/4H/wcACAEI/wcBCAIIAwgECAUIAwgFCAYIBwgICAkIBwgJCAoICwgMCA0ICwgNCA4IDwgQCBEIDwgRCBIIEwgUCBUIEwgVCBYIFwgYCBkIFwgZCBoIGwgcCB0IGwgdCB4IHwggCCEIHwghCCIIIwgkCCUIIwglCCYIJwgoCCkIJwgpCCoIKwgsCC0IKwgtCC4ILwgwCDEILwgxCDIIMwg0CDUIMwg1CDYINwg4CDkINwg5CDoIOwg8CD0IOwg9CD4IPwhACEEIPwhBCEIIQwhECEUIQwhFCEYIRwhICEkIRwhJCEoISwhMCE0ISwhNCE4ITwhQCFEITwhRCFIIUwhUCFUIUwhVCFYIVwhYCFkIVwhZCFoIWwhcCF0IWwhdCF4IXwhgCGEIXwhhCGIIYwhkCGUIYwhlCGYIZwhoCGkIZwhpCGoIawhsCG0IawhtCG4IbwhwCHEIbwhxCHIIcwh0CHUIcwh1CHYIdwh4CHkIdwh5CHoIewh8CH0Iewh9CH4IfwiACIEIfwiBCIIIgwiECIUIgwiFCIYIhwiICIkIhwiJCIoIiwiMCI0IiwiNCI4IjwiQCJEIjwiRCJIIkwiUCJUIkwiVCJYIlwiYCJkIlwiZCJoImwicCJ0ImwidCJ4InwigCKEInwihCKIIowikCKUIowilCKYIpwioCKkIpwipCKoIAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAAAABAAIAAwAEAAUAAwAFAAYABwAIAAkABwAJAAoACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAEwAVABYAFwAYABkAFwAZABoAGwAcAB0AGwAdAB4AHwAgACEAHwAhACIAIwAkACUAIwAlACYAJwAoACkAJwApACoAKwAsAC0ALgAsACsALgAvACwAKwAtADAAMQAwAC0AMQAtADIAMwAxADIAMwAyADQANQAzADQANQA0ADYAMgA3ADQAMgA4ADcANwA5ADoANwA7ADkAOAA7ADcAOAA8ADsAPQA8ADgAPQA+ADwAPwBAAEEAPwBBAEIAQwBEAEUAQwBFAEYARwBIAEkARwBJAEoASwBMAE0ASwBNAE4ATwBQAFEATwBRAFIAUwBUAFUAUwBVAFYAVwBYAFkAVwBZAFoAWwBcAF0AWwBdAF4AXwBgAGEAXwBhAGIAYwBkAGUAYwBlAGYAZwBoAGkAZwBpAGoAawBsAG0AawBtAG4AbwBwAHEAbwBxAHIAcwB0AHUAdgB3AHgAdgB4AHkAegB7AHwAegB8AH0AfgB/AIAAfgCAAIEAggCDAIQAggCEAIUAhgCHAIgAhgCIAIkAigCLAIwAigCMAI0AjgCPAJAAkQCPAI4AjgCQAJIAkwCUAJUAkwCVAJYAlgCVAJcAmACZAJoAmACaAJsAnACdAJ4AnwCgAKEAnwChAKIAowCkAKUAowClAKYApwCoAKkAqgCrAKwAqgCsAK0ArgCvALAArgCwALEAsgCzALQAsgC0ALUAtgC3ALgAuQC6ALsAuQC7ALwAvQC+AL8AvQC/AMAAwQDCAMMAwQDDAMQAxQDGAMcAxQDHAMgAyQDKAMsAyQDLAMwAzQDOAM8AzQDPANAA0QDSANMA0QDTANQA1QDWANcA1QDXANgA2QDaANsA2QDbANwA3QDeAN8A4ADhAOIA4ADiAOMA5ADlAOYA5ADmAOcA6ADpAOoA6ADqAOsA7ADtAO4A7ADuAO8A8ADxAPIA8ADyAPMA9AD1APYA9AD2APcA+AD5APoA+AD6APsA/AD9AP4A/AD+AP8AAAEBAQIBAAECAQMBBAEFAQYBBAEGAQcBCAEJAQoBCAEKAQsBDAENAQ4BDAEOAQ8BEAERARIBEAESARMBFAEVARYBFAEWARcBGAEZARoBGAEaARsBHAEdAR4BHAEeAR8BIAEhASIBIAEiASMBJAElASYBJAEmAScBKAEpASoBKAEqASsBLAEtAS4BLAEuAS8BMAExATIBMAEyATMBNAE1ATYBNAE2ATcBOAE5AToBOAE6ATsBPAE9AT4BPAE+AT8BQAFBAUIBQAFCAUMBRAFFAUYBRAFGAUcBSAFJAUoBSAFKAUsBTAFNAU4BTAFOAU8BUAFRAVIBUAFSAVMBVAFVAVYBVAFWAVcBWAFZAVoBWAFaAVsBXAFdAV4BXAFeAV8BYAFhAWIBYAFiAWMBZAFlAWYBZAFmAWcBaAFpAWoBaAFqAWsBbAFtAW4BbwFwAXEBbwFxAXIBcwF0AXUBcwF1AXYBdwF4AXkBdwF5AXoBewF8AX0BfgF/AYABfgGAAYEBggGDAYQBhAGFAYIBhAGGAYUBhwGIAYkBhwGJAYoBiwGMAY0BiwGNAY4BjwGQAZEBkgGTAZQBkgGUAZUBlgGXAZgBlgGYAZkBmgGbAZwBmgGcAZ0BngGfAaABngGgAaEBogGjAaQBogGkAaUBpgGnAagBpgGoAakBqgGrAawBqgGsAa0BrgGvAbABrgGwAbEBsgGzAbQBsgG0AbUBtgG3AbgBtgG4AbkBugG7AbwBugG8Ab0BvgG/AcABvgHAAcEBwgHDAcQBwgHEAcUBxgHHAcgBxgHIAckBygHLAcwBygHMAc0BzgHPAdABzgHQAdEB0gHTAdQB0gHUAdUB1gHXAdgB1gHYAdkB2gHbAdwB3QHeAd8B3QHfAeAB4QHiAeMB4QHjAeQB5QHmAecB5QHnAegB6QHqAesB6QHrAewB7QHuAe8B7QHvAfAB8QHyAfMB8QHzAfQB9QH2AfcB9QH3AfgB+QH1AfgB+gH7AfwB+wH9AfwB+gH8Af4B/wEAAgEC/wEBAgICAwIEAgUCBgIHAggCBgIIAgkCCgILAgwCCgIMAg0CDgIPAhACEQISAhMCEQITAhQCFQIWAhcCFQIXAhgCGQIaAhsCGQIbAhwCHQIeAh8CIAIhAiICIAIiAiMCJAIlAiYCJAImAicCKAIpAioCKAIqAisCLAItAi4CLAIuAi8CMAIxAjICMAIyAjMCNAI1AjYCNAI2AjcCOAI5AjoCOAI6AjsCPAI9Aj4CPAI+Aj8CQAJBAkICQAJCAkMCRAJFAkYCRwJIAkkCRwJJAkoCSwJMAk0CSwJNAk4CTwJQAlECTwJRAlICUwJUAlUCUwJVAlYCVwJYAlkCVwJZAloCWwJcAl0CWwJdAl4CXwJgAmECXwJhAmICYwJkAmUCYwJlAmYCZwJoAmkCZwJpAmoCawJsAm0CawJtAm4CbwJwAnECbwJxAnICcwJ0AnUCcwJ1AnYCdwJ4AnkCdwJ5AnoCewJ8An0CewJ9An4CfwKAAoECfwKBAoICgwKEAoUCgwKFAoYChwKIAokChwKJAooCiwKMAo0CiwKNAo4CjwKQApECjwKRApICkwKUApUCkwKVApYClwKYApkClwKZApoCmwKcAp0CmwKdAp4CnwKgAqECnwKhAqICowKkAqUCowKlAqYCpwKoAqkCpwKpAqoCqwKsAq0CqwKtAq4CrwKwArECrwKxArICswK0ArUCswK1ArYCtwK4ArkCtwK5AroCuwK8Ar0CuwK9Ar4CvwLAAsECvwLBAsICwwLEAsUCwwLFAsYCxwLIAskCxwLJAsoCywLMAs0CywLNAs4CzwLQAtECzwLRAtIC0wLUAtUC1gLXAtgC1gLYAtkC2gLbAtwC2gLcAt0C3gLfAuAC3gLgAuEC4gLjAuQC5QLmAucC5QLnAugC6QLqAusC6wLsAukC6wLtAuwC7gLvAvAC7gLwAvEC8gLzAvQC8gL0AvUCAAABAAIAAwAEAAUABgAHAAgACQAKAAsA\");\n\n//# sourceURL=webpack:///./assets/NormalCar2.glb?");

/***/ }),

/***/ "./assets/SUV.glb":
/*!************************!*\
  !*** ./assets/SUV.glb ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAAB0jQEAdA8AAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjk3NzY0fV0sImFzc2V0Ijp7InZlcnNpb24iOiIyLjAiLCJnZW5lcmF0b3IiOiJnbHRmcGFjayAwLjE2In0sImV4dGVuc2lvbnNVc2VkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiJdLCJleHRlbnNpb25zUmVxdWlyZWQiOlsiS0hSX21lc2hfcXVhbnRpemF0aW9uIl0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjAsImJ5dGVMZW5ndGgiOjUyMDAwLCJieXRlU3RyaWRlIjo4LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NTIwMDAsImJ5dGVMZW5ndGgiOjI2MDAwLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NzgwMDAsImJ5dGVMZW5ndGgiOjE5NzY0LCJ0YXJnZXQiOjM0OTYzfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIwMzgsInR5cGUiOiJWRUMzIiwibWluIjpbMCwxMDAzLDc5XSwibWF4IjpbODIxNyw1ODYwLDE2MjczXX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MjAzOCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozMDEyLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoxNjMwNCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjE0OCwidHlwZSI6IlZFQzMiLCJtaW4iOls4MjYsNDAyOCwxMDkxXSwibWF4IjpbNzM5MSw1NzExLDExODk1XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0Ijo4MTUyLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MTQ4LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6NjAyNCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIxNiwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MTc0ODgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxOTc2LCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzI5NSwwLDBdLCJtYXgiOls3OTIyLDU5NDYsMTYzODNdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjg3NDQsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoxOTc2LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6NjQ1NiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjMwODQsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjMzMjk2LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjIzMCwidHlwZSI6IlZFQzMiLCJtaW4iOls2MzQsNDMyLDIxNF0sIm1heCI6Wzc2MjMsMjgzMCwxNjE2MV19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MTY2NDgsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyMjMwLCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MTI2MjQsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNDE0LCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0Ijo1MTEzNiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyIsIm1pbiI6Wzk1MCwyMTQ1LDE1MjE0XSwibWF4IjpbNzI2NiwyODUxLDE1OTU3XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoyNTU2OCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MTk0NTIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozMCwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6NTEzMTIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50Ijo4NiwidHlwZSI6IlZFQzMiLCJtaW4iOlsxMjQxLDMwMTgsNzM2XSwibWF4IjpbNjk3NSwzOTM0LDE0ODNdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjI1NjU2LCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6ODYsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjoxOTUxMiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjEyNiwidHlwZSI6IlNDQUxBUiJ9XSwibWF0ZXJpYWxzIjpbeyJuYW1lIjoiV2hpdGUiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjY5ODE4NDM3MSwwLjY5ODE4NDM3MSwwLjY5ODE4NDM3MSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IldpbmRvd3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjAzNTYwMTMxNzksMC4wMzU2MDEzMTc5LDAuMDM1NjAxMzE3OSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkJsYWNrIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4wMTM3MDIwODYyLDAuMDEzNzAyMDg2MiwwLjAxMzcwMjA4NjIsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJHcmV5IiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4yMDE1NTYyOCwwLjIwMTU1NjI4LDAuMjAxNTU2MjgsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJIZWFkbGlnaHRzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC43OTkxMDI3ODMsMC4zNzYyNjIxMjgsMC4xMjc0Mzc3MTEsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJUYWlsTGlnaHRzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC43OTkxMDI3ODMsMC4wOTMwNTg5NzM2LDAuMDc0MjEzNTc5MywxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9XSwibWVzaGVzIjpbeyJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowLCJOT1JNQUwiOjF9LCJtb2RlIjo0LCJpbmRpY2VzIjoyLCJtYXRlcmlhbCI6MH0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjozLCJOT1JNQUwiOjR9LCJtb2RlIjo0LCJpbmRpY2VzIjo1LCJtYXRlcmlhbCI6MX0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjo2LCJOT1JNQUwiOjd9LCJtb2RlIjo0LCJpbmRpY2VzIjo4LCJtYXRlcmlhbCI6Mn0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjo5LCJOT1JNQUwiOjEwfSwi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lha+AJwPswCcD7MAnA+zAJwPswDiI4oA4iOKAOIjigDiI4oAYrvWAGK71gBiu9YAYrvWAPl96AD5fegA+X3oAPl96ACd1kQAndZEAJ3WRACd1kQAAAABAAIAAAACAAMABAAFAAYABAAGAAcABAAHAAgABAAIAAkACgALAAwACgAMAA0ADgAPABAADgAQABEAEgATABQAEgAUABUAFgAXABgAGAAZABYAGAAaABkAGwAcAB0AGwAdAB4AHwAgACEAIQAiAB8AIgAjAB8AJAAlACYAJAAmACcAKAApACoAKAAqACsALAAtAC4ALAAuAC8AMAAxADIAMAAyADMANAA1ADYANAA2ADcAOAA5ADoAOAA6ADsAPAA9AD4APAA+AD8AQABBAEIAQABCAEMARABFAEYARABGAEcASABJAEoASABKAEsATABNAE4ATABOAE8AUABRAFIAUABSAFMAVABVAFYAVABWAFcAWABZAFoAWABaAFsAXABdAF4AXABeAF8AYABhAGIAYwBkAGUAYwBlAGYAZwBoAGkAZwBpAGoAawBsAG0AawBtAG4AbwBwAHEAbwBxAHIAcwB0AHUAcwB1AHYAdwB4AHkAdwB5AHoAewB8AH0AfgB/AIAAfgCAAIEAggCDAIQAggCEAIUAhgCHAIgAhgCIAIkAigCLAIwAigCMAI0AjgCPAJAAjgCQAJEAkgCTAJQAkgCUAJUAlgCXAJgAlgCYAJkAmgCbAJwAmgCcAJ0AngCfAKAAoQCiAKMAoQCjAKQApQCmAKcApQCnAKgAqQCqAKsAqQCrAKwArQCuAK8ArQCvALAAsQCyALMAsQCzALQAtQC2ALcAtQC3ALgAuQC6ALsAuQC7ALwAvQC+AL8AvQC/AMAAwQDCAMMAwQDDAMQAxQDGAMcAxQDHAMgAyQDKAMsAyQDLAMwAzQDOAM8AzQDPANAA0QDSANMA1ADVANYA1ADWANcA2ADZANoA2ADaANsA2ADbANwA2ADcAN0A3gDfAOAA3gDgAOEA4gDjAOQA4gDkAOUA5gDnAOgA5gDoAOkA6gDrAOwA6gDsAO0A7gDvAPAA7gDwAPEA8gDzAPQA8gD0APUA9gD3APgA9gD4APkA+gD7APwA+gD8AP0A/gD/AAAB/gAAAQEBAgEDAQQBAgEEAQUBBgEHAQgBBgEIAQkBCgELAQwBCgEMAQ0BDgEPARABDgEQAREBEgETARQBEgEUARUBFgEXARgBFgEYARkBGgEbARwBGgEcAR0BHgEfASABHgEgASEBIgEjASQBIgEkASUBJgEnASgBJgEoASkBKgErASwBKgEsAS0BLgEvATABLgEwATEBMgEzATQBMgE0ATUBNgE3ATgBNgE4ATkBOgE7ATwBOgE8AT0BPgE/AUABPgFAAUEBQgFDAUQBQgFEAUUBRgFHAUgBRgFIAUkBSgFLAUwBSgFMAU0BTgFPAVABTgFQAVEBUgFTAVQBUgFUAVUBVgFXAVgBVgFYAVkBWgFbAVwBWgFcAV0BXgFfAWABXgFgAWEBYgFjAWQBYgFkAWUBZgFnAWgBaAFpAWYBaAFqAWkBawFsAW0BawFtAW4BbwFwAXEBbwFxAXIBcwF0AXUBcwF1AXYBdwF4AXkBdwF5AXoBewF8AX0BewF9AX4BfwGAAYEBfwGBAYIBgwGEAYUBgwGFAYYBhwGIAYkBhwGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlAGWAZcBmAGZAZoBmwGcAZ0BmwGdAZ4BnwGgAaEBnwGhAaIBowGkAaUBowGlAaYBpwGoAakBpwGpAaoBqwGsAa0BqwGtAa4BrwGwAbEBrwGxAbIBswG0AbUBswG1AbYBtwG4AbkBtwG5AboBuwG8Ab0BuwG9Ab4BvwHAAcEBvwHBAcIBwwHEAcUBwwHFAcYBxwHIAckBxwHJAcoBywHMAc0BywHNAc4BzwHQAdEBzwHRAdIB0wHUAdUB0wHVAdYB1wHYAdkB1wHZAdoB2wHcAd0B2wHdAd4B3wHgAeEB3wHhAeIB4wHkAeUB4wHlAeYB5wHoAekB6gHrAewB6gHsAe0B7gHvAfAB7gHwAfEB8gHzAfQB8gH0AfUB9gH3AfgB9gH4AfkB+gH7AfwB+gH8Af0B/gH/AQAC/gEAAgECAgIDAgQCAgIEAgUCBgIHAggCBgIIAgkCCgILAgwCCgIMAg0CDgIPAhACDgIQAhECEgITAhQCEgIUAhUCFgIXAhgCFgIYAhkCGgIbAhwCGgIcAh0CHgIfAiACHgIgAiECIgIjAiQCIgIkAiUCJgInAigCJgIoAikCKgIrAiwCKgIsAi0CLgIvAjACLgIwAjECMgIzAjQCMgI0AjUCNgI3AjgCNgI4AjkCOgI7AjwCOgI8Aj0CPgI/AkACPgJAAkECQgJDAkQCQgJEAkUCRgJHAkgCRgJIAkkCSgJLAkwCSgJMAk0CTgJPAlACTgJQAlECUgJTAlQCUgJUAlUCVgJXAlgCVgJYAlkCWgJbAlwCWgJcAl0CXgJfAmACXgJgAmECYgJjAmQCYgJkAmUCZgJnAmgCZgJoAmkCagJrAmwCagJsAm0CbgJrAmoCbgJvAmsCcAJxAnICcAJyAnMCdAJ1AnYCdAJ2AncCeAJ5AnoCegJ7AngCegJ8AnsCfQJ+An8CfQJ/AoACgQKCAoMCgQKDAoQChQKGAocChwKIAoUChwKJAogCigKLAowCigKMAo0CjgKPApACjgKQApECkgKTApQCkgKUApUClgKXApgClgKYApkCmgKbApwCmgKcAp0CngKfAqACngKgAqECogKjAqQCogKkAqUCpgKnAqgCpgKoAqkCqgKrAqwCqgKsAq0CrgKvArACrgKwArECsgKzArQCtQK2ArcCtQK3ArgCuQK6ArsCuQK7ArwCvQK+Ar8CvQK/AsACwQLCAsMCwQLDAsQCxQLGAscCxQLHAsgCyQLKAssCyQLLAswCzQLOAs8C0ALRAtIC0ALSAtMC1ALVAtYC1ALWAtcC2ALZAtoC2ALaAtsC3ALdAt4C3ALeAt8C4ALhAuIC4ALiAuMC5ALlAuYC5ALmAucC6ALpAuoC6ALqAusC7ALtAu4C7ALuAu8C8ALxAvIC8ALyAvMC9AL1AvYC9AL2AvcC+AL5AvoC+AL6AvsC+AL7AvwC+AL8Av0C/gL/AgAD/gIAAwEDAgMDAwQDAgMEAwUDBgMHAwgDBgMIAwkDCgMLAwwDDQMOAw8DEAMRAxIDEAMSAxMDFAMVAxYDFAMWAxcDGAMZAxoDGAMaAxsDHAMdAx4DHAMeAx8DIAMhAyIDIAMiAyMDJAMlAyYDJAMmAycDKAMpAyoDKAMqAysDLAMtAy4DLAMuAy8DMAMxAzIDMAMyAzMDNAM1AzYDNAM2AzcDOAM5AzoDOgM7AzgDOgM8AzsDPQM+Az8DQANBA0IDQwNEA0UDQwNFA0YDRwNIA0kDRwNJA0oDSwNMA00DTQNOA0sDTQNPA04DUANRA1IDUANSA1MDVANVA1YDVANWA1cDWANZA1oDWANaA1sDXANdA14DXANeA18DYANhA2IDYANiA2MDZANlA2YDZwNoA2kDZwNpA2oDawNsA20DawNtA24DbwNwA3EDcgNzA3QDcgN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfAN+A38DgAOBA4IDgAOCA4MDhAOFA4YDhAOGA4cDiAOJA4oDiAOKA4sDjAONA44DjAOOA48DkAORA5IDkwOUA5UDkwOVA5YDlwOYA5kDmgObA5wDmgOcA50DngOfA6ADoQOiA6MDoQOjA6QDpQOmA6cDpQOnA6gDqQOqA6sDrAOtA64DrwOwA7EDrwOxA7IDswO0A7UDswO1A7YDtwO4A7kDtwO5A7oDuwO8A70DuwO9A74DvwPAA8EDvwPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDyQPLA8wDzQPOA88DzQPPA9AD0QPSA9MD0QPTA9QD1QPWA9cD2APZA9oD2APaA9sD3APdA94D3APeA98D4APhA+ID4APiA+MD5APlA+YD5APmA+cD6APpA+oD6APqA+sD7APtA+4D7APuA+8D8APxA/ID8APyA/MD9AP1A/YD9AP2A/cD+AP5A/oD+AP6A/sD/AP9A/4D/AP+A/8DAAQBBAIEAAQCBAMEBAQFBAYEBAQGBAcECAQJBAoECAQKBAsEDAQNBA4EDAQOBA8EEAQRBBIEEAQSBBMEFAQVBBYEFgQXBBQEFgQYBBcEGQQaBBsEGQQbBBwEHQQeBB8EHwQgBB0EHwQhBCAEIgQjBCQEIgQkBCUEJgQnBCgEJgQoBCkEKgQrBCwEKgQsBC0ELgQvBDAELgQwBDEEMgQzBDQEMgQ0BDUENgQ3BDgENgQ4BDkEOgQ7BDwEOgQ8BD0EPgQ/BEAEPgRABEEEQgRDBEQEQgREBEUERgRHBEgERgRIBEkESgRLBEwESgRMBE0ETgRPBFAETgRQBFEEUgRTBFQEUgRUBFUEVgRXBFgEVgRYBFkEWgRbBFwEWgRcBF0EXgRfBGAEYQRiBGMEYQRjBGQEZQRmBGcEZQRnBGgEaQRqBGsEaQRrBGwEbQRuBG8EbQRvBHAEcQRyBHMEcQRzBHQEdQR2BHcEdQR3BHgEeQR6BHsEfAR9BH4EfAR+BH8EgASBBIIEgASCBIMEhASFBIYEhASGBIcEiASJBIoEiASKBIsEjASNBI4EjASOBI8EkASRBJIEkASSBJMElASVBJYElASWBJcEmASZBJoEmASaBJsEnASdBJ4EnwSgBKEEnwShBKIEowSkBKUEowSlBKYEpwSoBKkEpwSpBKoEqwSsBK0EqwStBK4ErwSwBLEErwSxBLIEswS0BLUEswS1BLYEtwS4BLkEtwS5BLoEuwS8BL0EuwS9BL4EvwTABMEEvwTBBMIEwwTEBMUEwwTFBMYExwTIBMkExwTJBMoEywTMBM0EywTNBM4EzwTQBNEE0gTTBNQE0gTUBNUE1gTXBNgE1gTYBNkE2gTbBNwE2gTcBN0E3gTfBOAE3gTgBOEE4gTjBOQE4gTkBOUE5gTnBOgE5gToBOkE6gTrBOwE6gTsBO0E7gTvBPAE7gTwBPEE8gTzBPQE8gT0BPUE9gT3BPgE9gT4BPkE+gT7BPwE+gT8BP0E/gT/BAAF/gQABQEFAgUDBQQFAgUEBQUFBgUHBQgFBgUIBQkFCgULBQwFCgUMBQ0FDgUPBRAFDgUQBREFEgUTBRQFEgUUBRUFFgUXBRgFFgUYBRkFGgUbBRwFGgUcBR0FHgUfBSAFHgUgBSEFIgUjBSQFIgUkBSUFJgUnBSgFJgUoBSkFKgUrBSwFKgUsBS0FLgUvBTAFLgUwBTEFMgUzBTQFMgU0BTUFNgU3BTgFNgU4BTkFOgU7BTwFOgU8BT0FPgU/BUAFPgVABUEFQgVDBUQFQgVEBUUFRgVHBUgFRgVIBUkFSgVLBUwFSgVMBU0FTgVPBVAFTgVQBVEFUgVTBVQFUgVUBVUFVgVXBVgFVgVYBVkFWgVbBVwFWgVcBV0FXgVfBWAFYAVhBV4FYAViBWEFYwVkBWUFYwVlBWYFZwVoBWkFZwVpBWoFawVsBW0FawVtBW4FbwVwBXEFbwVxBXIFcwV0BXUFcwV1BXYFdwV4BXkFdwV5BXoFewV8BX0FewV9BX4FfwWABYEFfwWBBYIFgwWEBYUFhgWHBYgFiQWKBYsFjAWNBY4FjAWOBY8FkAWRBZIFkwWUBZUFkwWVBZYFlwWYBZkFlwWZBZoFmwWcBZ0FmwWdBZ4FnwWgBaEFnwWhBaIFowWkBaUFowWlBaYFpwWoBakFpwWpBaoFqwWsBa0FqwWtBa4FrwWwBbEFrwWxBbIFswW0BbUFswW1BbYFtwW4BbkFtwW5BboFuwW8Bb0FuwW9Bb4FvwXABcEFvwXBBcIFwwXEBcUFwwXFBcYFxwXIBckFxwXJBcoFywXMBc0FywXNBc4FzwXQBdEFzwXRBdIF0wXUBdUF0wXVBdYF1wXYBdkF1wXZBdoF2wXcBd0F2wXdBd4F3wXgBeEF4gXjBeQF4gXkBeUF5gXnBegF5gXoBekF6gXrBewF6gXsBe0F7gXvBfAF7gXwBfEF8gXzBfQF8gX0BfUF9gX3BfgF9gX4BfkF+gX7BfwF+gX8Bf0F/gX/BQAG/gUABgEGAgYDBgQGAgYEBgUGBgYHBggGBgYIBgkGCgYLBgwGCgYMBg0GDgYPBhAGDgYQBhEGEgYTBhQGEgYUBhUGFgYXBhgGFgYYBhkGGgYbBhwGGgYcBh0GHgYfBiAGHgYgBiEGIgYjBiQGIgYkBiUGJgYnBigGJgYoBikGKgYrBiwGKgYsBi0GLgYvBjAGLgYwBjEGMgYzBjQGMgY0BjUGNgY3BjgGNgY4BjkGOgY7BjwGOgY8Bj0GPgY/BkAGPgZABkEGQgZDBkQGQgZEBkUGRgZHBkgGRgZIBkkGSgZLBkwGSgZMBk0GTgZPBlAGTgZQBlEGUgZTBlQGUgZUBlUGVgZXBlgGVgZYBlkGWgZbBlwGWgZcBl0GXgZfBmAGXgZgBmEGYgZjBmQGYgZkBmUGZgZnBmgGZgZoBmkGagZmBmkGagZpBmsGbAZtBm4GbAZuBm8GcAZxBnIGcAZyBnMGdAZ1BnYGdgZ3BnQGdgZ4BncGeQZ6BnsGeQZ7BnwGfQZ+Bn8GfQZ/BoAGgQaCBoMGgwaEBoEGgwaFBoQGhgaHBogGhgaIBokGigaLBowGigaMBo0GjgaPBpAGjgaQBpEGkgaTBpQGkgaUBpUGlgaXBpgGlgaYBpkGmgabBpwGmgacBp0GngafBqAGngagBqEGogajBqQGogakBqUGpganBqgGpgaoBqkGqgarBqwGqgasBq0GrgavBrAGsQayBrMGsQazBrQGtQa2BrcGtQa3BrgGuQa6BrsGuQa7BrwGvQa+Br8GvQa/BsAGwQbCBsMGwQbDBsQGxQbGBscGxQbHBsgGyQbKBssGzAbNBs4GzAbOBs8G0AbRBtIG0AbSBtMG1AbVBtYG1AbWBtcG2AbZBtoG2AbaBtsG3AbdBt4G3AbeBt8G4AbhBuIG4AbiBuMG5AblBuYG5AbmBucG6AbpBuoG6AbqBusG7AbtBu4G7AbuBu8G8AbxBvIG8AbyBvMG9Ab1BvYG9Ab2BvcG+Ab5BvoG+Ab6BvsG/Ab9Bv4G/Ab+Bv8GAAcBBwIHAwcEBwUHBgcHBwgHBgcIBwkHCgcLBwwHCgcMBw0HDgcPBxAHDgcQBxEHEgcTBxQHEgcUBxUHFgcXBxgHFgcYBxkHGgcbBxwHGgccBx0HHgcfByAHHgcgByEHIgcjByQHIgckByUHJgcnBygHJgcoBykHKgcrBywHKgcsBy0HLgcvBzAHMAcxBy4HMAcyBzEHMwc0BzUHNgc3BzgHOQc6BzsHOQc7BzwHPQc+Bz8HPQc/B0AHQQdCB0MHQwdEB0EHRAdFB0EHRgdHB0gHRgdIB0kHSgdLB0wHSgdMB00HTgdPB1AHTgdQB1EHUgdTB1QHUgdUB1UHVgdXB1gHVgdYB1kHWgdbB1wHXQdeB18HXQdfB2AHYQdiB2MHYQdjB2QHZQdmB2cHaAdpB2oHaAdqB2sHbAdtB24HbwdwB3EHcgdzB3QHcgd0B3UHdgd3B3gHdgd4B3kHegd7B3wHegd8B30Hfgd/B4AHfgeAB4EHggeDB4QHggeEB4UHhgeHB4gHiQeKB4sHiQeLB4wHjQeOB48HkAeRB5IHkAeSB5MHlAeVB5YHlweYB5kHlweZB5oHmwecB50HmwedB54HnwegB6EHogejB6QHpQemB6cHpQenB6gHqQeqB6sHqQerB6wHrQeuB68HrQevB7AHsQeyB7MHsQezB7QHtQe2B7cHtQe3B7gHuQe6B7sHvAe9B74HvwfAB8EHvwfBB8IHwwfEB8UHwwfFB8YHxwfIB8kHxwfJB8oHywfMB80HzgfPB9AHzgfQB9EH0gfTB9QH0gfUB9UH1gfXB9gH1gfYB9kH2gfbB9wH2gfcB90H3gffB+AH3gfgB+EH4gfjB+QH4gfkB+UH5gfnB+gH5gfoB+kH6gfrB+wH6gfsB+0H7gfvB/AH7gfwB/EH8gfzB/QH8gf0B/UHAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHwAgACEAHwAhACIAIwAkACUAJgAnACgAJgAoACkAKgArACwAKgAsAC0ALgAvADAALgAwADEAMgAzADQAMgA0ADUANgA3ADgANgA4ADkAOgA7ADwAOgA8AD0APgA/AEAAPgBAAEEAQgBDAEQAQgBEAEUARgBHAEgARgBIAEkASgBLAEwASgBMAE0ATgBPAFAATgBQAFEAUgBTAFQAUgBUAFUAVgBXAFgAVgBYAFkAWgBbAFwAWgBcAF0AXgBfAGAAXgBgAGEAYgBjAGQAYgBkAGUAZgBnAGgAaQBqAGsAaQBrAGwAbQBuAG8AcABxAHIAcAByAHMAdAB1AHYAdAB2AHcAeAB5AHoAeAB6AHsAfAB9AH4AfAB+AH8AgACBAIIAgACCAIMAhACFAIYAhACGAIcAiACJAIoAiACKAIsAjACNAI4AjACOAI8AkACRAJIAkACSAJMAAAABAAIAAwAEAAUAAwAFAAYABwAIAAkABwAJAAoACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAEwAVABYAFwAYABkAFwAZABoAGwAcAB0AGwAdAB4AHwAgACEAHwAhACIAIwAkACUAIwAlACYAJwAoACkAJwApACoAKwAsAC0AKwAtAC4ALwAwADEAMgAwAC8AMgAzADAANAAzADIANAA1ADMALwAxADYANwA2ADEANwAxADgAOQA3ADgAMQA6ADgAMQA7ADoAOQA4ADwAPQA5ADwAPQA8AD4APwBAAEEAPwBBAEIAQwBEAEUAQwBFAEYARwBIAEkARwBJAEoASwBMAE0ASwBNAE4ATwBQAFEATwBRAFIAUwBUAFUAUwBVAFYAVwBYAFkAVwBZAFoAWwBcAF0AWwBdAF4AXwBgAGEAXwBhAGIAYwBkAGUAYwBlAGYAZwBoAGkAZwBpAGoAawBsAG0AawBtAG4AbwBwAHEAcgBzAHQAcgB0AHUAdgB3AHgAdgB4AHkAegB7AHwAegB8AH0AfgB/AIAAfgCAAIEAggCDAIQAggCEAIUAhgCHAIgAiQCHAIYAhgCIAIoAiwCMAI0AiwCNAI4AjgCNAI8AkACRAJIAkACSAJMAlACVAJYAlwCYAJkAlwCZAJoAmwCcAJ0AmwCdAJ4AnwCgAKEAogCjAKQAogCkAKUApgCnAKgApgCoAKkAqgCrAKwAqgCsAK0ArgCvALAAsQCyALMAsQCzALQAtQC2ALcAtQC3ALgAuQC6ALsAuQC7ALwAvQC+AL8AvQC/AMAAwQDCAMMAwQDDAMQAxQDGAMcAxQDHAMgAyQDKAMsAyQDLAMwAzQDOAM8AzQDPANAA0QDSANMA0QDTANQA1QDWANcA1QDXANgA2QDaANsA2QDbANwA3QDZANwA3QDeANkA3wDgAOEA3wDhAOIA4wDkAOUA4wDlAOYA5wDoAOkA5wDpAOoA6wDsAO0A6wDtAO4A7wDwAPEA7wDxAPIA8wD0APUA8wD1APYA9wD4APkA9wD5APoA+wD8AP0A+wD9AP4A/wAAAQEB/wABAQIBAwEEAQUBAwEFAQYBBwEIAQkBBwEJAQoBCwEMAQ0BCwENAQ4BDwEQAREBDwERARIBEwEUARUBEwEVARYBFwEYARkBFwEZARoBGwEcAR0BGwEdAR4BHwEgASEBHwEhASIBIwEkASUBIwElASYBJwEoASkBJwEpASoBKwEsAS0BKwEtAS4BLwEwATEBLwExATIBMwE0ATUBMwE1ATYBNwE4ATkBNwE5AToBOwE8AT0BOwE9AT4BPwFAAUEBPwFBAUIBQwFEAUUBQwFFAUYBRwFIAUkBRwFJAUoBSwFMAU0BSwFNAU4BTwFQAVEBTwFRAVIBUwFUAVUBUwFVAVYBVwFYAVkBVwFZAVoBWwFcAV0BWwFdAV4BXwFgAWEBXwFhAWIBYwFkAWUBZgFnAWgBZgFoAWkBagFrAWwBagFsAW0BbgFvAXABbgFwAXEBcgFzAXQBdQF2AXcBdwF4AXUBdwF5AXgBegF7AXwBegF8AX0BfgF/AYABfgGAAYEBggGDAYQBggGEAYUBhgGHAYgBhgGIAYkBigGLAYwBigGMAY0BjgGPAZABjgGQAZEBkgGTAZQBkgGUAZUBlgGXAZgBlgGYAZkBmgGbAZwBmgGcAZ0BngGfAaABngGgAaEBogGjAaQBogGkAaUBpgGnAagBpgGoAakBqgGrAawBqgGsAa0BrgGvAbABrgGwAbEBsgGzAbQBsgG0AbUBtAGzAbYBtAG2AbcBuAG5AboBuAG6AbsBvAG9Ab4BvAG+Ab8BwAHBAcIBwAHCAcMBxAHFAcYBxAHGAccByAHJAcoByAHKAcsBzAHNAc4BzAHOAc8B0AHRAdIB0AHSAdMB1AHVAdYB1AHWAdcB2AHZAdoB2AHaAdsB3AHdAd4B3AHeAd8B4AHhAeIB4wHkAeUB4wHlAeYB5wHoAekB5wHpAeoB6wHsAe0B6wHtAe4B7wHwAfEB7wHxAfIB8wH0AfUB8wH1AfYB9wH4AfkB9wH5AfoB+wH8Af0B+wH9Af4B/wEAAgEC/wEBAgICAwIEAgUCAwIFAgYCBwIIAgkCBwIJAgoCCwIMAg0CCwINAg4CDwIQAhECDwIRAhICEwIUAhUCEwIVAhYCFwIYAhkCFwIZAhoCGwIcAh0CGwIdAh4CHwIgAiECHwIhAiICIwIkAiUCIwIlAiYCJwIoAikCJwIpAioCKwIsAi0CKwItAi4CLwIwAjECLwIxAjICMwI0AjUCMwI1AjYCNwI4AjkCNwI5AjoCOwI8Aj0CPgI/AkACPgJAAkECQgJDAkQCQgJEAkUCRgJHAkgCRgJIAkkCSgJLAkwCSgJMAk0CTgJPAlACTgJQAlECUgJTAlQCUgJUAlUCVgJSAlUCVwJYAlkCWAJaAlkCVwJZAlsCXAJdAl4CXAJeAl8CYAJhAmICYwJkAmUCYwJlAmYCZwJoAmkCZwJpAmoCawJsAm0CbgJvAnACbgJwAnECcgJzAnQCcgJ0AnUCdgJ3AngCdgJ4AnkCegJ7AnwCfQJ+An8CfQJ/AoACgQKCAoMCgQKDAoQChQKGAocChQKHAogCiQKKAosCiQKLAowCjQKOAo8CjQKPApACkQKSApMCkQKTApQClQKWApcClQKXApgCmQKaApsCmQKbApwCnQKeAp8CnQKfAqACoQKiAqMCoQKjAqQCpQKmAqcCpQKnAqgCqQKmAqUCqQKlAqoCqwKsAq0CqwKtAq4CrwKwArECrwKxArICswK0ArUCswK1ArYCtwK4ArkCtwK5AroCuwK8Ar0CuwK9Ar4CvwLAAsECvwLBAsICwwLEAsUCwwLFAsYCxwLIAskCxwLJAsoCywLMAs0CywLNAs4CzwLQAtECzwLRAtIC0wLUAtUC0wLVAtYC1wLYAtkC1wLZAtoC2wLcAt0C2wLdAt4C3wLgAuEC3wLhAuIC4wLkAuUC4wLlAuYC5wLoAukC5wLpAuoC6wLsAu0C6wLtAu4C7wLwAvEC7wLxAvIC8wL0AvUC8wL1AvYC9wL4AvkC9wL5AvoC+wL8Av0C+wL9Av4C/wIAAwED/wIBAwIDAwMEAwUDAwMFAwYDBwMIAwkDBwMJAwoDCwMMAw0DCwMNAw4DDwMQAxEDDwMRAxIDEwMUAxUDEwMVAxYDFwMYAxkDFwMZAxoDGwMcAx0DGwMdAx4DHwMgAyEDHwMhAyIDIwMkAyUDIwMlAyYDJwMoAykDJwMpAyoDKwMsAy0DKwMtAy4DLwMwAzEDMgMzAzQDMgM0AzUDNgM3AzgDNgM4AzkDOgM7AzwDOgM8Az0DPgM/A0ADQQNCA0MDQwNEA0EDQwNFA0QDRgNHA0gDRgNIA0kDSgNLA0wDSgNMA00DTgNPA1ADTgNQA1EDUgNTA1QDUgNUA1UDVgNXA1gDVgNYA1kDWgNbA1wDWgNcA10DXgNfA2ADXgNgA2EDYgNjA2QDYgNkA2UDZgNnA2gDZgNoA2kDagNrA2wDagNsA20DbgNvA3ADbgNwA3EDcgNzA3QDcgN0A3UDdgN3A3gDdgN4A3kDegN7A3wDegN8A30DfgN/A4ADfgOAA4EDggODA4QDggOEA4UDhgOHA4gDhgOIA4kDigOLA4wDigOMA40DjgOPA5ADjgOQA5EDkgOTA5QDkgOUA5UDlgOXA5gDlgOYA5kDmgObA5wDmgOcA50DngOfA6ADngOgA6EDogOjA6QDogOkA6UDpgOnA6gDpgOoA6kDqgOrA6wDqgOsA60DrgOvA7ADrgOwA7EDsgOzA7QDsgO0A7UDtgO3A7gDtgO4A7kDugO7A7wDugO8A70DvgO/A8ADvgPAA8EDwgPDA8QDwgPEA8UDxgPHA8gDxgPIA8kDygPLA8wDygPMA80DzgPPA9ADzgPQA9ED0gPTA9QD0gPUA9UD1gPXA9gD1gPYA9kD2gPbA9wD2gPcA90D3gPfA+AD3gPgA+ED4gPjA+QD4gPkA+UD5APmA+UD5wPoA+ID6QPnA+ID5QPpA+ID6QPqA+cD5QPrA+kD6wPsA+kD5QPtA+sD7gPvA/AD7gPwA/ED8gPzA/QD8gP0A/UD9gP3A/gD9gP4A/kD+gP7A/wD+gP8A/0D/gP/AwAE/gMABAEEAgQDBAQEAgQEBAUEBgQHBAgEBgQIBAkECgQLBAwECgQMBA0EDgQPBBAEDgQQBBEEEgQTBBQEEgQUBBUEFgQXBBgEFgQYBBkEGgQbBBwEGgQcBB0EHgQfBCAEHgQgBCEEIgQjBCQEIgQkBCUEJgQnBCgEJgQoBCkEKgQrBCwEKgQsBC0ELgQqBC0ELgQtBC8EMAQxBDIEMAQyBDMENAQwBDMENAQzBDUENgQ3BDgENgQ4BDkEOgQ2BDkEOgQ5BDsEPAQ6BDsEPAQ7BD0EPgQ/BEAEPgRABEEEQgRDBEQEQgREBEUERgRHBEgERgRIBEkESgRLBEwESgRMBE0ETgRPBFAETgRQBFEEUgRTBFQEUgRUBFUEVgRXBFgEVgRYBFkEWgRbBFwEWgRcBF0EXgRfBGAEXgRgBGEEYgRjBGQEYgRkBGUEZgRnBGgEZgRoBGkEagRrBGwEagRsBG0EbgRvBHAEbgRwBHEEcgRzBHQEcgR0BHUEdgR3BHgEdgR4BHkEegR7BHwEegR8BH0EfgR/BIAEfgSABIEEggSDBIQEggSEBIUEhgSHBIgEhgSIBIkEigSLBIwEigSMBI0EjgSPBJAEjgSQBJEEkgSTBJQEkgSUBJUElgSXBJgElgSYBJkEmgSbBJwEmgScBJ0EngSfBKAEngSgBKEEogSjBKQEogSkBKUEpgSnBKgEpgSoBKkEqgSrBKwEqgSsBK0ErgSvBLAErgSwBLEEsgSzBLQEsgS0BLUEtgS3BLgEtgS4BLkEugS7BLwEugS8BL0EvgS/BMAEvgTABMEEwgTDBMQEwgTEBMUExgTHBMgExgTIBMkEygTLBMwEygTMBM0EzgTPBNAEzgTQBNEE0gTTBNQE0gTUBNUE1gTXBNgE1gTYBNkE2gTbBNwE2gTcBN0E3gTfBOAE3gTgBOEE4gTjBOQE4gTkBOUE5gTnBOgE5gToBOkE6ATqBOkE6wTsBOYE7QTrBOYE6QTtBOYE7QTuBOsE6QTvBO0E7wTwBO0E6QTxBO8E8gTzBPQE8gT0BPUE9gT3BPgE9gT4BPkE+gT7BPwE+gT8BP0E/gT/BAAF/gQABQEFAgUDBQQFAgUEBQUFBgUHBQgFBgUIBQkFCgULBQwFCgUMBQ0FDgUPBRAFDgUQBREFEgUTBRQFEgUUBRUFFgUXBRgFFgUYBRkFGgUbBRwFGgUcBR0FHgUfBSAFHgUgBSEFIgUjBSQFIgUkBSUFJgUnBSgFJgUoBSkFKgUrBSwFKgUsBS0FLgUvBTAFLgUwBTEFMgUzBTQFMgU0BTUFNgUzBTIFNgU3BTMFOAU5BToFOAU6BTsFPAU9BT4FPAU+BT8FQAVBBUIFQAVCBUMFRAVFBUYFRAVGBUcFSAVJBUoFSAVKBUsFTAVNBU4FTAVOBU8FUAVRBVIFUAVSBVMFVAVVBVYFVAVWBVcFWAVZBVoFWAVaBVsFXAVdBV4FXAVeBV8FYAVhBWIFYAViBWMFZAVlBWYFZAVmBWcFaAVpBWoFaAVqBWsFbAVtBW4FbAVuBW8FcAVxBXIFcAVyBXMFdAV1BXYFdAV2BXcFeAV5BXoFeAV6BXsFfAV9BX4FfAV+BX8FgAWBBYIFgAWCBYMFhAWFBYYFhAWGBYcFiAWJBYoFiAWKBYsFjAWNBY4FjAWOBY8FkAWRBZIFkAWSBZMFlAWVBZYFlAWWBZcFmAWZBZoFmAWaBZsFnAWdBZ4FnAWeBZ8FoAWhBaIFoAWiBaMFpAWlBaYFpAWmBacFqAWpBaoFqAWqBasFrAWtBa4FrAWuBa8FsAWxBbIFsAWyBbMFtAW1BbYFtAW2BbcFuAW5BboFuAW6BbsFvAW9Bb4FvAW+Bb8FwAXBBcIFwAXCBcMFxAXFBcYFxAXGBccFyAXJBcoFyAXKBcsFzAXNBc4FzAXOBc8F0AXRBdIF0AXSBdMF1AXVBdYF1AXWBdcF2AXZBdoF2AXaBdsF3AXdBd4F3AXeBd8F4AXhBeIF4AXiBeMF5AXlBeYF5AXmBecF6AXpBeoF6AXqBesF7AXtBe4F7AXuBe8F8AXxBfIF8AXyBfMF8gX0BfMF9QX2BfAF9wX1BfAF8wX3BfAF9wX4BfUF8wX5BfcF+QX6BfcF8wX7BfkF/AX9Bf4F/QX/Bf4F/AX+BQAGAQb8BQAGAQYABgIG/QUDBv8FAwYEBv8FAwYFBgQGBQYGBgQGBQYHBgYGCAYJBgoGCAYKBgsGDAYNBg4GDAYOBg8GEAYRBhIGEAYSBhMGFAYVBhYGFAYWBhcGGAYZBhoGGAYaBhsGHAYdBh4GHAYeBh8GIAYhBiIGIAYiBiMGJAYlBiYGJAYmBicGKAYpBioGKAYqBisGLAYtBi4GLAYuBi8GMAYxBjIGMAYyBjMGNAY1BjYGNAY2BjcGOAY5BjoGOAY6BjsGPAY4BjsGPAY7Bj0GPgY8Bj0GPgY9Bj8GQAY+Bj8GQAY/BkEGQgZDBkQGQgZEBkUGRgZHBkgGRgZIBkkGSgZLBkwGSgZMBk0GTgZPBlAGTgZQBlEGUgZTBlQGUgZUBlUGVgZXBlgGVgZYBlkGWgZbBlwGWgZcBl0GXgZfBmAGXgZgBmEGYgZjBmQGYgZkBmUGZgZnBmgGZgZoBmkGagZrBmwGagZsBm0GbgZvBnAGbgZwBnEGcgZzBnQGcgZ0BnUGdgZ3BngGdgZ4BnkGegZ7BnwGegZ8Bn0GfgZ/BoAGfgaABoEGggaDBoQGggaEBoUGhgaHBogGhgaIBokGigaLBowGigaMBo0GjgaPBpAGjgaQBpEGkgaTBpQGkgaUBpUGlgaXBpgGlgaYBpkGmgabBpwGmgacBp0GngafBqAGngagBqEGogajBqQGogakBqUGpganBqgGpgaoBqkGqgarBqwGqgasBq0GrgavBrAGrgawBrEGsgazBrQGsga0BrUGtga3BrgGtga4BrkGuga7BrwGuga8Br0Gvga/BsAGvgbABsEGwgbDBsQGwgbEBsUGxgbHBsgGxgbIBskGygbLBswGygbMBs0GzgbPBtAGzgbQBtEG0gbTBtQG0gbUBtUG1gbXBtgG1gbYBtkG2gbbBtwG2gbcBt0G3gbfBuAG3gbgBuEG4gbjBuQG4gbkBuUG5gbnBugG5gboBukG6gbrBuwG6gbsBu0G7gbvBvAG7gbwBvEG8AbyBvEG8wb0Bu4G9QbzBu4G8Qb1Bu4G9Qb2BvMG8Qb3BvUG9wb4BvUG8Qb5BvcG+gb7BvwG/Qb7BvoG/Qb+BvsG+gb8Bv8G/wb8BgAH/wYABwEHAQcABwIHAQcCBwMHAwcCBwQHAwcEBwUHBgcHBwgHBgcIBwkHCgcLBwwHCgcMBw0HDgcPBxAHDgcQBxEHEgcTBxQHEgcUBxUHFgcXBxgHFgcYBxkHGgcbBxwHGgccBx0HHgcfByAHHgcgByEHIgcjByQHIgckByUHJgcnBygHJgcoBykHKgcrBywHKgcsBy0HLgcvBzAHLgcwBzEHMgczBzQHMgc0BzUHNgc3BzgHNgc4BzkHOgc3BzYHOgc7BzcHPAc7BzoHPAc9BzsHPgc9BzwHPgc/Bz0HQAdBB0IHQAdCB0MHRAdFB0YHRAdGB0cHSAdJB0oHSAdKB0sHTAdNB04HTAdOB08HUAdRB1IHUAdSB1MHVAdVB1YHVAdWB1cHWAdZB1oHWAdaB1sHXAddB14HXAdeB18HYAdhB2IHYAdiB2MHZAdlB2YHZAdmB2cHaAdpB2oHaAdqB2sHbAdtB24HbAduB28HcAdxB3IHcAdyB3MHdAd1B3YHdAd2B3cHeAd5B3oHeAd6B3sHfAd9B34HfAd+B38HgAeBB4IHgAeCB4MHhAeFB4YHhAeGB4cHiAeJB4oHiAeKB4sHjAeNB44HjAeOB48HkAeRB5IHkAeSB5MHlAeVB5YHlAeWB5cHmAeZB5oHmAeaB5sHnAedB54HnAeeB58HoAehB6IHoAeiB6MHpAelB6YHpAemB6cHqAepB6oHqAeqB6sHrAetB64HrAeuB68HsAexB7IHsAeyB7MHtAe1B7YHtAe2B7cHAAABAAIAAgADAAAAAgAEAAMABQAGAAcABQAHAAgACQAKAAsACwAMAAkACwANAAwADgAPABAADgAQABEAEgATABQAEgAUABUAFgAXABgAFgAYABkAGgAbABwAGgAcAB0AHgAfACAAHgAgACEAIgAeACMAIgAjACQAJQAmACcAJQAnACgAKQAqACsAKQArACwALQAuAC8ALQAvADAAMQAyADMAMQAzADQANQA2ADcANQA3ADgAOQA6ADsAOQA7ADwAPQA+AD8APQA/AEAAQQBCAEMAQQBDAEQARQBGAEcARQBHAEgASQBKAEsASQBLAEwASwBNAEwATgBPAEkAUABOAEkATABQAEkAUABRAE4ATABSAFAAUgBTAFAATABUAFIAVQBWAFcAVQBXAFgAWQBaAFsAWQBbAFwAXQBeAF8AXQBfAGAAYQBiAGMAYQBjAGQAZQBmAGcAZQBnAGgAaQBqAGsAaQBrAGwAbQBuAG8AbQBvAHAAcQByAHMAcQBzAHQAdQB2AHcAdQB3AHgAeQB6AHsAeQB7AHwAfQB+AH8AfQB/AIAAgQCCAIMAgQCDAIQAhQCGAIcAhQCHAIgAiQCKAIsAiQCLAIwAjQCOAI8AjQCPAJAAkQCSAJMAkQCTAJQAlQCWAJcAlQCXAJgAmQCaAJsAmQCbAJwAnQCeAJ8AnQCfAKAAoQCiAKMAoQCjAKQApQCmAKcApQCnAKgAqQCqAKsAqQCrAKwArQCuAK8ArQCvALAAsQCyALMAsQCzALQAtQC2ALcAtQC3ALgAuQC1ALoAuQC6ALsAvAC5AL0AvAC9AL4AvwC8AMAAvwDAAMEAwgC/AMMAwgDDAMQAxQDGAMcAxQDHAMgAyQDKAMsAyQDLAMwAzQDOAM8AzQDPANAA0QDSANMA0QDTANQA1QDWANcA1QDXANgA2QDaANsA2QDbANwA3QDeAN8A3QDfAOAA4QDiAOMA4QDjAOQA5QDmAOcA5QDnAOgA6QDqAOsA6QDrAOwA7QDuAO8A7QDvAPAA8QDyAPMA8QDzAPQA9QD2APcA9QD3APgA+QD6APsA+QD7APwA/QD+AP8A/QD/AAABAQECAQMBAQEDAQQBBQEGAQcBBQEHAQgBCQEKAQsBCQELAQwBDQEOAQ8BDQEPARABEQESARMBEQETARQBFQERARYBFQEWARcBGAEZARoBGAEaARsBHAEdAR4BHAEeAR8BIAEhASIBIAEiASMBJAElASYBJAEmAScBKAEpASoBKAEqASsBLAEtAS4BLAEuAS8BMAExATIBMAEyATMBNAE1ATYBNAE2ATcBOAE5AToBOAE6ATsBPAE9AT4BPAE+AT8BQAFBAUIBQAFCAUMBRAFFAUYBRAFGAUcBSAFJAUoBSAFKAUsBTAFNAU4BTAFOAU8BUAFRAVIBUAFSAVMBVAFVAVYBVAFWAVcBWAFZAVoBWAFaAVsBXAFdAV4BXAFeAV8BYAFhAWIBYAFiAWMBZAFlAWYBZAFmAWcBaAFpAWoBaAFqAWsBbAFtAW4BbAFuAW8BcAFxAXIBcAFyAXMBdAF1AXYBdAF2AXcBeAF5AXoBeAF6AXsBfAF9AX4BfAF+AX8BgAGBAYIBgAGCAYMBhAGFAYYBhAGGAYcBiAGJAYoBiAGKAYsBjAGNAY4BjAGOAY8BkAGRAZIBkAGSAZMBlAGVAZYBlAGWAZcBmAGZAZoBmAGaAZsBnAGdAZ4BnAGeAZ8BoAGhAaIBoAGiAaMBpAGlAaYBpAGmAacBqAGpAaoBqAGqAasBrAGtAa4BrAGuAa8BsAGxAbIBsAGyAbMBtAG1AbYBtAG2AbcBuAG5AboBuAG6AbsBvAG9Ab4BvAG+Ab8BwAHBAcIBwAHCAcMBxAHFAcYBxAHGAccByAHJAcoByAHKAcsBzAHNAc4BzAHOAc8B0AHRAdIB0AHSAdMB1AHVAdYB1AHWAdcB2AHZAdoB2AHaAdsB3AHdAd4B3AHeAd8B4AHhAeIB4AHiAeMB5AHlAeYB5AHmAecB6AHpAeoB6AHqAesB7AHtAe4B7AHuAe8B8AHxAfIB8AHyAfMB9AH1AfYB9AH2AfcB+AH5AfoB+AH6AfsB/AH9Af4B/AH+Af8BAAIBAgICAAICAgMCBAIFAgYCBAIGAgcCCAIJAgoCCAIKAgsCDAINAg4CDAIOAg8CEAIRAhICEAISAhMCFAIVAhYCFAIWAhcCGAIZAhoCGAIaAhsCHAIdAh4CHAIeAh8CIAIhAiICIAIiAiMCJAIlAiYCJAImAicCKAIpAioCKAIqAisCLAItAi4CLAIuAi8CMAIxAjICMAIyAjMCNAI1AjYCNAI2AjcCOAI5AjoCOAI6AjsCPAI9Aj4CPAI+Aj8CQAJBAkICQAJCAkMCRAJFAkYCRAJGAkcCSAJJAkoCSAJKAksCTAJNAk4CTAJOAk8CUAJRAlICUAJSAlMCVAJVAlYCVAJWAlcCWAJZAloCWAJaAlsCXAJdAl4CXAJeAl8CYAJhAmICYAJiAmMCZAJlAmYCZAJmAmcCaAJpAmoCaAJqAmsCbAJtAm4CbAJuAm8CbgJwAm8CcQJyAmwCcwJxAmwCbwJzAmwCcwJ0AnECbwJ1AnMCdQJ2AnMCbwJ3AnUCeAJ5AnoCeAJ6AnsCfAJ9An4CfAJ+An8CgAKBAoICgAKCAoMChAKFAoYChAKGAocCiAKJAooCiAKKAosCjAKNAo4CjAKOAo8CkAKRApICkAKSApMClAKVApYClAKWApcCmAKZApoCmAKaApsCnAKdAp4CnAKeAp8CoAKhAqICoAKiAqMCpAKlAqYCpAKmAqcCqAKpAqoCqAKqAqsCrAKtAq4CrAKuAq8CsAKxArICsAKyArMCtAK1ArYCtAK2ArcCuAK5AroCuAK6ArsCvAK9Ar4CvAK+Ar8CwALBAsICwALCAsMCxALFAsYCxALGAscCyALJAsoCyALKAssCzALNAs4CzALOAs8C0ALRAtIC0ALSAtMC1ALVAtYC1ALWAtcC2ALZAtoC2ALaAtsC3ALdAt4C3ALeAt8C4ALhAuIC4ALiAuMC5ALlAuYC5ALmAucC6ALpAuoC6ALqAusC7ALtAu4C7ALuAu8C8ALxAvIC8ALyAvMC9AL1AvYC9AL2AvcC+AL5AvoC+AL6AvsC/AL9Av4C/AL+Av8CAAMBAwIDAAMCAwMDBAMFAwYDBAMGAwcDCAMJAwoDCAMKAwsDDAMNAw4DDAMOAw8DEAMRAxIDEAMSAxMDFAMVAxYDFAMWAxcDGAMZAxoDGAMaAxsDHAMdAx4DHAMeAx8DIAMhAyIDIAMiAyMDJAMlAyYDJAMmAycDKAMpAyoDKAMqAysDLAMtAy4DLAMuAy8DMAMxAzIDMAMyAzMDNAM1AzYDNAM2AzcDOAM5AzoDOAM6AzsDPAM9Az4DPAM+Az8DQANBA0IDQANCA0MDRANFA0YDRANGA0cDSANJA0oDSANKA0sDTANNA04DTANOA08DUANRA1IDUANSA1MDVANVA1YDVANWA1cDWANZA1oDWANaA1sDXANdA14DXANeA18DYANhA2IDYANiA2MDZANlA2YDZANmA2cDaANpA2oDaANqA2sDbANtA24DbANuA28DcANxA3IDcANyA3MDdAN1A3YDdAN2A3cDeAN5A3oDeAN6A3sDfAN9A34DfAN+A38DgAOBA4IDgAOCA4MDhAOFA4YDhAOGA4cDiAOJA4oDiAOKA4sDjAONA44DjAOOA48DkAORA5IDkAOSA5MDlAOVA5YDlAOWA5cDmAOZA5oDmAOaA5sDnAOdA54DnAOeA58DoAOhA6IDoAOiA6MDpAOlA6YDpAOmA6cDqAOpA6oDqAOqA6sDrAOtA64DrAOuA68DsAOxA7IDsAOyA7MDtAO1A7YDtAO2A7cDuAO5A7oDuAO6A7sDvAO9A74DvAO+A78DwAPBA8IDwAPCA8MDxAPFA8YDxAPGA8cDyAPJA8oDyAPKA8sDzAPNA84DzAPOA88D0APRA9ID0APSA9MD1APVA9YD1APWA9cD2APZA9oD2APaA9sD3APdA94D3APeA98D4APhA+ID4APiA+MD5APlA+YD5APmA+cD6APpA+oD6APqA+sD7APtA+4D7APuA+8D8APxA/ID8APyA/MD9AP1A/YD9AP2A/cD+AP5A/oD+AP6A/sD/AP9A/4D/AP+A/8DAAQBBAIEAAQCBAMEBAQFBAYEBAQGBAcECAQJBAoECAQKBAsEDAQNBA4EDAQOBA8EEAQRBBIEEAQSBBMEFAQVBBYEFAQWBBcEGAQZBBoEGAQaBBsEHAQdBB4EHAQeBB8EIAQhBCIEIAQiBCMEJAQlBCYEJAQmBCcEKAQpBCoEKAQqBCsELAQtBC4ELAQuBC8EMAQxBDIEMAQyBDMENAQ1BDYENAQ2BDcEOAQ5BDoEOAQ6BDsEPAQ9BD4EPAQ+BD8EQARBBEIEQARCBEMERARFBEYERARGBEcESARJBEoESARKBEsETARNBE4ETAROBE8EUARRBFIEUARSBFMEVARVBFYEVARWBFcEWARZBFoEWARaBFsEXARdBF4EXAReBF8EYARhBGIEYARiBGMEZARlBGYEZARmBGcEaARpBGoEaARqBGsEbARtBG4EbARuBG8EcARxBHIEcARyBHMEdAR1BHYEdAR2BHcEeAR5BHoEeAR6BHsEfAR9BH4EfAR+BH8EgASBBIIEgASCBIMEhASFBIYEhASGBIcEiASJBIoEiASKBIsEjASNBI4EjASOBI8EkASRBJIEkASSBJMElASVBJYElASWBJcEmASZBJoEmASaBJsEmgScBJsEnQSeBJgEnwSdBJgEmwSfBJgEnwSgBJ0EmwShBJ8EoQSiBJ8EmwSjBKEEpASlBKYEpASmBKcEqASpBKoEqASqBKsErAStBK4ErASuBK8EsASxBLIEsASyBLMEtAS1BLYEtAS2BLcEuAS5BLoEuAS6BLsEvAS9BL4EvAS+BL8EwATBBMIEwATCBMMExATFBMYExATGBMcEyATJBMoEyATKBMsEzATNBM4EzATOBM8E0ATRBNIE0ATSBNME1ATVBNYE1ATWBNcE2ATZBNoE2ATaBNsE3ATdBN4E3ATeBN8E4AThBOIE4ATiBOME5ATlBOYE5ATmBOcE6ATpBOoE6ATqBOsE7ATtBO4E7ATuBO8E8ATxBPIE8ATyBPME9AT1BPYE9AT2BPcE+AT5BPoE+AT6BPsE/AT9BP4E/AT+BP8EAAUBBQIFAAUCBQMFBAUFBQYFBAUGBQcFCAUJBQoFCAUKBQsFDAUNBQ4FDAUOBQ8FEAURBRIFEAUSBRMFFAUVBRYFFAUWBRcFGAUZBRoFGAUaBRsFHAUdBR4FHAUeBR8FIAUhBSIFIAUiBSMFJAUlBSYFJAUmBScFKAUpBSoFKAUqBSsFLAUtBS4FLAUuBS8FMAUxBTIFMAUyBTMFNAU1BTYFNAU2BTcFOAU5BToFOAU6BTsFPAU9BT4FPAU+BT8FQAVBBUIFQAVCBUMFRAVFBUYFRAVGBUcFSAVEBUkFSAVJBUoFSwVIBUwFSwVMBU0FTgVLBU8FTgVPBVAFUQVOBVIFUQVSBVMFVAVVBVYFVAVWBVcFWAVZBVoFWAVaBVsFXAVdBV4FXAVeBV8FYAVhBWIFYAViBWMFZAVlBWYFZAVmBWcFaAVpBWoFaAVqBWsFbAVtBW4FbAVuBW8FcAVxBXIFcAVyBXMFdAV1BXYFdAV2BXcFeAV5BXoFeAV6BXsFfAV9BX4FfAV+BX8FgAWBBYIFgAWCBYMFhAWFBYYFhAWGBYcFiAWJBYoFiAWKBYsFjAWNBY4FjAWOBY8FkAWRBZIFkAWSBZMFlAWVBZYFlAWWBZcFmAWZBZoFmAWaBZsFnAWdBZ4FnAWeBZ8FoAWhBaIFoAWiBaMFpAWlBaYFpAWmBacFqAWpBaoFqAWqBasFrAWtBa4FrAWuBa8FsAWxBbIFsAWyBbMFtAW1BbYFtAW2BbcFuAW5BboFuAW6BbsFvAW9Bb4FvAW+Bb8FwAXBBcIFwAXCBcMFxAXFBcYFxAXGBccFyAXJBcoFyAXKBcsFzAXNBc4FzAXOBc8F0AXRBdIF0AXSBdMF1AXVBdYF1AXWBdcF2AXZBdoF2AXaBdsF3AXdBd4F3AXeBd8F4AXhBeIF4AXiBeMF5AXlBeYF5AXmBecF6AXpBeoF6AXqBesF7AXtBe4F7AXuBe8F8AXxBfIF8AXyBfMF9AX1BfYF9AX2BfcF+AX5BfoF+AX6BfsF/AX9Bf4F/AX+Bf8FAAYBBgIGAAYCBgMGBAYFBgYGBAYGBgcGCAYJBgoGCAYKBgsGDAYNBg4GDAYOBg8GEAYRBhIGEAYSBhMGFAYVBhYGFAYWBhcGGAYZBhoGGAYaBhsGHAYdBh4GHAYeBh8GIAYhBiIGIAYiBiMGJAYlBiYGJAYmBicGKAYpBioGKAYqBisGLAYtBi4GLAYuBi8GMAYxBjIGMAYyBjMGNAY1BjYGNAY2BjcGOAY5BjoGOAY6BjsGPAY9Bj4GPAY+Bj8GQAZBBkIGQAZCBkMGRAZFBkYGRAZGBkcGSAZJBkoGSAZKBksGTAZNBk4GTAZOBk8GUAZRBlIGUAZSBlMGVAZVBlYGVAZWBlcGWAZZBloGWAZaBlsGXAZdBl4GXAZeBl8GYAZhBmIGYAZiBmMGZAZlBmYGZAZmBmcGaAZpBmoGaAZqBmsGbAZtBm4GbAZuBm8GcAZxBnIGcAZyBnMGdAZ1BnYGdAZ2BncGeAZ5BnoGeAZ6BnsGfAZ9Bn4GfAZ+Bn8GgAaBBoIGgAaCBoMGhAaFBoYGhAaGBocGiAaJBooGiAaKBosGjAaNBo4GjAaOBo8GkAaRBpIGkAaSBpMGlAaVBpYGlAaWBpcGmAaZBpoGmAaaBpsGnAadBp4GnAaeBp8GoAahBqIGoAaiBqMGpAalBqYGpAamBqcGqAapBqoGqAaqBqsGrAatBq4GrAauBq8GsAaxBrIGsAayBrMGtAa1BrYGtAa2BrcGuAa5BroGuAa6BrsGvAa9Br4GvAa+Br8GwAbBBsIGwAbCBsMGwgbEBsMGxQbGBsAGxwbFBsAGwwbHBsAGxwbIBsUGwwbJBscGyQbKBscGwwbLBskGzAbNBs4GzAbOBs8G0AbRBtIG0AbSBtMG1AbVBtYG1AbWBtcG2AbZBtoG2AbaBtsG3AbdBt4G3AbeBt8G4AbhBuIG4AbiBuMG5AblBuYG5AbmBucG6AbpBuoG6AbqBusG7AbtBu4G7AbuBu8G8AbxBvIG8AbyBvMG9Ab1BvYG9Ab2BvcG+Ab5BvoG+Ab6BvsG/Ab9Bv4G/Ab+Bv8GAAcBBwIHAAcCBwMHBAcFBwYHBAcGBwcHCAcJBwoHCAcKBwsHDAcNBw4HDAcOBw8HEAcRBxIHEAcSBxMHFAcVBxYHFAcWBxcHGAcZBxoHGAcaBxsHHAcdBx4HHAceBx8HIAchByIHIAciByMHJAclByYHJAcmBycHKAcpByoHKAcqBysHLActBy4HLAcuBy8HMAcxBzIHMAcyBzMHNAc1BzYHNAc2BzcHOAc5BzoHOAc6BzsHPAc9Bz4HPAc+Bz8HQAdBB0IHQAdCB0MHRAdFB0YHRAdGB0cHSAdJB0oHSAdKB0sHTAdNB04HTAdOB08HUAdRB1IHUAdSB1MHVAdVB1YHVAdWB1cHWAdZB1oHWAdaB1sHXAddB14HXAdeB18HYAdhB2IHYAdiB2MHZAdlB2YHZAdmB2cHaAdpB2oHaAdqB2sHbAdtB24HbAduB28HcAdxB3IHcAdyB3MHdAd1B3YHdAd2B3cHeAd5B3oHeAd6B3sHfAd9B34HfAd+B38HgAeBB4IHgAeCB4MHhAeFB4YHhAeGB4cHiAeJB4oHiAeKB4sHjAeNB44HjAeOB48HkAeRB5IHkAeSB5MHlAeVB5AHlAeWB5UHlweYB5QHlweZB5gHmgebB5wHmgecB50HngefB6AHngegB6EHogejB6QHogekB6UHpgenB6gHpgeoB6kHqgerB6wHqgesB60HrgevB7AHrgewB7EHsgezB7QHsge0B7UHtge3B7gHtge4B7kHuge7B7wHuge8B70Hvge/B8AHvgfAB8EHwgfDB8QHwgfEB8UHxgfHB8gHxgfIB8kHygfLB8wHygfMB80HzgfPB9AHzgfQB9EH0gfTB9QH0gfUB9UH1gfXB9gH1gfYB9kH2gfbB9wH2gfcB90H3gffB+AH3gfgB+EH4gfjB+QH4gfkB+UH5gfnB+gH5gfoB+kH6gfrB+wH6gfsB+0H7gfvB/AH7gfwB/EH8gfzB/QH8gf0B/UH9gf3B/gH9gf4B/kH+gf7B/wH+gf8B/0H/gf/BwAI/gcACAEIAggDCAQIAggECAUIBggHCAgIBggICAkICggLCAwICggMCA0IDggPCBAIDggQCBEIEggTCBQIEggUCBUIFggXCBgIFggYCBkIGggbCBwIGggcCB0IHggfCCAIHgggCCEIIggjCCQIIggkCCUIJggnCCgIJggoCCkIKggrCCwIKggsCC0ILggvCDAILggwCDEIMggzCDQIMgg0CDUINgg3CDgINgg4CDkIOgg7CDwIOgg8CD0IPgg/CEAIPghACEEIQghDCEQIQghECEUIRghHCEgIRghICEkISghLCEwISghMCE0ITghPCFAITghQCFEIUghTCFQIUghUCFUIVghXCFgIVghYCFkIWghbCFwIWghcCF0IXghfCGAIXghgCGEIYghjCGQIYghkCGUIZghnCGgIZghoCGkIaghrCGwIaghsCG0IbghvCHAIbghwCHEIcghzCHQIcgh0CHUIdgh3CHgIdgh4CHkIegh7CHwIegh8CH0Ifgh/CIAIfgiACIEIggiDCIQIggiECIUIhgiHCIgIhgiICIkIigiLCIwIigiMCI0IjgiPCJAIjgiQCJEIkgiTCJQIkgiUCJUIlgiXCJgIlgiYCJkImgibCJwImgicCJ0IngifCKAIngigCKEIogijCKQIogikCKUIpginCKgIpgioCKkIqgirCKwIqgisCK0IrgivCLAIrgiwCLEIsgizCLQIsgi0CLUIAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFwAYABkAFwAZABoAGwAcAB0AGwAdAB4AHwAgACEAHwAhACIAIwAkACUAIwAlACYAJwAoACkAJwApACoAKwAsAC0AKwAtAC4ALwAwADEALwAxADIAMwA0ADUAMwA1ADYANwA4ADkANwA5ADoAOwA8AD0AOwA9AD4APwBAAEEAQgBDAEQAQgBEAEUARgBHAEgARgBIAEkASgBLAEwASgBMAE0ATgBPAFAATgBQAFEAUgBTAFQAUgBUAFUA\");\n\n//# sourceURL=webpack:///./assets/SUV.glb?");

/***/ }),

/***/ "./assets/SportsCar.glb":
/*!******************************!*\
  !*** ./assets/SportsCar.glb ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAACUdQEApBEAAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjkxMDkyfV0sImFzc2V0Ijp7InZlcnNpb24iOiIyLjAiLCJnZW5lcmF0b3IiOiJnbHRmcGFjayAwLjE2In0sImV4dGVuc2lvbnNVc2VkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiJdLCJleHRlbnNpb25zUmVxdWlyZWQiOlsiS0hSX21lc2hfcXVhbnRpemF0aW9uIl0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjAsImJ5dGVMZW5ndGgiOjQ4NDY0LCJieXRlU3RyaWRlIjo4LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NDg0NjQsImJ5dGVMZW5ndGgiOjI0MjMyLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NzI2OTYsImJ5dGVMZW5ndGgiOjE4Mzk2LCJ0YXJnZXQiOjM0OTYzfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjE4OTgsInR5cGUiOiJWRUMzIiwibWluIjpbMCw3NjcsNjVdLCJtYXgiOls3NDQ5LDQ3NzAsMTYyNzhdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjAsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoxODk4LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjI4MDgsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjE1MTg0LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6NzIzLCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzI3OCw3NDcsMF0sIm1heCI6WzcxNzEsMTQ0MiwxNjM4M119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6NzU5MiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjcyMywidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjU2MTYsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxMTA0LCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyMDk2OCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjEzMCwidHlwZSI6IlZFQzMiLCJtaW4iOls3NzcsMzI0OSwyNjA2XSwibWF4IjpbNjY3Miw0NTk5LDExNDQxXX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoxMDQ4NCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjEzMCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjc4MjQsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxODYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjIyMDA4LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjIyNywidHlwZSI6IlZFQzMiLCJtaW4iOls0NDIsMzY0LDI0N10sIm1heCI6WzcwMzksMjMzNiwxMzgwNl19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MTEwMDQsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyMjI3LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6ODE5NiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjMzOTYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjM5ODI0LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjIsInR5cGUiOiJWRUMzIiwibWluIjpbOTUzLDE3MjcsMTUyMDZdLCJtYXgiOls2NDk2LDIyNjMsMTYwMDldfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjE5OTEyLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MjIsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjoxNDk4OCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjMwLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0Ijo0MDAwMCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjE0LCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzEzODksMjU0OCw1OTVdLCJtYXgiOls2MDYwLDMwODIsMTA3OF19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MjAwMDAsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoxNCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE1MDQ4LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTgsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjQwMTEyLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTA0NCwidHlwZSI6IlZFQzMiLCJtaW4iOlszOTAsMCwxOTQxXSwibWF4IjpbNzA5MCwyMTQ2LDE0MTcwXX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoyMDA1NiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjEwNDQsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjoxNTA4NCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjE2NTYsInR5cGUiOiJTQ0FMQVIifV0sIm1hdGVyaWFscyI6W3sibmFtZSI6Ik9yYW5nZSIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNzk5MTAyNzgzLDAuMzMyNDUxNTUyLDAuMTA3MDIzMTA1LDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiRGFya09yYW5nZSIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNjk4MTg0MzcxLDAuMjkxNTQ3ODA1LDAuMDk0NTQzNjIwOSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IldpbmRvd3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjAzNTYwMTMxNzksMC4wMzU2MDEzMTc5LDAuMDM1NjAxMzE3OSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkdyZXkiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjIwMTU1NjI4LDAuMjAxNTU2MjgsMC4yMDE1NTYyOCwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkhlYWRsaWdodHMiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjc5OTEwMjc4MywwLjYwNTI3NTMzMywwLjE3MzIwNDYwMSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IlRhaWxMaWdodHMiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjc5OTEwMjc4MywwLjA5MzA1ODk3MzYsMC4wNzQyMTM1NzkzLDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiQmxhY2siLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjAxMzcwMjA4NjIsMC4wMTM3MDIwODYyLDAuMDEzNzAyMDg2MiwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9XSwibWVzaGVzIjpbeyJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowLCJOT1JNQUwiOjF9LCJtb2RlIjo0LCJpbmRpY2VzIjoyLCJtYXRlcmlhbCI6MH0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjozLCJOT1JNQUwiOjR9LCJtb2RlIjo0LCJpbmRpY2VzIjo1LCJtYXRlcmlhbCI6MX0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjo2LCJOT1JNQUwiOjd9LCJtb2RlIjo0LCJpbmRpY2VzIjo4LCJtYXRlcmlhbCI6Mn0seyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjo5LCJOT1JNQUwiOjEwfSwibW9kZSI6NCwiaW5kaWNlcyI6MTEsIm1hdGVyaWFsIjozfSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjEyLCJOT1JNQUwiOjEzfSwibW9kZSI6NCwiaW5kaWNlcyI6MTQsIm1hdGVyaWFsIjo0fSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjE1LCJOT1JNQUwiOjE2fSwibW9kZSI6NCwiaW5kaWNlcyI6MTcsIm1hdGVyaWFsIjo1fSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjE4LCJOT1JNQUwiOjE5fSwibW9kZSI6NCwiaW5kaWNlcyI6MjAsIm1hdGVyaWFsIjo2fV19XSwibm9kZXMiOlt7Im1lc2giOjAsInRyYW5zbGF0aW9uIjpbLTAuOTAzMTY4MjYxLC0wLjAxMDI4NDY0NzMsLTEuOTg0NjMxMDZdLCJzY2FsZSI6WzAuMDAwMjQyMjQ1NDQyLDAuMDAwMjQyMjQ1NDQyLDAuMDAwMjQyMjQ1NDQyXX1dLCJzY2VuZXMiOlt7Im5hbWUi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KTMAADsbSQaILwAAOxvSBxAxAACyG/AGkzEAALIbxwVpMAAAOxuQABAxAAA7GxgCiC8AALIbmwJpMAAAshtxAZMxAAA7G9IHEDEAADsbYggpMwAAshtdBykzAACyG/AGkzEAADsbYggpMwAAOxvSB0E1AACyG/AGvzQAALIbXQcpMwAAOxvSB0E1AAA7G0kGyjYAALIbxwXoNQAAshvwBr80AAA7G0kGyjYAADsbMQRaNwAAshsxBFU2AACyG8cF6DUAALIb9gYpMwAAshuXBow0AABSG5cGjDQAAFIb9gYpMwAAshsFASkzAACyG3EBkzEAALIbywHGMQAAshvOAsMwAACyG2wBKTMAALIbmwJpMAAAshsxBGQwAACyGzEE/S8AALIbcQG/NAAAshvLAYw0AACyG5sC6DUAALIbzgKPNQAAshvwBpMxAACyG10HKTMAALIb9gYpMwAAshuXBsYxAACyG8cF6DUAALIbMQRVNgAAshsxBO41AACyG5MFjzUAALIbxwVpMAAAshvwBpMxAACyG5cGxjEAALIbkwXDMAAAshvwBr80AACyG8cF6DUAALIbkwWPNQAAshuXBow0AACyGzEE/S8AALIbxwVpMAAAshuTBcMwAACyGzEEZDAAALIbXQcpMwAAshvwBr80AACyG5cGjDQAALIb9gYpMwAAshsxBO41AACyG84CjzUAAFIbzgKPNQAAUhsxBO41AACyG2wBKTMAALIbywHGMQAAUhvLAcYxAABSG2wBKTMAALIblwbGMQAAshv2BikzAABSG/YGKTMAAFIblwbGMQAAshuTBY81AACyGzEE7jUAAFIbMQTuNQAAUhuTBY81AACyG8sBjDQAALIbbAEpMwAAUhtsASkzAABSG8sBjDQAALIbkwXDMAAAshuXBsYxAABSG5cGxjEAAFIbkwXDMAAAshvOAsMwAACyGzEEZDAAAFIbMQRkMAAAUhvOAsMwAACyG5cGjDQAALIbkwWPNQAAUhuTBY81AABSG5cGjDQAALIbzgKPNQAAshvLAYw0AABSG8sBjDQAAFIbzgKPNQAAshsxBGQwAACyG5MFwzAAAFIbkwXDMAAAUhsxBGQwAACyG8sBxjEAALIbzgLDMAAAUhvOAsMwAABSG8sBxjEAAKoaDQS/NQAAqhryAnM1AADOGsADBjQAAM4aFgQdNAAAqhpwBXM1AACqGlQEvzUAAM4aTAQdNAAAzhqiBAY0AACqGmgGkDQAAKoamAVgNQAAzhrABPczAADOGv8EuDMAAKoaxwZMMwAAqhp7Bmg0AADOGg4FmjMAAM4aJQVEMwAAqhqYBfIwAACqGmgGwjEAAM4a/wSaMgAAzhrABFsyAACqGnsG6jEAAKoaxwYFMwAAzholBQ4zAADOGg4FuDIAAKoaVASTMAAAqhpwBd8wAADOGqIETDIAAM4aTAQ1MgAAqhryAt8wAACqGg0EkzAAAM4aFgQ1MgAAzhrAA0wyAACqGvoBwjEAAKoaygLyMAAAzhqiA1syAADOGmMDmjIAAKoamgEFMwAAqhrnAeoxAADOGlQDuDIAAM4aPQMOMwAAqhrnAWg0AACqGpoBTDMAAM4aPQNEMwAAzhpUA5ozAACqGsoCYDUAAKoa+gGQNAAAzhpjA7gzAADOGqID9zMAAB0bxgO/MwAAHRubA5MzAAAyG8IDfTMAADIb3QOYMwAAHRubA78yAAAdG8YDkzIAADIb3QO6MgAAMhvCA9UyAAAdG5sEkzIAAB0bxwS/MgAAMhugBNUyAAAyG4UEujIAAB0bxwSTMwAAHRubBL8zAAAyG4UEmDMAADIboAR9MwAAlAQxBPguAACUBBgCiC8AAP0BGAKILwAA/QExBPguAACUBBgCiC8AAJQEkAAQMQAA/QGQABAxAAD9ARgCiC8AAJQEkAAQMQAAlAQAACkzAAD9AQAAKTMAAP0BkAAQMQAAlAQAACkzAACUBJAAQTUAAP0BkABBNQAA/QEAACkzAACUBJAAQTUAAJQEGALKNgAA/QEYAso2AAD9AZAAQTUAAJQEGALKNgAAlAQxBFo3AAD9ATEEWjcAAP0BGALKNgAAlAQxBFo3AACUBEkGyjYAAP0BSQbKNgAA/QExBFo3AACUBEkGyjYAAJQE0gdBNQAA/QHSB0E1AAD9AUkGyjYAAJQE0gdBNQAAlARiCCkzAAD9AWIIKTMAAP0B0gdBNQAAlARiCCkzAACUBNIHEDEAAP0B0gcQMQAA/QFiCCkzAAD9ATEEWjcAAIYBMQRVNgAAhgGbAug1AAD9ARgCyjYAAJQE0gcQMQAAlARJBogvAAD9AUkGiC8AAP0B0gcQMQAAlARJBogvAACUBDEE+C4AAP0BMQT4LgAA/QFJBogvAACUBBgCiC8AAJQEMQT4LgAAlARJBogvAACUBGIIKTMAAJQE0gcQMQAAlAQAACkzAACUBJAAEDEAAJQEGALKNgAAlASQAEE1AACUBEkGyjYAAJQEMQRaNwAAlATSB0E1AACGATEEVTYAAIYBMQTuNQAAhgHOAo81AACGAZsC6DUAAP0BGALKNgAAhgGbAug1AACGAXEBvzQAAP0BkABBNQAA/QGQAEE1AACGAXEBvzQAAIYBBQEpMwAA/QEAACkzAAD9ATEE+C4AAIYBMQT9LwAAhgHHBWkwAAD9AUkGiC8AAP0BGAKILwAAhgGbAmkwAACGATEE/S8AAP0BMQT4LgAA/QEAACkzAACGAQUBKTMAAIYBcQGTMQAA/QGQABAxAAD9AUkGiC8AAIYBxwVpMAAAhgHwBpMxAAD9AdIHEDEAAP0BkAAQMQAAhgFxAZMxAACGAZsCaTAAAP0BGAKILwAA/QHSBxAxAACGAfAGkzEAAIYBXQcpMwAA/QFiCCkzAAD9AWIIKTMAAIYBXQcpMwAAhgHwBr80AAD9AdIHQTUAAP0B0gdBNQAAhgHwBr80AACGAccF6DUAAP0BSQbKNgAA/QFJBso2AACGAccF6DUAAIYBMQRVNgAA/QExBFo3AACGAfYGKTMAAOcB9gYpMwAA5wGXBow0AACGAZcGjDQAAIYBBQEpMwAAhgFsASkzAACGAcsBxjEAAIYBcQGTMQAAhgFxAb80AACGAcsBjDQAAIYB8AaTMQAAhgGXBsYxAACGAfYGKTMAAIYBXQcpMwAAhgHHBeg1AACGAZMFjzUAAIYBMQTuNQAAhgExBFU2AACGAccFaTAAAIYBkwXDMAAAhgGXBsYxAACGAfAGkzEAAIYBmwJpMAAAhgHOAsMwAACGATEEZDAAAIYBMQT9LwAAhgHwBr80AACGAZcGjDQAAIYBkwWPNQAAhgHHBeg1AACGAZsC6DUAAIYBzgKPNQAAhgHLAYw0AACGAXEBvzQAAIYBMQT9LwAAhgExBGQwAACGAZMFwzAAAIYBxwVpMAAAhgFxAZMxAACGAcsBxjEAAIYBzgLDMAAAhgGbAmkwAACGAV0HKTMAAIYB9gYpMwAAhgGXBow0AACGAfAGvzQAAIYBMQTuNQAA5wExBO41AADnAc4CjzUAAIYBzgKPNQAAhgFsASkzAADnAWwBKTMAAOcBywHGMQAAhgHLAcYxAACGAZcGxjEAAOcBlwbGMQAA5wH2BikzAACGAfYGKTMAAIYBkwWPNQAA5wGTBY81AADnATEE7jUAAIYBMQTuNQAAhgHLAYw0AADnAcsBjDQAAOcBbAEpMwAAhgFsASkzAACGAZMFwzAAAOcBkwXDMAAA5wGXBsYxAACGAZcGxjEAAIYBzgLDMAAA5wHOAsMwAADnATEEZDAAAIYBMQRkMAAAhgGXBow0AADnAZcGjDQAAOcBkwWPNQAAhgGTBY81AACGAc4CjzUAAOcBzgKPNQAA5wHLAYw0AACGAcsBjDQAAIYBMQRkMAAA5wExBGQwAADnAZMFwzAAAIYBkwXDMAAAhgHLAcYxAADnAcsBxjEAAOcBzgLDMAAAhgHOAsMwAACPAg0EvzUAAGsCFgQdNAAAawLAAwY0AACPAvICczUAAI8CcAVzNQAAawKiBAY0AABrAkwEHTQAAI8CVAS/NQAAjwJoBpA0AABrAv8EuDMAAGsCwAT3MwAAjwKYBWA1AACPAscGTDMAAGsCJQVEMwAAawIOBZozAACPAnsGaDQAAI8CmAXyMAAAawLABFsyAABrAv8EmjIAAI8CaAbCMQAAjwJ7BuoxAABrAg4FuDIAAGsCJQUOMwAAjwLHBgUzAACPAlQEkzAAAGsCTAQ1MgAAawKiBEwyAACPAnAF3zAAAI8C8gLfMAAAawLAA0wyAABrAhYENTIAAI8CDQSTMAAAjwL6AcIxAABrAmMDmjIAAGsCogNbMgAAjwLKAvIwAACPApoBBTMAAGsCPQMOMwAAawJUA7gyAACPAucB6jEAAI8C5wFoNAAAawJUA5ozAABrAj0DRDMAAI8CmgFMMwAAjwLKAmA1AABrAqID9zMAAGsCYwO4MwAAjwL6AZA0AAAbAsYDvzMAAAcC3QOYMwAABwLCA30zAAAbApsDkzMAABsCmwO/MgAABwLCA9UyAAAHAt0DujIAABsCxgOTMgAAGwKbBJMyAAAHAoUEujIAAAcCoATVMgAAGwLHBL8yAAAbAscEkzMAAAcCoAR9MwAABwKFBJgzAAAbApsEvzMAAEsMmgBLDJoASwyaAEsMmgB/AAAAfwAAAH8AAAB/AAAANHQIADR0CAA0dAgANHQIAGNLGwBjSxsAY0sbAGNLGwAAfwcAAH8HAAB/BwAAfwcAeRzmAHkc5gB5HOYAeRzmAHkc5gALFYMACxWDAAsVgwALFYMAIxyJACMciQAjHIkAIxyJABoFfAAaBXwAGgV8ABoFfAAGeSYABnkmAAZ5JgAGeSYAAP+BAAD/gQAA/4EAAP+BAH8AAgB/AAIAfwACAH8AAgACdc4AAnXOAAJ1zgACdc4AakUFAGpFBQBqRQUAakUFAAJ/CgACfwoAAn8KAAJ/CgBtQgQAbUIEAG1CBABtQgQAZU0KAGVNCgBlTQoAZU0KAAFyOAABcjgAAXI4AAFyOAA1cB0ANXAdADVwHQA1cB0A/iWHAP4lhwD+JYcA/iWHAGhIBwBoSAcAaEgHAGhIBwABfwYAAX8GAAF/BgABfwYAfwL7AH8C+wB/AvsAfwL7AHM2/QBzNv0Aczb9AHM2/QB+/fUAfv31AH799QB+/fUAbj8KAG4/CgBuPwoAbj8KAHYs8QB2LPEAdizxAHYs8QD7a0UA+2tFAPtrRQD7a0UAffXqAH316gB99eoAffXqAH4H8gB+B/IAfgfyAH4H8gBjTRMAY00TAGNNEwBjTRMAdS/tAHUv7QB1L+0AdS/tAG4+BwBuPgcAbj4HAG4+BwABXlUAAV5VAAFeVQABXlUAay8wAGsvMABrLzAAE1xWABNcVgATXFYAE1xWAACD7AAAg+wAAIPsAACD7AB+9/MAfvfzAH738wB+9/MAAYPsAAGD7AABg+wAAYPsAH37FwB9+xcAffsXAH37FwACfRYAAn0WAAJ9FgACfRYAZUwQAGVMEABlTBAAZUwQAAAWfQAAFn0AABZ9AAAWfQB/+wYAf/sGAH/7BgB98xEAffMRAH3zEQB98xEAf/sGAH/7BgB/+wYAf/sGAH/8BQB//AUAf/wFAH/8BQB/+QUAf/kFAH/5BQB/+QUAf/8IAH//CAB//wgAf/8IAADxggAA8YIAAPGCAADxggAAnbAAAJ2wAACdsAAAnbAAAPB+AADwfgAA8H4AAPB+AP6FHwD+hR8A/oUfAP6FHwD+htsA/obbAP6G2wD+htsAAKVZAAClWQAApVkAAKVZAH/9CwB//QsAf/0LAH/9CwBvwwQAb8MEAG/DBAB+8AgAfvAIAH7wCAB+8AgAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAABF+BwARfgcAEX4HABF+BwAMczQADHM0AAxzNAAMczQAA38FAAN/BQADfwUAA38FAP9zNgD/czYA/3M2AP9zNgAQfvUAEH71ABB+9QAQfvUAAX/1AAF/9QABf/UAAX/1AAd52wAHedsAB3nbAAd52wABdtEAAXbRAAF20QABdtEAAHPKAABzygAAc8oAAHPKAHUyAAB1MgAAdTIAAHUyAABqQOYAakDmAGpA5gBqQOYAbEMAAGxDAABsQwAAbEMAAGtF/gBrRf4Aa0X+AGtF/gAJNY0ACTWNAAk1jQAJNY0AIjKQACIykAAiMpAAIjKQAEEblgBBG5YAQRuWAEEblgD/Oo8A/zqPAP86jwD/Oo8Ah/QkAIf0JACH9CQAh/QkAP/GcQD/xnEA/8ZxAP/GcQD+xnEA/sZxAP7GcQD+xnEAB3E5AAdxOQAHcTkAB3E5ABRvOwAUbzsAFG87ABRvOwDCb/0Awm/9AMJv/QDCb/0A8A19APANfQDwDX0A8A19AMFuAADBbgAAwW4AAMFuAAA6osEAOqLBADqiwQA6osEAaEkGAGhJBgBoSQYAaEkGAG4/BABuPwQAbj8EAG4/BABkTgwAZE4MAGRODABkTgwACeKFAAnihQAJ4oUACeKFAMdyAADHcgAAx3IAAMdyAADIcgYAyHIGAMhyBgDIcgYAOKxNADisTQA4rE0AOKxNAGBS8wBgUvMAYFLzAGBS8wBoSfkAaEn5AGhJ+QBoSfkAWln5AFpZ+QBaWfkAWln5AHQz9AB0M/QAdDP0AHQz9AACgvEAAoLxAAKC8QACgvEAfvfzAH738wB+9/MAfvfzAACC8gAAgvIAAILyAACC8gB2LwQAdi8EAHYvBAB88+kAfPPpAHzz6QB88+kAfgXyAH4F8gB+BfIAfgXyAAFzygABc8oAAXPKAAFzygAEdc4ABHXOAAR1zgAEdc4AXlPuAF5T7gBeU+4Abj7zAG4+8wBuPvMAfATlAHwE5QB8BOUAfATlAAHHcgABx3IAAcdyAAHHcgAFupYABbqWAAW6lgAFupYAAIbbAACG2wAAhtsAAIbbAACFHwAAhR8AAIUfAACFHwAB13gAAdd4AAHXeAAB13gAAKxfAACsXwAArF8AAKxfAH728wB+9vMAfvbzAH728wB///gAf//4AH//+AB/AfYAfwH2AH8B9gB//PkAf/z5AH/8+QB/APgAfwD4AH8A+AB/APgAfv30AH799AB+/fQAfvfyAH738gB+9/IAfvfyAH/+9QB//vUAf/71AH/+9QB//fcAf/33AH/99wB//fcAfvX4AH71+AB+9fgAfvX4AIb1IwCG9SMAhvUjAIb1IwDlOpIA5TqSAOU6kgDlOpIA6hJ8AOoSfADqEnwA6hJ8AEiY/QBImP0ASJj9AEiY/QA3qbYAN6m2ADeptgA3qbYATZsLAE2bCwBNmwsATZsLAAHpgwAB6YMAAemDAAHpgwAY43kAGON5ABjjeQAY43kASZwaAEmcGgBJnBoASZwaAIT35wCE9+cAhPfnAIT35wD7M3QA+zN0APszdAD7M3QAAM2MAADNjAAAzYwAAM2MAPYzdAD2M3QA9jN0APYzdAAAdc4AAHXOAAB1zgAAdc4A/3PLAP9zywD/c8sA/3PLAPdzywD3c8sA93PLAGBR7gBgUe4AYFHuAGtD9gBrQ/YAa0P2AHL9NwBy/TcAcv03AHL9NwB2BS8AdgUvAHYFLwB2BS8Ad/0sAHf9LAB3/SwAd/0sAH/4+QB/+PkAf/j5AH/4+QB++vAAfvrwAH768AB++vAAfvrzAH768wB++vMAfvrzAAPmhAAD5oQAA+aEAAPmhAB7Bd8AewXfAHsF3wB7Bd8Afv0LAH79CwB+/QsAfv0LAADsgwAA7IMAAOyDAADsgwB++w4AfvsOAH77DgB++w4Afv3yAH798gB+/fIAfv3yACQAhgAkAIYAJACGACQAhgB/AvkAfwL5AH8C+QB/AvkA+xmEAPsZhAD7GYQA+xmEAH//AgB//wIAf/8CAH//AgBPqTEAT6kxAE+pMQBPqTEADACCAAwAggAMAIIADACCAH8AAAB/AAAAfwAAAH8AAAB+/vEAfv7xAH7+8QB+/vEAUgCfAFIAnwBSAJ8AUgCfABwwcgAcMHIAHDByABwwcgAAfRcAAH0XAAB9FwAAfRcAAH4MAAB+DAAAfgwAAH4MAAB/BQAAfwUAAH8FAAB/BQABfRkAAX0ZAAF9GQABfRkANXIVADVyFQA1chUANXIVAEtiHgBLYh4AS2IeAEtiHgAeAHsAHgB7AB4AewBOBGQATgRkAE4EZABOBGQAIB13ACAddwAgHXcAIB13ACkpcQApKXEAKSlxACkpcQCTAEIAkwBCAJMAQgCTAEIAggD1AIIA9QCCAPUAggD1AGAEUwBgBFMAYARTAGAEUwBCAG0AQgBtAEIAbQBCAG0A3YgXAN2IFwDdiBcA3YgXAAB/AAAAfwAAAH8AAAB/AABHsLwAR7C8AEewvABHsLwAngawAJ4GsACeBrAAngawAGD7UwBg+1MAYPtTAGD7UwAAgQAAAIEAAACBAAAAgQAACn74AAp++AAKfvgACn74AExHtwBMR7cATEe3AExHtwBGAGoARgBqAEYAagBGAGoARgBqAJYARgCWAEYAlgBGAJYARgCe/K8AnvyvAJ78rwCe/K8AugCWALoAlgC6AJYAugCWALoAlgAAgQAAAIEAAACBAAAAgQAARgBqAEYAagBGAGoARgBqALoAlgC6AJYAugCWALoAlgDdeBcA3XgXAN14FwDdeBcAAIEAAACBAAAAgQAAAIEAAB0AfAAdAHwAHQB8AB0AfAC+AJMAvgCTAL4AkwC+AJMAuV4vALleLwC5Xi8AuV4vAAp++gAKfvoACn76AAp++gCD+ewAg/nsAIP57ACD+ewAAM2MAADNjAAAzYwAAM2MAO586QDufOkA7nzpAO586QBjLkEAYy5BAGMuQQAlhwgAJYcIACWHCAAlhwgAouNQAKLjUACi41AAouNQAEZjJgBGYyYARmMmAEZjJgBG+2oARvtqAEb7agBG+2oAFFpYABRaWAAUWlgAFFpYADpVSgA6VUoAOlVKADpVSgBWrdcAVq3XAFat1wBWrdcAG4UQABuFEAAbhRAAG4UQAON78gDje/IA43vyAON78gD6e+AA+nvgAPp74AD6e+AAbz4EAG8+BABvPgQAbz4EAH/+BAB//gQAf/4EAH/+BAAC84IAAvOCAALzggAC84IA6X0AAOl9AADpfQAAfwAEAH8ABAB/AAQAfwAEAAUxdQAFMXUABTF1AAUxdQATXFUAE1xVABNcVQD/fwgA/38IAP9/CAD/fwgAAYH5AAGB+QABgfkAAYH5AAAWfQAAFn0AABZ9AAAWfQAAF30AABd9AAAXfQAAF30AABd9AAAXfQAAF30AABd9AP9/BwD/fwcA/38HAP9/BwCjqvYAo6r2AKOq9gCjqvYAAoTjAAKE4wAChOMAAoTjAAokhwAKJIcACiSHAAokhwALHYUACx2FAAsdhQALHYUA/nwdAP58HQD+fB0A/nwdAIEC9wCBAvcAgQL3AIEC9wD3eSUA93klAPd5JQD3eSUAdOsvAHTrLwB06y8AdOsvACExkAAhMZAAITGQACExkAAiL48AIi+PACIvjwAiL48AQRqWAEEalgBBGpYAQRqWAAuH3AALh9wAC4fcAAuH3ADWdhUA1nYVANZ2FQDWdhUAkPDHAJDwxwCQ8McAkPDHAAUAfwAFAH8ABQB/AAUAfwC1DJoAtQyaALUMmgC1DJoAgQAAAIEAAACBAAAAgQAAAMx0CADMdAgAzHQIAMx0CACdSxsAnUsbAJ1LGwCdSxsAAH8HAAB/BwAAfwcAAH8HAIcc5gCHHOYAhxzmAIcc5gCHHOYA9RWDAPUVgwD1FYMA9RWDAN0ciQDdHIkA3RyJAN0ciQDmBXwA5gV8AOYFfADmBXwA+nkmAPp5JgD6eSYA+nkmAAD/gQAA/4EAAP+BAAD/gQCBAAIAgQACAIEAAgCBAAIA/nXOAP51zgD+dc4A/nXOAJZFBQCWRQUAlkUFAJZFBQD+fwoA/n8KAP5/CgD+fwoAk0IEAJNCBACTQgQAk0IEAJtNCgCbTQoAm00KAJtNCgD/cjgA/3I4AP9yOAD/cjgAy3AdAMtwHQDLcB0Ay3AdAAIlhwACJYcAAiWHAAIlhwCYSAcAmEgHAJhIBwCYSAcA/38GAP9/BgD/fwYA/38GAIEC+wCBAvsAgQL7AIEC+wCNNv0AjTb9AI02/QCNNv0Agv31AIL99QCC/fUAgv31AJI/CgCSPwoAkj8KAJI/CgCKLPEAiizxAIos8QCKLPEABWtFAAVrRQAFa0UABWtFAIP16gCD9eoAg/XqAIP16gCCB/IAggfyAIIH8gCCB/IAnU0TAJ1NEwCdTRMAnU0TAIsv7QCLL+0Aiy/tAIsv7QCSPgcAkj4HAJI+BwCSPgcA/15VAP9eVQD/XlUA/15VAJUvMACVLzAAlS8wAO1cVgDtXFYA7VxWAO1cVgAAg+wAAIPsAACD7AAAg+wAgvfzAIL38wCC9/MAgvfzAP+D7AD/g+wA/4PsAP+D7ACD+xcAg/sXAIP7FwCD+xcA/n0WAP59FgD+fRYA/n0WAJtMEACbTBAAm0wQAJtMEAAAFn0AABZ9AAAWfQAAFn0AgfsGAIH7BgCB+wYAg/MRAIPzEQCD8xEAg/MRAIH7BgCB+wYAgfsGAIH7BgCB/AUAgfwFAIH8BQCB/AUAgfkFAIH5BQCB+QUAgfkFAIH/CACB/wgAgf8IAIH/CAAA8YIAAPGCAADxggAA8YIAAJ2wAACdsAAAnbAAAJ2wAADwfgAA8H4AAPB+AADwfgAChR8AAoUfAAKFHwAChR8AAobbAAKG2wAChtsAAobbAAClWQAApVkAAKVZAAClWQCB/QsAgf0LAIH9CwCB/QsAkcMEAJHDBACRwwQAgvAIAILwCACC8AgAgvAIAACBAAAAgQAAAIEAAACBAADvfgcA734HAO9+BwDvfgcA9HM0APRzNAD0czQA9HM0AP1/BQD9fwUA/X8FAP1/BQABczYAAXM2AAFzNgABczYA8H71APB+9QDwfvUA8H71AP9/9QD/f/UA/3/1AP9/9QD5edsA+XnbAPl52wD5edsA/3bRAP920QD/dtEA/3bRAABzygAAc8oAAHPKAABzygCLMgAAizIAAIsyAACLMgAAlkDmAJZA5gCWQOYAlkDmAJRDAACUQwAAlEMAAJRDAACVRf4AlUX+AJVF/gCVRf4A9zWNAPc1jQD3NY0A9zWNAN4ykADeMpAA3jKQAN4ykAC/G5YAvxuWAL8blgC/G5YAATqPAAE6jwABOo8AATqPAHn0JAB59CQAefQkAHn0JAABxnEAAcZxAAHGcQABxnEAAsZxAALGcQACxnEAAsZxAPlxOQD5cTkA+XE5APlxOQDsbzsA7G87AOxvOwDsbzsAPm/9AD5v/QA+b/0APm/9ABANfQAQDX0AEA19ABANfQA/bgAAP24AAD9uAAA/bgAAxqLBAMaiwQDGosEAxqLBAJhJBgCYSQYAmEkGAJhJBgCSPwQAkj8EAJI/BACSPwQAnE4MAJxODACcTgwAnE4MAPfihQD34oUA9+KFAPfihQA5cgAAOXIAADlyAAA5cgAAOHIGADhyBgA4cgYAOHIGAMisTQDIrE0AyKxNAMisTQCgUvMAoFLzAKBS8wCgUvMAmEn5AJhJ+QCYSfkAmEn5AKZZ+QCmWfkApln5AKZZ+QCMM/QAjDP0AIwz9ACMM/QA/oLxAP6C8QD+gvEA/oLxAIL38wCC9/MAgvfzAIL38wAAgvIAAILyAACC8gAAgvIAii8EAIovBACKLwQAhPPpAITz6QCE8+kAhPPpAIIF8gCCBfIAggXyAIIF8gD/c8oA/3PKAP9zygD/c8oA/HXOAPx1zgD8dc4A/HXOAKJT7gCiU+4AolPuAJI+8wCSPvMAkj7zAIQE5QCEBOUAhATlAIQE5QD/x3IA/8dyAP/HcgD/x3IA+7qWAPu6lgD7upYA+7qWAACG2wAAhtsAAIbbAACG2wAAhR8AAIUfAACFHwAAhR8A/9d4AP/XeAD/13gA/9d4AACsXwAArF8AAKxfAACsXwCC9vMAgvbzAIL28wCC9vMAgf/4AIH/+ACB//gAgQH2AIEB9gCBAfYAgfz5AIH8+QCB/PkAgQD4AIEA+ACBAPgAgQD4AIL99ACC/fQAgv30AIL38gCC9/IAgvfyAIL38gCB/vUAgf71AIH+9QCB/vUAgf33AIH99wCB/fcAgf33AIL1+ACC9fgAgvX4AIL1+AB69SMAevUjAHr1IwB69SMAGzqSABs6kgAbOpIAGzqSABYSfAAWEnwAFhJ8ABYSfAC4mP0AuJj9ALiY/QC4mP0Ayam2AMmptgDJqbYAyam2ALObCwCzmwsAs5sLALObCwD/6YMA/+mDAP/pgwD/6YMA6ON5AOjjeQDo43kA6ON5ALecGgC3nBoAt5waALecGgB89+cAfPfnAHz35wB89+cABTN0AAUzdAAFM3QABTN0AADNjAAAzYwAAM2MAADNjAAKM3QACjN0AAozdAAKM3QAAHXOAAB1zgAAdc4AAHXOAAFzywABc8sAAXPLAAFzywAJc8sACXPLAAlzywCgUe4AoFHuAKBR7gCVQ/YAlUP2AJVD9gCO/TcAjv03AI79NwCO/TcAigUvAIoFLwCKBS8AigUvAIn9LACJ/SwAif0sAIn9LACB+PkAgfj5AIH4+QCB+PkAgvrwAIL68ACC+vAAgvrwAIL68wCC+vMAgvrzAIL68wD95oQA/eaEAP3mhAD95oQAhQXfAIUF3wCFBd8AhQXfAIL9CwCC/QsAgv0LAIL9CwAA7IMAAOyDAADsgwAA7IMAgvsOAIL7DgCC+w4AgvsOAIL98gCC/fIAgv3yAIL98gDcAIYA3ACGANwAhgDcAIYAgQL5AIEC+QCBAvkAgQL5AAUZhAAFGYQABRmEAAUZhACB/wIAgf8CAIH/AgCB/wIAsakxALGpMQCxqTEAsakxAPQAggD0AIIA9ACCAPQAggCBAAAAgQAAAIEAAACBAAAAgv7xAIL+8QCC/vEAgv7xAK4AnwCuAJ8ArgCfAK4AnwDkMHIA5DByAOQwcgDkMHIAAH0XAAB9FwAAfRcAAH0XAAB+DAAAfgwAAH4MAAB+DAAAfwUAAH8FAAB/BQAAfwUA/30ZAP99GQD/fRkA/30ZAMtyFQDLchUAy3IVAMtyFQC1Yh4AtWIeALViHgC1Yh4A4gB7AOIAewDiAHsAsgRkALIEZACyBGQAsgRkAOAddwDgHXcA4B13AOAddwDXKXEA1ylxANcpcQDXKXEAbQBCAG0AQgBtAEIAbQBCAH4A9QB+APUAfgD1AH4A9QCgBFMAoARTAKAEUwCgBFMAvgBtAL4AbQC+AG0AvgBtACOIFwAjiBcAI4gXACOIFwAAfwAAAH8AAAB/AAAAfwAAubC8ALmwvAC5sLwAubC8AGIGsABiBrAAYgawAGIGsACg+1MAoPtTAKD7UwCg+1MAAIEAAACBAAAAgQAAAIEAAPZ++AD2fvgA9n74APZ++AC0R7cAtEe3ALRHtwC0R7cAugBqALoAagC6AGoAugBqALoAagBqAEYAagBGAGoARgBqAEYAYvyvAGL8rwBi/K8AYvyvAEYAlgBGAJYARgCWAEYAlgBGAJYAAIEAAACBAAAAgQAAAIEAALoAagC6AGoAugBqALoAagBGAJYARgCWAEYAlgBGAJYAI3gXACN4FwAjeBcAI3gXAACBAAAAgQAAAIEAAACBAADjAHwA4wB8AOMAfADjAHwAQgCTAEIAkwBCAJMAQgCTAEdeLwBHXi8AR14vAEdeLwD2fvoA9n76APZ++gD2fvoAffnsAH357AB9+ewAffnsAADNjAAAzYwAAM2MAADNjAASfOkAEnzpABJ86QASfOkAnS5BAJ0uQQCdLkEA24cIANuHCADbhwgA24cIAF7jUABe41AAXuNQAF7jUAC6YyYAumMmALpjJgC6YyYAuvtqALr7agC6+2oAuvtqAOxaWADsWlgA7FpYAOxaWADGVUoAxlVKAMZVSgDGVUoAqq3XAKqt1wCqrdcAqq3XAOWFEADlhRAA5YUQAOWFEAAde/IAHXvyAB178gAde/IABnvgAAZ74AAGe+AABnvgAJE+BACRPgQAkT4EAJE+BACB/gQAgf4EAIH+BACB/gQA/vOCAP7zggD+84IA/vOCABd9AAAXfQAAF30AAIEABACBAAQAgQAEAIEABAD7MXUA+zF1APsxdQD7MXUA7VxVAO1cVQDtXFUAAX8IAAF/CAABfwgAAX8IAP+B+QD/gfkA/4H5AP+B+QAAFn0AABZ9AAAWfQAAFn0AABd9AAAXfQAAF30AABd9AAAXfQAAF30AABd9AAAXfQABfwcAAX8HAAF/BwABfwcAXar2AF2q9gBdqvYAXar2AP6E4wD+hOMA/oTjAP6E4wD2JIcA9iSHAPYkhwD2JIcA9R2FAPUdhQD1HYUA9R2FAAJ8HQACfB0AAnwdAAJ8HQB/AvcAfwL3AH8C9wB/AvcACXklAAl5JQAJeSUACXklAIzrLwCM6y8AjOsvAIzrLwDfMZAA3zGQAN8xkADfMZAA3i+PAN4vjwDeL48A3i+PAL8algC/GpYAvxqWAL8algD1h9wA9YfcAPWH3AD1h9wAKnYVACp2FQAqdhUAKnYVAHDwxwBw8McAcPDHAHDwxwD7AH8A+wB/APsAfwD7AH8A/4EAAP+BAAD/gQAAF3sXABd7FwAXexcAF3sXAP+BAAD/gQAA/4EAAP+BAAABf/wAAX/8AAF//AABf/wA8YPwAPGD8ADxg/AA8YPwAAB/AQAAfwEAAH8BAAB/AQD/gfwA/4H8AP+B/AD/gfwAAX8BAAF/AQABfwEAAX8BAAJ9GAACfRgAAn0YAAJ9GAAAgf8AAIH/AACB/wAAgf8A54bnAOeG5wDnhucA54bnAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEEAACBBAAAgQQAAIEEAACBBAAAgQQAAIEEAACBBAAAgQQAAIEEAACBBAAAgQQAAIH8AACB/AAAgfwAAIH8AACB/AAAgfwAAIH8AACB/AAAgfwAAIH8AACB/AAAgfwACoPtAAqD7QAKg+0AAX8AAAF/AAABfwAAAX8AAAF/AAABgu8AAYLvAAGC7wABgu8AAIH+AACB/gAAgf4AAIH+AACB/gAAgf4AAIH+AACB/gAAgf8AAIH/AACB/wAAgf8AAH8BAAB/AQAAfwEAAH8BAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAABgu8AAYLvAAGC7wABgu8AA4LyAAOC8gADgvIABoLwAAaC8AAGgvAABoLwAPyB+gD8gfoA/IH6APyB+gD/g+sA/4PrAP+D6wAC+YEAAvmBAAL5gQAC+YEAAITjAACE4wAAhOMAAITjAP6D6gD+g+oA/oPqAP6D6gAAhOUAAITlAACE5QAHg+sAB4PrAAeD6wAHg+sAAYH+AAGB/gABgf4AAYH+AADqfQAA6n0AAOp9AADqfQAMfg0ADH4NAAx+DQAMfg0AAOp9AADqfQAA6n0AAOp9AP+BAAD/gQAA/4EAAP+BAAB+//AAfv/wAH7/8AB+//AAVfGjAFXxowBV8aMAVfGjAAB/AQAAfwEAAH8BAAB/AQB/AAAAfwAAAH8AAAB/AAAAfwACAH8AAgB/AAIAfwACAH8AAAB/AAAAfwAAAH8AAAB/AvoAfwL6AH8C+gB/AvoAfv/zAH7/8wB+//MAfv/zAH//CAB//wgAf/8IAH//CAD4+YEA+PmBAPj5gQD4+YEAAX8AAAF/AAABfwAAAX8AAAF/AAABfwAAAX8AAAF/AAD+heIA/oXiAP6F4gD+heIACOp9AAjqfQAI6n0ACOp9AP+BBAD/gQQA/4EEAP+BBAD/gQAA/4EAAP+BAAD/gQAAAn8KAAJ/CgACfwoAAn8KAP+BAAD/gQAA/4EAAP+BAAB+/A4AfvwOAH78DgB+/A4AdgEwAHYBMAB2ATAAdgEwAHQANAB0ADQAdAA0AHQANAAEAH8ABAB/AAQAfwAEAH8AAIH/AACB/wAAgf8AAIH/AP+BAAD/gQAA/4EAAP+BAAAAfwEAAH8BAAB/AQAAfwEAGAB9ABgAfQAYAH0AGAB9AACB/gAAgf4AAIH+AACB/gAJfvcACX73AAl+9wAJfvcAUgCfAFIAnwBSAJ8AUgCfAAsAgQALAIEACwCBAAsAgQAkAIYAJACGACQAhgAkAIYAegPcAHoD3AB6A9wAegPcAH4C8gB+AvIAfgLyAH4C8gAAgf8AAIH/AACB/wAAgf8AAH8BAAB/AQAAfwEAAH8BAFzyVgBc8lYAXPJWAFzyVgADfwUAA38FAAN/BQADfwUAAH8CAAB/AgAAfwIAAH8CAACB/gAAgf4AAIH+AACB/gAAgf4AAIH+AACB/gBNAGUATQBlAE0AZQBNAGUAAIH/AACB/wAAgf8AAIH/AAB/AQAAfwEAAH8BAAB/AQACfwAAAn8AAAJ/AAABgQAAAYEAAAGBAADpexcA6XsXAOl7FwDpexcAAYEAAAGBAAABgQAAAYEAAP9//AD/f/wA/3/8AP9//AAPg/AAD4PwAA+D8AAPg/AAAH8BAAB/AQAAfwEAAH8BAAGB/AABgfwAAYH8AAGB/AD/fwEA/38BAP9/AQD/fwEA/n0YAP59GAD+fRgA/n0YAACB/wAAgf8AAIH/AACB/wAZhucAGYbnABmG5wAZhucAAIEAAACBAAAAgQAAAIEAAACBBAAAgQQAAIEEAACBBAAAgQQAAIEEAACBBAAAgQQAAIEEAACBBAAAgQQAAIEEAACB/AAAgfwAAIH8AACB/AAAgfwAAIH8AACB/AAAgfwAAIH8AACB/AAAgfwAAIH8APaD7QD2g+0A9oPtAP9/AAD/fwAA/38AAP9/AAD/fwAA/4LvAP+C7wD/gu8A/4LvAACB/gAAgf4AAIH+AACB/gAAgf4AAIH+AACB/gAAgf4AAIH/AACB/wAAgf8AAIH/AAB/AQAAfwEAAH8BAAB/AQAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAA/4LvAP+C7wD/gu8A/4LvAP2C8gD9gvIA/YLyAPqC8AD6gvAA+oLwAPqC8AAEgfoABIH6AASB+gAEgfoAAYPrAAGD6wABg+sA/vmBAP75gQD++YEA/vmBAACE4wAAhOMAAITjAACE4wACg+oAAoPqAAKD6gACg+oAAITlAACE5QAAhOUA+YPrAPmD6wD5g+sA+YPrAP+B/gD/gf4A/4H+AP+B/gAA6n0AAOp9AADqfQAA6n0A9H4NAPR+DQD0fg0A9H4NAADqfQAA6n0AAOp9AADqfQABgQAAAYEAAAGBAAABgQAAgv/wAIL/8ACC//AAgv/wAKvxowCr8aMAq/GjAKvxowAAfwEAAH8BAAB/AQAAfwEAgQAAAIEAAACBAAAAgQAAAIEAAgCBAAIAgQACAIEAAgCBAAAAgQAAAIEAAACBAAAAgQL6AIEC+gCBAvoAgQL6AIL/8wCC//MAgv/zAIL/8wCB/wgAgf8IAIH/CACB/wgACPmBAAj5gQAI+YEACPmBAP9/AAD/fwAA/38AAP9/AAD/fwAA/38AAP9/AAD/fwAAAoXiAAKF4gACheIAAoXiAPjqfQD46n0A+Op9APjqfQABgQQAAYEEAAGBBAABgQQAAYEAAAGBAAABgQAAAYEAAP5/CgD+fwoA/n8KAP5/CgABgQAAAYEAAAGBAAABgQAAgvwOAIL8DgCC/A4AgvwOAIoBMACKATAAigEwAIoBMACMADQAjAA0AIwANACMADQA/AB/APwAfwD8AH8A/AB/AACB/wAAgf8AAIH/AACB/wABgQAAAYEAAAGBAAABgQAAAH8BAAB/AQAAfwEAAH8BAOgAfQDoAH0A6AB9AOgAfQAAgf4AAIH+AACB/gAAgf4A9373APd+9wD3fvcA9373AK4AnwCuAJ8ArgCfAK4AnwD1AIEA9QCBAPUAgQD1AIEA3ACGANwAhgDcAIYA3ACGAIYD3ACGA9wAhgPcAIYD3ACCAvIAggLyAIIC8gCCAvIAAIH/AACB/wAAgf8AAIH/AAB/AQAAfwEAAH8BAAB/AQCk8lYApPJWAKTyVgCk8lYA/X8FAP1/BQD9fwUA/X8FAAB/AgAAfwIAAH8CAAB/AgAAgf4AAIH+AACB/gAAgf4AAIH+AACB/gAAgf4AswBlALMAZQCzAGUAswBlAACB/wAAgf8AAIH/AACB/wAAfwEAAH8BAAB/AQAAfwEA/n8AAP5/AAD+fwAAAWtEAAFrRAABa0QAAWtEABJsQQASbEEAEmxBABJsQQASczIAEnMyABJzMgASczIAA3I4AANyOAADcjgAA3I4AG4/AABuPwAAbj8AAG4/AABqRQcAakUHAGpFBwBqRQcAYlEDAGJRAwBiUQMAYlEDAFxXCgBcVwoAXFcKAGtE/QBrRP0Aa0T9AGtE/QBrRPgAa0T4AGtE+ABrRPgAaEn6AGhJ+gBoSfoAaEn6AGRO+wBkTvsAZE77AGdK+ABnSvgAZ0r4AAJ0ywACdMsAAnTLAAJ0ywABdM0AAXTNAAF0zQABdM0AAnXPAAJ1zwACdc8AAnXPAAR0zQAEdM0ABHTNAAR0zQD/a0QA/2tEAP9rRAD/a0QA7mxBAO5sQQDubEEA7mxBAO5zMgDuczIA7nMyAO5zMgD9cjgA/XI4AP1yOAD9cjgAkj8AAJI/AACSPwAAkj8AAJZFBwCWRQcAlkUHAJZFBwCeUQMAnlEDAJ5RAwCeUQMApFcKAKRXCgCkVwoAlUT9AJVE/QCVRP0AlUT9AJVE+ACVRPgAlUT4AJVE+ACYSfoAmEn6AJhJ+gCYSfoAnE77AJxO+wCcTvsAmUr4AJlK+ACZSvgA/nTLAP50ywD+dMsA/nTLAP90zQD/dM0A/3TNAP90zQD+dc8A/nXPAP51zwD+dc8A/HTNAPx0zQD8dM0A/HTNAAodhQAKHYUACh2FAAodhQD2HYUA9h2FAPYdhQD2HYUAehDiAHoQ4gB6EOIAehDiAHMOzABzDswAcw7MAHMOzABzG9MAcxvTAHMb0wBzG9MAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAHvg9wB74PcAe+D3AHvg9wBzGy0AcxstAHMbLQBzGy0AewkgAHsJIAB7CSAAewkgAHz/GwB8/xsAfP8bAHz/GwB7FuoAexbqAHsW6gB7FuoAe/fgAHv34AB79+AAe/fgAHrwHgB68B4AevAeAHrwHgB76hYAe+oWAHvqFgB76hYAewngAHsJ4AB7CeAAewngAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAHTk0wB05NMAdOTTAHTk0wBzNA4AczQOAHM0DgBzNA4Ac/I0AHPyNABz8jQAc/I0AHPM8gBzzPIAc8zyAHPM8gBzNPIAczTyAHM08gBzNPIAcw40AHMONABzDjQAcw40AHPMDgBzzA4Ac8wOAHPMDgB0HNMAdBzTAHQc0wB0HNMAc/LMAHPyzABz8swAc/LMAHQcLQB0HC0AdBwtAHQcLQBrzzEAa88xAGvPMQBrzzEAAN97AADfewAA33sAAN97AHzlAQB85QEAfOUBAHzlAQB79yAAe/cgAHv3IAB79yAAcy0bAHMtGwBzLRsAcy0bAAB73wAAe98AAHvfAAB73wB8GwEAfBsBAHwbAQB8GwEAfwAAAH8AAAB/AAAAfwAAAHPTGwBz0xsAc9MbAHPTGwAAhSEAAIUhAACFIQAAhSEAeh7wAHoe8AB6HvAAeh7wAHsWFgB7FhYAexYWAHsWFgB/AAAAfwAAAH8AAAB/AAAAAP5/AAD+fwAA/n8AAP5/AHsgCQB7IAkAeyAJAHsgCQB/AAAAfwAAAH8AAAB/AAAAfAEbAHwBGwB8ARsAfAEbAAAhhQAAIYUAACGFAAAhhQB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAevDiAHrw4gB68OIAevDiAHoeEAB6HhAAeh4QAHoeEAAAQZMAAEGTAABBkwAAQZMAfAHlAHwB5QB8AeUAfAHlAHsg9wB7IPcAeyD3AHsg9wAAhSEAAIUhAACFIQAAhSEAc9PlAHPT5QBz0+UAc9PlAH8AAAB/AAAAfwAAAH8AAAB8G/8AfBv/AHwb/wB8G/8AAHvfAAB73wAAe98AAHvfAH8AAAB/AAAAfwAAAH8AAABzLeUAcy3lAHMt5QBzLeUAfOX/AHzl/wB85f8AfOX/AAA+kQAAPpEAAD6RAAA+kQB76uoAe+rqAHvq6gB76uoAeuIQAHriEAB64hAAeuIQAH8AAAB/AAAAfwAAAH8AAAAAk0EAAJNBAACTQQAAk0EAc+UtAHPlLQBz5S0Ac+UtAH8AAAB/AAAAfwAAAH8AAAB8/+UAfP/lAHz/5QB8/+UAAHshAAB7IQAAeyEAAHshAHvgCQB74AkAe+AJAHvgCQB/AAAAfwAAAH8AAAB/AAAAc+XTAHPl0wBz5dMAc+XTAACmpgAApqYAAKamAACmpgB64vAAeuLwAHri8AB64vAAehAeAHoQHgB6EB4AehAeAAACfwAAAn8AAAJ/AAACfwAA/oEAAP6BAAD+gQAA/oEAAG8+AABvPgAAbz4AAG8+AAAhewAAIXsAACF7AAAhewAAwpEAAMKRAADCkQAAwpEAAKamAACmpgAApqYAAKamAAA+bwAAPm8AAD5vAAA+bwAAgf4AAIH+AACB/gAAgf4AAN+FAADfhQAA34UAAN+FAABaWgAAWloAAFpaAABaWgAAb8IAAG/CAABvwgAAb8IAAL9tAAC/bQAAv20AAL9tAAB7IQAAeyEAAHshAAB7IQAAploAAKZaAACmWgAAploAAIECAACBAgAAgQIAAIECAABtvwAAbb8AAG2/AABtvwAAhd8AAIXfAACF3wAAhd8AAFqmAABapgAAWqYAAFqmAADCbwAAwm8AAMJvAADCbwAAv5MAAL+TAAC/kwAAv5MAAFqmAABapgAAWqYAAFqmAADfewAA33sAAN97AADfewAAAoEAAAKBAAACgQAAAoEAAN+FAADfhQAA34UAAN+FAABtQQAAbUEAAG1BAABtQQAAploAAKZaAACmWgAAploAACGFAAAhhQAAIYUAACGFAAAhewAAIXsAACF7AAAhewAAk78AAJO/AACTvwAAk78AAJHCAACRwgAAkcIAAJHCAAB//gAAf/4AAH/+AAB//gAAWloAAFpaAABaWgAAWloAAEFtAABBbQAAQW0AAEFtAACF3wAAhd8AAIXfAACF3wAAfwIAAH8CAAB/AgAAfwIAAJE+AACRPgAAkT4AAJE+AABapgAAWqYAAFqmAABapgB05C0AdOQtAHTkLQB05C0AdNMcAHTTHAB00xwAdNMcAHfhHwB34R8Ad+EfAHfhHwAAbsEAAG7BAABuwQAAbsEAd+HhAHfh4QB34eEAd+HhAGvPzwBrz88Aa8/PAGvPzwB00+QAdNPkAHTT5AB00+QAAMGSAADBkgAAwZIAAMGSAHcf4QB3H+EAdx/hAHcf4QB0LeQAdC3kAHQt5AB0LeQAazHPAGsxzwBrMc8AazHPAADAbgAAwG4AAMBuAADAbgB3Hx8Adx8fAHcfHwB3Hx8AazExAGsxMQBrMTEAazExAHQtHAB0LRwAdC0cAHQtHAAAWloAAFpaAABaWgAAWloAAKZaAACmWgAAploAAKZaAACmWgAAploAAKZaAACmWgAApqYAAKamAACmpgAApqYAAKamAACmpgAApqYAAKamAACSwQAAksEAAJLBAACSwQAAWqYAAFqmAABapgAAWqYAAJI/AACSPwAAkj8AAJI/AABaWgAAWloAAFpaAABaWgAAQG4AAEBuAABAbgAAQG4AAG4/AABuPwAAbj8AAG4/AABAkgAAQJIAAECSAABAkgCGEOIAhhDiAIYQ4gCGEOIAjQ7MAI0OzACNDswAjQ7MAI0b0wCNG9MAjRvTAI0b0wCBAAAAgQAAAIEAAACBAAAAheD3AIXg9wCF4PcAheD3AI0bLQCNGy0AjRstAI0bLQCFCSAAhQkgAIUJIACFCSAAhP8bAIT/GwCE/xsAhP8bAIUW6gCFFuoAhRbqAIUW6gCF9+AAhffgAIX34ACF9+AAhvAeAIbwHgCG8B4AhvAeAIXqFgCF6hYAheoWAIXqFgCFCeAAhQngAIUJ4ACFCeAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAjOTTAIzk0wCM5NMAjOTTAI00DgCNNA4AjTQOAI00DgCN8jQAjfI0AI3yNACN8jQAjczyAI3M8gCNzPIAjczyAI008gCNNPIAjTTyAI008gCNDjQAjQ40AI0ONACNDjQAjcwOAI3MDgCNzA4AjcwOAIwc0wCMHNMAjBzTAIwc0wCN8swAjfLMAI3yzACN8swAjBwtAIwcLQCMHC0AjBwtAJXPMQCVzzEAlc8xAJXPMQAA33sAAN97AADfewAA33sAhOUBAITlAQCE5QEAhOUBAIX3IACF9yAAhfcgAIX3IACNLRsAjS0bAI0tGwCNLRsAAHvfAAB73wAAe98AAHvfAIQbAQCEGwEAhBsBAIQbAQCBAAAAgQAAAIEAAACBAAAAjdMbAI3TGwCN0xsAjdMbAACFIQAAhSEAAIUhAACFIQCGHvAAhh7wAIYe8ACGHvAAhRYWAIUWFgCFFhYAhRYWAIEAAACBAAAAgQAAAIEAAAAA/n8AAP5/AAD+fwAA/n8AhSAJAIUgCQCFIAkAhSAJAIEAAACBAAAAgQAAAIEAAACEARsAhAEbAIQBGwCEARsAACGFAAAhhQAAIYUAACGFAIEAAACBAAAAgQAAAIEAAACG8OIAhvDiAIbw4gCG8OIAhh4QAIYeEACGHhAAhh4QAABBkwAAQZMAAEGTAABBkwCEAeUAhAHlAIQB5QCEAeUAhSD3AIUg9wCFIPcAhSD3AIEAAACBAAAAgQAAAIEAAAAAhSEAAIUhAACFIQAAhSEAjdPlAI3T5QCN0+UAjdPlAIEAAACBAAAAgQAAAIEAAACEG/8AhBv/AIQb/wCEG/8AAHvfAAB73wAAe98AAHvfAIEAAACBAAAAgQAAAIEAAACNLeUAjS3lAI0t5QCNLeUAhOX/AITl/wCE5f8AhOX/AAA+kQAAPpEAAD6RAAA+kQCF6uoAherqAIXq6gCF6uoAhuIQAIbiEACG4hAAhuIQAIEAAACBAAAAgQAAAIEAAAAAk0EAAJNBAACTQQAAk0EAjeUtAI3lLQCN5S0AjeUtAIEAAACBAAAAgQAAAIEAAACE/+UAhP/lAIT/5QCE/+UAAHshAAB7IQAAeyEAAHshAIXgCQCF4AkAheAJAIXgCQCBAAAAgQAAAIEAAACBAAAAjeXTAI3l0wCN5dMAjeXTAACmpgAApqYAAKamAACmpgCBAAAAgQAAAIEAAACBAAAAhuLwAIbi8ACG4vAAhuLwAIYQHgCGEB4AhhAeAIYQHgAAAn8AAAJ/AAACfwAAAn8AAP6BAAD+gQAA/oEAAP6BAABvPgAAbz4AAG8+AABvPgAAIXsAACF7AAAhewAAIXsAAMKRAADCkQAAwpEAAMKRAACmpgAApqYAAKamAACmpgAAPm8AAD5vAAA+bwAAPm8AAIH+AACB/gAAgf4AAIH+AADfhQAA34UAAN+FAADfhQAAWloAAFpaAABaWgAAWloAAG/CAABvwgAAb8IAAG/CAAC/bQAAv20AAL9tAAC/bQAAeyEAAHshAAB7IQAAeyEAAKZaAACmWgAAploAAKZaAACBAgAAgQIAAIECAACBAgAAbb8AAG2/AABtvwAAbb8AAIXfAACF3wAAhd8AAIXfAABapgAAWqYAAFqmAABapgAAwm8AAMJvAADCbwAAwm8AAL+TAAC/kwAAv5MAAL+TAABapgAAWqYAAFqmAABapgAA33sAAN97AADfewAA33sAAAKBAAACgQAAAoEAAAKBAADfhQAA34UAAN+FAADfhQAAbUEAAG1BAABtQQAAbUEAAKZaAACmWgAAploAAKZaAAAhhQAAIYUAACGFAAAhhQAAIXsAACF7AAAhewAAIXsAAJO/AACTvwAAk78AAJO/AACRwgAAkcIAAJHCAACRwgAAf/4AAH/+AAB//gAAf/4AAFpaAABaWgAAWloAAFpaAABBbQAAQW0AAEFtAABBbQAAhd8AAIXfAACF3wAAhd8AAH8CAAB/AgAAfwIAAH8CAACRPgAAkT4AAJE+AACRPgAAWqYAAFqmAABapgAAWqYAjOQtAIzkLQCM5C0AjOQtAIzTHACM0xwAjNMcAIzTHACJ4R8AieEfAInhHwCJ4R8AAG7BAABuwQAAbsEAAG7BAInh4QCJ4eEAieHhAInh4QCVz88Alc/PAJXPzwCVz88AjNPkAIzT5ACM0+QAjNPkAADBkgAAwZIAAMGSAADBkgCJH+EAiR/hAIkf4QCJH+EAjC3kAIwt5ACMLeQAjC3kAJUxzwCVMc8AlTHPAJUxzwAAwG4AAMBuAADAbgAAwG4AiR8fAIkfHwCJHx8AiR8fAJUxMQCVMTEAlTExAJUxMQCMLRwAjC0cAIwtHACMLRwAAFpaAABaWgAAWloAAFpaAACmWgAAploAAKZaAACmWgAAploAAKZaAACmWgAAploAAKamAACmpgAApqYAAKamAACmpgAApqYAAKamAACmpgAAksEAAJLBAACSwQAAksEAAFqmAABapgAAWqYAAFqmAACSPwAAkj8AAJI/AACSPwAAWloAAFpaAABaWgAAWloAAEBuAABAbgAAQG4AAEBuAABuPwAAbj8AAG4/AABuPwAAQJIAAECSAABAkgAAQJIAehDiAHoQ4gB6EOIAehDiAHMOzABzDswAcw7MAHMOzABzG9MAcxvTAHMb0wBzG9MAfwAAAH8AAAB/AAAAfwAAAHvg9wB74PcAe+D3AHvg9wBzGy0AcxstAHMbLQBzGy0AewkgAHsJIAB7CSAAewkgAHz/GwB8/xsAfP8bAHz/GwB7FuoAexbqAHsW6gB7FuoAe/fgAHv34AB79+AAe/fgAHrwHgB68B4AevAeAHrwHgB76hYAe+oWAHvqFgB76hYAewngAHsJ4AB7CeAAewngAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAHTk0wB05NMAdOTTAHTk0wBzNA4AczQOAHM0DgBzNA4Ac/I0AHPyNABz8jQAc/I0AHPM8gBzzPIAc8zyAHPM8gBzNPIAczTyAHM08gBzNPIAcw40AHMONABzDjQAcw40AHPMDgBzzA4Ac8wOAHPMDgB0HNMAdBzTAHQc0wB0HNMAc/LMAHPyzABz8swAc/LMAHQcLQB0HC0AdBwtAHQcLQBrzzEAa88xAGvPMQBrzzEAAN97AADfewAA33sAAN97AHzlAQB85QEAfOUBAHzlAQB79yAAe/cgAHv3IAB79yAAcy0bAHMtGwBzLRsAcy0bAAB73wAAe98AAHvfAAB73wB8GwEAfBsBAHwbAQB8GwEAfwAAAH8AAAB/AAAAfwAAAHPTGwBz0xsAc9MbAHPTGwAAhSEAAIUhAACFIQAAhSEAeh7wAHoe8AB6HvAAeh7wAHsWFgB7FhYAexYWAHsWFgB/AAAAfwAAAH8AAAB/AAAAAP5/AAD+fwAA/n8AAP5/AHsgCQB7IAkAeyAJAHsgCQB/AAAAfwAAAH8AAAB/AAAAfAEbAHwBGwB8ARsAfAEbAAAhhQAAIYUAACGFAAAhhQB/AAAAfwAAAH8AAAB/AAAAevDiAHrw4gB68OIAevDiAHoeEAB6HhAAeh4QAHoeEAAAQZMAAEGTAABBkwAAQZMAfAHlAHwB5QB8AeUAfAHlAHsg9wB7IPcAeyD3AHsg9wB/AAAAfwAAAH8AAAB/AAAAAIUhAACFIQAAhSEAAIUhAHPT5QBz0+UAc9PlAHPT5QB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfBv/AHwb/wB8G/8AfBv/AAB73wAAe98AAHvfAAB73wBzLeUAcy3lAHMt5QBzLeUAfOX/AHzl/wB85f8AfOX/AAA+kQAAPpEAAD6RAAA+kQB76uoAe+rqAHvq6gB76uoAeuIQAHriEAB64hAAeuIQAACTQQAAk0EAAJNBAACTQQBz5S0Ac+UtAHPlLQBz5S0AfP/lAHz/5QB8/+UAfP/lAAB7IQAAeyEAAHshAAB7IQB74AkAe+AJAHvgCQB74AkAfwAAAH8AAAB/AAAAfwAAAHPl0wBz5dMAc+XTAHPl0wAApqYAAKamAACmpgAApqYAfwAAAH8AAAB/AAAAfwAAAHri8AB64vAAeuLwAHri8AB6EB4AehAeAHoQHgB6EB4AAAJ/AAACfwAAAn8AAAJ/AAD+gQAA/oEAAP6BAAD+gQAAbz4AAG8+AABvPgAAbz4AACF7AAAhewAAIXsAACF7AADCkQAAwpEAAMKRAADCkQAApqYAAKamAACmpgAApqYAAD5vAAA+bwAAPm8AAD5vAACB/gAAgf4AAIH+AACB/gAA34UAAN+FAADfhQAA34UAAFpaAABaWgAAWloAAFpaAABvwgAAb8IAAG/CAABvwgAAv20AAL9tAAC/bQAAv20AAHshAAB7IQAAeyEAAHshAACmWgAAploAAKZaAACmWgAAgQIAAIECAACBAgAAgQIAAG2/AABtvwAAbb8AAG2/AACF3wAAhd8AAIXfAACF3wAAWqYAAFqmAABapgAAWqYAAMJvAADCbwAAwm8AAMJvAAC/kwAAv5MAAL+TAAC/kwAAWqYAAFqmAABapgAAWqYAAN97AADfewAA33sAAN97AAACgQAAAoEAAAKBAAACgQAA34UAAN+FAADfhQAA34UAAG1BAABtQQAAbUEAAG1BAACmWgAAploAAKZaAACmWgAAIYUAACGFAAAhhQAAIYUAACF7AAAhewAAIXsAACF7AACTvwAAk78AAJO/AACTvwAAkcIAAJHCAACRwgAAkcIAAH/+AAB//gAAf/4AAH/+AABaWgAAWloAAFpaAABaWgAAQW0AAEFtAABBbQAAQW0AAIXfAACF3wAAhd8AAIXfAAB/AgAAfwIAAH8CAAB/AgAAkT4AAJE+AACRPgAAkT4AAFqmAABapgAAWqYAAFqmAHTkLQB05C0AdOQtAHTkLQB00xwAdNMcAHTTHAB00xwAd+EfAHfhHwB34R8Ad+EfAABuwQAAbsEAAG7BAABuwQB34eEAd+HhAHfh4QB34eEAa8/PAGvPzwBrz88Aa8/PAHTT5AB00+QAdNPkAHTT5AAAwJIAAMCSAADAkgAAwJIAdx/hAHcf4QB3H+EAdx/hAHQt5AB0LeQAdC3kAHQt5ABrMc8AazHPAGsxzwBrMc8AAMFuAADBbgAAwW4AAMFuAHcfHwB3Hx8Adx8fAHcfHwBrMTEAazExAGsxMQBrMTEAdC0cAHQtHAB0LRwAdC0cAABaWgAAWloAAFpaAABaWgAAploAAKZaAACmWgAAploAAKZaAACmWgAAploAAKZaAACmpgAApqYAAKamAACmpgAApqYAAKamAACmpgAApqYAAJLAAACSwAAAksAAAJLAAABapgAAWqYAAFqmAABapgAAkkAAAJJAAACSQAAAkkAAAFpaAABaWgAAWloAAFpaAAA/bgAAP24AAD9uAAA/bgAAbkAAAG5AAABuQAAAbkAAAECSAABAkgAAQJIAAECSAIYQ4gCGEOIAhhDiAIYQ4gCNDswAjQ7MAI0OzACNDswAjRvTAI0b0wCNG9MAjRvTAIEAAACBAAAAgQAAAIEAAACF4PcAheD3AIXg9wCF4PcAjRstAI0bLQCNGy0AjRstAIUJIACFCSAAhQkgAIUJIACE/xsAhP8bAIT/GwCE/xsAhRbqAIUW6gCFFuoAhRbqAIX34ACF9+AAhffgAIX34ACG8B4AhvAeAIbwHgCG8B4AheoWAIXqFgCF6hYAheoWAIUJ4ACFCeAAhQngAIUJ4ACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACM5NMAjOTTAIzk0wCM5NMAjTQOAI00DgCNNA4AjTQOAI3yNACN8jQAjfI0AI3yNACNzPIAjczyAI3M8gCNzPIAjTTyAI008gCNNPIAjTTyAI0ONACNDjQAjQ40AI0ONACNzA4AjcwOAI3MDgCNzA4AjBzTAIwc0wCMHNMAjBzTAI3yzACN8swAjfLMAI3yzACMHC0AjBwtAIwcLQCMHC0Alc8xAJXPMQCVzzEAlc8xAADfewAA33sAAN97AADfewCE5QEAhOUBAITlAQCE5QEAhfcgAIX3IACF9yAAhfcgAI0tGwCNLRsAjS0bAI0tGwAAe98AAHvfAAB73wAAe98AhBsBAIQbAQCEGwEAhBsBAIEAAACBAAAAgQAAAIEAAACN0xsAjdMbAI3TGwCN0xsAAIUhAACFIQAAhSEAAIUhAIYe8ACGHvAAhh7wAIYe8ACFFhYAhRYWAIUWFgCFFhYAgQAAAIEAAACBAAAAgQAAAAD+fwAA/n8AAP5/AAD+fwCFIAkAhSAJAIUgCQCFIAkAgQAAAIEAAACBAAAAgQAAAIQBGwCEARsAhAEbAIQBGwAAIYUAACGFAAAhhQAAIYUAgQAAAIEAAACBAAAAgQAAAIbw4gCG8OIAhvDiAIbw4gCGHhAAhh4QAIYeEACGHhAAAEGTAABBkwAAQZMAAEGTAIQB5QCEAeUAhAHlAIQB5QCFIPcAhSD3AIUg9wCFIPcAgQAAAIEAAACBAAAAgQAAAACFIQAAhSEAAIUhAACFIQCN0+UAjdPlAI3T5QCN0+UAgQAAAIEAAACBAAAAgQAAAIQb/wCEG/8AhBv/AIQb/wAAe98AAHvfAAB73wAAe98AgQAAAIEAAACBAAAAgQAAAI0t5QCNLeUAjS3lAI0t5QCE5f8AhOX/AITl/wCE5f8AAD6RAAA+kQAAPpEAAD6RAIXq6gCF6uoAherqAIXq6gCG4hAAhuIQAIbiEACG4hAAgQAAAIEAAACBAAAAgQAAAACTQQAAk0EAAJNBAACTQQCN5S0AjeUtAI3lLQCN5S0AgQAAAIEAAACBAAAAgQAAAIT/5QCE/+UAhP/lAIT/5QAAeyEAAHshAAB7IQAAeyEAheAJAIXgCQCF4AkAheAJAIEAAACBAAAAgQAAAIEAAACN5dMAjeXTAI3l0wCN5dMAAKamAACmpgAApqYAAKamAIEAAACBAAAAgQAAAIEAAACG4vAAhuLwAIbi8ACG4vAAhhAeAIYQHgCGEB4AhhAeAAACfwAAAn8AAAJ/AAACfwAA/oEAAP6BAAD+gQAA/oEAAG8+AABvPgAAbz4AAG8+AAAhewAAIXsAACF7AAAhewAAwpEAAMKRAADCkQAAwpEAAKamAACmpgAApqYAAKamAAA+bwAAPm8AAD5vAAA+bwAAgf4AAIH+AACB/gAAgf4AAN+FAADfhQAA34UAAN+FAABaWgAAWloAAFpaAABaWgAAb8IAAG/CAABvwgAAb8IAAL9tAAC/bQAAv20AAL9tAAB7IQAAeyEAAHshAAB7IQAAploAAKZaAACmWgAAploAAIECAACBAgAAgQIAAIECAABtvwAAbb8AAG2/AABtvwAAhd8AAIXfAACF3wAAhd8AAFqmAABapgAAWqYAAFqmAADCbwAAwm8AAMJvAADCbwAAv5MAAL+TAAC/kwAAv5MAAFqmAABapgAAWqYAAFqmAADfewAA33sAAN97AADfewAAAoEAAAKBAAACgQAAAoEAAN+FAADfhQAA34UAAN+FAABtQQAAbUEAAG1BAABtQQAAploAAKZaAACmWgAAploAACGFAAAhhQAAIYUAACGFAAAhewAAIXsAACF7AAAhewAAk78AAJO/AACTvwAAk78AAJHCAACRwgAAkcIAAJHCAAB//gAAf/4AAH/+AAB//gAAWloAAFpaAABaWgAAWloAAEFtAABBbQAAQW0AAEFtAACF3wAAhd8AAIXfAACF3wAAfwIAAH8CAAB/AgAAfwIAAJE+AACRPgAAkT4AAJE+AABapgAAWqYAAFqmAABapgCM5C0AjOQtAIzkLQCM5C0AjNMcAIzTHACM0xwAjNMcAInhHwCJ4R8AieEfAInhHwAAbsEAAG7BAABuwQAAbsEAieHhAInh4QCJ4eEAieHhAJXPzwCVz88Alc/PAJXPzwCM0+QAjNPkAIzT5ACM0+QAAMCSAADAkgAAwJIAAMCSAIkf4QCJH+EAiR/hAIkf4QCMLeQAjC3kAIwt5ACMLeQAlTHPAJUxzwCVMc8AlTHPAADBbgAAwW4AAMFuAADBbgCJHx8AiR8fAIkfHwCJHx8AlTExAJUxMQCVMTEAlTExAIwtHACMLRwAjC0cAIwtHAAAWloAAFpaAABaWgAAWloAAKZaAACmWgAAploAAKZaAACmWgAAploAAKZaAACmWgAApqYAAKamAACmpgAApqYAAKamAACmpgAApqYAAKamAACSwAAAksAAAJLAAACSwAAAWqYAAFqmAABapgAAWqYAAJJAAACSQAAAkkAAAJJAAABaWgAAWloAAFpaAABaWgAAP24AAD9uAAA/bgAAP24AAG5AAABuQAAAbkAAAG5AAABAkgAAQJIAAECSAABAkgBuDT8Abg0/AG4NPwBuDT8AGzByABswcgAbMHIAGzByAE4SYwBOEmMAThJjAJINPwCSDT8Akg0/AJINPwDlMHIA5TByAOUwcgDlMHIAshJjALISYwCyEmMAIjGQACIxkAAiMZAAIjGQADsglAA7IJQAOyCUAN4xkADeMZAA3jGQAN4xkADFIJQAxSCUAMUglAAA34UAAN+FAADfhQAA34UAAKamAACmpgAApqYAAKamAACF3wAAhd8AAIXfAACF3wAAhSEAAIUhAACFIQAAhSEAAKZaAACmWgAAploAAKZaAADfewAA33sAAN97AADfewAAIXsAACF7AAAhewAAIXsAAFpaAABaWgAAWloAAFpaAAB7IQAAeyEAAHshAAB7IQAAe98AAHvfAAB73wAAe98Ac/I0AHPyNABz8jQAc/I0AABapgAAWqYAAFqmAABapgAAIYUAACGFAAAhhQAAIYUAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAHPaJgBz2iYAc9omAHPaJgBzzA4Ac8wOAHPMDgBzzA4Acw7MAHMOzABzDswAcw7MAHPyzABz8swAc/LMAHPyzABzzPIAc8zyAHPM8gBzzPIAcybaAHMm2gBzJtoAcybaAHPa2gBz2toAc9raAHPa2gBzNPIAczTyAHM08gBzNPIAczQOAHM0DgBzNA4AczQOAHMmJgBzJiYAcyYmAHMmJgBzDjQAcw40AHMONABzDjQAAIXfAACF3wAAhd8AAIXfAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAAAhhQAAIYUAACGFAAAhhQAAeyEAAHshAAB7IQAAeyEAAIUhAACFIQAAhSEAAIUhAADfhQAA34UAAN+FAADfhQAAe98AAHvfAAB73wAAe98AAKZaAACmWgAAploAAKZaAAAhewAAIXsAACF7AAAhewAApqYAAKamAACmpgAApqYAAFqmAABapgAAWqYAAFqmAADfewAA33sAAN97AADfewAAWloAAFpaAABaWgAAWloAfv0LAH79CwB+/QsAfv0LAH4DCwB+AwsAfgMLAH4DCwB+CAgAfggIAH4ICAB+CAgAfgsDAH4LAwB+CwMAfgsDAH4I+AB+CPgAfgj4AH4I+AB+C/0Afgv9AH4L/QB+C/0AfgP1AH4D9QB+A/UAfgP1AH799QB+/fUAfv31AH799QB++PgAfvj4AH74+AB++PgAfvX9AH71/QB+9f0AfvX9AH71AwB+9QMAfvUDAH71AwB++AgAfvgIAH74CAB++AgAc9omAHPaJgBz2iYAc9omAHPa2gBz2toAc9raAHPa2gBzJtoAcybaAHMm2gBzJtoAcyYmAHMmJgBzJiYAcyYmAADfhQAA34UAAN+FAADfhQAApqYAAKamAACmpgAApqYAAIXfAACF3wAAhd8AAIXfAACFIQAAhSEAAIUhAACFIQAAploAAKZaAACmWgAAploAAN97AADfewAA33sAAN97AAAhewAAIXsAACF7AAAhewAAWloAAFpaAABaWgAAWloAAHshAAB7IQAAeyEAAHshAAB73wAAe98AAHvfAAB73wCN8jQAjfI0AI3yNACN8jQAAFqmAABapgAAWqYAAFqmAAAhhQAAIYUAACGFAAAhhQB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAACBAAAAgQAAAIEAAACBAAAAjdomAI3aJgCN2iYAjdomAI3MDgCNzA4AjcwOAI3MDgCNDswAjQ7MAI0OzACNDswAjfLMAI3yzACN8swAjfLMAI3M8gCNzPIAjczyAI3M8gCNJtoAjSbaAI0m2gCNJtoAjdraAI3a2gCN2toAjdraAI008gCNNPIAjTTyAI008gCNNA4AjTQOAI00DgCNNA4AjSYmAI0mJgCNJiYAjSYmAI0ONACNDjQAjQ40AI0ONAAAhd8AAIXfAACF3wAAhd8AgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAAAhhQAAIYUAACGFAAAhhQAAeyEAAHshAAB7IQAAeyEAAIUhAACFIQAAhSEAAIUhAADfhQAA34UAAN+FAADfhQAAe98AAHvfAAB73wAAe98AAKZaAACmWgAAploAAKZaAAAhewAAIXsAACF7AAAhewAApqYAAKamAACmpgAApqYAAFqmAABapgAAWqYAAFqmAADfewAA33sAAN97AADfewAAWloAAFpaAABaWgAAWloAgv0LAIL9CwCC/QsAgv0LAIIDCwCCAwsAggMLAIIDCwCCCAgAgggIAIIICACCCAgAggsDAIILAwCCCwMAggsDAIII+ACCCPgAggj4AIII+ACCC/0Aggv9AIIL/QCCC/0AggP1AIID9QCCA/UAggP1AIL99QCC/fUAgv31AIL99QCC+PgAgvj4AIL4+ACC+PgAgvX9AIL1/QCC9f0AgvX9AIL1AwCC9QMAgvUDAIL1AwCC+AgAgvgIAIL4CACC+AgAjdomAI3aJgCN2iYAjdomAI3a2gCN2toAjdraAI3a2gCNJtoAjSbaAI0m2gCNJtoAjSYmAI0mJgCNJiYAjSYmAADfhQAA34UAAN+FAADfhQAApqYAAKamAACmpgAApqYAAIXfAACF3wAAhd8AAIXfAACFIQAAhSEAAIUhAACFIQAAploAAKZaAACmWgAAploAAN97AADfewAA33sAAN97AAAhewAAIXsAACF7AAAhewAAWloAAFpaAABaWgAAWloAAHshAAB7IQAAeyEAAHshAAB73wAAe98AAHvfAAB73wBz8jQAc/I0AHPyNABz8jQAAFqmAABapgAAWqYAAFqmAAAhhQAAIYUAACGFAAAhhQCBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAAB/AAAAfwAAAH8AAAB/AAAAc9omAHPaJgBz2iYAc9omAHPMDgBzzA4Ac8wOAHPMDgBzDswAcw7MAHMOzABzDswAc/LMAHPyzABz8swAc/LMAHPM8gBzzPIAc8zyAHPM8gBzJtoAcybaAHMm2gBzJtoAc9raAHPa2gBz2toAc9raAHM08gBzNPIAczTyAHM08gBzNA4AczQOAHM0DgBzNA4AcyYmAHMmJgBzJiYAcyYmAHMONABzDjQAcw40AHMONAAAhd8AAIXfAACF3wAAhd8AfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAACGFAAAhhQAAIYUAACGFAAB7IQAAeyEAAHshAAB7IQAAhSEAAIUhAACFIQAAhSEAAN+FAADfhQAA34UAAN+FAAB73wAAe98AAHvfAAB73wAAploAAKZaAACmWgAAploAACF7AAAhewAAIXsAACF7AACmpgAApqYAAKamAACmpgAAWqYAAFqmAABapgAAWqYAAN97AADfewAA33sAAN97AABaWgAAWloAAFpaAABaWgB+/QsAfv0LAH79CwB+/QsAfgMLAH4DCwB+AwsAfgMLAH4ICAB+CAgAfggIAH4ICAB+CwMAfgsDAH4LAwB+CwMAfgj4AH4I+AB+CPgAfgj4AH4L/QB+C/0Afgv9AH4L/QB+A/UAfgP1AH4D9QB+A/UAfv31AH799QB+/fUAfv31AH74+AB++PgAfvj4AH74+AB+9f0AfvX9AH71/QB+9f0AfvUDAH71AwB+9QMAfvUDAH74CAB++AgAfvgIAH74CABz2iYAc9omAHPaJgBz2iYAc9raAHPa2gBz2toAc9raAHMm2gBzJtoAcybaAHMm2gBzJiYAcyYmAHMmJgBzJiYAAN+FAADfhQAA34UAAN+FAACmpgAApqYAAKamAACmpgAAhd8AAIXfAACF3wAAhd8AAIUhAACFIQAAhSEAAIUhAACmWgAAploAAKZaAACmWgAA33sAAN97AADfewAA33sAACF7AAAhewAAIXsAACF7AABaWgAAWloAAFpaAABaWgAAeyEAAHshAAB7IQAAeyEAAHvfAAB73wAAe98AAHvfAI3yNACN8jQAjfI0AI3yNAAAWqYAAFqmAABapgAAWqYAACGFAAAhhQAAIYUAACGFAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAIEAAACBAAAAgQAAAIEAAACN2iYAjdomAI3aJgCN2iYAjcwOAI3MDgCNzA4AjcwOAI0OzACNDswAjQ7MAI0OzACN8swAjfLMAI3yzACN8swAjczyAI3M8gCNzPIAjczyAI0m2gCNJtoAjSbaAI0m2gCN2toAjdraAI3a2gCN2toAjTTyAI008gCNNPIAjTTyAI00DgCNNA4AjTQOAI00DgCNJiYAjSYmAI0mJgCNJiYAjQ40AI0ONACNDjQAjQ40AACF3wAAhd8AAIXfAACF3wCBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAAAAIYUAACGFAAAhhQAAIYUAAHshAAB7IQAAeyEAAHshAACFIQAAhSEAAIUhAACFIQAA34UAAN+FAADfhQAA34UAAHvfAAB73wAAe98AAHvfAACmWgAAploAAKZaAACmWgAAIXsAACF7AAAhewAAIXsAAKamAACmpgAApqYAAKamAABapgAAWqYAAFqmAABapgAA33sAAN97AADfewAA33sAAFpaAABaWgAAWloAAFpaAIL9CwCC/QsAgv0LAIL9CwCCAwsAggMLAIIDCwCCAwsAgggIAIIICACCCAgAgggIAIILAwCCCwMAggsDAIILAwCCCPgAggj4AIII+ACCCPgAggv9AIIL/QCCC/0Aggv9AIID9QCCA/UAggP1AIID9QCC/fUAgv31AIL99QCC/fUAgvj4AIL4+ACC+PgAgvj4AIL1/QCC9f0AgvX9AIL1/QCC9QMAgvUDAIL1AwCC9QMAgvgIAIL4CACC+AgAgvgIAI3aJgCN2iYAjdomAI3aJgCN2toAjdraAI3a2gCN2toAjSbaAI0m2gCNJtoAjSbaAI0mJgCNJiYAjSYmAI0mJgAAAAEAAgAAAAIAAwAEAAUABgAEAAYABwAIAAkACgAIAAoACwAMAA0ADgAMAA4ADwAQABEAEgAQABIAEwAUABUAFgAWABcAFAAWABgAFwAZABoAGwAZABsAHAAdAB4AHwAdAB8AIAAhACIAIwAhACMAJAAlACYAJwAlACcAKAApACoAKwApACsALAAtAC4ALwAtAC8AMAAxADIAMwAxADMANAA1ADYANwA1ADcAOAA5ADoAOwA5ADsAPAA9AD4APwA9AD8AQABBAEIAQwBBAEMARABFAEYARwBFAEcASABJAEoASwBJAEsATABNAE4ATwBNAE8AUABRAFIAUwBRAFMAVABVAFYAVwBVAFcAWABZAFoAWwBZAFsAXABdAF4AXwBdAF8AYABhAGIAYwBhAGMAZABlAGYAZwBlAGcAaABpAGoAawBpAGsAbABtAG4AbwBtAG8AcABxAHIAcwBxAHMAdAB1AHYAdwB1AHcAeAB5AHoAewB5AHsAfAB9AH4AfwB9AH8AgACBAIIAgwCBAIMAhACFAIYAhwCFAIcAiACJAIoAiwCMAI0AjgCMAI4AjwCQAJEAkgCQAJIAkwCUAJUAlgCUAJYAlwCYAJkAmgCYAJoAmwCcAJ0AngCcAJ4AnwCgAKEAogCgAKIAowCkAKUApgCkAKYApwCoAKkAqgCoAKoAqwCsAK0ArgCvALAAsQCvALEAsgCzALQAtQCzALUAtgC3ALgAuQC3ALkAugC7ALwAvQC7AL0AvgC/AMAAwQC/AMEAwgDDAMQAxQDDAMUAxgDHAMgAyQDHAMkAygDLAMwAzQDLAM0AzgDPANAA0QDPANEA0gDTANQA1QDTANUA1gDXANgA2QDXANkA2gDbANwA3QDbAN0A3gDfAOAA4QDiAOMA5ADiAOQA5QDmAOcA6ADmAOgA6QDmAOkA6gDmAOoA6wDsAO0A7gDsAO4A7wDwAPEA8gDwAPIA8wD0APUA9gD0APYA9wD4APkA+gD4APoA+wD8AP0A/gD8AP4A/wAAAQEBAgEAAQIBAwEEAQUBBgEEAQYBBwEIAQkBCgEIAQoBCwEMAQ0BDgEMAQ4BDwEQAREBEgEQARIBEwEUARUBFgEUARYBFwEYARkBGgEYARoBGwEcAR0BHgEcAR4BHwEgASEBIgEgASIBIwEkASUBJgEkASYBJwEoASkBKgEoASoBKwEsAS0BLgEsAS4BLwEwATEBMgEwATIBMwE0ATUBNgE0ATYBNwE4ATkBOgE4AToBOwE8AT0BPgE8AT4BPwFAAUEBQgFAAUIBQwFEAUUBRgFEAUYBRwFIAUkBSgFIAUoBSwFMAU0BTgFMAU4BTwFQAVEBUgFQAVIBUwFUAVUBVgFUAVYBVwFYAVkBWgFYAVoBWwFcAV0BXgFcAV4BXwFgAWEBYgFgAWIBYwFkAWUBZgFkAWYBZwFoAWkBagFoAWoBawFsAW0BbgFsAW4BbwFwAXEBcgFwAXIBcwF0AXUBdgF0AXYBdwF4AXkBegF4AXoBewF8AX0BfgF8AX4BfwGAAYEBggGAAYIBgwGEAYUBhgGEAYYBhwGIAYkBigGIAYoBiwGMAY0BjgGMAY4BjwGQAZEBkgGTAZQBlQGTAZUBlgGXAZgBmQGXAZkBmgGbAZwBnQGbAZ0BngGfAaABoQGfAaEBogGjAaQBpQGmAacBqAGpAaoBqwGpAasBrAGtAa4BrwGtAa8BsAGxAbIBswGxAbMBtAG1AbYBtwG1AbcBuAG5AboBuwG5AbsBvAG9Ab4BvwG9Ab8BwAHBAcIBwwHBAcMBxAHFAcYBxwHFAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHSAdQB1QHWAdcB2AHZAdoB2wHZAdsB3AHdAd4B3wHdAd8B4AHhAeIB4wHhAeMB5AHlAeYB5wHlAecB6AHpAeoB6wHpAesB7AHtAe4B7wHtAe8B8AHxAfIB8wHxAfMB9AH1AfYB9wH1AfcB+AH5AfoB+wH5AfsB/AH9Af4B/wH9Af8BAAIBAgICAwIBAgMCBAIFAgYCBwIFAgcCCAIJAgoCCwIJAgsCDAINAg4CDwINAg8CEAIRAhICEwIRAhMCFAIVAhYCFwIVAhcCGAIZAhoCGwIZAhsCHAIdAh4CHwIdAh8CIAIhAiICIwIhAiMCJAIlAiYCJwIoAikCKgIrAiwCLQIuAi8CMAIuAjACMQIyAjMCNAIyAjQCNQI2AjcCOAI2AjgCOQI6AjsCPAI6AjwCPQI+Aj8CQAI+AkACQQJCAkMCRAJCAkQCRQJGAkcCSAJGAkgCSQJKAksCTAJKAkwCTQJOAk8CUAJOAlACUQJSAlMCVAJSAlQCVQJWAlcCWAJWAlgCWQJaAlsCXAJaAlwCXQJeAl8CYAJeAmACYQJiAmMCZAJiAmQCZQJmAmcCaAJmAmgCaQJqAmsCbAJqAmwCbQJuAm8CcAJuAnACcQJyAnMCdAJyAnQCdQJ2AncCeAJ2AngCeQJ6AnsCfAJ6AnwCfQJ+An8CgAJ+AoACgQKCAoMChAKCAoQChQKGAocCiAKGAogCiQKKAosCjAKKAowCjQKOAo8CkAKOApACkQKSApMClAKSApQClQKWApcCmAKWApgCmQKaApsCnAKaApwCnQKeAp8CoAKhAqICowKhAqMCpAKlAqYCpwKlAqcCqAKpAqoCqwKpAqsCrAKtAq4CrwKtAq8CsAKxArICswKxArMCtAK1ArYCtwK1ArcCuAK5AroCuwK5ArsCvAK9Ar4CvwK9Ar8CwALBAsICwwLBAsMCxALFAsYCxwLFAscCyALJAsoCywLJAssCzALNAs4CzwLNAs8C0ALRAtIC0wLRAtMC1ALVAtYC1wLVAtcC2ALZAtoC2wLZAtsC3ALdAt4C3wLfAuAC3QLfAuEC4ALiAuMC5ALiAuQC5QLmAucC6ALmAugC6QLqAusC7ALsAu0C6gLsAu4C7QLvAvAC8QLvAvEC8gLzAvQC9QLzAvUC9gL3AvgC+QL3AvkC+gL7AvwC/QL7Av0C/gL/AgADAQP/AgEDAgMDAwQDBQMDAwUDBgMHAwgDCQMHAwkDCgMLAwwDDQMLAw0DDgMPAxADEQMPAxEDEgMTAxQDFQMTAxUDFgMXAxgDGQMXAxkDGgMbAxwDHQMbAx0DHgMfAyADIQMiAyMDJAMiAyQDJQMmAycDKAMmAygDKQMqAysDLAMqAywDLQMuAy8DMAMuAzADMQMyAzMDNAMyAzQDNQM2AzcDOAM2AzgDOQM6AzsDPAM6AzwDPQM+Az8DQAM+A0ADQQNCA0MDRANCA0QDRQNGA0cDSANGA0gDSQNKA0sDTANKA0wDTQNOA08DUANOA1ADUQNSA1MDVANSA1QDVQNWA1cDWANZA1oDWwNZA1sDXANdA14DXwNdA18DYANhA2IDYwNkA2UDZgNkA2YDZwNoA2kDagNoA2oDawNsA20DbgNsA24DbwNwA3EDcgNwA3IDcwN0A3UDdgN0A3YDdwN4A3kDegN4A3oDewN8A30DfgN8A34DfwOAA4EDggOAA4IDgwOEA4UDhgOEA4YDhwOIA4kDigOIA4oDiwOMA40DjgOMA44DjwOQA5EDkgOQA5IDkwOUA5UDlgOUA5YDlwOYA5kDmgOYA5oDmwOcA50DngOcA54DnwOgA6EDogOgA6IDowOkA6UDpgOkA6YDpwOoA6kDqgOoA6oDqwOsA60DrgOsA64DrwOwA7EDsgOwA7IDswO0A7UDtgO0A7YDtwO4A7kDugO4A7oDuwO8A70DvgO8A74DvwPAA8EDwgPAA8IDwwPEA8UDxgPEA8YDxwPIA8kDygPIA8oDywPMA80DzgPOA88DzAPOA9ADzwPRA9ID0wPRA9MD1APVA9YD1wPVA9cD2APZA9oD2wPZA9sD3APdA94D3wPdA98D4APhA+ID4wPhA+MD5APlA+YD5wPlA+cD6APpA+oD6wPpA+sD7APtA+4D7wPtA+8D8APxA/ID8wPxA/MD9AP1A/YD9wP1A/cD+AP5A/oD+wP5A/sD/AP9A/4D/wP9A/8DAAQBBAIEAwQBBAMEBAQFBAYEBwQFBAcECAQJBAoECwQJBAsEDAQNBA4EDwQNBA8EEAQRBBIEEwQRBBMEFAQVBBYEFwQVBBcEGAQZBBoEGwQZBBsEHAQdBB4EHwQdBB8EIAQhBCIEIwQhBCMEJAQlBCYEJwQlBCcEKAQpBCoEKwQpBCsELAQtBC4ELwQtBC8EMAQxBDIEMwQxBDMENAQ1BDYENwQ1BDcEOAQ5BDoEOwQ5BDsEPAQ9BD4EPwQ9BD8EQARBBEIEQwREBEUERgREBEYERwRIBEkESgRIBEoESwRMBE0ETgRMBE4ETwRQBFEEUgRQBFIEUwRUBFUEVgRUBFYEVwRYBFkEWgRYBFoEWwRcBF0EXgRcBF4EXwRgBGEEYgRgBGIEYwRkBGUEZgRnBGgEaQRnBGkEagRrBGwEbQRrBG0EbgRvBHAEcQRvBHEEcgRzBHQEdQRzBHUEdgR3BHgEeQR3BHkEegR7BHwEfQR7BH0EfgR/BIAEgQR/BIEEggSDBIQEhQSDBIUEhgSHBIgEiQSHBIkEigSLBIwEjQSLBI0EjgSPBJAEkQSPBJEEkgSTBJQElQSTBJUElgSXBJgEmQSaBJsEnASaBJwEnQSeBJ8EoASeBKAEoQSiBKMEpASiBKQEpQSmBKcEqASmBKgEqQSqBKsErASqBKwErQSuBK8EsASuBLAEsQSyBLMEtASyBLQEtQS2BLcEuAS2BLgEuQS6BLsEvAS6BLwEvQS+BL8EwAS+BMAEwQTCBMMExATCBMQExQTGBMcEyATGBMgEyQTKBMsEzATKBMwEzQTOBM8E0ATOBNAE0QTSBNME1ATSBNQE1QTWBNcE2ATWBNgE2QTaBNsE3ATaBNwE3QTeBN8E4ATeBOAE4QTiBOME5ATiBOQE5QTmBOcE6ATmBOgE6QTqBOsE7ATqBOwE7QTuBO8E8ATuBPAE8QTyBPME9ATyBPQE9QT2BPcE+AT2BPgE+QT6BPsE/AT6BPwE/QT+BP8EAAX+BAAFAQUCBQMFBAUCBQQFBQUGBQcFCAUGBQgFCQUKBQsFDAUKBQwFDQUOBQ8FEAUOBRAFEQUSBRMFFAUSBRQFFQUWBRcFGAUWBRgFGQUaBRsFHAUaBRwFHQUeBR8FIAUeBSAFIQUiBSMFJAUiBSQFJQUmBScFKAUmBSgFKQUqBSsFLAUqBSwFLQUuBS8FMAUuBTAFMQUyBTMFNAUyBTQFNQU2BTcFOAU2BTgFOQU6BTsFPAU6BTwFPQU+BT8FQAU+BUAFQQVCBUMFRAVFBUYFRwVFBUcFSAVJBUoFSwVJBUsFTAVNBU4FTwVNBU8FUAVRBVIFUwVRBVMFVAVVBVYFVwVYBVkFWgVbBVwFXQVbBV0FXgVfBWAFYQVfBWEFYgVjBWQFZQVjBWUFZgVnBWgFaQVnBWkFagVrBWwFbQVrBW0FbgVvBXAFcQVvBXEFcgVzBXQFdQVzBXUFdgV3BXgFeQV3BXkFegV7BXwFfQV+BX8FgAWBBYIFgwWEBYUFhgWEBYYFhwWIBYkFigWLBYwFjQWLBY0FjgWPBZAFkQWPBZEFkgWTBZQFlQWTBZUFlgWXBZgFmQWXBZkFmgWbBZwFnQWbBZ0FngWfBaAFoQWfBaEFogWjBaQFpQWjBaUFpgWnBagFqQWnBakFqgWrBawFrQWrBa0FrgWvBbAFsQWvBbEFsgWzBbQFtQWzBbUFtgW3BbgFuQW3BbkFugW7BbwFvQW7Bb0FvgW/BcAFwQW/BcEFwgXDBcQFxQXDBcUFxgXHBcgFyQXHBckFygXLBcwFzQXLBc0FzgXPBdAF0QXPBdEF0gXTBdQF1QXTBdUF1gXXBdgF2QXaBdsF3AXdBd4F3wXgBeEF4gXgBeIF4wXkBeUF5gXkBeYF5wXoBekF6gXoBeoF6wXsBe0F7gXsBe4F7wXwBfEF8gXwBfIF8wX0BfUF9gX0BfYF9wX4BfkF+gX4BfoF+wX8Bf0F/gX8Bf4F/wUABgEGAgYABgIGAwYEBgUGBgYEBgYGBwYIBgkGCgYIBgoGCwYMBg0GDgYMBg4GDwYQBhEGEgYQBhIGEwYUBhUGFgYUBhYGFwYYBhkGGgYYBhoGGwYcBh0GHgYcBh4GHwYgBiEGIgYgBiIGIwYkBiUGJgYkBiYGJwYoBikGKgYoBioGKwYsBi0GLgYsBi4GLwYwBjEGMgYwBjIGMwY0BjUGNgY0BjYGNwY4BjkGOgY4BjoGOwY8Bj0GPgY8Bj4GPwZABkEGQgZABkIGQwZEBkUGRgZEBkYGRwZIBkkGSgZIBkoGSwZMBk0GTgZMBk4GTwZQBlEGUgZTBlQGVQZTBlUGVgZXBlgGWQZXBlkGWgZbBlwGXQZbBl0GXgZfBmAGYQZfBmEGYgZjBmQGZQZjBmUGZgZnBmgGaQZnBmkGagZrBmwGbQZrBm0GbgZvBnAGcQZvBnEGcgZzBnQGdQZzBnUGdgZ3BngGeQZ3BnkGegZ7BnwGfQZ7Bn0GfgZ/BoAGgQZ/BoEGggaDBoQGhQaDBoUGhgaHBogGiQaHBokGigaLBowGjQaLBo0GjgaPBpAGkQaRBpIGjwaRBpMGkgaUBpUGlgaUBpYGlwaYBpkGmgaYBpoGmwacBp0GngaeBp8GnAaeBqAGnwahBqIGowahBqMGpAalBqYGpwalBqcGqAapBqoGqwapBqsGrAatBq4GrwatBq8GsAaxBrIGswaxBrMGtAa1BrYGtwa1BrcGuAa5BroGuwa5BrsGvAa9Br4Gvwa9Br8GwAbBBsIGwwbBBsMGxAbFBsYGxwbFBscGyAbJBsoGywbJBssGzAbNBs4GzwbNBs8G0AbRBtIG0wbUBtUG1gbUBtYG1wbYBtkG2gbYBtoG2wbcBt0G3gbcBt4G3wbgBuEG4gbgBuIG4wbkBuUG5gbkBuYG5wboBukG6gboBuoG6wbsBu0G7gbsBu4G7wbwBvEG8gbwBvIG8wb0BvUG9gb0BvYG9wb4BvkG+gb4BvoG+wb8Bv0G/gb8Bv4G/wYABwEHAgcABwIHAwcEBwUHBgcEBwYHBwcIBwkHCgcLBwwHDQcLBw0HDgcPBxAHEQcPBxEHEgcTBxQHFQcWBxcHGAcWBxgHGQcaBxsHHAcaBxwHHQceBx8HIAceByAHIQciByMHJAciByQHJQcmBycHKAcmBygHKQcqBysHLAcqBywHLQcuBy8HMAcuBzAHMQcyBzMHNAcyBzQHNQc2BzcHOAc2BzgHOQc6BzsHPAc6BzwHPQc+Bz8HQAc+B0AHQQdCB0MHRAdCB0QHRQdGB0cHSAdGB0gHSQdKB0sHTAdKB0wHTQdOB08HUAdOB1AHUQdSB1MHVAdSB1QHVQdWB1cHWAdWB1gHWQdaB1sHXAdaB1wHXQdeB18HYAdeB2AHYQdiB2MHZAdiB2QHZQdmB2cHaAdmB2gHaQcAAAEAAgADAAQABQADAAUABgAHAAgACQAHAAkACgALAAwADQALAA0ADgAPABAAEQAPABEAEgATABQAFQATABUAFgAXABgAGQAXABkAGgAbABwAHQAbAB0AHgAfACAAIQAfACEAIgAjACQAJQAjACUAJgAnACgAKQAnACkAKgArACwALQAuACwAKwAuAC8ALAArAC0AMAAxADAALQAxAC0AMgAzADEAMgAzADIANAAtADUAMgAtADYANQA2ADcANQA2ADgANwA1ADcAOQAyADUAOgA1ADkAOgAyADoANAA6ADkAOwA6ADsAPAA0ADoAPAA0ADwAPQA+AD8AQAA+AEAAQQBCAEMARABCAEQARQBGAEcASABGAEgASQBKAEsATABKAEwATQBOAE8AUABOAFAAUQBSAFMAVABSAFQAVQBWAFcAWABWAFgAWQBaAFsAXABaAFwAXQBeAF8AYABeAGAAYQBiAGMAZABiAGQAZQBmAGcAaABmAGgAaQBqAGsAbABqAGwAbQBuAG8AcABuAHAAcQByAHMAdAB1AHYAdwB3AHgAdQB3AHkAeAB6AHsAfAB6AHwAfQB+AH8AgAB+AIAAgQCCAIMAhACCAIQAhQCGAIcAiACGAIgAiQCKAIsAjACKAIwAjQCOAI8AkACRAI8AjgCOAJAAkgCTAJQAlQCTAJUAlgCWAJUAlwCYAJkAmgCYAJoAmwCcAJ0AngCfAKAAoQCfAKEAogCjAKQApQCjAKUApgCnAKgAqQCqAKsArACqAKwArQCuAK8AsACuALAAsQCyALMAtACyALQAtQC2ALcAuAC5ALoAuwC5ALsAvAC9AL4AvwC9AL8AwADBAMIAwwDBAMMAxADFAMYAxwDFAMcAyADJAMoAywDJAMsAzADNAM4AzwDNAM8A0ADRANIA0wDRANMA1ADVANYA1wDVANcA2ADZANoA2wDZANsA3ADdAN4A3wDdAN8A4ADhAOIA4wDhAOMA5ADlAOYA5wDlAOcA6ADpAOoA6wDpAOsA7ADtAO4A7wDtAO8A8ADxAPIA8wDxAPMA9AD1APYA9wD1APcA+AD5APoA+wD5APsA/AD9AP4A/wD9AP8AAAEBAQIBAwEBAQMBBAEFAQYBBwEFAQcBCAEJAQoBCwEJAQsBDAENAQ4BDwENAQ8BEAERARIBEwERARMBFAEVARYBFwEVARcBGAEZARoBGwEZARsBHAEdAR4BHwEdAR8BIAEhASIBIwEhASMBJAElASYBJwElAScBKAEpASoBKwEpASsBLAEtAS4BLwEtAS8BMAExATIBMwExATMBNAE1ATYBNwE1ATcBOAE5AToBOwE5ATsBPAE9AT4BPwE9AT8BQAFBAUIBQwFBAUMBRAFFAUYBRwFFAUcBSAFJAUoBSwFJAUsBTAFNAU4BTwFNAU8BUAFRAVIBUwFRAVMBVAFVAVYBVwFVAVcBWAFZAVoBWwFZAVsBXAFdAV4BXwFdAV8BYAFhAWIBYwFhAWMBZAFlAWYBZwFlAWcBaAFpAWoBawFpAWsBbAFtAW4BbwFwAXEBcgFwAXIBcwF0AXUBdgF0AXYBdwF4AXkBegF4AXoBewF8AX0BfgF/AYABgQGCAYMBhAGCAYQBhQGGAYcBiAGGAYgBiQGKAYsBjAGKAYwBjQGOAY8BkAGOAZABkQGSAZMBlAGSAZQBlQGWAZcBmAGWAZgBmQGaAZsBnAGaAZwBnQGeAZ8BoAGeAaABoQGiAaMBpAGiAaQBpQGmAacBqAGmAagBqQGqAasBrAGqAawBrQGuAa8BsAGuAbABsQGyAbMBtAGyAbQBtQG2AbcBuAG2AbgBuQG6AbsBvAG6AbwBvQG+Ab8BwAG+AcABwQHCAcMBxAHCAcQBxQHGAccByAHJAcoBywHLAcwByQHLAc0BzAHOAc8B0AHOAdAB0QHSAdMB1AHSAdQB1QHWAdcB2AHWAdgB2QHaAdsB3AHaAdwB3QHeAd8B4AHeAeAB4QHiAeMB5AHiAeQB5QHmAeIB5QHnAegB6QHoAeoB6QHnAekB6wHsAe0B7gHsAe4B7wHwAfEB8gHzAfQB9QHzAfUB9gH3AfgB+QH3AfkB+gH7AfwB/QH+Af8BAAL+AQACAQICAgMCBAICAgQCBQIGAgcCCAIGAggCCQIKAgsCDAINAg4CDwINAg8CEAIRAhICEwIRAhMCFAIVAhYCFwIVAhcCGAIZAhoCGwIZAhsCHAIdAh4CHwIdAh8CIAIhAiICIwIhAiMCJAIlAiYCJwIlAicCKAIpAioCKwIpAisCLAItAi4CLwItAi8CMAIxAjICMwIxAjMCNAI1AjYCNwI1AjcCOAI5AjoCOwI5AjsCPAI9Aj4CPwI9Aj8CQAJBAkICQwJBAkMCRAJFAkYCRwJFAkcCSAJJAkoCSwJJAksCTAJNAk4CTwJNAk8CUAJRAlICUwJRAlMCVAJVAlYCVwJVAlcCWAJZAloCWwJZAlsCXAJdAl4CXwJdAl8CYAJhAmICYwJhAmMCZAJlAmYCZwJlAmcCaAJpAmoCawJpAmsCbAJtAm4CbwJtAm8CcAJxAnICcwJxAnMCdAJ1AnYCdwJ1AncCeAJ5AnoCewJ5AnsCfAJ9An4CfwJ9An8CgAKBAoICgwKBAoMChAKFAoYChwKFAocCiAKJAooCiwKJAosCjAKNAo4CjwKNAo8CkAKRApICkwKRApMClAKVApYClwKVApcCmAKZApoCmwKZApsCnAKdAp4CnwKdAp8CoAKhAqICowKhAqMCpAKlAqYCpwKlAqcCqAKpAqoCqwKpAqsCrAKtAq4CrwKtAq8CsAKxArICswKxArMCtAK1ArYCtwK1ArcCuAK5AroCuwK5ArsCvAK9Ar4CvwK9Ar8CwALBAsICwwLEAsUCxgLEAsYCxwLIAskCygLIAsoCywLMAs0CzgLMAs4CzwLQAtEC0gIAAAEAAgAAAAIAAwAEAAUABgAEAAYABwAIAAkACgAIAAoACwAMAA0ADgAMAA4ADwAQABEAEgAQABIAEwAUABUAFgAUABYAFwAYABkAGgAYABoAGwAcAB0AHgAfACAAIQAfACEAIgAjACQAJQAjACUAJgAnACgAKQAnACkAKgArACwALQAuAC8AMAAxADIAMwAxADMANAA1ADYANwA1ADcAOAA5ADoAOwA5ADsAPAA9AD4APwA9AD8AQABBAEIAQwBBAEMARABFAEYARwBFAEcASABJAEoASwBJAEsATABNAE4ATwBNAE8AUABRAFIAUwBRAFMAVABVAFYAVwBVAFcAWABZAFoAWwBZAFsAXABdAF4AXwBgAGEAYgBgAGIAYwBkAGUAZgBkAGYAZwBoAGkAagBoAGoAawBsAG0AbgBvAHAAcQByAHMAdAByAHQAdQB2AHcAeAB2AHgAeQB6AHsAfAB6AHwAfQB+AH8AgAB+AIAAgQAAAAEAAgAAAAIAAwAEAAUABgAEAAYABwAIAAkACgAIAAoACwAMAA0ADgAMAA4ADwAQABEAEgAQABIAEwAUABUAFgAUABYAFwAVABgAGQAVABoAGAAbABwAHQAbAB0AHgAfACAAIQAfACEAIgAjACQAJQAjACUAJgAnACgAKQAnACkAKgArACwALQArAC0ALgAvADAAMQAvADEAMgAzADQANQAzADUANgA3ADgAOQA3ADkAOgA7ADwAPQA7AD0APgA/AEAAQQA/AEEAQgBBAEMAQgBEAEUAPwBGAEQAPwBCAEYAPwBGAEcARABCAEgARgBIAEkARgBCAEoASABLAEwATQBLAE0ATgBPAFAAUQBPAFEAUgBTAFQAVQBTAFUAVgBXAFgAWQBXAFkAWgBbAFwAXQBbAF0AXgBfAGAAYQBfAGEAYgBjAGQAZQBjAGUAZgBnAGgAaQBnAGkAagBrAGwAbQBrAG0AbgBvAHAAcQBvAHEAcgBzAHQAdQBzAHUAdgB3AHgAeQB3AHkAegB7AHwAfQB7AH0AfgB/AIAAgQB/AIEAggCDAIQAhQCDAIUAhgCHAIgAiQCHAIkAigCLAIwAjQCLAI0AjgCPAJAAkQCPAJEAkgCTAJQAlQCTAJUAlgCXAJgAmQCXAJkAmgCbAJwAnQCbAJ0AngCfAKAAoQCfAKEAogCjAKQApQCjAKUApgCnAKgAqQCnAKkAqgCrAKwArQCrAK0ArgCvALAAsQCvALEAsgCzALQAtQCzALUAtgC3ALgAuQC3ALkAugC7ALwAvQC7AL0AvgC8AL8AwAC8AMEAvwDCAMMAxADCAMQAxQDGAMcAyADGAMgAyQDKAMsAzADKAMwAzQDOAM8A0ADOANAA0QDSANMA1ADSANQA1QDWANcA2ADWANgA2QDaANsA3ADaANwA3QDeAN8A4ADeAOAA4QDiAOMA5ADiAOQA5QDmAOcA6ADmAOgA6QDqAOsA7ADqAOwA7QDuAO8A8ADuAPAA8QDyAPMA9ADyAPQA9QD2APcA+AD2APgA+QD6APsA/AD6APwA/QD+AP8AAAH+AAABAQECAQMBBAECAQQBBQEGAQcBCAEGAQgBCQEKAQsBDAEKAQwBDQEOAQ8BEAEOARABEQESARMBFAESARQBFQEWARcBGAEWARgBGQEaARsBHAEaARwBHQEeAR8BIAEeASABIQEiASMBJAEiASQBJQEmAScBKAEmASgBKQEqASsBLAEqASwBLQEuAS8BMAEuATABMQEyATMBNAEyATQBNQE2ATcBOAE2ATgBOQE6ATsBPAE6ATwBPQE+AT8BQAE+AUABQQFCAUMBRAFCAUQBRQFGAUcBSAFGAUgBSQFKAUsBTAFKAUwBTQFOAU8BUAFOAVABUQFSAVMBVAFSAVQBVQFWAVcBWAFWAVgBWQFaAVsBXAFaAVwBXQFeAV8BYAFeAWABYQFiAWMBZAFiAWQBZQFmAWcBaAFmAWgBaQFqAWsBbAFqAWwBbQFuAW8BcAFuAXABcQFyAXMBdAFyAXQBdQF2AXcBeAF2AXgBeQF6AXsBfAF6AXwBfQF+AX8BgAF+AYABgQGCAYMBhAGCAYQBhQGGAYcBiAGGAYgBiQGKAYsBjAGKAYwBjQGOAY8BkAGOAZABkQGSAZMBlAGSAZQBlQGWAZcBmAGWAZgBmQGaAZsBnAGaAZwBnQGeAZ8BoAGeAaABoQGiAaMBpAGiAaQBpQGmAacBqAGmAagBqQGqAasBrAGqAawBrQGuAa8BsAGuAbABsQGyAbMBtAGyAbQBtQG2AbcBuAG2AbgBuQG6AbsBvAG6AbwBvQG+Ab8BwAG+AcABwQHCAcMBxAHCAcQBxQHGAccByAHGAcgByQHKAcsBzAHKAcwBzQHOAc8B0AHOAdAB0QHSAdMB1AHSAdQB1QHWAdcB2AHWAdgB2QHaAdsB3AHaAdwB3QHeAd8B4AHeAeAB4QHiAeMB5AHiAeQB5QHmAecB6AHmAegB6QHqAesB7AHqAewB7QHuAe8B8AHuAfAB8QHyAfMB9AHyAfQB9QH2AfcB+AH2AfgB+QH6AfsB/AH6AfwB/QH+Af8BAAL+AQACAQICAgMCBAICAgQCBQIGAgcCCAIGAggCCQIKAgsCDAIKAgwCDQIOAg8CEAIOAhACEQISAhMCFAISAhQCFQIWAhcCGAIWAhgCGQIaAhsCHAIaAhwCHQIeAh8CIAIeAiACIQIiAiMCJAIiAiQCJQImAicCKAImAigCKQIqAisCLAIqAiwCLQIuAi8CMAIuAjACMQIyAjMCNAIyAjQCNQI2AjcCOAI2AjgCOQI6AjsCPAI6AjwCPQI+Aj8CQAI+AkACQQJCAkMCRAJCAkQCRQJGAkcCSAJGAkgCSQJKAksCTAJKAkwCTQJOAk8CUAJOAlACUQJSAlMCVAJSAlQCVQJWAlcCWAJWAlgCWQJaAlsCXAJaAlwCXQJeAl8CYAJeAmACYQJiAmMCZAJiAmQCZQJmAmcCaAJmAmgCaQJoAmoCaQJrAmwCZgJtAmsCZgJpAm0CZgJtAm4CawJpAm8CbQJvAnACbQJpAnECbwJyAnMCdAJyAnQCdQJ2AncCeAJ2AngCeQJ6AnsCfAJ6AnwCfQJ+An8CgAJ+AoACgQKCAoMChAKCAoQChQKGAocCiAKGAogCiQKKAosCjAKKAowCjQKOAo8CkAKOApACkQKSApMClAKSApQClQKWApcCmAKWApgCmQKaApsCnAKaApwCnQKeAp8CoAKeAqACoQKiAqMCpAKiAqQCpQKmAqcCqAKmAqgCqQKqAqsCrAKqAqwCrQKuAq8CsAKuArACsQKyArMCtAKyArQCtQK2ArcCuAK2ArgCuQK6ArsCvAK6ArwCvQK+Ar8CwAK+AsACwQLCAsMCxALCAsQCxQLGAscCyALGAsgCyQLKAssCzALKAswCzQLOAs8C0ALOAtAC0QLSAtMC1ALSAtQC1QLWAtcC2ALWAtgC2QLaAtsC3ALaAtwC3QLeAt8C4ALeAuAC4QLiAuMC5ALiAuQC5QLmAucC6ALmAugC6QLqAusC7ALqAuwC7QLuAu8C8ALuAvAC8QLyAvMC9ALyAvQC9QL2AvcC+AL2AvgC+QL6AvsC/AL6AvwC/QL+Av8CAAP+AgADAQMCAwMDBAMCAwQDBQMGAwcDCAMGAwgDCQMKAwsDDAMKAwwDDQMOAw8DEAMOAxADEQMSAxMDFAMSAxQDFQMWAxcDGAMWAxgDGQMaAxsDHAMaAxwDHQMeAx8DIAMeAyADIQMiAyMDJAMiAyQDJQMmAycDKAMmAygDKQMqAysDLAMqAywDLQMuAy8DMAMuAzADMQMyAzMDNAMyAzQDNQM2AzcDOAM2AzgDOQM6AzsDPAM6AzwDPQM+Az8DQAM+A0ADQQNCA0MDRANCA0QDRQNGA0cDSANGA0gDSQNKA0sDTANKA0wDTQNOA08DUANOA1ADUQNSA1MDVANSA1QDVQNWA1cDWANWA1gDWQNaA1sDXANaA1wDXQNeA18DYANeA2ADYQNiA2MDZANiA2QDZQNmA2cDaANmA2gDaQNqA2sDbANqA2wDbQNuA28DcANuA3ADcQNyA3MDdANyA3QDdQN2A3cDeAN2A3gDeQN6A3sDfAN6A3wDfQN+A38DgAN+A4ADgQOCA4MDhAOCA4QDhQOGA4cDiAOGA4gDiQOKA4sDjAOKA4wDjQOOA48DkAOOA5ADkQOSA5MDlAOSA5QDlQOWA5cDmAOWA5gDmQOaA5sDnAOaA5wDnQOeA58DoAOeA6ADoQOiA6MDpAOiA6QDpQOmA6cDqAOmA6gDqQOqA6sDrAOqA6wDrQOuA68DsAOuA7ADsQOyA7MDtAOyA7QDtQO2A7cDuAO2A7gDuQO6A7sDvAO6A7wDvQO+A78DwAO+A8ADwQPCA8MDxAPCA8QDxQPGA8cDyAPGA8gDyQPKA8sDzAPKA8wDzQPOA88D0APOA9AD0QPSA9MD1APSA9QD1QPWA9cD2APWA9gD2QPaA9sD3APaA9wD3QPeA98D4APeA+AD4QPiA+MD5APiA+QD5QPmA+cD6APmA+gD6QPqA+sD7APqA+wD7QPuA+8D8APuA/AD8QPyA/MD9APyA/QD9QP2A/cD+AP2A/gD+QP6A/sD/AP6A/wD/QP+A/8DAAT+AwAEAQQCBAMEBAQCBAQEBQQGBAcECAQGBAgECQQKBAsEDAQKBAwEDQQOBA8EEAQOBBAEEQQSBBMEFAQSBBQEFQQWBBcEGAQWBBgEGQQaBBsEHAQaBBwEHQQeBB8EIAQeBCAEIQQiBCMEJAQiBCQEJQQmBCcEKAQmBCgEKQQqBCsELAQqBCwELQQuBC8EMAQuBDAEMQQyBDMENAQyBDQENQQ2BDcEOAQ2BDgEOQQ6BDsEPAQ6BDwEPQQ+BD8EQAQ+BEAEQQRCBEMERARCBEQERQRGBEcESARGBEgESQRKBEsETARKBEwETQROBE8EUAROBFAEUQRSBFMEVARSBFQEVQRWBFcEWARWBFgEWQRaBFsEXARaBFwEXQReBF8EYAReBGAEYQRiBGMEZARiBGQEZQRmBGcEaARmBGgEaQRqBGsEbARqBGwEbQRuBG8EcARuBHAEcQRyBHMEdARyBHQEdQR2BHcEeAR2BHgEeQR6BHsEfAR6BHwEfQR+BH8EgAR+BIAEgQSCBIMEhASCBIQEhQSGBIcEiASGBIgEiQSKBIsEjASKBIwEjQSOBI8EkASOBJAEkQSSBJMElASSBJQElQSUBJYElQSXBJgEkgSZBJcEkgSVBJkEkgSZBJoElwSVBJsEmQSbBJwEmQSVBJ0EmwSeBJ8EoASeBKAEoQSiBKMEpASiBKQEpQSmBKcEqASmBKgEqQSqBKsErASqBKwErQSuBK8EsASuBLAEsQSyBLMEtASyBLQEtQS2BLcEuAS2BLgEuQS6BLsEvAS6BLwEvQS+BL8EwAS+BMAEwQTCBMMExATCBMQExQTGBMcEyATGBMgEyQTKBMsEzATKBMwEzQTOBM8E0ATOBNAE0QTSBNME1ATSBNQE1QTWBNcE2ATWBNgE2QTaBNsE3ATaBNwE3QTeBN8E4ATeBOAE4QTiBOME5ATiBOQE5QTmBOcE6ATmBOgE6QTqBOsE7ATqBOwE7QTuBO8E8ATuBPAE8QTyBPME9ATyBPQE9QT2BPcE+AT2BPgE+QT6BPsE/AT6BPwE/QT+BP8EAAX+BAAFAQUCBQMFBAUCBQQFBQUGBQcFCAUGBQgFCQUKBQsFDAUKBQwFDQUOBQ8FEAUOBRAFEQUSBRMFFAUSBRQFFQUWBRcFGAUWBRgFGQUaBRsFHAUaBRwFHQUeBR8FIAUeBSAFIQUiBSMFJAUiBSQFJQUmBScFKAUmBSgFKQUqBSsFLAUqBSwFLQUuBS8FMAUuBTAFMQUyBTMFNAUyBTQFNQU2BTIFNwU2BTcFOAU5BTYFOgU5BToFOwU8BTkFPQU8BT0FPgU/BUAFQQU/BUEFQgVDBUQFRQVDBUUFRgVHBUgFSQVHBUkFSgVLBUwFTQVLBU0FTgVPBVAFUQVPBVEFUgVTBVQFVQVTBVUFVgVXBVgFWQVXBVkFWgVbBVwFXQVbBV0FXgVfBWAFYQVfBWEFYgVjBWQFZQVjBWUFZgVnBWgFaQVnBWkFagVrBWwFbQVrBW0FbgVvBXAFcQVvBXEFcgVzBXQFdQVzBXUFdgV3BXgFeQV3BXkFegV7BXwFfQV7BX0FfgV/BYAFgQV/BYEFggWDBYQFhQWDBYUFhgWHBYgFiQWHBYkFigWLBYwFjQWLBY0FjgWPBZAFkQWPBZEFkgWTBZQFlQWTBZUFlgWXBZgFmQWXBZkFmgWbBZwFnQWbBZ0FngWfBaAFoQWfBaEFogWjBaQFpQWjBaUFpgWnBagFqQWnBakFqgWrBawFrQWrBa0FrgWvBbAFsQWvBbEFsgWzBbQFtQWzBbUFtgW3BbgFuQW3BbkFugW7BbwFvQW7Bb0FvgW/BcAFwQW/BcEFwgXDBcQFxQXDBcUFxgXHBcgFyQXHBckFygXLBcwFzQXLBc0FzgXPBdAF0QXPBdEF0gXTBdQF1QXTBdUF1gXXBdgF2QXXBdkF2gXbBdwF3QXbBd0F3gXfBeAF4QXfBeEF4gXjBeQF5QXjBeUF5gXnBegF6QXnBekF6gXrBewF7QXrBe0F7gXvBfAF8QXvBfEF8gXzBfQF9QXzBfUF9gX3BfgF+QX3BfkF+gX7BfwF/QX7Bf0F/gX/BQAGAQb/BQEGAgYDBgQGBQYDBgUGBgYHBggGCQYHBgkGCgYLBgwGDQYLBg0GDgYPBhAGEQYPBhEGEgYTBhQGFQYTBhUGFgYXBhgGGQYXBhkGGgYbBhwGHQYbBh0GHgYfBiAGIQYfBiEGIgYjBiQGJQYjBiUGJgYnBigGKQYnBikGKgYrBiwGLQYrBi0GLgYvBjAGMQYvBjEGMgYzBjQGNQYzBjUGNgY3BjgGOQY3BjkGOgY7BjwGPQY7Bj0GPgY/BkAGQQY/BkEGQgZDBkQGRQZDBkUGRgZHBkgGSQZHBkkGSgZLBkwGTQZLBk0GTgZPBlAGUQZPBlEGUgZTBlQGVQZTBlUGVgZXBlgGWQZXBlkGWgZbBlwGXQZbBl0GXgZfBmAGYQZfBmEGYgZjBmQGZQZjBmUGZgZnBmgGaQZnBmkGagZrBmwGbQZrBm0GbgZvBnAGcQZvBnEGcgZzBnQGdQZzBnUGdgZ3BngGeQZ3BnkGegZ7BnwGfQZ7Bn0GfgZ/BoAGgQZ/BoEGggaDBoQGhQaDBoUGhgaHBogGiQaHBokGigaLBowGjQaLBo0GjgaPBpAGkQaPBpEGkgaTBpQGlQaTBpUGlgaXBpgGmQaXBpkGmgabBpwGnQabBp0GngafBqAGoQafBqEGogajBqQGpQajBqUGpganBqgGqQanBqkGqgarBqwGrQarBq0GrgavBrAGsQavBrEGsgazBrQGtQazBrUGtga3BrgGuQa3BrkGuga7BrwGvQa7Br0Gvga9Br8GvgbABsEGuwbCBsAGuwa+BsIGuwbCBsMGwAa+BsQGwgbEBsUGwga+BsYGxAbHBsgGyQbHBskGygbLBswGzQbLBs0GzgbPBtAG0QbPBtEG0gbTBtQG1QbTBtUG1gbXBtgG2QbXBtkG2gbbBtwG3QbbBt0G3gbfBuAG4QbfBuEG4gbjBuQG5QbjBuUG5gbnBugG6QbnBukG6gbrBuwG7QbrBu0G7gbvBvAG8QbvBvEG8gbzBvQG9QbzBvUG9gb3BvgG+Qb3BvkG+gb7BvwG/Qb7Bv0G/gb/BgAHAQf/BgEHAgcDBwQHBQcDBwUHBgcHBwgHCQcHBwkHCgcLBwwHDQcLBw0HDgcPBxAHEQcPBxEHEgcTBxQHFQcTBxUHFgcXBxgHGQcXBxkHGgcbBxwHHQcbBx0HHgcfByAHIQcfByEHIgcjByQHJQcjByUHJgcnBygHKQcnBykHKgcrBywHLQcrBy0HLgcvBzAHMQcvBzEHMgczBzQHNQczBzUHNgc3BzgHOQc3BzkHOgc7BzwHPQc7Bz0HPgc/B0AHQQc/B0EHQgdDB0QHRQdDB0UHRgdHB0gHSQdHB0kHSgdLB0wHTQdLB00HTgdPB1AHUQdPB1EHUgdTB1QHVQdTB1UHVgdXB1gHWQdXB1kHWgdbB1wHXQdbB10HXgdfB2AHYQdfB2EHYgdjB2QHZQdjB2UHZgdnB2gHaQdnB2kHagdrB2wHbQdrB20HbgdvB3AHcQdvB3EHcgdzB3QHdQdzB3UHdgd3B3gHeQd3B3kHegd7B3wHfQd7B30Hfgd/B4AHgQd/B4EHggeDB4QHhQeDB4UHhgeHB4gHiQeHB4kHigeLB4wHjQeLB40HjgePB5AHkQePB5EHkgeTB5QHlQeTB5UHlgeXB5gHmQeXB5kHmgebB5wHnQebB50HngefB6AHoQefB6EHogejB6QHpQejB6UHpgenB6gHqQenB6kHqgerB6wHrQerB60HrgevB7AHsQevB7EHsgezB7QHtQezB7UHtge3B7gHuQe3B7kHuge7B7wHvQe7B70Hvge/B8AHwQe/B8EHwgfDB8QHxQfDB8UHxgfHB8gHyQfHB8kHygfLB8wHzQfLB80HzgfPB9AH0QfPB9EH0gfTB9QH1QfTB9UH1gfXB9gH2QfXB9kH2gfbB9wH3QfbB90H3gffB+AH4QffB+EH4gfjB+QH5QfjB+UH5gfnB+gH6QfnB+kH6gfrB+wH7QfrB+0H7gfvB/AH8QfvB/EH8gfzB/QH9QfzB/UH9gf3B/gH+Qf3B/kH+gf7B/wH/Qf7B/0H/gf/BwAIAQj/BwEIAggDCAQIBQgDCAUIBggHCAgICQgHCAkICggLCAwIDQgLCA0IDggPCBAIEQgPCBEIEggTCBQIFQgTCBUIFggXCBgIGQgXCBkIGggbCBwIHQgbCB0IHggfCCAIIQgfCCEIIggjCCQIJQgjCCUIJggnCCgIKQgnCCkIKggrCCwILQgrCC0ILggvCDAIMQgvCDEIMggzCDQINQgzCDUINgg3CDgIOQg3CDkIOgg7CDwIPQg7CD0IPgg/CEAIQQg/CEEIQghDCEQIRQhDCEUIRghHCEgISQhHCEkISghLCEwITQhLCE0ITghPCFAIUQhPCFEIUghTCFQIVQhTCFUIVghXCFgIWQhXCFkIWghbCFwIXQhbCF0IXghfCGAIYQhfCGEIYghjCGQIZQhjCGUIZghnCGgIaQhnCGkIaghrCGwIbQhrCG0IbghvCHAIcQhvCHEIcghzCHQIdQhzCHUIdgh3CHgIeQh3CHkIegh7CHwIfQh7CH0Ifgh/CIAIgQh/CIEIggiDCIQIhQiDCIUIhgiHCIgIiQiHCIkIigiLCIwIjQiLCI0IjgiPCJAIkQiPCJEIkgiTCJQIlQiTCJUIlgiXCJgImQiXCJkImgibCJwInQibCJ0IngifCKAIoQifCKEIogijCKQIpQijCKUIpginCKgIqQinCKkIqgirCKwIrQirCK0IrgivCLAIsQivCLEIsggAAAEAAgAAAAIAAwAEAAUABgAEAAYABwAIAAkACgALAAwADQALAA0ADgAPABAAEQAPABEAEgATABQAFQAAAAEAAgAAAAIAAwAEAAUABgAHAAgACQAHAAkACgALAAwADQAAAAEAAgAAAAIAAwAEAAUABgAEAAYABwAIAAkACgAIAAoACwAMAA0ADgAMAA4ADwAQABEAEgAQABIAEwAUABUAFgAUABYAFwAYABkAGgAYABoAGwAcAB0AHgAcAB4AHwAgACEAIgAgACIAIwAkACUAJgAkACYAJwAoACkAKgAoACoAKwAsAC0ALgAsAC4ALwAwADEAMgAwADIAMwA0ADUANgA0ADYANwA2ADgANwA5ADoANAA7ADkANAA3ADsANAA7ADwAOQA3AD0AOwA9AD4AOwA3AD8APQBAAEEAQgBAAEIAQwBEAEAAQwBEAEMARQBGAEQARQBGAEUARwBIAEYARwBIAEcASQBKAEsATABKAEwATQBOAE8AUABOAFAAUQBSAFMAVABSAFQAVQBWAFcAWABWAFgAWQBaAFsAXABaAFwAXQBeAF8AYABeAGAAYQBiAGMAZABiAGQAZQBmAGcAaABmAGgAaQBqAGsAbABqAGwAbQBuAG8AcABuAHAAcQByAHMAdAByAHQAdQB2AHcAeAB2AHgAeQB6AHsAfAB6AHwAfQB7AH4AfAB7AH8AfgB/AIAAfgB/AIEAgACBAIIAgACBAIMAggCDAIQAggCDAIUAhACGAIcAiACGAIgAiQCKAIsAjACKAIwAjQCOAI8AkACOAJAAkQCSAJMAlACSAJQAlQCWAJcAmACWAJgAmQCaAJsAnACaAJwAnQCeAJ8AoACeAKAAoQCiAKMApACiAKQApQCmAKcAqACmAKgAqQCqAKsArACqAKwArQCuAK8AsACuALAAsQCyALMAtACyALQAtQC2ALcAuAC2ALgAuQC6ALsAvAC6ALwAvQC+AL8AwAC+AMAAwQDCAMMAxADCAMQAxQDGAMcAyADGAMgAyQDKAMsAzADKAMwAzQDOAM8A0ADOANAA0QDSANMA1ADSANQA1QDWANcA2ADWANgA2QDaANsA3ADaANwA3QDeAN8A4ADeAOAA4QDiAOMA5ADiAOQA5QDmAOcA6ADmAOgA6QDqAOsA7ADqAOwA7QDuAO8A8ADuAPAA8QDyAPMA9ADyAPQA9QD2APcA+AD2APgA+QD6APsA/AD6APwA/QD+AP8AAAH+AAABAQECAQMBBAECAQQBBQEGAQcBCAEGAQgBCQEKAQsBDAEKAQwBDQEOAQ8BEAEOARABEQESARMBFAESARQBFQEWARcBGAEWARgBGQEaARsBHAEaARwBHQEeAR8BIAEeASABIQEiASMBJAEiASQBJQEmAScBKAEmASgBKQEqASsBLAEqASwBLQEuAS8BMAEuATABMQEyATMBNAEyATQBNQE0ATYBNQE3ATgBMgE5ATcBMgE1ATkBMgE5AToBNwE1ATsBOQE7ATwBOQE1AT0BOwE+AT8BQAE+AUABQQFCAUMBRAFCAUQBRQFGAUcBSAFGAUgBSQFKAUsBTAFKAUwBTQFOAU8BUAFOAVABUQFSAVMBVAFSAVQBVQFWAVcBWAFWAVgBWQFaAVsBXAFaAVwBXQFeAV8BYAFeAWABYQFiAWMBZAFiAWQBZQFmAWcBaAFmAWgBaQFqAWsBbAFqAWwBbQFuAW8BcAFuAXABcQFyAXMBdAFyAXQBdQF1AXQBdgF1AXYBdwF3AXYBeAF3AXgBeQF6AXsBfAF6AXwBfQF+AX8BgAF+AYABgQGCAYMBhAGCAYQBhQGGAYcBiAGGAYgBiQGKAYsBjAGKAYwBjQGOAY8BkAGOAZABkQGSAZMBlAGSAZQBlQGWAZcBmAGWAZgBmQGaAZsBnAGaAZwBnQGeAZ8BoAGeAaABoQGiAaMBpAGiAaQBpQGmAacBqAGmAagBqQGqAasBrAGqAawBrQGuAa8BsAGuAbABsQGyAbMBtAGyAbQBtQG2AbcBuAG2AbgBuQG6AbsBvAG6AbwBvQG+Ab8BwAG+AcABwQHCAcMBxAHCAcQBxQHGAccByAHGAcgByQHKAcsBzAHKAcwBzQHOAc8B0AHOAdAB0QHSAdMB1AHSAdQB1QHWAdcB2AHWAdgB2QHaAdsB3AHaAdwB3QHeAd8B4AHeAeAB4QHiAeMB5AHiAeQB5QHmAecB6AHmAegB6QHqAesB7AHqAewB7QHuAe8B8AHuAfAB8QHyAfMB9AHyAfQB9QH2AfcB+AH2AfgB+QH6AfsB/AH6AfwB/QH+Af8BAAL+AQACAQICAgMCBAICAgQCBQIGAgcCCAIGAggCCQIKAgsCDAIKAgwCDQIOAg8CEAIOAhACEQISAhMCFAISAhQCFQIWAhcCGAIWAhgCGQIaAhsCHAIaAhwCHQIeAh8CIAIeAiACIQIiAiMCJAIiAiQCJQImAicCKAImAigCKQIqAisCLAIqAiwCLQIuAi8CMAIuAjACMQIyAjMCNAIyAjQCNQI2AjcCOAI2AjgCOQI6AjsCPAI6AjwCPQI8Aj4CPQI/AkACOgJBAj8COgI9AkECOgJBAkICPwI9AkMCQQJDAkQCQQI9AkUCQwJGAkcCSAJGAkgCSQJKAksCTAJKAkwCTQJOAk8CUAJOAlACUQJSAlMCVAJSAlQCVQJWAlcCWAJWAlgCWQJaAlsCXAJaAlwCXQJeAl8CYAJeAmACYQJiAmMCZAJiAmQCZQJmAmcCaAJmAmgCaQJqAmsCbAJqAmwCbQJuAm8CcAJuAnACcQJyAnMCdAJyAnQCdQJ2AncCeAJ2AngCeQJ6AnsCfAJ7An0CfAJ6AnwCfgJ7An8CfQJ/AoACfQJ/AoECgAKCAnoCfgKCAn4CgwKEAoICgwKEAoMChQKGAocCiAKGAogCiQKKAosCjAKKAowCjQKOAo8CkAKOApACkQKSApMClAKSApQClQKWApcCmAKWApgCmQKaApsCnAKaApwCnQKeAp8CoAKeAqACoQKiAqMCpAKiAqQCpQKmAqcCqAKmAqgCqQKqAqsCrAKqAqwCrQKuAq8CsAKuArACsQKyArMCtAKyArQCtQK2ArcCuAK2ArgCuQK6ArsCvAK6ArwCvQK+Ar8CwAK+AsACwQLCAsMCxALCAsQCxQLGAscCyALGAsgCyQLKAssCzALKAswCzQLOAs8C0ALOAtAC0QLSAtMC1ALSAtQC1QLWAtcC2ALWAtgC2QLaAtsC3ALaAtwC3QLeAt8C4ALeAuAC4QLiAuMC5ALiAuQC5QLmAucC6ALmAugC6QLqAusC7ALqAuwC7QLuAu8C8ALuAvAC8QLyAvMC9ALyAvQC9QL2AvcC+AL2AvgC+QL6AvsC/AL6AvwC/QL+Av8CAAP+AgADAQMCAwMDBAMCAwQDBQMGAwcDCAMGAwgDCQMKAwsDDAMKAwwDDQMOAw8DEAMOAxADEQMSAxMDFAMSAxQDFQMWAxcDGAMWAxgDGQMaAxsDHAMaAxwDHQMeAx8DIAMeAyADIQMiAyMDJAMiAyQDJQMmAycDKAMmAygDKQMqAysDLAMqAywDLQMuAy8DMAMuAzADMQMyAzMDNAMyAzQDNQM2AzcDOAM2AzgDOQM6AzsDPAM6AzwDPQM+Az8DQAM+A0ADQQNAA0IDQQNDA0QDPgNFA0MDPgNBA0UDPgNFA0YDQwNBA0cDRQNHA0gDRQNBA0kDRwNKA0sDTANKA0wDTQNOA08DUANOA1ADUQNSA1MDVANSA1QDVQNWA1cDWANWA1gDWQNaA1sDXANaA1wDXQNeA18DYANeA2ADYQNiA2MDZANiA2QDZQNmA2cDaANmA2gDaQNqA2sDbANqA2wDbQNuA28DcANuA3ADcQNyA3MDdANyA3QDdQN2A3cDeAN2A3gDeQN6A3sDfAN6A3wDfQN+A38DgAN+A4ADgQOCA38DfgOCA4MDfwOEA4UDhgOEA4YDhwOIA4kDigOIA4oDiwOMA40DjgOMA44DjwOQA5EDkgOQA5IDkwOUA5UDlgOUA5YDlwOYA5kDmgOYA5oDmwOcA50DngOcA54DnwOgA6EDogOgA6IDowOkA6UDpgOkA6YDpwOoA6kDqgOoA6oDqwOsA60DrgOsA64DrwOwA7EDsgOwA7IDswO0A7UDtgO0A7YDtwO4A7kDugO4A7oDuwO8A70DvgO8A74DvwPAA8EDwgPAA8IDwwPEA8UDxgPEA8YDxwPIA8kDygPIA8oDywPMA80DzgPMA84DzwPQA9ED0gPQA9ID0wPUA9UD1gPUA9YD1wPYA9kD2gPYA9oD2wPcA90D3gPcA94D3wPgA+ED4gPgA+ID4wPkA+UD5gPkA+YD5wPoA+kD6gPoA+oD6wPsA+0D7gPsA+4D7wPwA/ED8gPwA/ID8wP0A/UD9gP0A/YD9wP4A/kD+gP4A/oD+wP8A/0D/gP8A/4D/wMABAEEAgQABAIEAwQEBAUEBgQEBAYEBwQIBAkECgQIBAoECwQMBA0EDgQMBA4EDwQQBBEEEgQQBBIEEwQ=\");\n\n//# sourceURL=webpack:///./assets/SportsCar.glb?");

/***/ }),

/***/ "./assets/SportsCar2.glb":
/*!*******************************!*\
  !*** ./assets/SportsCar2.glb ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAACkfgEAdA8AAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjkzOTcyfV0sImFzc2V0Ijp7InZlcnNpb24iOiIyLjAiLCJnZW5lcmF0b3IiOiJnbHRmcGFjayAwLjE2In0sImV4dGVuc2lvbnNVc2VkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiJdLCJleHRlbnNpb25zUmVxdWlyZWQiOlsiS0hSX21lc2hfcXVhbnRpemF0aW9uIl0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjAsImJ5dGVMZW5ndGgiOjUwMDU2LCJieXRlU3RyaWRlIjo4LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NTAwNTYsImJ5dGVMZW5ndGgiOjI1MDI4LCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NzUwODQsImJ5dGVMZW5ndGgiOjE4ODg4LCJ0YXJnZXQiOjM0OTYzfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjI1NTAsInR5cGUiOiJWRUMzIiwibWluIjpbMzE3LDcwMSwwXSwibWF4IjpbNzQ5Miw1MDIwLDE2MzgzXX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MjU1MCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNzUwLCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyMDQwMCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjEzMCwidHlwZSI6IlZFQzMiLCJtaW4iOls4ODgsMzQ2MiwyMzUzXSwibWF4IjpbNjkyMSw0ODU1LDExNzA4XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoxMDIwMCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjEzMCwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjc1MDAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxODYsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjIxNDQwLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjQ2NSwidHlwZSI6IlZFQzMiLCJtaW4iOlswLDM5NywyMzVdLCJtYXgiOls3ODA5LDM1NzEsMTYyODNdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjEwNzIwLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MjQ2NSwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjc4NzIsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNzU2LCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0Ijo0MTE2MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjIyLCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzEwMjEsMTgzMiwxNTIwNl0sIm1heCI6WzY3ODgsMjQ5OCwxNTg4M119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MjA1ODAsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyMiwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE1Mzg0LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzAsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjQxMzM2LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzgsInR5cGUiOiJWRUMzIiwibWluIjpbMTI2MSwyNzUzLDYxOF0sIm1heCI6WzY1NDgsMzY4MiwxMTgxXX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoyMDY2OCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjM4LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MTU0NDQsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50Ijo2NiwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6NDE2NDAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxMDUyLCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzUxMSwwLDE3ODNdLCJtYXgiOls3MzA2LDIzNDAsMTQ1ODJdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjIwODIwLCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MTA1MiwidHlwZSI6IlZFQzMiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjIsImJ5dGVPZmZzZXQiOjE1NTc2LCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTY1NiwidHlwZSI6IlNDQUxBUiJ9XSwibWF0ZXJpYWxzIjpbeyJuYW1lIjoiV2hpdGUiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjY4NTk0OTA4NywwLjY4NTk0OTA4NywwLjY4NTk0OTA4NywxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IldpbmRvd3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjAzNTIxNjAyNiwwLjAzNTIxNjAyNiwwLjAzNTIxNjAyNiwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkdyZXkiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjE1NzQzMDExMiwwLjE1NzQzMDExMiwwLjE1NzQzMDExMiwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IkhlYWRsaWdodHMiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgwMDAwMDA3MiwwLjM3NDQ1NzU5OCwwLjEyNzQ3NDY1MSwxXSwibWV0YWxsaWNGYWN0b3IiOjAsInJvdWdobmVzc0ZhY3RvciI6MC41fSwiZG91YmxlU2lkZWQiOnRydWV9LHsibmFtZSI6IlRhaWxMaWdodHMiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgwMDAwMDA3MiwwLjA5MjE1NTc2MiwwLjA3Mzc0Njk4NjcsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJCbGFjayIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMDEzNDA5NDA5NywwLjAxMzQwOTQwOTcsMC4wMTM0MDk0MDk3LDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX1dLCJtZXNoZXMiOlt7InByaW1pdGl2ZXMiOlt7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjAsIk5PUk1BTCI6MX0sIm1vZGUiOjQsImluZGljZXMiOjIsIm1hdGVyaWFsIjowfSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjMsIk5PUk1BTCI6NH0sIm1vZGUiOjQsImluZGljZXMiOjUsIm1hdGVyaWFsIjoxfSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjYsIk5PUk1BTCI6N30sIm1vZGUiOjQsImluZGljZXMiOjgsIm1hdGVyaWFsIjoyfSx7ImF0dHJpYnV0ZXMiOnsiUE9TSVRJT04iOjksIk5PUk1BTCI6MTB9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LAAtAC4ALAAuAC8AMAAxADIAMAAyADMANAA1ADYANAA2ADcAOAA5ADoAOAA6ADsAPAA9AD4APAA+AD8AQABBAEIAQABCAEMARABFAEYARABGAEcASABJAEoASABKAEsATABNAE4ATABOAE8AUABRAFIAUABSAFMAVABVAFYAVABWAFcAWABZAFoAWABaAFsAXABdAF4AXABeAF8AYABhAGIAYABiAGMAZABlAGYAZABmAGcAaABpAGoAaABqAGsAbABtAG4AbABuAG8AcABxAHIAcAByAHMAdAB1AHYAdAB2AHcAeAB5AHoAewB8AH0AewB9AH4AfwCAAIEAfwCBAIIAgwCEAIUAgwCFAIYAhwCIAIkAigCLAIwAigCMAI0AjgCPAJAAjgCQAJEAkgCTAJQAkgCUAJUAlgCXAJgAmQCXAJYAmQCaAJcAmwCaAJkAmwCcAJoAlgCYAJ0AngCdAJgAngCYAJ8AoACeAJ8AoACfAKEAmACiAJ8AmACjAKIAowCkAKIAowClAKQApgCnAKgApgCoAKkAqgCrAKwAqgCsAK0ArgCvALAArgCwALEAsgCzALQAsgC0ALUAtgC3ALgAtgC4ALkAugC7ALwAugC8AL0AvgC/AMAAvgDAAMEAwgDDAMQAwgDEAMUAxgDHAMgAxgDIAMkAygDLAMwAygDMAM0AzgDPANAAzgDQANEA0gDTANQA0gDUANUA1gDXANgA1gDYANkA2gDbANwA2gDcAN0A3gDfAOAA3gDgAOEA4gDjAOQA5QDmAOcA5QDnAOgA6QDqAOsA6QDrAOwA7QDuAO8A7QDvAPAA8QDyAPMA8QDzAPQA9QD2APcA9QD3APgA+QD6APsA+QD7APwA/QD+AP8A/QD/AAABAQECAQMBAQEDAQQBBQEGAQcBCAEJAQoBCAEKAQsBDAENAQ4BDAEOAQ8BEAERARIBEAESARMBFAEVARYBFAEWARcBGAEZARoBGAEaARsBHAEdAR4BHAEeAR8BIAEhASIBIAEiASMBJAElASYBJAEmAScBKAEpASoBKAEqASsBLAEtAS4BLAEuAS8BMAExATIBMAEyATMBNAE1ATYBNAE2ATcBOAE5AToBOAE6ATsBPAE9AT4BPwFAAUEBQgFAAT8BPwFBAUMBRAFFAUYBRAFGAUcBSAFJAUoBSAFKAUsBSwFKAUwBTQFOAU8BTQFPAVABUQFSAVMBUQFTAVQBVQFWAVcBVQFXAVgBWQFaAVsBWQFbAVwBXQFeAV8BXQFfAWABYQFiAWMBYQFjAWQBZQFmAWcBZQFnAWgBaQFqAWsBaQFrAWwBbQFuAW8BbQFvAXABcQFyAXMBcQFzAXQBdQF2AXcBdQF3AXgBeQF6AXsBeQF7AXwBfQF+AX8BfQF/AYABgQGCAYMBgQGDAYQBhQGGAYcBhQGHAYgBiQGKAYsBiQGLAYwBjQGOAY8BjQGPAZABkQGSAZMBkQGTAZQBlQGWAZcBlQGXAZgBmQGaAZsBmQGbAZwBnQGeAZ8BnQGfAaABoQGiAaMBoQGjAaQBpQGmAacBpQGnAagBqQGqAasBqQGrAawBrQGuAa8BrQGvAbABsQGyAbMBsQGzAbQBtQG2AbcBtQG3AbgBuQG6AbsBuQG7AbwBvQG+Ab8BvQG/AcABwQHCAcMBwQHDAcQBxQHGAccBxQHHAcgByQHKAcsByQHLAcwBzQHOAc8BzQHPAdAB0QHSAdMB0QHTAdQB1QHWAdcB1QHXAdgB2QHaAdsB2QHbAdwB3QHeAd8B3QHfAeAB4QHiAeMB5AHlAeYB5AHmAecB6AHpAeoB6AHqAesB7AHtAe4B7AHuAe8B8AHxAfIB8AHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB+gH8Af0B/gH/AQAC/gEAAgECAgIDAgQCAgIEAgUCBgIHAggCCQIKAgsCCQILAgwCDQIOAg8CDQIPAhACEQISAhMCEQITAhQCFQIWAhcCFQIXAhgCGQIaAhsCGQIbAhwCHQIeAh8CHQIfAiACIQIiAiMCIQIjAiQCJQImAicCJQInAigCKQIqAisCLAItAi4CLwIwAjECMgIzAjQCMgI0AjUCNgI3AjgCNgI4AjkCOgI7AjwCPQI+Aj8CPQI/AkACQQJCAkMCQQJDAkQCRQJGAkcCSAJJAkoCSAJKAksCTAJNAk4CTAJOAk8CUAJRAlICUAJSAlMCVAJVAlYCVAJWAlcCWAJZAloCWAJaAlsCXAJdAl4CXAJeAl8CYAJhAmICYAJiAmMCZAJlAmYCZAJmAmcCaAJpAmoCaAJqAmsCbAJtAm4CbAJuAm8CcAJxAnICcAJyAnMCdAJ1AnYCdAJ2AncCeAJ5AnoCeAJ6AnsCfAJ9An4CfAJ+An8CgAKBAoICgAKCAoMChAKFAoYChAKGAocCiAKJAooCiAKKAosCjAKNAo4CjAKOAo8CkAKRApICkwKUApUClgKXApgClgKYApkCmgKbApwCmgKcAp0CngKfAqACngKgAqECogKjAqQCogKkAqUCpgKnAqgCpgKoAqkCqgKrAqwCqgKsAq0CrgKvArACrgKwArECsgKzArQCsgK0ArUCtgK3ArgCtgK4ArkCugK7ArwCugK8Ar0CvgK/AsACvgLAAsECwgLDAsQCwgLEAsUCxgLHAsgCxgLIAskCygLLAswCygLMAs0CzgLPAtACzgLQAtEC0gLTAtQC0gLUAtUC1gLXAtgC1gLYAtkC2gLbAtwC2gLcAt0C3gLfAuAC3gLgAuEC4gLjAuQC4gLkAuUC5gLnAugC5gLoAukC6gLrAuwC6gLsAu0C7gLvAvAC7gLwAvEC8gLzAvQC8gL0AvUC9gL3AvgC9gL4AvkC+gL7AvwC/QL+Av8C/QL/AgADAQMCAwMDBAMFAwYDBAMGAwcDCAMJAwoDCAMKAwsDDAMNAw4DDAMOAw8DEAMRAxIDEAMSAxMDFAMVAxYDFAMWAxcDGAMZAxoDGwMcAx0DGwMdAx4DHwMgAyEDHwMhAyIDIwMkAyUDIwMlAyYDJwMoAykDJwMpAyoDKwMsAy0DKwMtAy4DLwMwAzEDLwMxAzIDMwM0AzUDMwM1AzYDNwM4AzkDOgM7AzwDOgM8Az0DPgM/A0ADPgNAA0EDQgNDA0QDRQNGA0cDRQNHA0gDSQNKA0sDSQNLA0wDTQNOA08DTQNPA1ADUQNSA1MDUQNTA1QDVQNWA1cDVQNXA1gDWQNaA1sDWQNbA1wDXQNeA18DXQNfA2ADYQNiA2MDYQNjA2QDZQNmA2cDZQNnA2gDaQNqA2sDaQNrA2wDbQNuA28DbQNvA3ADcQNyA3MDcQNzA3QDdQN2A3cDdQN3A3gDeQN6A3sDfAN9A34DfAN+A38DgAOBA4IDgAOCA4MDhAOFA4YDhAOGA4cDiAOJA4oDiAOKA4sDjAONA44DjAOOA48DkAORA5IDkwOUA5UDlQOWA5MDlQOXA5YDmAOZA5oDmAOaA5sDnAOdA54DnAOeA58DoAOhA6IDoAOiA6MDpAOlA6YDpAOmA6cDqAOpA6oDqAOqA6sDrAOtA64DrAOuA68DsAOxA7IDsAOyA7MDtAO1A7YDtAO2A7cDuAO5A7oDuAO6A7sDvAO9A74DvAO+A78DwAPBA8IDwAPCA8MDxAPFA8YDxAPGA8cDyAPJA8oDyAPKA8sDzAPNA84DzAPOA88D0APRA9ID0APSA9MD1APVA9YD1APWA9cD2APZA9oD2APaA9sD3APdA94D3APeA98D4APhA+ID4wPkA+UD4wPlA+YD5wPoA+kD5wPpA+oD6wPsA+0D7gPvA/AD7gPwA/ED8gPzA/QD9QP2A/cD+AP5A/oD+AP6A/sD/AP9A/4D/AP+A/8DAAQBBAIEAAQCBAMEBAQFBAYEBAQGBAcECAQJBAoECAQKBAsEDAQNBA4EDAQOBA8EEAQRBBIEEAQSBBMEFAQVBBYEFAQWBBcEGAQZBBoEGAQaBBsEHAQdBB4EHAQeBB8EIAQhBCIEIAQiBCMEJAQlBCYEJwQoBCkEKgQrBCwEKgQsBC0ELgQvBDAELgQwBDEEMgQzBDQEMgQ0BDUENgQ3BDgENgQ4BDkEOgQ7BDwEOgQ8BD0EPgQ/BEAEPgRABEEEQgRDBEQEQgREBEUERgRHBEgESQRKBEsESQRLBEwETQROBE8ETQRPBFAEUQRSBFMEUQRTBFQEVQRWBFcEWARZBFoEWARaBFsEXARdBF4EXAReBF8EYARhBGIEYARiBGMEZARlBGYEZARmBGcEaARpBGoEaARqBGsEbARtBG4EbARuBG8EcARxBHIEcARyBHMEdAR1BHYEdwR4BHkEdwR5BHoEewR8BH0EewR9BH4EfwSABIEEfwSBBIIEgwSEBIUEgwSFBIYEhwSIBIkEhwSJBIoEiwSMBI0EiwSNBI4EjwSQBJEEjwSRBJIEkwSUBJUEkwSVBJYElwSYBJkElwSZBJoEmwScBJ0EmwSdBJ4EnwSgBKEEnwShBKIEowSkBKUEowSlBKYEpwSoBKkEpwSpBKoEqwSsBK0EqwStBK4ErwSwBLEEsgSzBLQEsgS0BLUEtgS3BLgEtgS4BLkEugS7BLwEugS8BL0EvgS/BMAEvgTABMEEwgTDBMQEwgTEBMUExgTHBMgExgTIBMkEygTLBMwEygTMBM0EzgTPBNAEzgTQBNEE0gTTBNQE1QTWBNcE1QTXBNgE2QTaBNsE2QTbBNwE3QTeBN8E3QTfBOAE4QTiBOME4QTjBOQE5QTmBOcE5QTnBOgE6QTqBOsE6QTrBOwE7QTuBO8E7QTvBPAE8QTyBPME8QTzBPQE9QT2BPcE9QT3BPgE+QT6BPsE+QT7BPwE/QT+BP8E/QT/BAAFAQUCBQMFAQUDBQQFBQUGBQcFBQUHBQgFCQUKBQsFCQULBQwFDQUOBQ8FDQUPBRAFEQUSBRMFEQUTBRQFFQUWBRcFFQUXBRgFGQUaBRsFGQUbBRwFHQUeBR8FHQUfBSAFIQUiBSMFIQUjBSQFJQUmBScFJQUnBSgFKQUqBSsFKQUrBSwFLQUuBS8FLQUvBTAFMQUyBTMFMQUzBTQFNQU2BTcFNQU3BTgFOQU6BTsFOQU7BTwFPQU+BT8FPQU/BUAFQQVCBUMFQQVDBUQFRQVGBUcFRQVHBUgFSQVKBUsFSQVLBUwFTQVOBU8FTQVPBVAFUQVSBVMFUQVTBVQFVQVWBVcFVQVXBVgFWQVaBVsFWQVbBVwFXQVeBV8FXQVfBWAFYQViBWMFYQVjBWQFZQVmBWcFZQVnBWgFaQVqBWsFaQVrBWwFbQVuBW8FbQVvBXAFcQVyBXMFcQVzBXQFdQV2BXcFdQV3BXgFeQV6BXsFeQV7BXwFfQV+BX8FgAWBBYIFgAWCBYMFhAWFBYYFhAWGBYcFiAWJBYoFiAWKBYsFjAWNBY4FjwWQBZEFjwWRBZIFkwWUBZUFkwWVBZYFlwWYBZkFlwWZBZoFmwWcBZ0FmwWdBZ4FnwWgBaEFnwWhBaIFowWkBaUFowWlBaYFpwWoBakFpwWpBaoFqwWsBa0FqwWtBa4FrwWwBbEFrwWxBbIFswW0BbUFswW1BbYFtwW4BbkFtwW5BboFuwW8Bb0FuwW9Bb4FvwXABcEFvwXBBcIFwwXEBcUFwwXFBcYFxwXIBckFxwXJBcoFywXMBc0FywXNBc4FzwXQBdEFzwXRBdIF0wXUBdUF1gXXBdgF1gXYBdkF2gXbBdwF2gXcBd0F3gXfBeAF3gXgBeEF4gXjBeQF4gXkBeUF5gXnBegF5gXoBekF6gXrBewF6gXsBe0F7gXvBfAF7gXwBfEF8gXzBfQF8gX0BfUF9gX3BfgF+QX6BfsF+QX7BfwF/QX+Bf8F/QX/BQAGAQYCBgMGAQYDBgQGBQYGBgcGBQYHBggGCQYKBgsGCQYLBgwGDQYOBg8GDQYPBhAGEQYSBhMGEQYTBhQGFQYWBhcGFQYXBhgGGQYaBhsGGQYbBhwGHQYeBh8GHQYfBiAGIQYiBiMGIQYjBiQGJQYmBicGJQYnBigGKQYqBisGKQYrBiwGLQYuBi8GMAYxBjIGMAYyBjMGNAYwBjMGNQY2BjcGNQY3BjgGOQY6BjsGOgY8BjsGOQY7Bj0GPgY/BkAGPgZABkEGQgZDBkQGQgZEBkUGRgZHBkgGRgZIBkkGSgZLBkwGSgZMBk0GTgZPBlAGTgZQBlEGUgZTBlQGUgZUBlUGVgZXBlgGVgZYBlkGWgZbBlwGWgZcBl0GXgZfBmAGXgZgBmEGYgZjBmQGYgZkBmUGZgZnBmgGZgZoBmkGagZrBmwGagZsBm0GbgZvBnAGbgZwBnEGcgZzBnQGcgZ0BnUGdgZ3BngGdgZ4BnkGegZ7BnwGegZ8Bn0GfgZ/BoAGfgaABoEGggaDBoQGggaEBoUGhgaHBogGhgaIBokGigaLBowGigaMBo0GjgaPBpAGjgaQBpEGkgaTBpQGkgaUBpUGlgaXBpgGlgaYBpkGmgabBpwGmgacBp0GngafBqAGngagBqEGogajBqQGogakBqUGpganBqgGpgaoBqkGqgarBqwGqgasBq0GrgavBrAGrgawBrEGsgazBrQGsga0BrUGtga3BrgGtga4BrkGuga7BrwGuga8Br0Gvga/BsAGvgbABsEGwgbDBsQGwgbEBsUGxgbHBsgGxgbIBskGygbLBswGygbMBs0GzgbPBtAGzgbQBtEG0gbTBtQG1QbWBtcG1QbXBtgG2QbaBtsG2QbbBtwG3QbeBt8G3QbfBuAG4QbiBuMG4QbjBuQG5QbmBucG6AbpBuoG6wbsBu0G6wbtBu4G7wbwBvEG7wbxBvIG8wb0BvUG8wb1BvYG9wb4BvkG+gb7BvwG+gb8Bv0G/gb/BgAH/gYABwEHAgcDBwQHAgcEBwUHBgcHBwgHBgcIBwkHCgcLBwwHCgcMBw0HDgcPBxAHDgcQBxEHEgcTBxQHEgcUBxUHFgcXBxgHFgcYBxkHGgcbBxwHHQceBx8HIAchByIHIwckByUHIwclByYHJwcoBykHJwcpByoHKwcsBy0HLgcvBzAHLgcwBzEHMgczBzQHMgc0BzUHNgc3BzgHOQc6BzsHOQc7BzwHPQc+Bz8HPQc/B0AHQQdCB0MHQQdDB0QHRQdGB0cHRQdHB0gHSQdKB0sHSQdLB0wHTQdOB08HTQdPB1AHUQdSB1MHUQdTB1QHVQdWB1cHVQdXB1gHWQdaB1sHWQdbB1wHXQdeB18HXQdfB2AHYQdiB2MHYQdjB2QHZQdmB2cHZQdnB2gHaQdqB2sHaQdrB2wHbQduB28HbQdvB3AHcQdyB3MHcQdzB3QHdQd2B3cHdQd3B3gHeQd6B3sHeQd7B3wHfQd+B38HfQd/B4AHgQeCB4MHhAeFB4YHhweIB4kHhweJB4oHiweMB40HiweNB44HjweQB5EHjweRB5IHkweUB5UHkweVB5YHlweYB5kHlweZB5oHmwecB50HmwedB54HnwegB6EHnwehB6IHowekB6UHowelB6YHpweoB6kHpwepB6oHqwesB60HqwetB64HrwewB7EHrwexB7IHswe0B7UHswe1B7YHtwe4B7kHtwe5B7oHuwe8B70Huwe9B74HvwfAB8EHvwfBB8IHwwfEB8UHwwfFB8YHxwfIB8kHxwfJB8oHywfMB80HywfNB84HzwfQB9EHzwfRB9IH0wfUB9UH0wfVB9YH1wfYB9kH1wfZB9oH2wfcB90H2wfdB94H3wfgB+EH3wfhB+IH4wfkB+UH4wflB+YH5wfoB+kH5wfpB+oH6wfsB+0H7gfvB/AH7gfwB/EH8gfzB/QH9Qf2B/cH9Qf3B/gH+Qf6B/sH+Qf7B/wH/Qf+B/8H/Qf/BwAIAQgCCAMIAQgDCAQIBQgGCAcIBQgHCAgICQgKCAsIDAgNCA4IDAgOCA8IEAgRCBIIEAgSCBMIFAgVCBYIFAgWCBcIGAgZCBoIGAgaCBsIHAgdCB4IHAgeCB8IIAghCCIIIAgiCCMIJAglCCYIJAgmCCcIKAgpCCoIKwgsCC0IKwgtCC4ILwgwCDEILwgxCDIIMwg0CDUINgg3CDgINgg4CDkIOgg7CDwIOgg8CD0IPgg/CEAIPghACEEIQghDCEQIQghECEUIRghHCEgIRghICEkISghLCEwISghMCE0ITghPCFAITghQCFEIUghTCFQIUghUCFUIVghXCFgIVghYCFkIWghbCFwIWghcCF0IXghfCGAIXghgCGEIYghjCGQIYghkCGUIZghnCGgIZghoCGkIaghrCGwIbQhuCG8IbQhvCHAIcQhyCHMIcQhzCHQIdQh2CHcIdQh3CHgIeQh6CHsIeQh7CHwIfQh+CH8IfQh/CIAIgQiCCIMIhAiFCIYIhgiHCIQIhgiICIcIiQiKCIsIiQiLCIwIjQiOCI8IjQiPCJAIkQiSCJMIkQiTCJQIlQiWCJcIlQiXCJgImQiaCJsImQibCJwInQieCJ8InQifCKAIoQiiCKMIoQijCKQIpQimCKcIpQinCKgIqQiqCKsIqQirCKwIrQiuCK8IrQivCLAIsQiyCLMIsQizCLQItQi2CLcItQi3CLgIuQi6CLsIuQi7CLwIvQi+CL8IvQi/CMAIwQjCCMMIwQjDCMQIxQjGCMcIxQjHCMgIyQjKCMsIyQjLCMwIzQjOCM8IzQjPCNAI0QjSCNMI1AjVCNYI1AjWCNcI2AjZCNoI2AjaCNsI3AjdCN4I3wjgCOEI3wjhCOII4wjkCOUI5gjnCOgI6QjqCOsI6QjrCOwI7QjuCO8I7QjvCPAI8QjyCPMI8QjzCPQI9Qj2CPcI9Qj3CPgI+Qj6CPsI+Qj7CPwI/Qj+CP8I/Qj/CAAJAQkCCQMJAQkDCQQJBQkGCQcJBQkHCQgJCQkKCQsJCQkLCQwJDQkOCQ8JDQkPCRAJEQkSCRMJEQkTCRQJFQkWCRcJGAkZCRoJGwkcCR0JGwkdCR4JHwkgCSEJHwkhCSIJIwkkCSUJIwklCSYJJwkoCSkJJwkpCSoJKwksCS0JKwktCS4JLwkwCTEJLwkxCTIJMwk0CTUJMwk1CTYJNwk4CTkJOgk7CTwJOgk8CT0JPgk/CUAJPglACUEJQglDCUQJQglECUUJRglHCUgJSQlKCUsJSglMCUsJTQlOCU8JTQlPCVAJUQlSCVMJUQlTCVQJVQlWCVcJVQlXCVgJWQlaCVsJWQlbCVwJXQleCV8JXQlfCWAJYQliCWMJYQljCWQJZQlmCWcJaAlpCWoJaAlqCWsJbAltCW4JbAluCW8JcAlxCXIJcAlyCXMJdAl1CXYJdAl2CXcJeAl5CXoJeAl6CXsJfAl9CX4JfAl+CX8JgAmBCYIJgAmCCYMJhAmFCYYJhAmGCYcJiAmJCYoJiAmKCYsJjAmNCY4JjAmOCY8JkAmRCZIJkAmSCZMJlAmVCZYJlAmWCZcJmAmZCZoJmAmaCZsJnAmdCZ4JnAmeCZ8JoAmhCaIJowmkCaUJowmlCaYJpwmoCakJpwmpCaoJqwmsCa0JqwmtCa4JrwmwCbEJrwmxCbIJswm0CbUJswm1CbYJtwm4CbkJtwm5CboJuwm8Cb0Juwm9Cb4JvwnACcEJvwnBCcIJwwnECcUJxgnHCcgJxgnICckJygnLCcwJygnMCc0JzgnPCdAJzgnQCdEJ0gnTCdQJ0gnUCdUJ1gnXCdgJ1gnYCdkJ2gnbCdwJ2gncCd0J3gnfCeAJ3gngCeEJ4gnjCeQJ4gnkCeUJ5gnnCegJ5gnoCekJ6gnrCewJ6gnsCe0J7gnvCfAJ7gnwCfEJ8gnzCfQJ8gn0CfUJAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHwAgACEAHwAhACIAIwAkACUAJgAnACgAKQAqACsAKQArACwALQAuAC8ALQAvADAAMQAyADMAMQAzADQANQA2ADcANQA3ADgAOQA6ADsAOQA7ADwAPQA+AD8APQA/AEAAQQBCAEMAQQBDAEQARQBGAEcARQBHAEgASQBKAEsASQBLAEwATQBOAE8ATQBPAFAAUQBSAFMAUQBTAFQAVQBWAFcAVQBXAFgAWQBaAFsAWQBbAFwAXQBeAF8AYABhAGIAYABiAGMAZABlAGYAZwBoAGkAagBrAGwAagBsAG0AbgBvAHAAbgBwAHEAcgBzAHQAcgB0AHUAdgB3AHgAdgB4AHkAegB7AHwAegB8AH0AfgB/AIAAfgCAAIEAAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHAAeAB8AIAAhACIAIAAiACMAJAAlACYAJAAmACcAKAAlACQAKAApACUAKgArACwAKgAsAC0ALgAvADAALgAwADEAMgAzADQANAA1ADIANAA2ADUANwA4ADkANwA5ADoAOwA8AD0AOwA9AD4APwBAAEEAQQBCAD8AQQBDAEIARABFAEYARABGAEcASABJAEoASABKAEsATABNAE4ATABOAE8AUABRAFIAUABSAFMAVABVAFYAVABWAFcAWABZAFoAWABaAFsAXABdAF4AXABeAF8AYABhAGIAYABiAGMAZABlAGYAZABmAGcAaABpAGoAaABqAGsAbABtAG4AbwBwAHEAcgBzAHQAcgB0AHUAdgB3AHgAdgB4AHkAegB7AHwAegB8AH0AfgB/AIAAfgCAAIEAggCDAIQAggCEAIUAhgCHAIgAhgCIAIkAigCLAIwAigCMAI0AjgCPAJAAjgCQAJEAkgCTAJQAkgCUAJUAlgCXAJgAlgCYAJkAmgCbAJwAmgCcAJ0AngCfAKAAngCgAKEAogCeAKEAogChAKMApAClAKYApACmAKcAqACpAKoAqACqAKsArACtAK4ArgCvAKwArgCwAK8AsQCyALMAsQCzALQAtQC2ALcAtQC3ALgAuQC6ALsAuwC8ALkAuwC9ALwAvgC/AMAAvgDAAMEAwgDDAMQAwgDEAMUAxgDHAMgAxgDIAMkAygDLAMwAygDMAM0AzgDPANAAzgDQANEA0gDTANQA0gDUANUA1gDXANgA1gDYANkA2gDbANwA2gDcAN0A3gDfAOAA3gDgAOEA4gDjAOQA4gDkAOUA5gDnAOgA6QDqAOsA7ADtAO4A7ADuAO8A8ADxAPIA8ADyAPMA9AD1APYA9AD2APcA+AD5APoA+AD6APsA/AD9AP4A/AD+AP8AAAEBAQIBAAECAQMBBAEFAQYBBAEGAQcBCAEJAQoBCAEKAQsBDAENAQ4BDAEOAQ8BEAERARIBEAESARMBFAEVARYBFAEWARcBGAEZARoBGAEaARsBHAEdAR4BHAEeAR8BIAEhASIBIAEiASMBJAElASYBJAEmAScBKAEpASoBKAEqASsBKgEsASsBLQEuASgBLwEtASgBKwEvASgBLwEwAS0BKwExAS8BMQEyAS8BKwEzATEBNAE1ATYBNAE2ATcBOAE5AToBOAE6ATsBPAE9AT4BPAE+AT8BQAFBAUIBQAFCAUMBRAFFAUYBRAFGAUcBSAFJAUoBSAFKAUsBTAFNAU4BTAFOAU8BUAFRAVIBUAFSAVMBVAFVAVYBVAFWAVcBWAFZAVoBWAFaAVsBXAFdAV4BXAFeAV8BYAFhAWIBYAFiAWMBZAFlAWYBZAFmAWcBaAFpAWoBaAFqAWsBbAFtAW4BbAFuAW8BcAFxAXIBcAFyAXMBdAF1AXYBdAF2AXcBeAF5AXoBeAF6AXsBfAF9AX4BfAF+AX8BgAGBAYIBgAGCAYMBhAGFAYYBhAGGAYcBiAGJAYoBiAGKAYsBjAGNAY4BjAGOAY8BkAGMAZEBkAGRAZIBkwGUAZUBkwGVAZYBlwGYAZkBlwGZAZoBmwGcAZ0BmwGdAZ4BnwGgAaEBnwGhAaIBowGkAaUBowGlAaYBpwGoAakBpwGpAaoBqwGsAa0BqwGtAa4BrwGwAbEBrwGxAbIBswG0AbUBswG1AbYBtwG4AbkBtwG5AboBuwG8Ab0BuwG9Ab4BvwHAAcEBvwHBAcIBwwHEAcUBwwHFAcYBxwHIAckBxwHJAcoBywHMAc0BywHNAc4BzwHQAdEBzwHRAdIB0wHUAdUB0wHVAdYB1wHYAdkB1wHZAdoB2wHcAd0B2wHdAd4B3wHgAeEB3wHhAeIB4wHkAeUB4wHlAeYB5wHoAekB5wHpAeoB6wHsAe0B6wHtAe4B7wHrAfAB7wHwAfEB8gHzAfQB8gH0AfUB9gH3AfgB9gH4AfkB+gH7AfwB+gH8Af0B/gH/AQAC/gEAAgECAgIDAgQCAgIEAgUCBgIHAggCBgIIAgkCCgILAgwCCgIMAg0CDgIPAhACDgIQAhECEgITAhQCEgIUAhUCFgIXAhgCFgIYAhkCGgIbAhwCGgIcAh0CHgIfAiACHgIgAiECIgIjAiQCIgIkAiUCJgInAigCJgIoAikCKgIrAiwCKgIsAi0CLgIvAjACLgIwAjECMgIzAjQCMgI0AjUCNgI3AjgCNgI4AjkCOgI7AjwCOgI8Aj0CPgI/AkACPgJAAkECQgJDAkQCQgJEAkUCRgJHAkgCRgJIAkkCSgJLAkwCSgJMAk0CTgJPAlACTgJQAlECUgJTAlQCUgJUAlUCVgJXAlgCVgJYAlkCWgJbAlwCWgJcAl0CXgJfAmACXgJgAmECYgJjAmQCYgJkAmUCZgJnAmgCZgJoAmkCagJrAmwCagJsAm0CbgJvAnACbgJwAnECcgJzAnQCcgJ0AnUCdgJ3AngCdgJ4AnkCegJ7AnwCegJ8An0CfgJ/AoACfgKAAoECggKDAoQCggKEAoUChgKHAogChgKIAokCigKLAowCigKMAo0CjgKPApACjgKQApECkgKTApQCkgKUApUClgKXApgClgKYApkCmgKbApwCmgKcAp0CngKfAqACngKgAqECogKjAqQCogKkAqUCpgKnAqgCpgKoAqkCqgKrAqwCqgKsAq0CrgKvArACrgKwArECsgKzArQCsgK0ArUCtgK3ArgCtgK4ArkCugK7ArwCugK8Ar0CvgK/AsACvgLAAsECwgLDAsQCwgLEAsUCxgLHAsgCxgLIAskCygLLAswCygLMAs0CzgLPAtACzgLQAtEC0gLTAtQC0gLUAtUC1gLXAtgC1gLYAtkC2gLbAtwC2gLcAt0C3gLfAuAC3gLgAuEC4gLjAuQC4gLkAuUC5gLnAugC5gLoAukC6gLrAuwC6gLsAu0C7gLvAvAC7gLwAvEC8gLzAvQC8gL0AvUC9gL3AvgC9gL4AvkC+gL7AvwC+gL8Av0C/gL/AgAD/gIAAwEDAgMDAwQDAgMEAwUDBgMHAwgDBgMIAwkDCgMLAwwDCgMMAw0DDgMPAxADDgMQAxEDEgMTAxQDEgMUAxUDFgMXAxgDFgMYAxkDGgMbAxwDGgMcAx0DHgMfAyADHgMgAyEDIgMjAyQDIgMkAyUDJgMnAygDJgMoAykDKgMrAywDKgMsAy0DLgMvAzADLgMwAzEDMgMzAzQDMgM0AzUDNgM3AzgDNgM4AzkDOgM7AzwDOgM8Az0DPgM/A0ADPgNAA0EDQgNDA0QDQgNEA0UDRgNHA0gDRgNIA0kDSgNLA0wDSgNMA00DTgNPA1ADTgNQA1EDUgNTA1QDUgNUA1UDVANWA1UDVwNYA1IDWQNXA1IDVQNZA1IDWQNaA1cDVQNbA1kDWwNcA1kDVQNdA1sDXgNfA2ADXgNgA2EDYgNjA2QDYgNkA2UDZgNnA2gDZgNoA2kDagNrA2wDagNsA20DbgNvA3ADbgNwA3EDcgNzA3QDcgN0A3UDdgN3A3gDdgN4A3kDegN7A3wDegN8A30DfgN/A4ADfgOAA4EDggODA4QDggOEA4UDhgOHA4gDhgOIA4kDigOLA4wDigOMA40DjgOPA5ADjgOQA5EDkgOTA5QDkgOUA5UDlgOXA5gDlgOYA5kDmgObA5wDmgOcA50DngOfA6ADngOgA6EDogOjA6QDogOkA6UDpgOnA6gDpgOoA6kDqgOrA6wDqgOsA60DrgOvA7ADrgOwA7EDsgOzA7QDsgO0A7UDtgO3A7gDtgO4A7kDugO7A7wDugO8A70DvgO/A8ADvgPAA8EDwgPDA8QDwgPEA8UDxgPHA8gDxgPIA8kDygPLA8wDygPMA80DzgPPA9ADzgPQA9ED0gPTA9QD0gPUA9UD1gPXA9gD1gPYA9kD2gPbA9wD2gPcA90D3gPfA+AD3gPgA+ED4gPjA+QD4gPkA+UD5gPnA+gD5gPoA+kD6gPrA+wD6gPsA+0D7gPvA/AD7gPwA/ED8gPzA/QD8gP0A/UD9gP3A/gD9gP4A/kD+gP7A/wD+gP8A/0D/gP/AwAE/gMABAEEAgQDBAQEAgQEBAUEBgQHBAgEBgQIBAkECgQLBAwECgQMBA0EDgQPBBAEDgQQBBEEEgQTBBQEEgQUBBUEFgQXBBgEFgQYBBkEGgQbBBwEGgQcBB0EHgQfBCAEHgQgBCEEIgQjBCQEIgQkBCUEJgQnBCgEJgQoBCkEKgQrBCwEKgQsBC0ELgQvBDAELgQwBDEEMgQzBDQEMgQ0BDUENgQ3BDgENgQ4BDkEOgQ7BDwEOgQ8BD0EPgQ/BEAEPgRABEEEQgRDBEQEQgREBEUERgRHBEgERgRIBEkESgRLBEwESgRMBE0ETgRPBFAETgRQBFEEUgRTBFQEUgRUBFUEVgRXBFgEVgRYBFkEWgRbBFwEWgRcBF0EXgRfBGAEXgRgBGEEYgRjBGQEYgRkBGUEZgRnBGgEZgRoBGkEagRrBGwEagRsBG0EbgRvBHAEbgRwBHEEcgRzBHQEcgR0BHUEdgR3BHgEdgR4BHkEegR7BHwEegR8BH0EfgR/BIAEfgSABIEEggSDBIQEggSEBIUEhgSHBIgEhgSIBIkEigSLBIwEigSMBI0EjgSPBJAEjgSQBJEEkgSTBJQEkgSUBJUElgSXBJgElgSYBJkEmgSbBJwEmgScBJ0EngSfBKAEngSgBKEEogSjBKQEogSkBKUEpgSnBKgEpgSoBKkEqgSrBKwEqgSsBK0ErgSvBLAErgSwBLEEsgSzBLQEsgS0BLUEtgS3BLgEtgS4BLkEugS7BLwEugS8BL0EvgS/BMAEvgTABMEEwgTDBMQEwgTEBMUExgTHBMgExgTIBMkEygTLBMwEygTMBM0EzgTPBNAEzgTQBNEE0gTTBNQE0gTUBNUE1gTXBNgE1gTYBNkE2gTbBNwE2gTcBN0E3gTfBOAE3gTgBOEE4gTjBOQE4gTkBOUE5gTnBOgE5gToBOkE6gTrBOwE6gTsBO0E7gTvBPAE7gTwBPEE8gTzBPQE8gT0BPUE9gT3BPgE9gT4BPkE+gT7BPwE+gT8BP0E/gT/BAAF/gQABQEFAgUDBQQFAgUEBQUFBgUHBQgFBgUIBQkFCgULBQwFCgUMBQ0FDgUPBRAFDgUQBREFEgUTBRQFEgUUBRUFFgUXBRgFFgUYBRkFGgUbBRwFGgUcBR0FHgUfBSAFHgUgBSEFIgUjBSQFIgUkBSUFJgUnBSgFJgUoBSkFKgUrBSwFKgUsBS0FLgUvBTAFLgUwBTEFMgUzBTQFMgU0BTUFNgU3BTgFNgU4BTkFOgU7BTwFOgU8BT0FPgU/BUAFPgVABUEFQgVDBUQFQgVEBUUFRgVHBUgFRgVIBUkFSgVLBUwFSgVMBU0FTgVPBVAFTgVQBVEFUgVTBVQFUgVUBVUFVgVXBVgFVgVYBVkFWgVbBVwFWgVcBV0FXgVfBWAFXgVgBWEFYgVjBWQFYgVkBWUFZgVnBWgFZgVoBWkFagVrBWwFagVsBW0FbgVvBXAFbgVwBXEFcgVzBXQFcgV0BXUFdgV3BXgFdgV4BXkFegV7BXwFegV8BX0FfgV/BYAFfgWABYEFgAWCBYEFgwWEBX4FhQWDBX4FgQWFBX4FhQWGBYMFgQWHBYUFhwWIBYUFgQWJBYcFigWLBYwFigWMBY0FjgWPBZAFjgWQBZEFkgWTBZQFkgWUBZUFlgWXBZgFlgWYBZkFmgWbBZwFmgWcBZ0FngWfBaAFngWgBaEFogWjBaQFogWkBaUFpgWnBagFpgWoBakFqgWrBawFqgWsBa0FrgWvBbAFrgWwBbEFsgWzBbQFsgW0BbUFtgW3BbgFtgW4BbkFugW7BbwFugW8Bb0FvgW/BcAFvgXABcEFwgXDBcQFwgXEBcUFxgXHBcgFxgXIBckFygXLBcwFygXMBc0FzgXPBdAFzgXQBdEF0gXTBdQF0gXUBdUF1gXXBdgF1gXYBdkF2gXbBdwF2gXcBd0F3gXfBeAF3gXgBeEF4gXjBeQF4gXkBeUF5gXnBegF5gXoBekF6gXrBewF6gXsBe0F7gXvBfAF7gXwBfEF8gXzBfQF8gX0BfUF9gX3BfgF9gX4BfkF+gX7BfwF+gX8Bf0F/gX/BQAG/gUABgEGAgYDBgQGAgYEBgUGBgYHBggGBgYIBgkGCgYLBgwGCgYMBg0GDgYPBhAGDgYQBhEGEgYTBhQGEgYUBhUGFgYXBhgGFgYYBhkGGgYbBhwGGgYcBh0GHgYfBiAGHgYgBiEGIgYjBiQGIgYkBiUGJgYnBigGJgYoBikGKgYrBiwGKgYsBi0GLgYvBjAGLgYwBjEGMgYzBjQGMgY0BjUGNgY3BjgGNgY4BjkGOgY7BjwGOgY8Bj0GPgY/BkAGPgZABkEGQgZDBkQGQgZEBkUGRgZHBkgGRgZIBkkGSgZLBkwGSgZMBk0GTgZPBlAGTgZQBlEGUgZTBlQGUgZUBlUGVgZXBlgGVgZYBlkGWgZbBlwGWgZcBl0GXgZfBmAGXgZgBmEGYgZeBmMGYgZjBmQGZQZmBmcGZQZnBmgGaQZqBmsGaQZrBmwGbQZuBm8GbQZvBnAGcQZyBnMGcQZzBnQGdQZ2BncGdQZ3BngGeQZ6BnsGeQZ7BnwGfQZ+Bn8GfQZ/BoAGgQaCBoMGgQaDBoQGhQaGBocGhQaHBogGiQaKBosGiQaLBowGjQaOBo8GjQaPBpAGkQaSBpMGkQaTBpQGlQaWBpcGlQaXBpgGmQaaBpsGmQabBpwGnQaeBp8GnQafBqAGoQaiBqMGoQajBqQGpQamBqcGpQanBqgGqQaqBqsGqQarBqwGrQauBq8GrQavBrAGsQayBrMGsQazBrQGtQa2BrcGtQa3BrgGuQa6BrsGuQa7BrwGvQa+Br8GvQa/BsAGwQbCBsMGwQbDBsQGxQbGBscGxQbHBsgGyQbKBssGyQbLBswGzQbOBs8GzQbPBtAG0QbSBtMG0QbTBtQG1QbWBtcG1QbXBtgG2QbaBtsG2QbbBtwG3QbeBt8G3QbfBuAG4QbiBuMG4QbjBuQG5QbmBucG5QbnBugG6QbqBusG6QbrBuwG7QbuBu8G7QbvBvAG8QbyBvMG8QbzBvQG9Qb2BvcG9Qb3BvgG+Qb6BvsG+Qb7BvwG/Qb+Bv8G/Qb/BgAHAQcCBwMHAQcDBwQHBQcGBwcHBQcHBwgHCQcKBwsHCQcLBwwHDQcOBw8HDQcPBxAHEQcSBxMHEQcTBxQHFQcWBxcHFQcXBxgHGQcaBxsHGQcbBxwHHQceBx8HHQcfByAHIQciByMHIQcjByQHJQcmBycHJQcnBygHKQcqBysHKQcrBywHLQcuBy8HLQcvBzAHMQcyBzMHMQczBzQHNQc2BzcHNQc3BzgHOQc6BzsHOQc7BzwHPQc+Bz8HPQc/B0AHQQdCB0MHQQdDB0QHRQdGB0cHRQdHB0gHSQdKB0sHSQdLB0wHTQdOB08HTQdPB1AHUQdSB1MHUQdTB1QHVQdWB1cHVQdXB1gHWQdaB1sHWQdbB1wHXQdeB18HXQdfB2AHYQdiB2MHYQdjB2QHZQdmB2cHZQdnB2gHaQdqB2sHaQdrB2wHbQduB28HbQdvB3AHcQdyB3MHcQdzB3QHdQd2B3cHdQd3B3gHeQd6B3sHeQd7B3wHfQd+B38HfQd/B4AHgQeCB4MHgQeDB4QHhQeGB4cHhQeHB4gHiQeKB4sHiQeLB4wHjQeOB48HjQePB5AHkQeSB5MHkQeTB5QHlQeWB5cHlQeXB5gHmQeaB5sHmQebB5wHnQeeB58HnQefB6AHoQeiB6MHoQejB6QHpQemB6cHpQenB6gHqQeqB6sHqQerB6wHqwetB6wHrgevB6kHsAeuB6kHrAewB6kHsAexB64HrAeyB7AHsgezB7AHrAe0B7IHtQe2B7cHtQe3B7gHuQe6B7sHuQe7B7wHvQe+B78HvQe/B8AHwQfCB8MHwQfDB8QHxQfGB8cHxQfHB8gHyQfKB8sHyQfLB8wHzQfOB88HzQfPB9AH0QfSB9MH0QfTB9QH1QfWB9cH1QfXB9gH2QfaB9sH2QfbB9wH3QfeB98H3QffB+AH4QfiB+MH4QfjB+QH5QfmB+cH5QfnB+gH6QfqB+sH6QfrB+wH7QfuB+8H7QfvB/AH8QfyB/MH8QfzB/QH9Qf2B/cH9Qf3B/gH+Qf6B/sH+Qf7B/wH/Qf+B/8H/Qf/BwAIAQgCCAMIAQgDCAQIBQgGCAcIBQgHCAgICQgKCAsICQgLCAwIDQgOCA8IDQgPCBAIEQgSCBMIEQgTCBQIFQgWCBcIFQgXCBgIGQgaCBsIGQgbCBwIHQgeCB8IHQgfCCAIIQgiCCMIIQgjCCQIJQgmCCcIJQgnCCgIKQgqCCsIKQgrCCwILQguCC8ILQgvCDAIMQgyCDMIMQgzCDQINQg2CDcINQg3CDgIOQg6CDsIOQg7CDwIPQg+CD8IPQg/CEAIQQhCCEMIQQhDCEQIRQhGCEcIRQhHCEgISQhKCEsISQhLCEwITQhOCE8ITQhPCFAIUQhSCFMIUQhTCFQIVQhWCFcIVQhXCFgIWQhaCFsIWQhbCFwIXQheCF8IXQhfCGAIYQhiCGMIYQhjCGQIZQhmCGcIZQhnCGgIaQhqCGsIaQhrCGwIbQhuCG8IbQhvCHAIcQhyCHMIcQhzCHQIdQh2CHcIdQh3CHgIeQh6CHsIeQh7CHwIfQh+CH8IfQh/CIAIgQiCCIMIgQiDCIQIhQiGCIcIhQiHCIgIiQiKCIsIiQiLCIwIjQiOCI8IjQiPCJAIkQiSCJMIkQiTCJQIlQiWCJcIlQiXCJgImQiaCJsImQibCJwInQieCJ8InQifCKAIoQiiCKMIoQijCKQIpQimCKcIpQinCKgIqQiqCKsIqQirCKwIrQiuCK8IrQivCLAIsQiyCLMIsQizCLQItQi2CLcItQi3CLgIuQi6CLsIuQi7CLwIvQi+CL8IvQi/CMAIwQjCCMMIwQjDCMQIxQjGCMcIxQjHCMgIyQjKCMsIyQjLCMwIzQjOCM8IzQjPCNAI0QjSCNMI0QjTCNQI1QjWCNcI1QjXCNgI2QjaCNsI2QjbCNwI3QjeCN8I3QjfCOAI4QjiCOMI4QjjCOQI5QjmCOcI5QjnCOgI6QjqCOsI6QjrCOwI7QjuCO8I7QjvCPAI8QjyCPMI8QjzCPQI9Qj2CPcI9Qj3CPgI+Qj6CPsI+Qj7CPwI/Qj+CP8I/Qj/CAAJAQkCCQMJAQkDCQQJBQkGCQcJBQkHCQgJCQkKCQsJCQkLCQwJDQkOCQ8JDQkPCRAJEQkSCRMJEQkTCRQJFQkWCRcJFQkXCRgJGQkaCRsJGQkbCRwJHQkeCR8JHQkfCSAJIQkiCSMJIQkjCSQJJQkmCScJJQknCSgJKQkqCSsJKQkrCSwJLQkuCS8JLQkvCTAJMQkyCTMJMQkzCTQJNQk2CTcJNQk3CTgJOQk6CTsJOQk7CTwJPQk+CT8JPQk/CUAJQQlCCUMJQQlDCUQJRQlGCUcJRQlHCUgJSQlKCUsJSQlLCUwJTQlOCU8JTQlPCVAJUQlSCVMJUQlTCVQJVQlWCVcJVQlXCVgJWQlaCVsJWQlbCVwJXQleCV8JXQlfCWAJYQliCWMJYQljCWQJZQlmCWcJZQlnCWgJaQlqCWsJaQlrCWwJbQluCW8JbQlvCXAJcQlyCXMJcQlzCXQJdQl2CXcJdQl3CXgJeQl6CXsJeQl7CXwJfQl+CX8JfQl/CYAJgQmCCYMJgQmDCYQJhQmGCYcJhQmHCYgJiQmKCYsJiQmLCYwJjQmOCY8JjQmPCZAJkQmSCZMJkQmTCZQJlQmWCZcJlQmXCZgJmQmaCZsJmQmbCZwJnQmeCZ8JnQmfCaAJAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAAAABAAIAAgADAAAAAwAEAAAAAgAFAAMABgAHAAgACAAJAAYACAAKAAkACwAMAA0ACwANAA4ADwAQABEADwARABIAEwAUABUAFQAWABMAFgAXABMAFQAYABYAGQAaABsAGwAcABkAGwAdABwAHgAfACAAHgAgACEAIgAjACQAIgAkACUAAAABAAIAAAACAAMABAAFAAYABAAGAAcACAAJAAoACAAKAAsADAANAA4ADAAOAA8AEAARABIAEAASABMAFAAVABYAFAAWABcAGAAZABoAGAAaABsAHAAdAB4AHAAeAB8AIAAhACIAIAAiACMAJAAlACYAJAAmACcAKAApACoAKAAqACsALAAtAC4ALAAuAC8AMAAxADIAMAAyADMANAA1ADYANAA2ADcANgA4ADcAOQA6ADQAOwA5ADQANwA7ADQAOwA8ADkANwA9ADsAPQA+ADsANwA/AD0AQABBAEIAQABCAEMARABFAEYARABGAEcASABJAEoASABKAEsATABNAE4ATABOAE8AUABRAFIAUABSAFMAVABVAFYAVABWAFcAWABZAFoAWABaAFsAXABdAF4AXABeAF8AYABhAGIAYABiAGMAZABlAGYAZABmAGcAaABpAGoAaABqAGsAbABtAG4AbABuAG8AcABxAHIAcAByAHMAdAB1AHYAdAB2AHcAdQB4AHYAdQB5AHgAeQB6AHgAeQB7AHoAfAB9AH4AfAB+AH8AgACBAIIAgACCAIMAhACAAIMAhACDAIUAhgCHAIgAhgCIAIkAigCLAIwAigCMAI0AjgCPAJAAjgCQAJEAkgCTAJQAkgCUAJUAlgCXAJgAlgCYAJkAmgCbAJwAmgCcAJ0AngCfAKAAngCgAKEAogCjAKQAogCkAKUApgCnAKgApgCoAKkAqgCrAKwAqgCsAK0ArgCvALAArgCwALEAsgCzALQAsgC0ALUAtgC3ALgAtgC4ALkAugC7ALwAugC8AL0AvgC/AMAAvgDAAMEAwgDDAMQAwgDEAMUAxgDHAMgAxgDIAMkAygDLAMwAygDMAM0AzgDPANAAzgDQANEA0gDTANQA0gDUANUA1gDXANgA1gDYANkA2gDbANwA2gDcAN0A3gDfAOAA3gDgAOEA4gDjAOQA4gDkAOUA5gDnAOgA5gDoAOkA6gDrAOwA6gDsAO0A7gDvAPAA7gDwAPEA8gDzAPQA8gD0APUA9gD3APgA9gD4APkA+gD7APwA+gD8AP0A/gD/AAAB/gAAAQEBAgEDAQQBAgEEAQUBBgEHAQgBBgEIAQkBCgELAQwBCgEMAQ0BDgEPARABDgEQAREBEgETARQBEgEUARUBFgEXARgBFgEYARkBGgEbARwBGgEcAR0BHgEfASABHgEgASEBIgEjASQBIgEkASUBJgEnASgBJgEoASkBKgErASwBKgEsAS0BLgEvATABLgEwATEBMgEzATQBMgE0ATUBNgE3ATgBNgE4ATkBOgE7ATwBOgE8AT0BPAE+AT0BPwFAAToBQQE/AToBPQFBAToBQQFCAT8BPQFDAUEBQwFEAUEBPQFFAUMBRgFHAUgBRgFIAUkBSgFLAUwBSgFMAU0BTgFPAVABTgFQAVEBUgFTAVQBUgFUAVUBVgFXAVgBVgFYAVkBWgFbAVwBWgFcAV0BXgFfAWABXgFgAWEBYgFjAWQBYgFkAWUBZgFnAWgBZgFoAWkBagFrAWwBagFsAW0BbgFvAXABbgFwAXEBcgFzAXQBcgF0AXUBdgF3AXgBdgF4AXkBegF7AXwBegF8AX0BfgF/AYABfgGAAYEBggGDAYQBggGEAYUBhgGHAYgBhgGIAYkBigGLAYwBigGMAY0BjgGPAZABjgGQAZEBkgGTAZQBkgGUAZUBlgGXAZgBlgGYAZkBmgGbAZwBmgGcAZ0BngGfAaABngGgAaEBogGjAaQBogGkAaUBpgGnAagBpgGoAakBqgGrAawBqgGsAa0BrgGvAbABrgGwAbEBsgGzAbQBsgG0AbUBtgG3AbgBtgG4AbkBugG7AbwBugG8Ab0BvgG/AcABvgHAAcEBwgHDAcQBwgHEAcUBxgHHAcgBxgHIAckBygHLAcwBygHMAc0BzgHPAdABzgHQAdEB0gHTAdQB0gHUAdUB1gHXAdgB1gHYAdkB2gHbAdwB2gHcAd0B3gHfAeAB3gHgAeEB4gHjAeQB4gHkAeUB5gHnAegB5gHoAekB6gHrAewB6gHsAe0B7gHvAfAB7gHwAfEB8gHzAfQB8gH0AfUB9gH3AfgB9gH4AfkB+gH7AfwB+gH8Af0B/gH/AQAC/gEAAgECAgIDAgQCAgIEAgUCBgIHAggCBgIIAgkCCgILAgwCCgIMAg0CDgIPAhACDgIQAhECEgITAhQCEgIUAhUCFgIXAhgCFgIYAhkCGgIbAhwCGgIcAh0CHgIfAiACHgIgAiECIgIjAiQCIgIkAiUCJgInAigCJgIoAikCKgIrAiwCKgIsAi0CLgIvAjACLgIwAjECMgIzAjQCMgI0AjUCNgI3AjgCNgI4AjkCOgI7AjwCOgI8Aj0CPgI/AkACPgJAAkECQgJDAkQCQgJEAkUCRgJHAkgCRgJIAkkCSAJKAkkCSwJMAkYCTQJLAkYCSQJNAkYCTQJOAksCSQJPAk0CTwJQAk0CSQJRAk8CUgJTAlQCUgJUAlUCUwJWAlQCUwJXAlYCVwJYAlYCVwJZAlgCWQJaAlgCWQJbAloCXAJdAl4CXAJeAl8CYAJhAmICYAJiAmMCZAJlAmYCZAJmAmcCaAJpAmoCaAJqAmsCbAJtAm4CbAJuAm8CcAJxAnICcAJyAnMCdAJ1AnYCdAJ2AncCeAJ5AnoCeAJ6AnsCfAJ9An4CfAJ+An8CgAKBAoICgAKCAoMChAKFAoYChAKGAocCiAKJAooCiAKKAosCjAKNAo4CjAKOAo8CkAKMAo8CkAKPApECkgKTApQCkgKUApUClgKXApgClgKYApkCmgKbApwCmgKcAp0CngKfAqACngKgAqECogKjAqQCogKkAqUCpgKnAqgCpgKoAqkCqgKrAqwCqgKsAq0CrgKvArACrgKwArECsgKzArQCsgK0ArUCtgK3ArgCtgK4ArkCugK7ArwCugK8Ar0CvgK/AsACvgLAAsECwgLDAsQCwgLEAsUCxgLHAsgCxgLIAskCygLLAswCygLMAs0CzgLPAtACzgLQAtEC0gLTAtQC0gLUAtUC1gLXAtgC1gLYAtkC2gLbAtwC2gLcAt0C3gLfAuAC3gLgAuEC4gLjAuQC4gLkAuUC5gLnAugC5gLoAukC6gLrAuwC6gLsAu0C7gLvAvAC7gLwAvEC8gLzAvQC8gL0AvUC9gL3AvgC9gL4AvkC+gL7AvwC+gL8Av0C/gL/AgAD/gIAAwEDAgMDAwQDAgMEAwUDBgMHAwgDBgMIAwkDCgMLAwwDCgMMAw0DDgMPAxADDgMQAxEDEgMTAxQDEgMUAxUDFgMXAxgDFgMYAxkDGgMbAxwDGgMcAx0DHgMfAyADHgMgAyEDIgMjAyQDIgMkAyUDJgMnAygDJgMoAykDKgMrAywDKgMsAy0DLgMvAzADLgMwAzEDMgMzAzQDMgM0AzUDNgM3AzgDNgM4AzkDOgM7AzwDOgM8Az0DPgM/A0ADPgNAA0EDQgNDA0QDQgNEA0UDRgNHA0gDRgNIA0kDSgNLA0wDSgNMA00DTANOA00DTwNQA0oDUQNPA0oDTQNRA0oDUQNSA08DTQNTA1EDUwNUA1EDTQNVA1MDVgNXA1gDVgNYA1kDWgNbA1wDWgNcA10DXgNfA2ADXgNgA2EDYgNjA2QDYgNkA2UDZgNnA2gDZgNoA2kDagNrA2wDagNsA20DbgNvA3ADbgNwA3EDcgNzA3QDcgN0A3UDdgN3A3gDdgN4A3kDegN7A3wDegN8A30DfgN/A4ADfgOAA4EDggODA4QDggOEA4UDhgOHA4gDhgOIA4kDigOLA4wDigOMA40DjgOLA4oDjgOPA4sDkAOPA44DkAORA48DkgOTA5QDkgOUA5UDlgOTA5IDlgOXA5MDmAOZA5oDmAOaA5sDnAOdA54DnAOeA58DoAOhA6IDoAOiA6MDpAOlA6YDpAOmA6cDqAOpA6oDqAOqA6sDrAOtA64DrAOuA68DsAOxA7IDsAOyA7MDtAO1A7YDtAO2A7cDuAO5A7oDuAO6A7sDvAO9A74DvAO+A78DwAPBA8IDwAPCA8MDxAPFA8YDxAPGA8cDyAPJA8oDyAPKA8sDzAPNA84DzAPOA88D0APRA9ID0APSA9MD1APVA9YD1APWA9cD2APZA9oD2APaA9sD3APdA94D3APeA98D4APhA+ID4APiA+MD5APlA+YD5APmA+cD6APpA+oD6APqA+sD7APtA+4D7APuA+8D8APxA/ID8APyA/MD9AP1A/YD9AP2A/cD+AP5A/oD+AP6A/sD/AP9A/4D/AP+A/8DAAQBBAIEAAQCBAMEBAQFBAYEBAQGBAcECAQJBAoECAQKBAsEDAQNBA4EDAQOBA8EEAQRBBIEEAQSBBMEFAQVBBYEFAQWBBcEGAQZBBoEGAQaBBsE\");\n\n//# sourceURL=webpack:///./assets/SportsCar2.glb?");

/***/ }),

/***/ "./assets/Taxi.glb":
/*!*************************!*\
  !*** ./assets/Taxi.glb ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAABAkgEAeA8AAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjk4OTg4fV0sImFzc2V0Ijp7InZlcnNpb24iOiIyLjAiLCJnZW5lcmF0b3IiOiJnbHRmcGFjayAwLjE2In0sImV4dGVuc2lvbnNVc2VkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiJdLCJleHRlbnNpb25zUmVxdWlyZWQiOlsiS0hSX21lc2hfcXVhbnRpemF0aW9uIl0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjAsImJ5dGVMZW5ndGgiOjUyODgwLCJieXRlU3RyaWRlIjo4LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NTI4ODAsImJ5dGVMZW5ndGgiOjI2NDQwLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NzkzMjAsImJ5dGVMZW5ndGgiOjE5NjY4LCJ0YXJnZXQiOjM0OTYzfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjMwMjYsInR5cGUiOiJWRUMzIiwibWluIjpbMCw2MzksMF0sIm1heCI6WzcwMTUsNTA4NywxNjM4M119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjMwMjYsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6NDM1NiwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6MjQyMDgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxMzAsInR5cGUiOiJWRUMzIiwibWluIjpbNjE2LDI5NjYsMjk0N10sIm1heCI6WzY0MDAsNDM4NywxMTUzM119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MTIxMDQsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoxMzAsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0Ijo4NzEyLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MTg2LCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0IjoyNTI0OCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjExNzQsInR5cGUiOiJWRUMzIiwibWluIjpbNDYwLDAsMjMzN10sIm1heCI6WzY1NTYsNTA0NCwxMzgzOF19LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MTI2MjQsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoxMTc0LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6OTA4NCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjE4MzAsInR5cGUiOiJTQ0FMQVIifSx7ImJ1ZmZlclZpZXciOjAsImJ5dGVPZmZzZXQiOjM0NjQwLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjIzOCwidHlwZSI6IlZFQzMiLCJtaW4iOls1MDksMzQ1LDI2MF0sIm1heCI6WzY1MDcsMjE5MSwxNjMwN119LHsiYnVmZmVyVmlldyI6MSwiYnl0ZU9mZnNldCI6MTczMjAsImNvbXBvbmVudFR5cGUiOjUxMjAsImNvdW50IjoyMjM4LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MTI3NDQsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNDA4LCJ0eXBlIjoiU0NBTEFSIn0seyJidWZmZXJWaWV3IjowLCJieXRlT2Zmc2V0Ijo1MjU0NCwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjI4LCJ0eXBlIjoiVkVDMyIsIm1pbiI6Wzc3NCwxNTk2LDE1NTU5XSwibWF4IjpbNjI0MSwyMDQxLDE2MTk0XX0seyJidWZmZXJWaWV3IjoxLCJieXRlT2Zmc2V0IjoyNjI3MiwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjI4LCJ0eXBlIjoiVkVDMyIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MTk1NjAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjozNiwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MCwiYnl0ZU9mZnNldCI6NTI3NjgsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoxNCwidHlwZSI6IlZFQzMiLCJtaW4iOlsxMDAxLDIzOTgsNTIyXSwibWF4IjpbNjAxNSwyOTE5LDExMzVdfSx7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjI2Mzg0LCJjb21wb25lbnRUeXBlIjo1MTIwLCJjb3VudCI6MTQsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoyLCJieXRlT2Zmc2V0IjoxOTYzMiwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjE4LCJ0eXBlIjoiU0NBTEFSIn1dLCJtYXRlcmlhbHMiOlt7Im5hbWUiOiJZZWxsb3ciLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJiYXNlQ29sb3JGYWN0b3IiOlswLjgwMDAwMDA3MiwwLjU4MTM0MjM5OSwwLjA1NjY3NzI2MzIsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJXaW5kb3dzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yRmFjdG9yIjpbMC4wMzU2MDEzMTc5LDAuMDM1NjAxMzE3OSwwLjAzNTYwMTMxNzksMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfSx7Im5hbWUiOiJCbGFjayIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMDEzNzAyMDg2MiwwLjAxMzcwMjA4NjIsMC4wMTM3MDIwODYyLDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiR3JleSIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuMjAxNTU2MjgsMC4yMDE1NTYyOCwwLjIwMTU1NjI4LDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiSGVhZGxpZ2h0cyIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNzk5MTAyNzgzLDAuMzc2MjYyMTI4LDAuMTI3NDM3NzExLDFdLCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjV9LCJkb3VibGVTaWRlZCI6dHJ1ZX0seyJuYW1lIjoiVGFpbExpZ2h0cyIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvckZhY3RvciI6WzAuNzk5MTAyNzgzLDAuMDkzMDU4OTczNiwwLjA3NDIxMzU3OTMsMV0sIm1ldGFsbGljRmFjdG9yIjowLCJyb3VnaG5lc3NGYWN0b3IiOjAuNX0sImRvdWJsZVNpZGVkIjp0cnVlfV0sIm1lc2hlcyI6W3sicHJpbWl0aXZlcyI6W3siYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MCwiTk9STUFMIjoxfSwibW9kZSI6NCwiaW5kaWNlcyI6MiwibWF0ZXJpYWwiOjB9LHsiYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MywiTk9STUFMIjo0fSwibW9kZSI6NCwiaW5kaWNlcyI6NSwibWF0ZXJpYWwiOjF9LHsiYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6NiwiTk9STUFMIjo3fSwibW9kZSI6NCwiaW5kaWNlcyI6OCwibWF0ZXJpYWwiOjJ9LHsiYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6OSwiTk9STUFMIjox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eNnwAHjZ8AAAitEAAIrRAACK0QAAitEAiiwRAIosEQCKLBEAiiwRAAB2LwAAdi8AAHYvAAB2LwCBAAAAgQAAAIEAAACBAAAAAIrRAACK0QAAitEAAIrRAJU/GQCVPxkAlT8ZAJU/GQAAdi8AAHYvAAB2LwAAdi8Alr/mAJa/5gCWv+YAlr/mAAB2LwAAdi8AAHYvAAB2LwB/AAAAfwAAAH8AAAB/AAAAADR0AAA0dAAANHQAADR0AAA0dAAANHQAAH8AAAB/AAAAfwAAAH8AAAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AAA0dAAANHQAADR0AADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAAB/AAAAfwAAAH8AAAB/AAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjAAAzIwAAMyMAADMjACUwhwAlMIcAJTCHACUwhwAAIw0AACMNAAAjDQA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fgB/AH0AfwCAAIEAggCDAIQAhQCGAIQAhgCHAIgAiQCKAIgAigCLAIwAjQCOAI8AkACRAI8AkQCSAJMAlACVAJMAlQCWAJcAmACZAJcAmQCaAJsAnACdAJ4AnACbAJ4AnwCcAKAAnwCeAKAAoQCfAJsAnQCiAKMAogCdAKMAnQCkAKUAowCkAKUApACmAKQApwCmAJ0AqACkAKQAqACnAKgAqQCnAJ0AqgCoAKgAqwCpAKoAqwCoAKoArACrAK0ArgCvAK0ArwCwALEAsgCzALEAswC0ALUAtgC3ALUAtwC4ALkAugC7ALkAuwC8AL0AvgC/AL0AvwDAAMEAwgDDAMEAwwDEAMUAxgDHAMUAxwDIAMkAygDLAMkAywDMAM0AzgDPAM0AzwDQANEA0gDTANEA0wDUANUA1gDXANUA1wDYANkA2gDbANkA2wDcAN0A3gDfAN0A3wDgAOEA4gDjAOEA4wDkAOUA5gDnAOUA5wDoAOkA6gDrAOwA7QDuAOwA7gDvAPAA8QDyAPAA8gDzAPQA9QD2APQA9gD3APgA+QD6APgA+gD7APwA/QD+APwA/gD/AAABAQECAQABAgEDAQQBBQEGAQQBBgEHAQgBCQEKAQgBCgELAQwBDQEOAQ8BEAERAQ8BEQESARMBFAEVARMBFQEWARcBGAEZARcBGQEaARsBHAEdARsBHQEeAR8BIAEhAR8BIQEiASMBJAElASMBJQEmAScBKAEpAScBKQEqASsBLAEtASsBLQEuAS8BMAExAS8BMQEyATMBNAE1ATMBNQE2ATcBOAE5ATcBOQE6ATsBPAE9ATsBPQE+AT8BQAFBAUIBQwFEAUIBRAFFAUYBQwFCAUcBSAFGAUcBRgFJAUcBSQFKAUcBSgFLAUsBSgFMAUoBTQFMAU0BTgFMAU0BTwFOAUsBTAFQAVEBSwFQAVIBUQFQAVIBUAFTAVQBVQFIAVYBVQFUAVYBVwFVAVgBWQFaAVgBWgFbAVwBXQFeAVwBXgFfAWABYQFiAWABYgFjAWQBZQFmAWQBZgFnAWgBaQFqAWgBagFrAWwBbQFuAWwBbgFvAXABcQFyAXABcgFzAXQBdQF2AXQBdgF3AXgBeQF6AXgBegF7AXwBfQF+AXwBfgF/AYABgQGCAYABggGDAYQBhQGGAYQBhgGHAYgBiQGKAYgBigGLAYwBjQGOAYwBjgGPAZABkQGSAZABkgGTAZQBlQGWAZQBlgGXAZgBmQGaAZgBmgGbAZwBnQGeAZwBngGfAaABoQGiAaABogGjAaQBpQGmAaQBpgGnAagBqQGqAagBqgGrAawBrQGuAawBrgGvAbABsQGyAbABsgGzAbQBtQG2AbQBtgG3AbgBuQG6AbgBugG7AbwBvQG+AbwBvgG/AcABwQHCAcABwgHDAcQBxQHGAcQBxgHHAcgByQHKAcgBygHLAcwBzQHOAcwBzgHPAdAB0QHSAdAB0gHTAdQB1QHWAdQB1gHXAdgB2QHaAdgB2gHbAdwB3QHeAdwB3gHfAeAB4QHiAeMB5AHlAeMB5QHmAecB6AHpAecB6QHqAesB7AHtAesB7QHuAe8B8AHxAe8B8QHyAfMB9AH1AfMB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AQACAQICAgACAgIDAgQCBQIGAgQCBgIHAggCCQIKAgsCDAINAg4CDwIQAg4CEAIRAhICEwIUAhICFAIVAhYCFwIYAhYCGAIZAhoCGwIcAhoCHAIdAh4CHwIgAh4CIAIhAiICIwIkAiICJAIlAiYCJwIoAiYCKAIpAioCKwIsAioCLAItAi4CLwIwAjECMgIzAjQCNQI2AjcCOAI5AjcCOQI6AjsCPAI9AjsCPQI+Aj8CQAJBAkICQwJEAkICRAJFAkYCRwJIAkYCSAJJAkoCSwJMAk0CTgJPAk0CTwJQAlECUgJTAlECUwJUAlUCVgJXAlUCVwJYAlkCWgJbAlkCWwJcAl0CXgJfAl0CXwJgAmECYgJjAmECYwJkAmUCZgJnAmUCZwJoAmkCagJrAmkCawJsAm0CbgJvAm0CbwJwAnECcgJzAnECcwJ0AnUCdgJ3AnUCdwJ4AnkCegJ7AnkCewJ8An0CfgJ/An0CfwKAAoECggKDAoECgwKEAoUChgKHAoUChwKIAokCigKLAokCiwKMAo0CjgKPAo0CjwKQApECkgKTApECkwKUApUClgKXApUClwKYApkCmgKbApkCmwKcAp0CngKfAp0CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAqoCrAKtAq4CrwKwAq4CsAKxArICswK0ArUCtgK3ArUCtwK4ArkCugK7ArkCuwK8Ar0CvgK/Ar0CvwLAAsECwgLDAsECwwLEAsUCxgLHAsUCxwLIAskCygLLAskCywLMAs0CzgLPAs0CzwLQAtEC0gLTAtEC0wLUAtUC1gLXAtUC1wLYAtkC2gLbAtkC2wLcAt0C3gLfAt0C3wLgAuEC4gLjAuEC4wLkAuUC5gLnAuUC5wLoAukC6gLrAukC6wLsAu0C7gLvAu0C7wLwAvEC8gLzAvEC8wL0AvUC9gL3AvUC9wL4AvkC+gL7AvkC+wL8Av0C/gL/Av0C/wIAAwEDAgMDAwEDAwMEAwUDBgMHAwUDBwMIAwkDCgMLAwkDCwMMAw0DDgMPAw0DDwMQAxEDEgMTAxEDEwMUAxUDFgMXAxUDFwMYAxkDGgMbAxkDGwMcAx0DHgMfAx0DHwMgAyEDIgMjAyEDIwMkAyUDJgMnAyUDJwMoAykDKgMrAykDKwMsAy0DLgMvAy0DLwMwAzEDMgMzAzEDMwM0AzUDNgM3AzUDNwM4AzkDOgM7AzkDOwM8Az0DPgM/Az0DPwNAA0EDQgNDA0EDQwNEA0UDRgNHA0UDRwNIA0kDSgNLA0kDSwNMA00DTgNPA00DTwNQA1EDUgNTA1QDVQNWA1QDVgNXA1gDWQNaA1gDWgNbA1wDXQNeA1wDXgNfA2ADYQNiA2ADYgNjA2QDZQNmA2QDZgNnA2gDaQNqA2gDagNrA2wDbQNuA2wDbgNvA3ADcQNyA3ADcgNzA3QDdQN2A3QDdgN3A3gDeQN6A3gDegN7A3wDfQN+A3wDfgN/A4ADgQOCA4ADggODA4QDhQOGA4QDhgOHA4gDiQOKA4gDigOLA4wDjQOOA4wDjgOPA5ADkQOSA5ADkgOTA5QDlQOWA5YDlwOUA5YDmAOXA5kDmgObA5kDmwOcA50DngOfA50DnwOgA6EDogOjA6MDpAOhA6MDpQOkA6YDpwOoA6YDqAOpA6oDqwOsA6oDrAOtA64DrwOwA64DsAOxA7IDswO0A7IDtAO1A7YDtwO4A7YDuAO5A7oDuwO8A7oDvAO9A74DvwPAA74DwAPBA8IDwwPEA8IDxAPFA8YDxwPIA8YDyAPJA8oDywPMA8oDzAPNA84DzwPQA84D0APRA9ID0wPUA9ID1APVA9YD1wPYA9kD2gPbA9kD2wPcA90D3gPfA90D3wPgA+ED4gPjA+ED4wPkA+UD5gPnA+UD5wPoA+kD6gPrA+kD6wPsA+0D7gPvA+0D7wPwA/ED8gPzA/ED8wP0A/UD9gP3A/UD9wP4A/kD+gP7A/kD+wP8A/0D/gP/A/0D/wMABAEEAgQDBAEEAwQEBAUEBgQHBAUEBwQIBAkECgQLBAkECwQMBA0EDgQPBBAEEQQSBBAEEgQTBBQEFQQWBBQEFgQXBBgEGQQaBBgEGgQbBBwEHQQeBBwEHgQfBCAEIQQiBCAEIgQjBCQEJQQmBCQEJgQnBCgEKQQqBCgEKgQrBCwELQQuBCwELgQvBDAEMQQyBDAEMgQzBDQENQQ2BDQENgQ3BDgEOQQ6BDgEOgQ7BDwEPQQ+BDwEPgQ/BEAEQQRCBEAEQgRDBEQERQRGBEQERgRHBEgESQRKBEgESgRLBEwETQROBEwETgRPBFAEUQRSBFAEUgRTBFQEVQRWBFQEVgRXBFgEWQRaBFgEWgRbBFwEXQReBFwEXgRfBGAEYQRiBGAEYgRjBGQEZQRmBGcEaARpBGcEaQRqBGsEbARtBG4EbwRwBG4EcARxBHIEcwR0BHIEdAR1BHYEdwR4BHYEeAR5BHoEewR8BHoEfAR9BH4EfwSABH4EgASBBIIEgwSEBIIEhASFBIYEhwSIBIYEiASJBIoEiwSMBIoEjASNBI4EjwSQBI4EkASRBJIEkwSUBJIElASVBJYElwSYBJYEmASZBJoEmwScBJoEnASdBJ4EnwSgBJ4EoAShBKIEowSkBKUEpgSnBKUEpwSoBKkEqgSrBKkEqwSsBK0ErgSvBK0ErwSwBLEEsgSzBLEEswS0BLUEtgS3BLUEtwS4BLkEugS7BLkEuwS8BL0EvgS/BL0EvwTABMEEwgTDBMEEwwTEBMUExgTHBMUExwTIBMkEygTLBMkEywTMBM0EzgTPBM0EzwTQBNEE0gTTBNME1ATRBNME1QTUBNYE1wTYBNYE2ATZBNoE2wTcBNoE3ATdBN4E3wTgBN4E4AThBOIE4wTkBOIE5ATlBOYE5wToBOYE6ATpBOoE6wTsBOoE7ATtBO4E7wTwBO4E8ATxBPIE8wT0BPIE9AT1BPYE9wT4BPYE+AT5BPoE+wT8BP0E/gT/BP0E/wQABQEFAgUDBQEFAwUEBQUFBgUHBQUFBwUIBQkFCgULBQkFCwUMBQ0FDgUPBQ0FDwUQBREFEgUTBREFEwUUBRUFFgUXBRUFFwUYBRkFGgUbBRkFGwUcBR0FHgUfBSAFIQUiBSAFIgUjBSQFJQUmBSQFJgUnBSgFKQUqBSgFKgUrBSwFLQUuBSwFLgUvBTAFMQUyBTMFMgUxBTMFMQU0BTIFNQUwBTUFNgUwBTIFNwU1BTgFOQU6BTgFOgU7BTwFPQU+BTwFPgU/BUAFQQVCBUAFQgVDBUQFRQVGBUcFSAVJBUcFSQVKBUsFTAVNBUsFTQVOBU8FUAVRBVIFUwVUBVIFVAVVBVYFVwVYBVYFWAVZBVoFWwVcBVoFXAVdBV4FXwVgBV4FYAVhBWIFYwVkBWIFZAVlBWYFZwVoBWYFaAVpBWoFawVsBWoFbAVtBW4FbwVwBW4FcAVxBXIFcwV0BXIFdAV1BXYFdwV4BXYFeAV5BXoFewV8BXoFfAV9BX4FfwWABX4FgAWBBYIFgwWEBYIFhAWFBYYFhwWIBYYFiAWJBYoFiwWMBYoFjAWNBY4FjwWQBZEFkgWTBZEFkwWUBZUFlgWXBZUFlwWYBZkFmgWbBZkFmwWcBZ0FngWfBZ0FnwWgBaEFogWjBaEFowWkBaUFpgWnBaUFpwWoBakFqgWrBakFqwWsBa0FrgWvBa0FrwWwBbEFsgWzBbQFtQW2BbQFtgW3BbgFuQW6BbgFugW7BbwFvQW+BbwFvgW/BcAFwQXCBcAFwgXDBcQFxQXGBcQFxgXHBcgFyQXKBcgFygXLBcwFzQXOBcwFzgXPBdAF0QXSBdAF0gXTBdQF1QXWBdQF1gXXBdgF2QXaBdgF2gXbBdwF3QXeBdwF3gXfBeAF4QXiBeAF4gXjBeQF5QXmBecF6AXpBecF6QXqBesF7AXtBesF7QXuBe8F8AXxBe8F8QXyBfMF9AX1BfMF9QX2BfcF+AX5BfcF+QX6BfsF/AX9BfsF/QX+Bf8FAAYBBv8FAQYCBgMGBAYFBgMGBQYGBgcGCAYJBgcGCQYKBgsGDAYNBgsGDQYOBg8GEAYRBg8GEQYSBhMGFAYVBhMGFQYWBhcGGAYZBhcGGQYaBhsGHAYdBhsGHQYeBh8GIAYhBh8GIQYiBiMGJAYlBiMGJQYmBicGKAYpBicGKQYqBisGLAYtBisGLQYuBi8GMAYxBi8GMQYyBjMGNAY1BjMGNQY2BjcGOAY5BjcGOQY6BjsGPAY9BjsGPQY+Bj8GQAZBBj8GQQZCBkMGRAZFBkMGRQZGBkcGSAZJBkcGSQZKBksGTAZNBksGTQZOBk8GUAZRBk8GUQZSBlMGVAZVBlMGVQZWBlcGWAZZBlcGWQZaBlsGXAZdBlsGXQZeBl8GYAZhBl8GYQZiBmMGZAZlBmMGZQZmBmcGaAZpBmcGaQZqBmsGbAZtBm4GbwZwBm4GcAZxBnIGcwZ0BnIGdAZ1BnYGdwZ4BnYGeAZ5BnoGewZ8BnoGfAZ9Bn4GfwaABn4GgAaBBoIGgwaEBoUGhgaHBogGiQaKBosGjAaNBosGjQaOBo8GkAaRBo8GkQaSBpMGlAaVBpYGlwaYBpkGmgabBpkGmwacBp0GngafBp0GnwagBqEGogajBqEGowakBqUGpganBqUGpwaoBqkGqgarBqkGqwasBq0GrgavBq0GrwawBrEGsgazBrEGswa0BrUGtga3BrUGtwa4BrkGuga7BrwGvQa+Br8GwAbBBsIGwwbEBsIGxAbFBsYGxwbIBsYGyAbJBsoGywbMBs0GzgbPBs0GzwbQBtEG0gbTBtEG0wbUBtUG1gbXBtgG2QbaBtgG2gbbBtwG3QbeBtwG3gbfBuAG4QbiBuAG4gbjBuQG5QbmBuQG5gbnBugG6QbqBugG6gbrBuwG7QbuBuwG7gbvBvAG8QbyBvAG8gbzBvQG9Qb2BvQG9gb3BvgG+Qb6BvgG+gb7BvwG/Qb+BvwG/gb/BgAHAQcCBwAHAgcDBwQHBQcGBwQHBgcHBwgHCQcKBwgHCgcLBwwHDQcOBwwHDgcPBxAHEQcSBxAHEgcTBxQHFQcWBxQHFgcXBxgHGQcaBxgHGgcbBxwHHQceBxwHHgcfByAHIQciByAHIgcjByQHJQcmByQHJgcnBygHKQcqBygHKgcrBywHLQcuBy8HMAcxBzIHMwc0BzUHNgc3BzUHNwc4BzkHOgc7BzkHOwc8Bz0HPgc/B0AHQQdCB0AHQgdDB0QHRQdGB0QHRgdHB0gHSQdKB0gHSgdLB0wHTQdOB0wHTgdPB1AHUQdSB1AHUgdTB1QHVQdWB1QHVgdXB1gHWQdaB1gHWgdbB1wHXQdeB1wHXgdfB2AHYQdiB2AHYgdjB2QHZQdmB2QHZgdnB2gHaQdqB2gHagdrB2wHbQduB2wHbgdvB3AHcQdyB3AHcgdzB3QHdQd2B3QHdgd3B3gHeQd6B3gHegd7B3wHfQd+B3wHfgd/B4AHgQeCB4AHggeDB4QHhQeGB4QHhgeHB4gHiQeKB4gHigeLB4wHjQeOB4wHjgePB5AHkQeSB5AHkgeTB5QHlQeWB5QHlgeXB5gHmQeaB5gHmgebB5wHnQeeB5wHngefB6AHoQeiB6AHogejB6QHpQemB6QHpgenB6gHqQeqB6gHqgerB6wHrQeuB6wHrgevB7AHsQeyB7AHsgezB7QHtQe2B7QHtge3B7gHuQe6B7gHuge7B7wHvQe+B7wHvge/B8AHwQfCB8AHwgfDB8QHxQfGB8QHxgfHB8gHyQfKB8gHygfLB8wHzQfOB8wHzgfPB9AH0QfSB9AH0gfTB9QH1QfWB9QH1gfXB9gH2QfaB9gH2gfbB9wH3QfeB98H4AfhB98H4QfiB+MH5AflB+MH5QfmB+cH6AfpB+cH6QfqB+sH7AftB+sH7QfuB+8H8AfxB+8H8QfyB/MH9Af1B/MH9Qf2B/cH+Af5B/cH+Qf6B/sH/Af9B/sH/Qf+B/8HAAgBCP8HAQgCCAMIBAgFCAMIBQgGCAcICAgJCAcICQgKCAsIDAgNCAsIDQgOCA8IEAgRCA8IEQgSCBMIFAgVCBMIFQgWCBcIGAgZCBcIGQgaCBsIHAgdCBsIHQgeCB8IIAghCCEIIggfCCEIIwgiCCQIJQgmCCQIJggnCCgIKQgqCCgIKggrCCwILQguCC4ILwgsCC4IMAgvCDEIMggzCDEIMwg0CDUINgg3CDUINwg4CDkIOgg7CDkIOwg8CD0IPgg/CD0IPwhACEEIQghDCEEIQwhECEUIRghHCEUIRwhICEkISghLCEkISwhMCE0ITghPCE0ITwhQCFEIUghTCFEIUwhUCFUIVghXCFUIVwhYCFkIWghbCFkIWwhcCF0IXghfCF0IXwhgCGEIYghjCGQIZQhmCGQIZghnCGgIaQhqCGgIaghrCGwIbQhuCGwIbghvCHAIcQhyCHAIcghzCHQIdQh2CHQIdgh3CHgIeQh6CHgIegh7CHwIfQh+CHwIfgh/CIAIgQiCCIAIggiDCIQIhQiGCIQIhgiHCIgIiQiKCIgIigiLCIwIjQiOCIwIjgiPCJAIkQiSCJAIkgiTCJQIlQiWCJQIlgiXCJgImQiaCJsInAidCJsInQieCJ8IoAihCJ8IoQiiCKMIpAilCKMIpQimCKcIqAipCKcIqQiqCKsIrAitCKsIrQiuCK8IsAixCK8IsQiyCLMItAi1CLMItQi2CLcIuAi5CLcIuQi6CLsIvAi9CLsIvQi+CL8IwAjBCL8IwQjCCMMIxAjFCMMIxQjGCMcIyAjJCMcIyQjKCMsIzAjNCMsIzQjOCM8I0AjRCM8I0QjSCNMI1AjVCNMI1QjWCNcI2AjZCNcI2QjaCNsI3AjdCNsI3QjeCN8I4AjhCN8I4QjiCOMI5AjlCOMI5QjmCOcI6AjpCOcI6QjqCOsI7AjtCOsI7QjuCO8I8AjxCPII8wj0CPII9Aj1CPYI9wj4CPkI+gj7CPkI+wj8CP0I/gj/CP0I/wgACQEJAgkDCQEJAwkECQUJBgkHCQUJBwkICQkJCgkLCQkJCwkMCQ0JDgkPCQ0JDwkQCREJEgkTCREJEwkUCRUJFgkXCRUJFwkYCRkJGgkbCRkJGwkcCR0JHgkfCR0JHwkgCSEJIgkjCSEJIwkkCSUJJgknCSUJJwkoCSkJKgkrCSkJKwksCS0JLgkvCTAJMQkyCTAJMgkzCTQJNQk2CTQJNgk3CTgJOQk6CTgJOgk7CTwJPQk+CTwJPgk/CUAJQQlCCUAJQglDCUQJRQlGCUQJRglHCUgJSQlKCUgJSglLCUwJTQlOCU8JUAlRCVIJUwlUCVUJUwlSCVYJVwlYCVkJWglbCVwJXQleCV8JYAlhCWIJYwlkCWUJZglnCWgJaQlqCWsJbAltCW4JbwlwCXEJcglzCXQJdQl2CXcJeAl5CXoJewl8CX0Jfgl/CYAJgQmCCYMJhAmFCYYJhwmICYkJigmLCYwJjQmOCY8JkAmRCZIJkwmUCZUJlgmXCZgJmQmaCZsJnAmdCZ4JnwmgCaEJogmjCaQJpQmmCacJqAmpCaoJqwmsCa0JqgmsCa4JrwmwCbEJsgmzCbQJtQm2CbcJuAm5CboJuwm8Cb0Jvgm/CcAJwQnCCcMJxAnFCcYJxwnICckJygnLCcwJzQnOCc8J0AnRCdIJ0wnUCdUJ1gnXCdgJ2QnaCdsJ3AndCd4J3wngCeEJ4gnjCeQJ5QnmCecJ6AnpCeoJ6wnsCe0J7gnvCfAJ8QnyCfMJ9An1CfYJ9wn4CfkJ+gn7CfwJ/Qn+CfwJ/gn/CQAKAQoCCgAKAgoDCgQKBQoGCgQKBgoHCggKCQoKCggKCgoLCgwKDQoOCgwKDgoPChAKEQoSChAKEgoTChQKFQoWChQKFgoXChgKGQoaChgKGgobChwKHQoeChwKHgofCiAKIQoiCiAKIgojCiQKJQomCiQKJgonCigKKQoqCigKKgorCiwKLQouCiwKLgovCjAKMQoyCjAKMgozCjQKNQo2CjQKNgo3CjgKOQo6CjgKOgo7CjwKPQo+CjwKPgo/CkAKQQpCCkAKQgpDCkQKRQpGCkQKRgpHCkgKSQpKCkgKSgpLCkwKTQpOCkwKTgpPClAKUQpSClAKUgpTClQKVQpWClQKVgpXClgKWQpaClgKWgpbClwKXQpeClwKXgpfCmAKYQpiCmAKYgpjCmQKZQpmCmQKZgpnCmgKaQpqCmgKagprCmwKbQpuCmwKbgpvCnAKcQpyCnAKcgpzCnQKdQp2CnQKdgp3CngKeQp6CngKegp7CnwKfQp+CnwKfgp/CoAKgQqCCoAKggqDCoQKhQqGCoQKhgqHCogKiQqKCogKigqLCowKjQqOCo8KkAqRCpIKkwqUCpUKkwqSCpYKlwqYCpkKmgqbCpwKnQqeCp8KoAqhCqIKowqkCqUKpgqnCqgKqQqqCqsKrAqtCq4KrwqwCrEKsgqzCrQKtQq2CrcKuAq5CroKuwq8Cr0Kvgq/CsAKwQrCCsMKxArFCsYKxwrICskKygrLCswKzQrOCs8K0ArRCtIK0wrUCtUK1grXCtgK2QraCtsK3ArdCt4K3wrgCuEK4grjCuQK5QrmCucK6ArpCuoK6wrsCu0K6grsCu4K7wrwCvEK8grzCvQK9Qr2CvcK+Ar5CvoK+wr8Cv0K/gr/CgALAQsCCwMLBAsFCwYLBwsICwkLCgsLCwwLDQsOCw8LEAsRCxILEwsUCxULFgsXCxgLGQsaCxsLHAsdCx4LHwsgCyELIgsjCyQLJQsmCycLKAspCyoLKwssCy0LLgsvCzALMQsyCzMLNAs1CzYLNws4CzkLOgs7CzwLPQs+CzwLPgs/C0ALQQtCC0ALQgtDC0QLRQtGC0QLRgtHC0gLSQtKC0gLSgtLC0wLTQtOC0wLTgtPC1ALUQtSC1ALUgtTC1QLVQtWC1QLVgtXC1gLWQtaC1gLWgtbC1wLXQteC1wLXgtfC2ALYQtiC2ALYgtjC2QLZQtmC2QLZgtnC2gLaQtqC2gLagtrC2wLbQtuC2wLbgtvC3ALcQtyC3ALcgtzC3QLdQt2C3QLdgt3C3gLeQt6C3gLegt7C3wLfQt+C3wLfgt/C4ALgQuCC4ALgguDC4QLhQuGC4QLhguHC4gLiQuKC4gLiguLC4wLjQuOC4wLjguPC5ALkQuSC5ALkguTC5QLlQuWC5QLlguXC5gLmQuaC5gLmgubC5wLnQueC5wLngufC6ALoQuiC6ALogujC6QLpQumC6QLpgunC6gLqQuqC6gLqgurC6wLrQuuC6wLrguvC7ALsQuyC7ALsguzC7QLtQu2C7QLtgu3C7gLuQu6C7gLugu7C7wLvQu+C7wLvgu/C8ALwQvCC8ALwgvDC8QLxQvGC8QLxgvHC8gLyQvKC8gLygvLC8wLzQvOC88L0AvRCwAAAQACAAAAAgADAAQABQAGAAQABgAHAAgACQAKAAgACgALAAwADQAOAAwADgAPABAAEQASABAAEgATABQAFQAWABQAFgAXABgAGQAaABgAGgAbABwAHQAeAB8AIAAhAB8AIQAiACMAJAAlACMAJQAmACcAKAApACoAKwAsACoALAAtAC4ALwAwAC4AMAAxADIAMwA0ADIANAA1ADYANwA4ADYAOAA5ADoAOwA8AD0APgA/AD0APwBAAEEAQgBDAEEAQwBEAEUARgBHAEUARwBIAEkASgBLAEkASwBMAE0ATgBPAE0ATwBQAFEAUgBTAFEAUwBUAFUAVgBXAFUAVwBYAFkAWgBbAFkAWwBcAF0AXgBfAGAAYQBiAGAAYgBjAGQAZQBmAGQAZgBnAGgAaQBqAGsAbABtAGsAbQBuAG8AcABxAG8AcQByAHMAdAB1AHMAdQB2AHcAeAB5AHcAeQB6AHsAfAB9AH4AfwCAAH4AgACBAAAAAQACAAMABAAFAAMABQAGAAcACAAJAAcACQAKAAsADAANAAsADQAOAA8AEAARAA8AEQASABMAFAAVABMAFQAWABcAGAAZABcAGQAaABsAHAAdAB4AHwAgAB4AIAAhACIAIwAkACIAJAAlACYAJwAoACYAKAApACoAKwAsACoALAAtAC4ALwAwAC4AMAAxADIAMAAvADIAMwAwADQANQA2ADQANgA3ADgAOQA6ADgAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEIARABFAEYARwBIAEYASABJAEoASwBMAEoATABNAE4ATwBQAE4AUABRAFIAUwBUAFIAVABVAFYAVwBYAFYAWABZAFoAWwBcAF0AXgBfAF0AXwBgAGEAYgBjAGEAYwBkAGUAZgBnAGUAZwBoAGkAagBrAGkAawBsAG0AbgBvAG0AbwBwAHEAcgBzAHEAcwB0AHUAdgB3AHgAeQB6AHgAegB7AHwAfQB+AHwAfgB/AIAAgQCCAIAAggCDAIQAhQCGAIQAhgCHAIgAiQCKAIgAigCLAIwAjQCOAIwAjgCPAJAAkQCSAJAAkgCTAJQAlQCWAJQAlgCXAJgAmQCaAJgAmgCbAJwAnQCeAJwAngCfAKAAoQCiAKAAogCjAKQApQCmAKQApgCnAKgAqQCqAKgAqgCrAKwArQCuAKwArgCvAK4AsACvALEAsgCsALMAsQCsAK8AswCsALMAtACxAK8AtQCzALUAtgCzAK8AtwC1ALgAuQC6ALgAugC7ALwAvQC+ALwAvgC/AMAAwQDCAMAAwgDDAMQAxQDGAMQAxgDHAMgAyQDKAMgAygDLAMwAzQDOAMwAzgDPANAA0QDSANAA0gDTANQA1QDWANQA1gDXANgA2QDaANgA2gDbANwA3QDeANwA3gDfAOAA4QDiAOAA4gDjAOQA5QDmAOQA5gDnAOgA6QDqAOgA6gDrAOwA7QDuAOwA7gDvAPAA8QDyAPAA8gDzAPQA9QD2APQA9gD3APgA9AD3APgA9wD5APoA+AD5APoA+QD7APwA/QD+APwA/gD/AAABAQECAQABAgEDAQQBBQEGAQUBBwEGAQUBCAEHAQQBBgEJAQoBBAEJAQoBCQELAQwBDQEOAQwBDgEPARABEQESARABEgETARQBFQEWARQBFgEXARgBGQEaARgBGgEbARwBHQEeARwBHgEfASABIQEiASABIgEjASQBJQEmASQBJgEnASgBKQEqASgBKgErASwBLQEuASwBLgEvATABMQEyATABMgEzATQBNQE2ATQBNgE3ATgBOQE6ATgBOgE7ATwBPQE+ATwBPgE/AUABQQFCAUABQgFDAUQBRQFGAUQBRgFHAUgBSQFKAUgBSgFLAUwBTQFOAUwBTgFPAVABUQFSAVABUgFTAVQBVQFWAVQBVgFXAVgBWQFaAVgBWgFbAVwBXQFeAVwBXgFfAWABYQFiAWABYgFjAWQBZQFmAWQBZgFnAWgBaQFqAWgBagFrAWwBbQFuAWwBbgFvAXABcQFyAXABcgFzAXQBdQF2AXQBdgF3AXgBeQF6AXgBegF7AXwBfQF+AXwBfgF/AYABgQGCAYABggGDAYQBhQGGAYQBhgGHAYgBiQGKAYgBigGLAYwBjQGOAYwBjgGPAZABkQGSAZABkgGTAZQBlQGWAZQBlgGXAZgBmQGaAZgBmgGbAZwBnQGeAZwBngGfAaABoQGiAaABogGjAaQBpQGmAaQBpgGnAagBqQGqAagBqgGrAawBrQGuAawBrgGvAbABsQGyAbABsgGzAbIBtAGzAbUBtgGwAbcBtQGwAbMBtwGwAbcBuAG1AbMBuQG3AbkBugG3AbMBuwG5AbwBvQG+AbwBvgG/AcABwQHCAcABwgHDAcQBxQHGAcQBxgHHAcgByQHKAcgBygHLAcwBzQHOAcwBzgHPAdAB0QHSAdAB0gHTAdQB1QHWAdQB1gHXAdgB2QHaAdgB2gHbAdwB3QHeAdwB3gHfAeAB4QHiAeAB4gHjAeQB5QHmAeQB5gHnAegB6QHqAegB6gHrAewB7QHuAewB7gHvAfAB8QHyAfAB8gHzAfQB9QH2AfQB9gH3AfgB+QH6AfgB+gH7AfwB+QH4AfwB/QH5Af4B/QH8Af4B/wH9AQACAQICAgACAgIDAgQCBQIGAgQCBgIHAggCCQIKAggCCgILAgsCCgIMAgsCDAINAg4CDwIQAg4CEAIRAhICEwIUAhICFAIVAhYCFwIYAhYCGAIZAhoCGwIcAhoCHAIdAh4CHwIgAh4CIAIhAiICIwIkAiICJAIlAiYCJwIoAiYCKAIpAioCKwIsAioCLAItAi4CLwIwAi4CMAIxAjICMwI0AjICNAI1AjYCNwI4AjYCOAI5AjoCOwI8AjoCPAI9Aj4CPwJAAj4CQAJBAkICQwJEAkICRAJFAkYCRwJIAkYCSAJJAkoCSwJMAkoCTAJNAk4CTwJQAk4CUAJRAlICUwJUAlICVAJVAlYCVwJYAlYCWAJZAloCWwJcAloCXAJdAl4CXwJgAl4CYAJhAmICYwJkAmICZAJlAmYCZwJoAmYCaAJpAmoCawJsAmoCbAJtAm4CbwJwAm4CcAJxAnICcwJ0AnICdAJ1AnYCdwJ4AnYCeAJ5AnoCewJ8AnoCfAJ9An4CfwKAAn4CgAKBAoICgwKEAoIChAKFAoYChwKIAoYCiAKJAooCiwKMAooCjAKNAo4CjwKQAo4CkAKRApICkwKUApIClAKVApYClwKYApYCmAKZApoCmwKcApoCnAKdAp4CnwKgAp4CoAKhAqICowKkAqICpAKlAqYCpwKoAqYCqAKpAqoCqwKsAqoCrAKtAq4CrwKwAq4CsAKxArICswK0ArICtAK1ArYCtwK4ArYCuAK5ArgCugK5ArsCvAK2Ar0CuwK2ArkCvQK2Ar0CvgK7ArkCvwK9Ar8CwAK9ArkCwQK/AsICwwLEAsICxALFAsYCxwLIAsYCyALJAsoCywLMAsoCzALNAs4CzwLQAs4C0ALRAtIC0wLUAtIC1ALVAtYC1wLYAtYC2ALZAtoC2wLcAtoC3ALdAt4C3wLgAt4C4ALhAuIC4wLkAuIC5ALlAuYC5wLoAuYC6ALpAuoC6wLsAuoC7ALtAu4C7wLwAu4C8ALxAvIC8wL0AvIC9AL1AvYC9wL4AvYC+AL5AvoC+wL8AvoC/AL9Av4C/wIAA/4CAAMBAwIDAwMEAwIDBAMFAwYDBwMIAwYDCAMJAwoDCwMMAwsDDQMMAwsDDgMNAwoDDAMPAxADCgMPAxADDwMRAxIDEwMUAxIDFAMVAxYDFwMYAxYDGAMZAxoDGwMcAxoDHAMdAx4DHwMgAx4DIAMhAyIDIwMkAyIDJAMlAyYDJwMoAyYDKAMpAyoDKwMsAyoDLAMtAy4DLwMwAy4DMAMxAzIDMwM0AzIDNAM1AzYDNwM4AzYDOAM5AzoDOwM8AzoDPAM9Az4DPwNAAz4DQANBA0IDQwNEA0IDRANFA0YDRwNIA0YDSANJA0oDSwNMA0oDTANNA04DTwNQA04DUANRA1IDUwNUA1IDVANVA1YDVwNYA1YDWANZA1oDWwNcA1oDXANdA14DXwNgA14DYANhA2IDYwNkA2IDZANlA2YDZwNoA2YDaANpA2oDawNsA2oDbANtA24DbwNwA24DcANxA3IDcwN0A3IDdAN1A3YDdwN4A3YDeAN5A3oDewN8A3oDfAN9A34DfwOAA34DgAOBA4IDgwOEA4IDhAOFA4YDhwOIA4YDiAOJA4oDiwOMA4oDjAONA44DjwOQA44DkAORA5IDkwOUA5IDlAOVA5YDlwOYA5YDmAOZA5oDmwOcA5oDnAOdA54DnwOgA54DoAOhA6IDowOkA6IDpAOlA6YDpwOoA6YDqAOpA6oDqwOsA6oDrAOtA64DrwOwA64DsAOxA7IDswO0A7IDtAO1A7YDtwO4A7YDuAO5A7oDuwO8A7oDvAO9A74DvwPAA74DwAPBA8ADwgPBA8MDxAO+A8UDwwO+A8EDxQO+A8UDxgPDA8EDxwPFA8cDyAPFA8EDyQPHA8oDywPMA8oDzAPNA84DzwPQA84D0APRA9ID0wPUA9ID1APVA9YD1wPYA9YD2APZA9oD2wPcA9oD3APdA94D3wPgA94D4APhA+ID4wPkA+ID5APlA+YD5wPoA+YD6APpA+oD6wPsA+oD7APtA+4D7wPwA+4D8APxA/ID8wP0A/ID9AP1A/YD9wP4A/YD+AP5A/oD+wP8A/oD/AP9A/4D/wMABP4DAAQBBAIEAwQEBAIEBAQFBAYEBwQIBAYECAQJBAoECwQMBAoEDAQNBA4EDwQQBA4EEAQRBBIEEwQUBBIEFAQVBBYEFwQYBBYEGAQZBBoEGwQcBBoEHAQdBB4EHwQgBB4EIAQhBCIEIwQkBCIEJAQlBCYEJwQoBCYEKAQpBCoEKwQsBCoELAQtBC4ELwQwBC4EMAQxBDIEMwQ0BDIENAQ1BDYENwQ4BDYEOAQ5BDoEOwQ8BDoEPAQ9BD4EPwRABD4EQARBBEIEQwREBEIERARFBEYERwRIBEYESARJBEoESwRMBEoETARNBE4ETwRQBE4EUARRBFIEUwRUBFIEVARVBFYEVwRYBFYEWARZBFoEWwRcBFoEXARdBF4EXwRgBF4EYARhBGIEYwRkBGIEZARlBGYEZwRoBGYEaARpBGoEawRsBGoEbARtBG4EbwRwBG4EcARxBHIEcwR0BHIEdAR1BHYEdwR4BHYEeAR5BHoEewR8BHoEfAR9BH4EfwSABH4EgASBBIIEgwSEBIIEhASFBIYEhwSIBIYEiASJBIoEiwSMBIoEjASNBI4EjwSQBI4EkASRBJIEkwSUBJIElASVBAAAAQACAAAAAgADAAQABQAGAAQABgAHAAgACQAKAAgACgALAAwADQAOAAwADgAPABAAEQASABAAEgATABQAFQAWABQAFgAXABgAGQAaABgAGgAbABwAHQAeABwAHgAfACAAIQAiACAAIgAjACQAJQAmACQAJgAnACgAKQAqACgAKgArACwALQAuACwALgAvADAAMQAyADAAMgAzADQANQA2ADQANgA3ADgAOQA6ADgAOgA7ADwAPQA+ADwAPgA/AEAAQQBCAEAAQgBDAEQARQBGAEQARgBHAEYASABHAEkASgBEAEsASQBEAEcASwBEAEsATABJAEcATQBLAE0ATgBLAEcATwBNAFAAUQBSAFAAUgBTAFQAVQBWAFQAVgBXAFgAWQBaAFgAWgBbAFwAXQBeAFwAXgBfAGAAYQBiAGAAYgBjAGQAZQBmAGQAZgBnAGgAaQBqAGgAagBrAGwAbQBuAGwAbgBvAHAAcQByAHAAcgBzAHQAdQB2AHQAdgB3AHgAeQB6AHgAegB7AHwAfQB+AHwAfgB/AIAAgQCCAIAAggCDAIQAhQCGAIQAhgCHAIgAiQCKAIgAigCLAIwAjQCOAIwAjgCPAJAAkQCSAJAAkgCTAJQAlQCWAJQAlgCXAJgAmQCaAJgAmgCbAJwAnQCeAJwAngCfAKAAoQCiAKAAogCjAKQApQCmAKQApgCnAKgAqQCqAKgAqgCrAKwArQCuAKwArgCvALAAsQCyALAAsgCzALQAtQC2ALQAtgC3ALgAuQC6ALgAugC7ALwAvQC+ALwAvgC/AMAAwQDCAMAAwgDDAMQAxQDGAMQAxgDHAMgAyQDKAMgAygDLAMwAzQDOAMwAzgDPANAA0QDSANAA0gDTANQA1QDWANQA1gDXANgA2QDaANgA2gDbANwA3QDeANwA3gDfAOAA4QDiAOAA4gDjAOQA5QDmAOQA5gDnAOgA6QDqAOgA6gDrAOwA7QDuAOwA7gDvAPAA8QDyAPAA8gDzAPQA9QD2APQA9gD3APgA+QD6APgA+gD7APwA/QD+APwA/gD/AAABAQECAQABAgEDAQQBBQEGAQQBBgEHAQgBCQEKAQgBCgELAQwBCAENAQwBDQEOAQ8BEAERAQ8BEQESARMBFAEVARMBFQEWARcBGAEZARcBGQEaARsBHAEdARsBHQEeAR8BIAEhAR8BIQEiASMBJAElASMBJQEmAScBKAEpAScBKQEqASsBLAEtASsBLQEuAS8BMAExAS8BMQEyATMBNAE1ATMBNQE2ATcBOAE5ATcBOQE6ATsBPAE9ATsBPQE+AT8BQAFBAT8BQQFCAUMBRAFFAUMBRQFGAUcBSAFJAUcBSQFKAUsBTAFNAUsBTQFOAU8BUAFRAU8BUQFSAVMBVAFVAVMBVQFWAVcBWAFZAVcBWQFaAVsBXAFdAVsBXQFeAV8BYAFhAV8BYQFiAWMBZAFlAWMBZQFmAWcBaAFpAWcBaQFqAWsBbAFtAWsBbQFuAW8BcAFxAW8BcQFyAXMBdAF1AXMBdQF2AXcBeAF5AXcBeQF6AXsBfAF9AXsBfQF+AX8BgAGBAX8BgQGCAYMBhAGFAYMBhQGGAYcBiAGJAYcBiQGKAYsBjAGNAYsBjQGOAY8BkAGRAY8BkQGSAZMBlAGVAZMBlQGWAZcBmAGZAZcBmQGaAZsBnAGdAZsBnQGeAZ8BoAGhAZ8BoQGiAaMBpAGlAaMBpQGmAacBqAGpAacBqQGqAasBrAGtAasBrQGuAa8BsAGxAa8BsQGyAbMBtAG1AbMBtQG2AbcBuAG5AbcBuQG6AbsBvAG9AbsBvQG+Ab8BwAHBAb8BwQHCAcMBxAHFAcMBxQHGAccByAHJAccByQHKAcsBzAHNAcsBzQHOAc8B0AHRAc8B0QHSAdMB1AHVAdMB1QHWAdcB2AHZAdcB2QHaAdsB3AHdAdsB3QHeAd8B4AHhAd8B4QHiAeMB5AHlAeMB5QHmAecB6AHpAecB6QHqAesB7AHtAesB7QHuAe8B8AHxAe8B8QHyAfMB9AH1AfMB9QH2AfcB+AH5AfcB+QH6AfsB/AH9AfsB/QH+Af8BAAIBAv8BAQICAgMCBAIFAgMCBQIGAgcCCAIJAgcCCQIKAgsCDAINAgsCDQIOAg8CEAIRAg8CEQISAhMCFAIVAhMCFQIWAhcCGAIZAhcCGQIaAhsCHAIdAhsCHQIeAh8CIAIhAh8CIQIiAiMCJAIlAiMCJQImAicCKAIpAicCKQIqAisCLAItAisCLQIuAi8CMAIxAi8CMQIyAjMCNAI1AjMCNQI2AjcCOAI5AjcCOQI6AjsCPAI9AjsCPQI+Aj8CQAJBAj8CQQJCAkMCRAJFAkMCRQJGAkcCSAJJAkcCSQJKAksCTAJNAksCTQJOAk8CUAJRAk8CUQJSAlMCVAJVAlMCVQJWAlcCWAJZAlcCWQJaAlsCXAJdAlsCXQJeAl8CYAJhAl8CYQJiAmMCZAJlAmMCZQJmAmcCaAJpAmcCaQJqAmsCbAJtAmsCbQJuAm8CcAJxAm8CcQJyAnECcwJyAnQCdQJvAnYCdAJvAnICdgJvAnYCdwJ0AnICeAJ2AngCeQJ2AnICegJ4AnsCfAJ9AnsCfQJ+An8CgAKBAn8CgQKCAoMChAKFAoMChQKGAocCiAKJAocCiQKKAosCjAKNAosCjQKOAo8CkAKRAo8CkQKSApMClAKVApMClQKWApcCmAKZApcCmQKaApsCnAKdApsCnQKeAp8CoAKhAp8CoQKiAqMCpAKlAqMCpQKmAqcCqAKpAqcCqQKqAqsCrAKtAqsCrQKuAq8CsAKxAq8CsQKyArMCtAK1ArMCtQK2ArcCuAK5ArcCuQK6ArsCvAK9ArsCvQK+Ar8CwALBAr8CwQLCAsMCxALFAsMCxQLGAscCyALJAscCyQLKAssCzALNAssCzQLOAs8C0ALRAs8C0QLSAtMC1ALVAtMC1QLWAtcC2ALZAtcC2QLaAtsC3ALdAtsC3QLeAt8C4ALhAt8C4QLiAuMC5ALlAuMC5QLmAucC6ALpAucC6QLqAusC7ALtAusC7QLuAu8C8ALxAu8C8QLyAvMC9AL1AvMC9QL2AvcC+AL5AvcC+QL6AvsC/AL9AvsC/QL+Av8CAAMBA/8CAQMCAwMDBAMFAwMDBQMGAwcDCAMJAwcDCQMKAwsDDAMNAwsDDQMOAw8DEAMRAw8DEQMSAxMDFAMVAxMDFQMWAxcDGAMZAxcDGQMaAxsDHAMdAxsDHQMeAx8DIAMhAx8DIQMiAyMDJAMlAyMDJQMmAycDKAMpAycDKQMqAysDLAMtAysDLQMuAy8DMAMxAy8DMQMyAzMDNAM1AzMDNQM2AzcDOAM5AzcDOQM6AzsDPAM9AzsDPQM+Az8DQANBAz8DQQNCA0MDRANFA0MDRQNGA0cDSANJA0cDSQNKA0sDTANNA0sDTQNOA08DUANRA08DUQNSA1MDVANVA1MDVQNWA1cDWANZA1cDWQNaA1sDXANdA1sDXQNeA18DYANhA18DYQNiA2MDZANlA2MDZQNmA2cDaANpA2cDaQNqA2sDbANtA2sDbQNuA28DcANxA28DcQNyA3MDdAN1A3MDdQN2A3cDeAN5A3cDeQN6A3sDfAN9A3sDfQN+A38DgAOBA38DgQOCA4MDhAOFA4MDhQOGA4cDiAOJA4cDiQOKA4sDjAONA4sDjQOOA48DkAORA48DkQOSA5MDlAOVA5MDlQOWA5cDmAOZA5cDmQOaA5sDnAOdA5sDnQOeA58DoAOhA58DoQOiA6MDpAOlA6MDpQOmA6cDqAOpA6cDqQOqA6sDrAOtA6sDrQOuA68DsAOxA68DsQOyA7MDtAO1A7MDtQO2A7cDuAO5A7cDuQO6A7sDvAO9A7sDvQO+A78DwAPBA78DwQPCA8MDxAPFA8MDxQPGA8cDyAPJA8cDyQPKA8sDzAPNA8sDzQPOA88D0APRA88D0QPSA9MD1APVA9MD1QPWA9cD2APZA9cD2QPaA9sD3APdA9sD3QPeA98D4APhA98D4QPiA+MD5APlA+MD5QPmA+cD6APpA+cD6QPqA+sD7APtA+sD7QPuA+8D8APxA+8D8QPyA/MD9AP1A/MD9QP2A/cD+AP5A/cD+QP6A/sD/AP9A/sD/QP+A/8DAAQBBP8DAQQCBAMEBAQFBAMEBQQGBAcECAQJBAcECQQKBAsEDAQNBAsEDQQOBA8EEAQRBA8EEQQSBBMEFAQVBBMEFQQWBBcEGAQZBBcEGQQaBBsEHAQdBBsEHQQeBB8EIAQhBB8EIQQiBCMEJAQlBCMEJQQmBCcEKAQpBCcEKQQqBCsELAQtBCsELQQuBC8EMAQxBC8EMQQyBDMENAQ1BDMENQQ2BDcEOAQ5BDcEOQQ6BDsEPAQ9BDsEPQQ+BD8EQARBBD8EQQRCBEMERARFBEMERQRGBEcESARJBEcESQRKBEsETARNBEsETQROBE8EUARRBE8EUQRSBFMEVARVBFMEVQRWBFcEWARZBFcEWQRaBFsEXARdBFsEXQReBF8EYARhBF8EYQRiBGMEZARlBGMEZQRmBGcEaARpBGcEaQRqBGsEbARtBGsEbQRuBG8EcARxBG8EcQRyBHMEdAR1BHMEdQR2BHcEeAR5BHcEeQR6BHsEfAR9BHsEfQR+BH8EgASBBH8EgQSCBIMEhASFBIMEhQSGBIcEiASJBIcEiQSKBIsEjASNBIsEjQSOBI8EkASRBI8EkQSSBJMElASVBJMElQSWBJcEmASZBJcEmQSaBJsEnASdBJsEnQSeBJ0EnwSeBKAEoQSbBKIEoASbBJ4EogSbBKIEowSgBJ4EpASiBKQEpQSiBJ4EpgSkBKcEqASpBKcEqQSqBKsErAStBKsErQSuBK8EsASxBK8EsQSyBLMEtAS1BLMEtQS2BLcEuAS5BLcEuQS6BLsEvAS9BLsEvQS+BL8EwATBBL8EwQTCBMMExATFBMMExQTGBMcEyATJBMcEyQTKBMsEzATNBMsEzQTOBM8E0ATRBM8E0QTSBNME1ATVBNME1QTWBNcE2ATZBNcE2QTaBNsE3ATdBNsE3QTeBN8E4AThBN8E4QTiBOME5ATlBOME5QTmBOcE6ATpBOcE6QTqBOsE7ATtBOsE7QTuBO8E8ATxBO8E8QTyBPME9AT1BPME9QT2BPcE+AT5BPcE+QT6BPsE/AT9BPsE/QT+BP8EAAUBBf8EAQUCBQMFBAUFBQMFBQUGBQcFCAUJBQcFCQUKBQsFDAUNBQsFDQUOBQ8FEAURBQ8FEQUSBRMFFAUVBRMFFQUWBRcFGAUZBRcFGQUaBRsFHAUdBRsFHQUeBR8FIAUhBR8FIQUiBSMFJAUlBSMFJQUmBScFKAUpBScFKQUqBSsFLAUtBSsFLQUuBS8FMAUxBS8FMQUyBTMFNAU1BTMFNQU2BTcFOAU5BTcFOQU6BTsFPAU9BTsFPQU+BT8FQAVBBT8FQQVCBUMFRAVFBUMFRQVGBUcFSAVJBUcFSQVKBUsFRwVMBUsFTAVNBU4FTwVQBU4FUAVRBVIFUwVUBVIFVAVVBVYFVwVYBVYFWAVZBVoFWwVcBVoFXAVdBV4FXwVgBV4FYAVhBWIFYwVkBWIFZAVlBWYFZwVoBWYFaAVpBWoFawVsBWoFbAVtBW4FbwVwBW4FcAVxBXIFcwV0BXIFdAV1BXYFdwV4BXYFeAV5BXoFewV8BXoFfAV9BX4FfwWABX4FgAWBBYIFgwWEBYIFhAWFBYYFhwWIBYYFiAWJBYoFiwWMBYoFjAWNBY4FjwWQBY4FkAWRBZIFkwWUBZIFlAWVBZYFlwWYBZYFmAWZBZoFmwWcBZoFnAWdBZ4FnwWgBZ4FoAWhBaIFowWkBaIFpAWlBaYFpwWoBaYFqAWpBaoFqwWsBaoFrAWtBa4FrwWwBa4FsAWxBbIFswW0BbIFtAW1BbYFtwW4BbYFuAW5BboFuwW8BboFvAW9Bb4FvwXABb4FwAXBBcIFwwXEBcIFxAXFBcYFxwXIBcYFyAXJBcoFywXMBcoFzAXNBc4FzwXQBc4F0AXRBdIF0wXUBdIF1AXVBdYF1wXYBdYF2AXZBdoF2wXcBdoF3AXdBd4F3wXgBd4F4AXhBeIF4wXkBeIF5AXlBeYF5wXoBeYF6AXpBeoF6wXsBeoF7AXtBe4F7wXwBe4F8AXxBfIF8wX0BfIF9AX1BfYF9wX4BfYF+AX5BfoF+wX8BfoF/AX9Bf4F/wUABv4FAAYBBgIGAwYEBgIGBAYFBgYGBwYIBgYGCAYJBgoGCwYMBgoGDAYNBg4GDwYQBg4GEAYRBhIGEwYUBhIGFAYVBhYGFwYYBhYGGAYZBhoGGwYcBhoGHAYdBh4GHwYgBh4GIAYhBiIGIwYkBiIGJAYlBiYGJwYoBiYGKAYpBioGKwYsBioGLAYtBi4GLwYwBi4GMAYxBjIGMwY0BjIGNAY1BjYGNwY4BjYGOAY5BjoGOwY8BjoGPAY9Bj4GPwZABj4GQAZBBkIGQwZEBkIGRAZFBkYGRwZIBkYGSAZJBkoGSwZMBkoGTAZNBk4GTwZQBk4GUAZRBlIGUwZUBlIGVAZVBlYGVwZYBlYGWAZZBloGWwZcBloGXAZdBl4GXwZgBl4GYAZhBmIGYwZkBmIGZAZlBmYGZwZoBmYGaAZpBmoGawZsBmoGbAZtBm4GbwZwBm4GcAZxBnIGcwZ0BnIGdAZ1BnYGdwZ4BnYGeAZ5BnoGewZ8BnoGfAZ9Bn4GfwaABn4GgAaBBoIGgwaEBoIGhAaFBoYGhwaIBoYGiAaJBooGiwaMBooGjAaNBo4GjwaQBo4GkAaRBpIGkwaUBpIGlAaVBpYGlwaYBpYGmAaZBpoGmwacBpoGnAadBp4GnwagBp4GoAahBqIGowakBqIGpAalBqYGpwaoBqYGqAapBqoGqwasBqoGrAatBq4GrwawBq4GsAaxBrIGswa0BrIGtAa1BrYGtwa4BrYGuAa5BroGuwa8BroGvAa9Br4GvwbABr4GwAbBBsIGwwbEBsIGxAbFBsYGxwbIBsYGyAbJBsgGygbJBssGzAbGBs0GywbGBskGzQbGBs0GzgbLBskGzwbNBs8G0AbNBskG0QbPBtIG0wbUBtIG1AbVBtYG1wbYBtYG2AbZBtoG2wbcBtoG3AbdBt4G3wbgBt4G4AbhBuIG4wbkBuIG5AblBuYG5wboBuYG6AbpBuoG6wbsBuoG7AbtBu4G7wbwBu4G8AbxBvIG8wb0BvIG9Ab1BvYG9wb4BvYG+Ab5BvoG+wb8BvoG/Ab9Bv4G/wYAB/4GAAcBBwIHAwcEBwIHBAcFBwYHBwcIBwYHCAcJBwoHCwcMBwoHDAcNBw4HDwcQBw4HEAcRBxIHEwcUBxIHFAcVBxYHFwcYBxYHGAcZBxoHGwccBxoHHAcdBx4HHwcgBx4HIAchByIHIwckByIHJAclByYHJwcoByYHKAcpByoHKwcsByoHLActBy4HLwcwBy4HMAcxBzIHMwc0BzIHNAc1BzYHNwc4BzYHOAc5BzoHOwc8BzoHPAc9Bz4HPwdABz4HQAdBB0IHQwdEB0IHRAdFB0YHRwdIB0YHSAdJB0oHSwdMB0oHTAdNB04HTwdQB04HUAdRB1IHUwdUB1IHVAdVB1YHVwdYB1YHWAdZB1oHWwdcB1oHXAddB14HXwdgB14HYAdhB2IHYwdkB2IHZAdlB2YHZwdoB2YHaAdpB2oHawdsB2oHbAdtB24HbwdwB24HcAdxB3IHcwd0B3IHdAd1B3YHdwd4B3YHeAd5B3oHewd8B3oHfAd9B34HfweAB34HgAeBB4IHgweEB4IHhAeFB4YHhweIB4YHiAeJB4oHiweMB4oHjAeNB44HjweQB44HkAeRB5IHkweUB5IHlAeVB5YHlweYB5YHmAeZB5oHmwecB5oHnAedB54HnwegB54HoAehB6IHowekB6IHpAelB6YHpweoB6YHqAepB6oHqwesB6oHrAetB64HrwewB64HsAexB7IHswe0B7IHtAe1B7YHtwe4B7YHuAe5B7oHuwe8B7oHvAe9B74HvwfAB74HwAfBB8IHwwfEB8IHxAfFB8YHxwfIB8YHyAfJB8oHywfMB8oHzAfNB84HzwfQB84H0AfRB9IH0wfUB9IH1AfVB9YH1wfYB9YH2AfZB9oH2wfcB9oH3AfdB94H3wfgB94H4AfhB+IH4wfkB+IH5AflB+YH5wfoB+YH6AfpB+oH6wfsB+oH7AftB+4H7wfwB+4H8AfxB/IH8wf0B/IH9Af1B/YH9wf4B/YH+Af5B/oH+wf8B/oH/Af9B/4H/wcACP4HAAgBCAIIAwgECAIIBAgFCAYIBwgICAYICAgJCAoICwgMCAoIDAgNCA4IDwgQCA4IEAgRCBIIEwgUCBIIFAgVCBYIFwgYCBYIGAgZCBoIGwgcCBoIHAgdCB4IHwggCB4IIAghCCIIIwgkCCIIJAglCCYIJwgoCCYIKAgpCCoIKwgsCCoILAgtCC4ILwgwCC4IMAgxCDIIMwg0CDIINAg1CDYINwg4CDYIOAg5CDoIOwg8CDoIPAg9CD4IPwhACD4IQAhBCEIIQwhECEIIRAhFCEYIRwhICEYISAhJCEoISwhMCEoITAhNCE4ITwhQCE4IUAhRCFIIUwhUCFIIVAhVCFYIVwhYCFYIWAhZCFoIWwhcCFoIXAhdCF4IXwhgCF4IYAhhCGIIYwhkCGIIZAhlCGYIZwhoCGYIaAhpCGoIawhsCGoIbAhtCG4IbwhwCG4IcAhxCHIIcwh0CHIIdAh1CHYIdwh4CHYIeAh5CHoIewh8CHoIfAh9CH4IfwiACH4IgAiBCIIIgwiECIIIhAiFCIYIhwiICIYIiAiJCIoIiwiMCIoIjAiNCI4IjwiQCI4IkAiRCJIIkwiUCJIIlAiVCJYIlwiYCJYImAiZCJoImwicCJoInAidCJ4InwigCJ4IoAihCKIIowikCKIIpAilCKYIpwioCKYIqAipCKoIqwisCKoIrAitCK4IrwiwCK4IsAixCLIIswi0CLIItAi1CLYItwi4CLYIuAi5CLoIuwi8CLoIvAi9CAAAAQACAAAAAgADAAQABQAGAAQABgAHAAgACQAKAAsADAANAA4ADwAQAA4AEAARABIAEwAUABIAFAAVABYAFwAYABkAGgAbAAAAAQACAAAAAgADAAQABQAGAAcACAAJAAcACQAKAAsADAANAA==\");\n\n//# sourceURL=webpack:///./assets/Taxi.glb?");

/***/ }),

/***/ "./assets/boy.glb":
/*!************************!*\
  !*** ./assets/boy.glb ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:model/gltf-binary;base64,Z2xURgIAAADQRAsA1IsAAEpTT057ImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjcwMjY4OH1dLCJhc3NldCI6eyJ2ZXJzaW9uIjoiMi4wIiwiZ2VuZXJhdG9yIjoiZ2x0ZnBhY2sgMC4xNiJ9LCJleHRlbnNpb25zVXNlZCI6WyJLSFJfbWVzaF9xdWFudGl6YXRpb24iLCJLSFJfdGV4dHVyZV90cmFuc2Zvcm0iXSwiZXh0ZW5zaW9uc1JlcXVpcmVkIjpbIktIUl9tZXNoX3F1YW50aXphdGlvbiJdLCJidWZmZXJWaWV3cyI6W3siYnVmZmVyIjowLCJieXRlT2Zmc2V0IjowLCJieXRlTGVuZ3RoIjo2MDE0Mzh9LHsiYnVmZmVyIjowLCJieXRlT2Zmc2V0Ijo2MDE0NDAsImJ5dGVMZW5ndGgiOjE2NzQ0LCJieXRlU3RyaWRlIjo4LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NjE4MTg0LCJieXRlTGVuZ3RoIjo4MzcyLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NjI2NTU2LCJieXRlTGVuZ3RoIjo4MzcyLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NjM0OTI4LCJieXRlTGVuZ3RoIjo4MzcyLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NjQzMzAwLCJieXRlTGVuZ3RoIjo4MzcyLCJieXRlU3RyaWRlIjo0LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NjUxNjcyLCJieXRlTGVuZ3RoIjoxODg0MCwidGFyZ2V0IjozNDk2M30seyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjY3MDUxMiwiYnl0ZUxlbmd0aCI6MzQ1Nn0seyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjY3Mzk2OCwiYnl0ZUxlbmd0aCI6MzY4fSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6Njc0MzM2LCJieXRlTGVuZ3RoIjoyNzI3Mn0seyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjcwMTYwOCwiYnl0ZUxlbmd0aCI6MTA4MH1dLCJhY2Nlc3NvcnMiOlt7ImJ1ZmZlclZpZXciOjEsImJ5dGVPZmZzZXQiOjAsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50IjoyMDkzLCJ0eXBlIjoiVkVDMyIsIm1pbiI6WzAsMCwwXSwibWF4IjpbMTYzODMsMTYxNDEsNDcxMF19LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMCwiY291bnQiOjIwOTMsInR5cGUiOiJWRUMzIiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjozLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MjA5MywidHlwZSI6IlZFQzIifSx7ImJ1ZmZlclZpZXciOjQsImJ5dGVPZmZzZXQiOjAsImNvbXBvbmVudFR5cGUiOjUxMjEsImNvdW50IjoyMDkzLCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMSwiY291bnQiOjIwOTMsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo2LCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6OTQyMCwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6NywiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjU0LCJ0eXBlIjoiTUFUNCJ9LHsiYnVmZmVyVmlldyI6OCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjYwLCJ0eXBlIjoiU0NBTEFSIiwibWluIjpbMC4wMzMzMzMzMzUxXSwibWF4IjpbMi4wMDAwMDAyNF19LHsiYnVmZmVyVmlldyI6OCwiYnl0ZU9mZnNldCI6MjQwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MSwidHlwZSI6IlNDQUxBUiIsIm1pbiI6WzAuMDMzMzMzMzM1MV0sIm1heCI6WzAuMDMzMzMzMzM1MV19LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjYwLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6NDgwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6NjAsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0Ijo5NjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjE0NDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjE5MjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI0MDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI4ODAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjMzNjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjM4NDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjQzMjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjQ4MDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjUyODAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjU3NjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjYyNDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjY3MjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjcyMDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjc2ODAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjgxNjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjg2NDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjkxMjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjk2MDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjEwMDgwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6NjAsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoxMDU2MCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjYwLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTEwNDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjExNTIwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6NjAsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoxMjAwMCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjYwLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTI0ODAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjEyOTYwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6NjAsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoxMzQ0MCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjYwLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTM5MjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjE0NDAwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MSwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjE0NDA4LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6NjAsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoxNDg4OCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjYwLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTUzNjgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjE1ODQ4LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6NjAsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoxNjMyOCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjYwLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTY4MDgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjE3Mjg4LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6NjAsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoxMCwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjYwLCJ0eXBlIjoiVkVDMyJ9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTc3NjgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo2MCwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjgsImJ5dGVPZmZzZXQiOjI0NCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjgsInR5cGUiOiJTQ0FMQVIiLCJtaW4iOlswLjAzMzMzMzMzNTFdLCJtYXgiOlswLjI2NjY2NjY4MV19LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTgyNDgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTgzMTIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTgzNzYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg0NDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg1MDQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg1NjgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg2MzIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg2OTYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg3NjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg4MjQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg4ODgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTg5NTIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTkwMTYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTkwODAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTkxNDQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTkyMDgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTkyNzIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTkzMzYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk0MDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk0NjQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk1MjgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk1OTIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk2NTYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk3MjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk3ODQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk4NDgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk5MTIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MTk5NzYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjAwNDAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjAxMDQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjAxNjgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjAyMzIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjAyOTYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjAzNjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjA0MjQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjA0ODgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjA1NTIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjA2MTYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50Ijo4LCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6MTAsImJ5dGVPZmZzZXQiOjcyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjgsInR5cGUiOiJWRUMzIn0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMDY4MCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjgsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo4LCJieXRlT2Zmc2V0IjoyNzYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyMiwidHlwZSI6IlNDQUxBUiIsIm1pbiI6WzAuMDMzMzMzMzM1MV0sIm1heCI6WzAuNzMzMzMzNDA5XX0seyJidWZmZXJWaWV3Ijo4LCJieXRlT2Zmc2V0IjozNjQsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxLCJ0eXBlIjoiU0NBTEFSIiwibWluIjpbMC4wMzMzMzMzMzUxXSwibWF4IjpbMC4wMzMzMzMzMzUxXX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMDc0NCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjA5MjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIxMDk2LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMTI3MiwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjE0NDgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIxNjI0LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMTgwMCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjE5NzYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIyMTUyLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MSwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIyMTYwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MSwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIyMTY4LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMjM0NCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjI1MjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIyNjk2LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMjg3MiwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjMwNDgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIzMjI0LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMzQwMCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjM1NzYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjIzNzUyLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyMzkyOCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjQxMDQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI0MjgwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyNDQ1NiwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjQ2MzIsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI0ODA4LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyNDk4NCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjUxNjAsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI1MzM2LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyNTUxMiwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjU2ODgsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI1ODY0LCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyNjA0MCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjYyMTYsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI2MzkyLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyNjU2OCwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9LHsiYnVmZmVyVmlldyI6OSwiYnl0ZU9mZnNldCI6MjY3NDQsImNvbXBvbmVudFR5cGUiOjUxMjIsImNvdW50IjoyMiwidHlwZSI6IlZFQzQiLCJub3JtYWxpemVkIjp0cnVlfSx7ImJ1ZmZlclZpZXciOjksImJ5dGVPZmZzZXQiOjI2OTIwLCJjb21wb25lbnRUeXBlIjo1MTIyLCJjb3VudCI6MjIsInR5cGUiOiJWRUM0Iiwibm9ybWFsaXplZCI6dHJ1ZX0seyJidWZmZXJWaWV3IjoxMCwiYnl0ZU9mZnNldCI6ODE2LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjIsInR5cGUiOiJWRUMzIn0seyJidWZmZXJWaWV3Ijo5LCJieXRlT2Zmc2V0IjoyNzA5NiwiY29tcG9uZW50VHlwZSI6NTEyMiwiY291bnQiOjIyLCJ0eXBlIjoiVkVDNCIsIm5vcm1hbGl6ZWQiOnRydWV9XSwiaW1hZ2VzIjpbeyJidWZmZXJWaWV3IjowLCJtaW1lVHlwZSI6ImltYWdlL3BuZyJ9XSwidGV4dHVyZXMiOlt7InNvdXJjZSI6MH1dLCJtYXRlcmlhbHMiOlt7Im5hbWUiOiJCb2R5IiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiOnsiYmFzZUNvbG9yVGV4dHVyZSI6eyJpbmRleCI6MCwidGV4Q29vcmQiOjAsImV4dGVuc2lvbnMiOnsiS0hSX3RleHR1cmVfdHJhbnNmb3JtIjp7Im9mZnNldCI6WzAuMDI1NDE3NTEwNCwwLjAyMDY4MDk2NF0sInNjYWxlIjpbMC4wMDAyMzQ5NjM3MzYsMC4wMDAyMzU4Nzg3NjFdfX19LCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjY5MDAzNDgwN30sImRvdWJsZVNpZGVkIjp0cnVlfV0sIm1lc2hlcyI6W3sicHJpbWl0aXZlcyI6W3siYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MCwiTk9STUFMIjoxLCJURVhDT09SRF8wIjoyLCJKT0lOVFNfMCI6MywiV0VJR0hUU18wIjo0fSwibW9kZSI6NCwiaW5kaWNlcyI6NSwibWF0ZXJpYWwiOjB9XX1dLCJza2lucyI6W3siam9pbnRzIjpbNTQsNDUsNDQsNDMsMiwxLDIyLDIxLDIwLDE5LDYsNCwzLDUsOSw4LDcsMTIsMTEsMTAsMTUsMTQsMTMsMTgsMTcsMTYsNDIsNDEsNDAsMzksMjYsMjQsMjMsMjUsMjksMjgsMjcsMzIsMzEsMzAsMzUsMzQsMzMsMzgsMzcsMzYsNDksNDgsNDcsNDYsNTMsNTIsNTEsNTBdLCJpbnZlcnNlQmluZE1hdHJpY2VzIjo2fV0sImFuaW1hdGlvbnMiOlt7Im5hbWUiOiJJZGxlIiwic2FtcGxlcnMiOlt7ImlucHV0Ijo3LCJvdXRwdXQiOjl9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTB9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTF9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTJ9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTN9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTR9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTV9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTZ9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTd9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTh9LHsiaW5wdXQiOjcsIm91dHB1dCI6MTl9LHsiaW5wdXQiOjcsIm91dHB1dCI6MjB9LHsiaW5wdXQiOjcsIm91dHB1dCI6MjF9LHsiaW5wdXQiOjcsIm91dHB1dCI6MjJ9LHsiaW5wdXQiOjcsIm91dHB1dCI6MjN9LHsiaW5wdXQiOjcsIm91dHB1dCI6MjR9LHsiaW5wdXQiOjcsIm91dHB1dCI6MjV9LHsiaW5wdXQiOjcsIm91dHB1dCI6MjZ9LHsiaW5wdXQiOjcsIm91dHB1dCI6Mjd9LHsiaW5wdXQiOjcsIm91dHB1dCI6Mjh9LHsiaW5wdXQiOjcsIm91dHB1dCI6Mjl9LHsiaW5wdXQiOjcsIm91dHB1dCI6MzB9LHsiaW5wdXQiOjcsIm91dHB1dCI6MzF9LHsiaW5wdXQiOjcsIm91dHB1dCI6MzJ9LHsiaW5wdXQiOjcsIm91dHB1dCI6MzN9LHsiaW5wdXQiOjcsIm91dHB1dCI6MzR9LHsiaW5wdXQiOjcsIm91dHB1dCI6MzV9LHsiaW5wdXQiOjcsIm91dHB1dCI6MzZ9LHsiaW5wdXQiOjcsIm91dHB1dCI6Mzd9LHsiaW5wdXQiOjcsIm91dHB1dCI6Mzh9LHsiaW5wdXQiOjgsIm91dHB1dCI6Mzl9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDB9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDF9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDJ9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDN9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDR9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDV9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDZ9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDd9LHsiaW5wdXQiOjcsIm91dHB1dCI6NDh9XSwiY2hhbm5lbHMiOlt7InNhbXBsZXIiOjAsInRhcmdldCI6eyJub2RlIjo0NSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MSwidGFyZ2V0Ijp7Im5vZGUiOjQ0LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoyLCJ0YXJnZXQiOnsibm9kZSI6NDMsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjMsInRhcmdldCI6eyJub2RlIjoyLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo0LCJ0YXJnZXQiOnsibm9kZSI6MjIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjUsInRhcmdldCI6eyJub2RlIjoyMSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6NiwidGFyZ2V0Ijp7Im5vZGUiOjIwLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo3LCJ0YXJnZXQiOnsibm9kZSI6MTksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjgsInRhcmdldCI6eyJub2RlIjo2LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo5LCJ0YXJnZXQiOnsibm9kZSI6NCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTAsInRhcmdldCI6eyJub2RlIjo5LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoxMSwidGFyZ2V0Ijp7Im5vZGUiOjgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEyLCJ0YXJnZXQiOnsibm9kZSI6MTIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEzLCJ0YXJnZXQiOnsibm9kZSI6MTEsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE0LCJ0YXJnZXQiOnsibm9kZSI6MTUsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE1LCJ0YXJnZXQiOnsibm9kZSI6MTQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE2LCJ0YXJnZXQiOnsibm9kZSI6MTgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE3LCJ0YXJnZXQiOnsibm9kZSI6MTcsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE4LCJ0YXJnZXQiOnsibm9kZSI6NDIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE5LCJ0YXJnZXQiOnsibm9kZSI6NDEsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjIwLCJ0YXJnZXQiOnsibm9kZSI6NDAsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjIxLCJ0YXJnZXQiOnsibm9kZSI6MzksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjIyLCJ0YXJnZXQiOnsibm9kZSI6MjYsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjIzLCJ0YXJnZXQiOnsibm9kZSI6MjQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjI0LCJ0YXJnZXQiOnsibm9kZSI6MjksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjI1LCJ0YXJnZXQiOnsibm9kZSI6MjgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjI2LCJ0YXJnZXQiOnsibm9kZSI6MzIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjI3LCJ0YXJnZXQiOnsibm9kZSI6MzEsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjI4LCJ0YXJnZXQiOnsibm9kZSI6MzUsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjI5LCJ0YXJnZXQiOnsibm9kZSI6MzQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjMwLCJ0YXJnZXQiOnsibm9kZSI6MzgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjMxLCJ0YXJnZXQiOnsibm9kZSI6MzcsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjMyLCJ0YXJnZXQiOnsibm9kZSI6NDksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjMzLCJ0YXJnZXQiOnsibm9kZSI6NDgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjM0LCJ0YXJnZXQiOnsibm9kZSI6NDcsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjM1LCJ0YXJnZXQiOnsibm9kZSI6NTMsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjM2LCJ0YXJnZXQiOnsibm9kZSI6NTIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjM3LCJ0YXJnZXQiOnsibm9kZSI6NTEsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjM4LCJ0YXJnZXQiOnsibm9kZSI6NTYsInBhdGgiOiJ0cmFuc2xhdGlvbiJ9fSx7InNhbXBsZXIiOjM5LCJ0YXJnZXQiOnsibm9kZSI6NTYsInBhdGgiOiJyb3RhdGlvbiJ9fV19LHsibmFtZSI6Ikp1bXAuMDAyIiwic2FtcGxlcnMiOlt7ImlucHV0Ijo0OSwib3V0cHV0Ijo1MH0seyJpbnB1dCI6NDksIm91dHB1dCI6NTF9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjUyfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo1M30seyJpbnB1dCI6NDksIm91dHB1dCI6NTR9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjU1fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo1Nn0seyJpbnB1dCI6NDksIm91dHB1dCI6NTd9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjU4fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo1OX0seyJpbnB1dCI6NDksIm91dHB1dCI6NjB9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjYxfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo2Mn0seyJpbnB1dCI6NDksIm91dHB1dCI6NjN9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjY0fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo2NX0seyJpbnB1dCI6NDksIm91dHB1dCI6NjZ9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjY3fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo2OH0seyJpbnB1dCI6NDksIm91dHB1dCI6Njl9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjcwfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo3MX0seyJpbnB1dCI6NDksIm91dHB1dCI6NzJ9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjczfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo3NH0seyJpbnB1dCI6NDksIm91dHB1dCI6NzV9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjc2fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo3N30seyJpbnB1dCI6NDksIm91dHB1dCI6Nzh9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjc5fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo4MH0seyJpbnB1dCI6NDksIm91dHB1dCI6ODF9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjgyfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo4M30seyJpbnB1dCI6NDksIm91dHB1dCI6ODR9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjg1fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo4Nn0seyJpbnB1dCI6NDksIm91dHB1dCI6ODd9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjg4fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo4OX1dLCJjaGFubmVscyI6W3sic2FtcGxlciI6MCwidGFyZ2V0Ijp7Im5vZGUiOjQ1LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoxLCJ0YXJnZXQiOnsibm9kZSI6NDQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjIsInRhcmdldCI6eyJub2RlIjo0MywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MywidGFyZ2V0Ijp7Im5vZGUiOjIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjQsInRhcmdldCI6eyJub2RlIjoyMiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6NSwidGFyZ2V0Ijp7Im5vZGUiOjIxLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo2LCJ0YXJnZXQiOnsibm9kZSI6MjAsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjcsInRhcmdldCI6eyJub2RlIjoxOSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6OCwidGFyZ2V0Ijp7Im5vZGUiOjYsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjksInRhcmdldCI6eyJub2RlIjo0LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoxMCwidGFyZ2V0Ijp7Im5vZGUiOjksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjExLCJ0YXJnZXQiOnsibm9kZSI6OCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTIsInRhcmdldCI6eyJub2RlIjoxMiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTMsInRhcmdldCI6eyJub2RlIjoxMSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTQsInRhcmdldCI6eyJub2RlIjoxNSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTUsInRhcmdldCI6eyJub2RlIjoxNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTYsInRhcmdldCI6eyJub2RlIjoxOCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTcsInRhcmdldCI6eyJub2RlIjoxNywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTgsInRhcmdldCI6eyJub2RlIjo0MiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTksInRhcmdldCI6eyJub2RlIjo0MSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjAsInRhcmdldCI6eyJub2RlIjo0MCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjEsInRhcmdldCI6eyJub2RlIjozOSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjIsInRhcmdldCI6eyJub2RlIjoyNiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjMsInRhcmdldCI6eyJub2RlIjoyNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjQsInRhcmdldCI6eyJub2RlIjoyOSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjUsInRhcmdldCI6eyJub2RlIjoyOCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjYsInRhcmdldCI6eyJub2RlIjozMiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjcsInRhcmdldCI6eyJub2RlIjozMSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjgsInRhcmdldCI6eyJub2RlIjozNSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjksInRhcmdldCI6eyJub2RlIjozNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzAsInRhcmdldCI6eyJub2RlIjozOCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzEsInRhcmdldCI6eyJub2RlIjozNywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzIsInRhcmdldCI6eyJub2RlIjo0OSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzMsInRhcmdldCI6eyJub2RlIjo0OCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzQsInRhcmdldCI6eyJub2RlIjo0NywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzUsInRhcmdldCI6eyJub2RlIjo1MywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzYsInRhcmdldCI6eyJub2RlIjo1MiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzcsInRhcmdldCI6eyJub2RlIjo1MSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzgsInRhcmdldCI6eyJub2RlIjo1NiwicGF0aCI6InRyYW5zbGF0aW9uIn19LHsic2FtcGxlciI6MzksInRhcmdldCI6eyJub2RlIjo1NiwicGF0aCI6InJvdGF0aW9uIn19XX0seyJuYW1lIjoiUnVubmluZyIsInNhbXBsZXJzIjpbeyJpbnB1dCI6OTAsIm91dHB1dCI6OTJ9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjkzfSx7ImlucHV0Ijo5MCwib3V0cHV0Ijo5NH0seyJpbnB1dCI6OTAsIm91dHB1dCI6OTV9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjk2fSx7ImlucHV0Ijo5MCwib3V0cHV0Ijo5N30seyJpbnB1dCI6OTAsIm91dHB1dCI6OTh9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjk5fSx7ImlucHV0Ijo5MSwib3V0cHV0IjoxMDB9LHsiaW5wdXQiOjkxLCJvdXRwdXQiOjEwMX0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTAyfSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMDN9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjEwNH0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTA1fSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMDZ9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjEwN30seyJpbnB1dCI6OTAsIm91dHB1dCI6MTA4fSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMDl9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjExMH0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTExfSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMTJ9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjExM30seyJpbnB1dCI6OTAsIm91dHB1dCI6MTE0fSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMTV9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjExNn0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTE3fSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMTh9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjExOX0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTIwfSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMjF9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjEyMn0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTIzfSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMjR9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjEyNX0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTI2fSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMjd9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjEyOH0seyJpbnB1dCI6OTAsIm91dHB1dCI6MTI5fSx7ImlucHV0Ijo5MCwib3V0cHV0IjoxMzB9LHsiaW5wdXQiOjkwLCJvdXRwdXQiOjEzMX1dLCJjaGFubmVscyI6W3sic2FtcGxlciI6MCwidGFyZ2V0Ijp7Im5vZGUiOjQ1LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoxLCJ0YXJnZXQiOnsibm9kZSI6NDQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjIsInRhcmdldCI6eyJub2RlIjo0MywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MywidGFyZ2V0Ijp7Im5vZGUiOjIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjQsInRhcmdldCI6eyJub2RlIjoyMiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6NSwidGFyZ2V0Ijp7Im5vZGUiOjIxLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo2LCJ0YXJnZXQiOnsibm9kZSI6MjAsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjcsInRhcmdldCI6eyJub2RlIjoxOSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6OCwidGFyZ2V0Ijp7Im5vZGUiOjYsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjksInRhcmdldCI6eyJub2RlIjo0LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoxMCwidGFyZ2V0Ijp7Im5vZGUiOjksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjExLCJ0YXJnZXQiOnsibm9kZSI6OCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTIsInRhcmdldCI6eyJub2RlIjoxMiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTMsInRhcmdldCI6eyJub2RlIjoxMSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTQsInRhcmdldCI6eyJub2RlIjoxNSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTUsInRhcmdldCI6eyJub2RlIjoxNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTYsInRhcmdldCI6eyJub2RlIjoxOCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTcsInRhcmdldCI6eyJub2RlIjoxNywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTgsInRhcmdldCI6eyJub2RlIjo0MiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTksInRhcmdldCI6eyJub2RlIjo0MSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjAsInRhcmdldCI6eyJub2RlIjo0MCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjEsInRhcmdldCI6eyJub2RlIjozOSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjIsInRhcmdldCI6eyJub2RlIjoyNiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjMsInRhcmdldCI6eyJub2RlIjoyNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjQsInRhcmdldCI6eyJub2RlIjoyOSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjUsInRhcmdldCI6eyJub2RlIjoyOCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjYsInRhcmdldCI6eyJub2RlIjozMiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjcsInRhcmdldCI6eyJub2RlIjozMSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjgsInRhcmdldCI6eyJub2RlIjozNSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MjksInRhcmdldCI6eyJub2RlIjozNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzAsInRhcmdldCI6eyJub2RlIjozOCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzEsInRhcmdldCI6eyJub2RlIjozNywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzIsInRhcmdldCI6eyJub2RlIjo0OSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzMsInRhcmdldCI6eyJub2RlIjo0OCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzQsInRhcmdldCI6eyJub2RlIjo0NywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzUsInRhcmdldCI6eyJub2RlIjo1MywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzYsInRhcmdldCI6eyJub2RlIjo1MiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzcsInRhcmdldCI6eyJub2RlIjo1MSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MzgsInRhcmdldCI6eyJub2RlIjo1NiwicGF0aCI6InRyYW5zbGF0aW9uIn19LHsic2FtcGxlciI6MzksInRhcmdldCI6eyJub2RlIjo1NiwicGF0aCI6InJvdGF0aW9uIn19XX1dLCJub2RlcyI6W3sibWVzaCI6MCwic2tpbiI6MCwidHJhbnNsYXRpb24iOlstMC43NjA3NDgyNjcsMy44MjE2NzcyZS0wOSwtMC4yMDAzMjA4ODVdLCJzY2FsZSI6WzkuMjg3MDQ0NjdlLTA1LDkuMjg3MDQ0NjdlLTA1LDkuMjg3MDQ0NjdlLTA1XX0seyJuYW1lIjoibWl4YW1vcmlnOk5lY2suMDAxIiwidHJhbnNsYXRpb24iOls4LjYxMDYwODk3ZS0xNCwwLjA2MzU1ODY3NTMsLTEuMzgwNjIxODRlLTA5XSwicm90YXRpb24iOlstMC4wNTAxNDY2OTUyLDguMDk0NDE2MTZlLTA4LC0zLjMxMDI4NzUxZS0wOCwwLjk5ODc0MTg2NV0sInNjYWxlIjpbMSwwLjk5OTk5OTgyMSwxXX0seyJuYW1lIjoibWl4YW1vcmlnOk5lY2siLCJ0cmFuc2xhdGlvbiI6WzUuMjAxMzk0ODdlLTE0LDAuMTQ2NTY1NjAxLDQuNjU2NDkzODZlLTA5XSwicm90YXRpb24iOlswLjEyNDE5MTM3NCwzLjA5ODc0MTg5ZS0wOCw3Ljc4NzQ3OTExZS0wOSwwLjk5MjI1ODMxXSwic2NhbGUiOlsxLDEsMC45OTk5OTk4ODFdLCJjaGlsZHJlbiI6WzFdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRUaHVtYjEuMDAxIiwidHJhbnNsYXRpb24iOls1LjU2MzY2NTc5ZS0wOCwwLjAyMTc5OTAzOTEsLTcuNzk0ODY0MzFlLTA5XSwicm90YXRpb24iOlswLjA2MDkxMDA5ODMsMC4wNDAyMDEyMTY5LDAuMDQ5NTU0NzUwMywwLjk5NjEwMTQ5OV0sInNjYWxlIjpbMS4wMDAwMDAxMiwxLjAwMDAwMDI0LDEuMDAwMDAwMTJdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRUaHVtYjEuMDAyIiwidHJhbnNsYXRpb24iOls2Ljc4MTU5MzI0ZS0wOCwwLjAxOTg2MjM4NzMsLTIuNDQ5MjQ3MzhlLTA4XSwicm90YXRpb24iOlswLjA1NzkxMDE1MTgsMC4xNjc5MzE1NTcsMC4wNDg4NTk3NzEzLDAuOTgyODgyNjE5XSwic2NhbGUiOlsxLjAwMDAwMDEyLDAuOTk5OTk5OTQsMV0sImNoaWxkcmVuIjpbM119LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZFRodW1iMS4wMDMiLCJ0cmFuc2xhdGlvbiI6WzQuNjU5NDA5NTdlLTA4LDAuMDE5ODYyNDIyNyw5LjQ2ODYzOTIxZS0wOV0sInJvdGF0aW9uIjpbMC40OTAwNzMyMzQsMC4xNzcxMTQwNTUsMC42NDkyNDY1MTQsMC41NTQwMTk3NDldLCJzY2FsZSI6WzAuOTk5OTk5OTQsMS4wMDAwMDAxMiwxLjAwMDAwMDQ4XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kVGh1bWIxIiwidHJhbnNsYXRpb24iOlswLjA0NDc5OTY2MzEsMC4wMzA3Mjg5ODgzLC0wLjAwMzg5OTU0MDUyXSwicm90YXRpb24iOlstMC40MTI2ODQ1NiwtMC40MTAzMDc1NTYsLTAuMzIzNjMxNDk1LDAuNzQ2MDU3NTFdLCJjaGlsZHJlbiI6WzQsNV19LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZEluZGV4MS4wMDEiLCJ0cmFuc2xhdGlvbiI6Wy0xLjExNzU4NzA5ZS0wOCwwLjAyMTQ1NzgxMzcsLTcuNzc2NTQ5ODllLTA4XSwicm90YXRpb24iOlstMS42Nzg5MDEwM2UtMDUsLTguNjMxMzM1NzNlLTA2LDAuMDAwMTk1OTcyMjg3LDFdLCJzY2FsZSI6WzEsMC45OTk5OTk4ODEsMV19LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZEluZGV4MS4wMDIiLCJ0cmFuc2xhdGlvbiI6Wy03LjQ1MDY3NDc0ZS0wOSwwLjAzMTE4NDYwNjMsLTEuMDQwNzUyODRlLTA3XSwicm90YXRpb24iOlstNS44Nzk5NDIxOGUtMDUsMS4wMzE2MTg0N2UtMDYsMC4wMDE1NDI5Mzg3NiwwLjk5OTk5ODgwOF0sInNjYWxlIjpbMSwxLDAuOTk5OTk5ODgxXSwiY2hpbGRyZW4iOls3XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kSW5kZXgxIiwidHJhbnNsYXRpb24iOlswLjAzMzMxMDcyNjMsMC4wOTA0NTkwNDg3LDAuMDAwMjQ2NDQzOTg5XSwicm90YXRpb24iOlstMC4wNDYwNjE5MjE5LDAuMDEyOTA0NzQxOCwtMC4wMjIyMDI5NTU2LDAuOTk4NjA4NDddLCJzY2FsZSI6WzEsMS4wMDAwMDAxMiwxXSwiY2hpbGRyZW4iOls4XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kTWlkZGxlMS4wMDEiLCJ0cmFuc2xhdGlvbiI6WzEuMTE3NTg0MjVlLTA4LDAuMDI0OTU1NzE2LC03LjkyNzg4MmUtMDhdLCJyb3RhdGlvbiI6WzcuNDAwNzI5MzdlLTA1LC0yLjAzNDMzNjZlLTA2LC0wLjAwMTk2MjQ4NzU5LDAuOTk5OTk4MDkzXSwic2NhbGUiOlsxLDEuMDAwMDAwMTIsMC45OTk5OTk4ODFdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRNaWRkbGUxLjAwMiIsInRyYW5zbGF0aW9uIjpbMS4yMzYwODgzOWUtMDgsMC4wMzU0NDg0ODc4LC00LjUzMzM1MDQxZS0wOF0sInJvdGF0aW9uIjpbLTguNTk0MjExOThlLTA1LC0yLjMwNDY1MDI1ZS0wNiwwLjAwMjEyNTkxNzcsMC45OTk5OTc3MzVdLCJzY2FsZSI6WzEuMDAwMDAwMTIsMS4wMDAwMDAxMiwwLjk5OTk5OTk0XSwiY2hpbGRyZW4iOlsxMF19LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZE1pZGRsZTEiLCJ0cmFuc2xhdGlvbiI6WzAuMDEyMDc4OTMzNCwwLjA5NDk3ODgzMTcsLTAuMDAwNDgwMzEwMzIyXSwicm90YXRpb24iOlstMC4wNDYxNzAzMzksMC4wMTMwNTkyMTE5LC0wLjAxODkyMjk5NTgsMC45OTg2Njg5NjldLCJzY2FsZSI6WzEuMDAwMDAwMTIsMC45OTk5OTk4ODEsMV0sImNoaWxkcmVuIjpbMTFdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRSaW5nMS4wMDEiLCJ0cmFuc2xhdGlvbiI6Wy0xLjE5MzI1NzA1ZS0wOSwwLjAyMjExNTMwODgsLTUuMTAxOTAxNDhlLTA4XSwicm90YXRpb24iOls2Ljg0ODkwODM4ZS0wNSw2LjQxNDkwODk3ZS0wNiwtMC4wMDE1NzY5NDYyMywwLjk5OTk5ODc0OF0sInNjYWxlIjpbMS4wMDAwMDAxMiwwLjk5OTk5OTk0LDEuMDAwMDAwMTJdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRSaW5nMS4wMDIiLCJ0cmFuc2xhdGlvbiI6Wy0zLjgwODQxODAzZS0wOSwwLjAzMjM2OTEyOTQsLTEuMjM4NWUtMDddLCJyb3RhdGlvbiI6Wy0wLjAwMDExMDQ4OTQ0NywtMy4zOTgyODAzNGUtMDYsMC4wMDI2NTQ1ODgwOCwwLjk5OTk5NjQ4M10sInNjYWxlIjpbMSwwLjk5OTk5OTg4MSwxXSwiY2hpbGRyZW4iOlsxM119LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZFJpbmcxIiwidHJhbnNsYXRpb24iOlstMC4wMDgxMDIxOTUzNCwwLjA5NjM3NTE1MjUsLTAuMDAwOTI0NjI3NzA0XSwicm90YXRpb24iOlstMC4wNDY2ODE1NjA2LDAuMDEzOTcxODMwNywwLjAwMDU2NjgzOTgyMywwLjk5ODgxMTk2XSwic2NhbGUiOlsxLDEuMDAwMDAwMTIsMV0sImNoaWxkcmVuIjpbMTRdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRQaW5reTEuMDAxIiwidHJhbnNsYXRpb24iOls2LjA0ODI0NTQ2ZS0wOSwwLjAxNTgzNDEzOTcsNi42NzE4Njc2OGUtMDhdLCJyb3RhdGlvbiI6WzAuMDAwMTA2Mzk5OTczLC03LjI4MTI1OTk3ZS0wNiwtMC4wMDI4ODQ4MDg0NiwwLjk5OTk5NTgyOF0sInNjYWxlIjpbMC45OTk5OTk5NCwwLjk5OTk5OTgyMSwxLjAwMDAwMDI0XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kUGlua3kxLjAwMiIsInRyYW5zbGF0aW9uIjpbNS41ODc5MzU0NWUtMDksMC4wMjY2MDY2MzYxLC0xLjY4ODAyMjE3ZS0wOF0sInJvdGF0aW9uIjpbMC4wMDAyMzY5Mzc4MDUsMS4yNjMxNjAwMmUtMDYsLTAuMDA1NzM5ODY2NzYsMC45OTk5ODM0OV0sInNjYWxlIjpbMS4wMDAwMDAxMiwxLjAwMDAwMDEyLDEuMDAwMDAwMTJdLCJjaGlsZHJlbiI6WzE2XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kUGlua3kxIiwidHJhbnNsYXRpb24iOlstMC4wMjczOTE1MTAxLDAuMDkzODkyMzM1OSwtMC4wMDExMDQ2Mjc5N10sInJvdGF0aW9uIjpbLTAuMDQ2OTMyOTkxNiwwLjAxNDQxMzYyMzEsMC4wMTAwMjk5MjUsMC45OTg3NDM3MTNdLCJzY2FsZSI6WzEsMC45OTk5OTk5NCwwLjk5OTk5OTk0XSwiY2hpbGRyZW4iOlsxN119LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZCIsInRyYW5zbGF0aW9uIjpbMS4wNjgxMzMwNWUtMDgsMC4yMTQzNTc3MTksLTIuMjE3MTMzNzhlLTA3XSwicm90YXRpb24iOlswLjA0NzY5NjkyMiwtMC4wMjEzNTM4MzM0LC0wLjAwNjYyOTIxMzY5LDAuOTk4NjExNjg5XSwic2NhbGUiOlswLjk5OTk5OTk0LDAuOTk5OTk5OTQsMV0sImNoaWxkcmVuIjpbNiw5LDEyLDE1LDE4XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRGb3JlQXJtIiwidHJhbnNsYXRpb24iOlsxLjQ5MTQ2MzQ5ZS0wOCwwLjIwNzUxNTY1Nyw1LjcxOTI0MzE4ZS0wN10sInJvdGF0aW9uIjpbMC4wNjQ3NzQ0Mzg3LDAuMDQyMDM5MzU3MSwwLjAwNjQxNjY3MzMxLDAuOTk2OTkzMzYzXSwic2NhbGUiOlswLjk5OTk5OTk0LDEsMS4wMDAwMDAxMl0sImNoaWxkcmVuIjpbMTldfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEFybSIsInRyYW5zbGF0aW9uIjpbNC4zMjg5ODk2MWUtMDksMC4xMTc4ODkxMDYsMS4xNzkwNjQ5NWUtMDddLCJyb3RhdGlvbiI6WzAuMDMxODY3Nzk4NCwwLjA1NTM3NzM2NzksLTAuMDAzODM0MjA1NDUsMC45OTc5NDk0ODFdLCJzY2FsZSI6WzEsMS4wMDAwMDAxMiwwLjk5OTk5OTk0XSwiY2hpbGRyZW4iOlsyMF19LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0U2hvdWxkZXIiLCJ0cmFuc2xhdGlvbiI6WzAuMDQwODU3MjUxNywwLjEwNzkxNDY1NiwtMC4wMTE4Mjg1NTY3XSwicm90YXRpb24iOlstMC41MzEzNjg4NTIsLTAuNDQzNzczMTgsLTAuNTQxOTI0NDc3LDAuNDc2NDc2OTY3XSwic2NhbGUiOlswLjk5OTk5OTgyMSwwLjk5OTk5OTg4MSwwLjk5OTk5OTk0XSwiY2hpbGRyZW4iOlsyMV19LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZFRodW1iMS4wMDYiLCJ0cmFuc2xhdGlvbiI6WzcuOTQ3NTM0OWUtMDgsMC4wMjE3OTkwMjk4LC0yLjk1MTQxNTI5ZS0wOF0sInJvdGF0aW9uIjpbLTAuMDYyOTg4OTI5NSwwLjAzNzE0NDI5OTYsLTAuMDQ2ODg2MjA1NywwLjk5NjIyMDA1Ml0sInNjYWxlIjpbMS4wMDAwMDAxMiwxLDEuMDAwMDAwMjRdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRUaHVtYjEuMDA1IiwidHJhbnNsYXRpb24iOlstNS44Mzg1NjczMmUtMDgsMC4wMTk4NjIzNzQzLDEuMDc4MTUwMTllLTA4XSwicm90YXRpb24iOlstMC4wNzM3ODcwMTg3LDAuMTQ0OTg2OTU3LC0wLjAxNzIxMzM0NjQsMC45ODY1MjgyNzddLCJzY2FsZSI6WzEsMS4wMDAwMDAxMiwxLjAwMDAwMDEyXSwiY2hpbGRyZW4iOlsyM119LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZFRodW1iMS4wMDciLCJ0cmFuc2xhdGlvbiI6Wy02LjA1Mzg0NTQyZS0wOCwwLjAxOTg2MjM4MTcsMy4xOTI2MjY5NmUtMDhdLCJyb3RhdGlvbiI6Wy0wLjQ2MzI3MjI3NCwwLjQ3ODA2ODMyMiwtMC42Njg2MzMyODIsMC4zMzEyOTkwMzddLCJzY2FsZSI6WzAuOTk5OTk5NzYyLDAuOTk5OTk5NTgzLDAuOTk5OTk5NjQyXX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kVGh1bWIxLjAwNCIsInRyYW5zbGF0aW9uIjpbMC4wNDQ5Mjk4Mjg1LDAuMDMwNzI4ODQxMiwtMC4wMDE4ODEwMzY3OV0sInJvdGF0aW9uIjpbMC40Nzg0NTE1MiwwLjY1MzI5MzMxMiwtMC4yMTQ3NzYxMjksMC41NDYwNDMzMzZdLCJzY2FsZSI6WzAuOTk5OTk5ODgxLDAuOTk5OTk5NzYyLDAuOTk5OTk5OTRdLCJjaGlsZHJlbiI6WzI0LDI1XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kSW5kZXgxLjAwNSIsInRyYW5zbGF0aW9uIjpbNS41ODc2MTAzN2UtMDgsMC4wMjE0NTc2NzIxLC0yLjc5NjI2Njg2ZS0wOF0sInJvdGF0aW9uIjpbMC4wMDAxOTI5NjM3MDcsMC4wMDM5MDU4OTA3NCwtMi42NTA1NzUxNWUtMDUsMC45OTk5OTIzNzFdLCJzY2FsZSI6WzEuMDAwMDAwMjQsMSwxLjAwMDAwMDI0XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kSW5kZXgxLjAwNCIsInRyYW5zbGF0aW9uIjpbLTYuOTg0OTE5MzFlLTA5LDAuMDMxMTg0NzY4MywxLjg2MjY0NTE1ZS0wOV0sInJvdGF0aW9uIjpbMC4wMDE1MjE4NTEyOSwwLjAyOTc1NzE2NDQsLTAuMDAwMjY1NTM0NDE0LDAuOTk5NTU2MDY1XSwic2NhbGUiOlswLjk5OTk5OTg4MSwwLjk5OTk5OTk0LDAuOTk5OTk5ODgxXSwiY2hpbGRyZW4iOlsyN119LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZEluZGV4MS4wMDMiLCJ0cmFuc2xhdGlvbiI6WzAuMDMzMDAzODA3MSwwLjA5MDQ1ODkwNzIsLTAuMDA0NTE4OTY1NzJdLCJyb3RhdGlvbiI6WzAuMDA5NjQ0NzE2MDUsLTAuNzI3NTM0ODksLTAuMDUwMjEzOTE0NCwwLjY4NDE2MjY3Nl0sImNoaWxkcmVuIjpbMjhdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRNaWRkbGUxLjAwNSIsInRyYW5zbGF0aW9uIjpbMS44MzM1NDEzMmUtMDksMC4wMjQ5NTU1NjUxLDYuOTg0OTE5MzFlLTEwXSwicm90YXRpb24iOlstMC4wMDE5NjM4NDAzMywtMC4wNDUxODEwNDM0LDQuMzk2NjgzMjllLTA1LDAuOTk4OTc2ODg2XSwic2NhbGUiOlswLjk5OTk5OTg4MSwxLjAwMDAwMDEyLDFdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRNaWRkbGUxLjAwNCIsInRyYW5zbGF0aW9uIjpbMy44NzIyMDg1MWUtMDgsMC4wMzU0NDg0NTgsLTIuMTIwMDY4NTdlLTA5XSwicm90YXRpb24iOlswLjAwMjEyNzMwMzI4LDAuMDQ4NzAxMDE4MSwtNS4wODY4MTI2ZS0wNSwwLjk5ODgxMTEyNl0sInNjYWxlIjpbMSwwLjk5OTk5OTk0LDFdLCJjaGlsZHJlbiI6WzMwXX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kTWlkZGxlMS4wMDMiLCJ0cmFuc2xhdGlvbiI6WzAuMDEyMDQwNzY4OCwwLjA5NDk3ODc0OTgsLTAuMDAxMDczOTUyNDJdLCJyb3RhdGlvbiI6WzAuMDE1NDc5OTEyMSwtMC42ODEzNTA0NywtMC4wNDc0MzMzMDkzLDAuNzMwMjU0ODg5XSwic2NhbGUiOlswLjk5OTk5OTk0LDAuOTk5OTk5ODIxLDFdLCJjaGlsZHJlbiI6WzMxXX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kUmluZzEuMDA1IiwidHJhbnNsYXRpb24iOlstMi4yMzY4NDEyOWUtMDgsMC4wMjIxMTUzNTM1LC0zLjM1MDgxNTQ1ZS0wOF0sInJvdGF0aW9uIjpbLTAuMDAwMTYzNDUzMjgyLC0wLjA3Njg0MTMwOTcsLTAuMDAxNTcwMDYyMDEsMC45OTcwNDIxMl0sInNjYWxlIjpbMSwwLjk5OTk5OTg4MSwxXX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kUmluZzEuMDA0IiwidHJhbnNsYXRpb24iOls2LjcyODgwNTZlLTA4LDAuMDMyMzY5MjY3Miw0LjY1NjYxMjg3ZS0xMF0sInJvdGF0aW9uIjpbMC4wMDA0MTIwMjYzMDQsMC4xMjg0MDU2NiwwLjAwMjYyNDgxNjQ5LDAuOTkxNzE4MjMzXSwic2NhbGUiOlsxLjAwMDAwMDEyLDEsMV0sImNoaWxkcmVuIjpbMzNdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRSaW5nMS4wMDMiLCJ0cmFuc2xhdGlvbiI6Wy0wLjAwNzkxNjQ5NTIsMC4wOTYzNzQ5NjYyLDAuMDAxOTU1NzU1MjldLCJyb3RhdGlvbiI6WzAuMDQ1OTcyOTMyMSwtMC4wNzE5MjkxMTIxLC0wLjAwODEwOTUxODMzLDAuOTk2MzE2NjcxXSwic2NhbGUiOlsxLDEuMDAwMDAwMjQsMC45OTk5OTk5NF0sImNoaWxkcmVuIjpbMzRdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRQaW5reTEuMDA1IiwidHJhbnNsYXRpb24iOlstMS44MjY1MzQxMmUtMDgsMC4wMTU4MzQwOTUsLTguNTQyNjk2ODZlLTA4XSwicm90YXRpb24iOlstMC4wMDAxODQzOTU3NzMsLTAuMTQwMzk4NzU2LC0wLjAwMjg3OTkzMTEzLDAuOTkwMDkwODQ3XSwic2NhbGUiOlsxLjAwMDAwMDEyLDAuOTk5OTk5NzAyLDFdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEhhbmRQaW5reTEuMDA0IiwidHJhbnNsYXRpb24iOlstMS42OTczMjc0M2UtMDgsMC4wMjY2MDY3MDg4LDMuNDI1NjQ3MzJlLTA4XSwicm90YXRpb24iOlswLjAwMTk3NjczNTE5LC0wLjI2OTYyNjc2NiwtMC4wMDUzOTQwMzEyOSwwLjk2Mjk0Nzc4Nl0sInNjYWxlIjpbMSwwLjk5OTk5OTk0LDFdLCJjaGlsZHJlbiI6WzM2XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRIYW5kUGlua3kxLjAwMyIsInRyYW5zbGF0aW9uIjpbLTAuMDI3MDIzMzI2NiwwLjA5Mzg5MjQxMDQsMC4wMDQ2MDkyOTA1MV0sInJvdGF0aW9uIjpbMC4wNDI2MDU4MjEsMC4zNzIyOTQ0MjYsMC4wMjIwODY5NDgyLDAuOTI2ODczMTQ3XSwic2NhbGUiOlswLjk5OTk5OTk0LDAuOTk5OTk5ODgxLDAuOTk5OTk5ODgxXSwiY2hpbGRyZW4iOlszN119LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0SGFuZC4wMDEiLCJ0cmFuc2xhdGlvbiI6Wy0yLjYxNDI3NjQ0ZS0wOCwwLjIxNDM1Nzc3OCwtMy4xOTIwNTY5N2UtMDddLCJyb3RhdGlvbiI6Wy0wLjA0NjIyMjEwNTYsLTAuMjUwMzIwMzE1LC0wLjAxMzQ5ODc0MzEsMC45NjY5NjQ5XSwic2NhbGUiOlsxLDEuMDAwMDAwMTIsMS4wMDAwMDAxMl0sImNoaWxkcmVuIjpbMjYsMjksMzIsMzUsMzhdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEZvcmVBcm0uMDAxIiwidHJhbnNsYXRpb24iOlszLjk1ODUzMDIxZS0wOCwwLjIwNzUxNTU1MywtNS41MTczOTkwMmUtMDddLCJyb3RhdGlvbiI6Wy0wLjA2NDQ3MjY5NzcsMC4xNDEyMzAzNiwtMC4wMDg5NDI5OTUyMiwwLjk4NzgzNDY5Ml0sInNjYWxlIjpbMC45OTk5OTk4ODEsMC45OTk5OTk4MjEsMC45OTk5OTk4ODFdLCJjaGlsZHJlbiI6WzM5XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRBcm0uMDAxIiwidHJhbnNsYXRpb24iOlstMy42OTg3MTc3OGUtMDgsMC4xMTc4ODkxNDQsMi40ODgwNTM1ZS0wN10sInJvdGF0aW9uIjpbLTAuMDMyMDg4MDY3NCwwLjA5MjYxODY5NjQsLTAuMDAwNzY4MDMzNjEzLDAuOTk1MTg0MTgzXSwic2NhbGUiOlsxLDAuOTk5OTk5OTQsMS4wMDAwMDAxMl0sImNoaWxkcmVuIjpbNDBdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdFNob3VsZGVyLjAwMSIsInRyYW5zbGF0aW9uIjpbLTAuMDQwODU4MjM4OSwwLjEwNzkxNDY1NiwtMC4wMTE4Mjg1NTk1XSwicm90YXRpb24iOlswLjYwMjU3MjczOSwtMC41MjY5NTA0NzksMC40NjE0NTQzOTEsMC4zODI0Nzc2NzFdLCJzY2FsZSI6WzAuOTk5OTk5OTQsMC45OTk5OTk3NjIsMV0sImNoaWxkcmVuIjpbNDFdfSx7Im5hbWUiOiJtaXhhbW9yaWc6U3BpbmUyIiwidHJhbnNsYXRpb24iOls4LjM5MzI4NjA3ZS0xNCwwLjE0MDYxNzQxNSwxLjg2MjUyNjQ3ZS0wOV0sInJvdGF0aW9uIjpbLTAuMDU4ODYwODM4NCwtMS40NDQ3MDIyN2UtMTAsMS4zODAwMjc5MWUtMDgsMC45OTgyNjYyMl0sImNoaWxkcmVuIjpbMiwyMiw0Ml19LHsibmFtZSI6Im1peGFtb3JpZzpTcGluZTEiLCJ0cmFuc2xhdGlvbiI6WzUuNDY4Mjc0MjhlLTE0LDAuMTQ2MzQyMTczLDEuMjExMTI0NzFlLTA4XSwicm90YXRpb24iOlstMC4wNzExNTk4NTQ1LC0xLjE4MjM0MjY5ZS0wNyw5LjEwNjA0MzkyZS0wOSwwLjk5NzQ2NDk1NV0sInNjYWxlIjpbMSwxLjAwMDAwMDEyLDFdLCJjaGlsZHJlbiI6WzQzXX0seyJuYW1lIjoibWl4YW1vcmlnOlNwaW5lIiwidHJhbnNsYXRpb24iOlstNy4xMDM4MTg4NGUtMTUsMC4xMjYwNTkyOTQsLTMuMTM2NjAyMDllLTEyXSwicm90YXRpb24iOlstMC4wMzAxMDA1MDc3LC0yLjM4MzEwODE4ZS0wNywtNy4xNzY1Mjg3ZS0wOSwwLjk5OTU0Njg4NV0sInNjYWxlIjpbMSwwLjk5OTk5OTgyMSwwLjk5OTk5OTg4MV0sImNoaWxkcmVuIjpbNDRdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEZvb3QuMDAyIiwidHJhbnNsYXRpb24iOlstMS43NDM0NzAwNGUtMDksMC4wNjg2NTY4OTE2LDEuMDQyNjM3NTNlLTA5XSwicm90YXRpb24iOlstMC4yMjYyNDQzOSw5LjA4MTExNzAxZS0wNywtMS40ODI1MDg0OGUtMDcsMC45NzQwNzA2MDldLCJzY2FsZSI6WzAuOTk5OTk5ODgxLDEuMDAwMDA3NzUsMC45OTk5OTIzMTFdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdEZvb3QiLCJ0cmFuc2xhdGlvbiI6Wy0xLjczNTU1NzE5ZS0wNywwLjE4OTEzODQyNywtMS43MDI3NzY1OWUtMDhdLCJyb3RhdGlvbiI6Wy0wLjU0NjkxOTUyNSwtMC4wMDU4MTQ4MDAwNCwwLjAwMjgyMjA1NzM0LDAuODM3MTYwMjg5XSwic2NhbGUiOlswLjk5OTk5OTgyMSwxLDFdLCJjaGlsZHJlbiI6WzQ2XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRMZWciLCJ0cmFuc2xhdGlvbiI6WzEuMDQzMDQyMTNlLTA3LDAuMjA5MjI0NDMzLDEuNDk1MDU0OTJlLTA4XSwicm90YXRpb24iOlswLjA2MTIwMjkyNDcsLTAuMDI1NTcyNDkxOCwwLjAwMzU4OTg0MDg0LDAuOTk3NzkxMzVdLCJzY2FsZSI6WzEsMC45OTk5OTk4ODEsMC45OTk5OTk4ODFdLCJjaGlsZHJlbiI6WzQ3XX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRVcExlZyIsInRyYW5zbGF0aW9uIjpbMC4wOTE0MjI5Mzc4LDAuMDAxOTE0NTAwMTQsMC4wMDU5Mjc1ODEzNF0sInJvdGF0aW9uIjpbMC45OTg1NzIxMTEsMC4wMDg0MTAwMTE0MiwwLjAyOTM4Mzg5MjIsMC4wNDM4MTM0MzM1XSwic2NhbGUiOlsxLDAuOTk5OTk5OTQsMS4wMDAwMDI1XSwiY2hpbGRyZW4iOls0OF19LHsibmFtZSI6Im1peGFtb3JpZzpMZWZ0Rm9vdC4wMDMiLCJ0cmFuc2xhdGlvbiI6Wy02LjY2Njk4OTYzZS0wOSwwLjA2ODY2MDE0NzUsLTIuMTY2NjA4ZS0wOV0sInJvdGF0aW9uIjpbLTAuMjI2MjMyOTc2LC0zLjAzNjY3Nzc1ZS0wNywtMS41MTQzMTA1M2UtMDcsMC45NzQwNzMyMzFdLCJzY2FsZSI6WzAuOTk5OTk5OTQsMS4wMDAwMDc4NywwLjk5OTk5MjQzXX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRGb290LjAwMSIsInRyYW5zbGF0aW9uIjpbLTEuMzQ5NjI3NzllLTA4LDAuMTg5MTM4NDU3LC0xLjE1NTQ1NDRlLTA5XSwicm90YXRpb24iOlstMC41NDY5MDEyMjYsMC4wMDAyNTA1NzY2MTcsLTAuMDA2NDU4NjgyNDcsMC44MzcxNzIzMjldLCJzY2FsZSI6WzAuOTk5OTk5OTQsMC45OTk5OTk4ODEsMV0sImNoaWxkcmVuIjpbNTBdfSx7Im5hbWUiOiJtaXhhbW9yaWc6TGVmdExlZy4wMDEiLCJ0cmFuc2xhdGlvbiI6Wy0xLjA0MDU0NjQ5ZS0wOCwwLjIwOTIyNDUyMiwtNS40NTI1MTUzM2UtMDldLCJyb3RhdGlvbiI6WzAuMDYxMzA5OTMzNywtMC4wMjcxMjMxNTMyLDAuMDAwNDYwNjc4MSwwLjk5Nzc1MDEwM10sInNjYWxlIjpbMS4wMDAwMDAxMiwxLjAwMDAwMDI0LDEuMDAwMDAwMTJdLCJjaGlsZHJlbiI6WzUxXX0seyJuYW1lIjoibWl4YW1vcmlnOkxlZnRVcExlZy4wMDEiLCJ0cmFuc2xhdGlvbiI6Wy0wLjA5MTQyMzkyMTMsMC4wMDE5MTQ0NDA1NCwwLjAwNTkyNzQ5ODkyXSwicm90YXRpb24iOlswLjk5ODU1Mzc1MywtMC4wMDU3OTIwODA4OSwwLjAyOTk5ODEyOTIsMC4wNDQyMzcwNDM3XSwic2NhbGUiOlswLjk5OTk5ODUxLDAuOTk5OTk5ODgxLDAuOTk5OTQzNDM1XSwiY2hpbGRyZW4iOls1Ml19LHsibmFtZSI6Im1peGFtb3JpZzpIaXBzIiwidHJhbnNsYXRpb24iOls1LjAwODAyNjg1ZS0wNywwLjQ1NTI4OTA5NiwwLjAxMDYzOTIyMDVdLCJyb3RhdGlvbiI6WzAuMDY4MzYzNjE0NCwyLjM3ODYxMDNlLTA3LDEuNjI5OTE2ODJlLTA4LDAuOTk3NjYwNDU4XSwic2NhbGUiOlsxLDAuOTk5OTk5OTQsMC45OTk5OTk5NF0sImNoaWxkcmVuIjpbNDUsNDksNTNdfSx7Im5hbWUiOiJCb2R5IiwiY2hpbGRyZW4iOlswXX0seyJuYW1lIjoiQXJtYXR1cmUuMDAxIiwiY2hpbGRyZW4iOls1NSw1NF19XSwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzU2XX1dLCJzY2VuZSI6MH0gICDguAoAQklOAIlQTkcNChoKAAAADUlIRFIAAAQAAAAEAAgGAAAAfx0rgwAAAAlwSFlzAAALEgAACxIB0t1+/AAAABt0RVh0U29mdHdhcmUAQ2Vsc3lzIFN0dWRpbyBUb29swafhfAAAIABJREFUeNrsvfmTHVl2Hvbdm/lqe1WvNtSCKgCNbvT09Ozk0DRpUpqhGTYZJBWUw+ZQPzns/8yWF5GyJJIKiUErJNmkJZMhc8gZTnfPdDdQQKFQAAq1ofbtZeb1D7m8rMRdzs3l1XvAPREzjarKly/z5s17z/edc77DAAg4c+bMmTNnzpw5c+bMmTNnzt5qY44AcObMmTNnzpw5c+bMmTNnzhwB4MyZM2fOnDlz5syZM2fOnDlzBIAzZ86cOXPmzJkzZ86cOXPmzBEAzpw5c+bMmTNnzpw5c+bMmTNHADhz5syZM2fOnDlz5syZM2fOHAHgzJkzZ86cOXPmzJkzZ86cOXMEgDNnzpw5c+bMmTNnzpw5c+bMEQDOnDlz5syZM2fOnDlz5syZM0cAOHPmzJkzZ86cOXPmzJkzZ44AcObMmTNnzpw5c+bMmTNnzpw5AsCZM2fOnDlz5syZM2fOnDlz5ggAZ86cOXPmzJkzZ86cOXPmzJkjAJw5c+bMmTNnzpw5c+bMmTNnjgBw5syZM2fOnDlz5syZM2fOnDkCwJkzZ86cOXPmzJkzZ86cOXPmCABn76BNTU2h1WphYmICrVaL/LnDw0Ps7++7AXQ23Is4Y1haWsL09DQAQAiR/V5mQghEUYSrqyucnZ2h2+3i4uICl5eXbjCdOXPmzJkzZ84cAeDM2c2Cm9HRUbRarWsg3/d9jIyMYGxsTAl0TCaEwNnZGY6OjrC7u+sAkLOhsomJCczPz2NpaUk6txlj2X9lfyva+fk5oihCEAS4urrC+fk5rq6ucHl5ifPzczfgzpw5c+bMmTNnjgBw5qwZkD8yMoLx8XGMj48bQTxjLAM0afSzeH7K7/f29rC9vY3T01P3UJwNrE1PT2NxcRHT09NKgJ/Ob9l7kf+Migwo2sXFBYQQCIIAQRCg2+3i7OwMZ2dnOD8/l75fzpw5c+bMmTNnzhwB4OwdtjRVv91uw/f9LIpvAvlFoG76uaodHR3h8PAQr169cg/N2UBYq9XC/Pw8ZmZmMDk5KQXzMgJA9o5QQb/pncx/1/n5OcIwRBiGuLq6wunpKYIgcNkDzpw5c+bMmTNnjgBw9lZOpEIUXwby6wbqMjCj+o6yoOfly5fY3993IMbZjdjExARu3bqFxcVF5fznnL8R4S+C9Pzcz/+cvi9l3g9dZk3+uy4uLgAAQRDg/Pz8WmlBmlngzJkzZ86cOXPmzBEAzgYc5Nuk6pcFFibSQFXrTAE0NqBnb28P+/v7ODw8dBPBWeM2NzeHhYUFTE1Naeep6m9lPiMD8TYlNTpyQne+8/NzBEGQCROenp46YUJnzpw5c+bMmTNHADjrlxVV9amp+ipgYZvCbwPedYrnpvNQ9AOKdnJygtevX2NnZwdRFLnJ4qw2S9P879y5Q/6MbI5TovqyzAHZMap3S/V+27y3FCLh4uICYRg6YUJnzpw5A7CwsJCttZ7nvbHu5tf9dJ28vLxEGIZu8Jw5k9jo6CgmJibgeR4YY4ii6Bo2yL9jabDi4ODAEQDOhuyBE1L16/wuGZhoMuWXAubTa5C95DbfsbOzg52dHSca6KySTU5OYmFhAfPz80pgLwPYRRKNShDYEgt5QsFEGqiup/gZGQmoOlZHDjhhQmfOnL1Ltrq6CsYYRkZGlPuEbD1O10WXWeXsXTfOOcbGxtButzNNpby/k2KD9OdioLDb7eLVq1dZeaMjAJwNFMhvtVoZ0C+m6lOjdWXAQh2fpZAEutTnpgFR0Y6OjrC3t4e9vT03+ZyR39GlpaU3RP2aeBfLRPLL/F3XcrBIzKkiVnWA9vQ6U2HCNHvg7Ows+28QBG4SOnPmbKhsfHwc8/PzGfi38ZnydnFxkWVUXVxcuGxGZ2+9jY6OYnx8HCMjI2i329eCGjKfhHOOKIrAOc98mPQzAPD69Wvs7+87AsDZYNjIyAgWFxexsLBwbdLm2SwTIKDWB8uid3VF3GxBelPH226qZ2dnODw8xO7urmPYnUltYmIC8/PzWFpa6uv3ViHpihufad2gtBnUkQV137fsfV5fX3eEnTNnzobKZmdnMTs7m61nKXCX+WA6/yXfESYlBC4uLrLuLc6cvS3+1uTkJDzPw9jY2Bt4qJjpmH+v8vpFMgLg8vISm5ubjgBwdvM2NzeH5eVlTExMvAHyZargRfBeaRJpanrzLxC17l+WfmwLbGzqjJuw/f197O3tOdFAZwCA6elpLC4uotPpVCKr6s7esXm/6yYWit9RXJts/m4C/wAyRj/9dxAE+OKLL3B2duYmqDNnzgbeVlZWrpVpyrRe8ntEvsyx6BPmP5v/e6qxcnJygqurK1dK5WxozPM8TE5OZtH+9Hd5oxAARaySkgFF/2ttbW2o3w9HAAy5TUxMYHZ2FktLS2+k2spa5NmCiCaiclXMpmSAKkpY9Vp05zs6OsLh4aETDXwHLRX1m5mZQbvdlnarGAaz7bBRpp7f9v2yeYdVZGj68+bmJnZ2dpxIljNnzgbaHjx4oP170cdQ+Uvpcel6qNN2OT09zdq3ujXS2SBioHa7Dc/zMDo6+oZvYCIAVFgof540o7poz58/H2oxYkcADKl5nof5+XksLy+j1Wq9AS5UzG8TBABFbb/odMsAA9Wh1/UfHxQ2TjYmL1++xP7+vlMvfwc2pFu3bmFxcdEK1FaZ+3W8x6rvKnPNg0J0mNa+/M8PHz50GTvOnDkbSJucnMTy8rJ2rctHKXXrcLEEgNItCYhLBZyQoLMbBa2MYXJyEuPj429kPMuOVZUaFn0blX+TagTIbNh1ABwBMITW6XSwsrKSiYfp6vFVBEBVUG8LVPI/UyKIuhfa1OKsynXaRjvL2N7eHvb39x3YeMtsbm4OCwsLmJqaIoFRW3BfRRyzzDtWNwlh89mqWQRplMskQpgSpWkEbHt7G1tbW7i6unIT2pkzZwNjCwsLmJ6eNq7/shIAVYakjNwtrpWqPeXq6gpXV1cZGdDtdt1DctaIjY+PZx3L0ii/zLeS+VfF7BZV8FCWKaPyXdK/nZ2d4cWLF44AcNa8jYyMYGFhAYuLi9fSWnQtwoqgX3ZsnQ495Vw2AL+JqL4KXDQlQiYjFBhjOD4+xuvXr7G7u+tS64bU0jT/O3fuNHL+MqKcdYH2JqP4efXdJrN2TCKEKlJmfX0du7u7boI7c+ZsIOz27duYnJzUBncAXAP9qg4r+WyB4jpcVm+l2+0iCAKcn59nhIDTD3BWxqdKu5Z5nnetc5kM1OtEioUQ8DzvjYzoYumLKkiQ6gapsgiurq6wsbHhCABnzVpR5K84GVXgtiiGp6tDbsLhrwvA20QO6ziuKfCj+t69vT1sb2/j9PTUTfYhsMnJSSwsLGB+ft4qo6UfGSY3Ae4HqfxGd8+yNVJGADDGEIYhvvjiC/dOOnPm7Mbt3r17GBkZIa+5RT2A/PG6zADZupkHSjK/s1h+moKrtLvA5eUlrq6uXKDDmRTwp63Kfd/HyMiIMnBZhgDIp/AXRf9s0v5VmQMbGxtDmzHoCIABt1Tk7/bt20bH1pTOZVMCYAINZdXIm6xhtmGuqwKWMhkKlGNT0cBXr165yT9oiyVjWFpawszMTFZ+Yzvvde9h3aDcRjBzUEC9rpOIzjG1OW/xWZjG3YkEOnPm7CZtZGQE9+7de2NNK7YBpICWYv2/DtgXfR3TMXlyQbbPpZkBl5eXuLi4cGUD7yimmZiYQKvVAuccvu9b+yw6AiCv2C9L7c+DfxOWoNju7i4ODg4cAeCsPktF/m7fvn1N5I+yyNuCCFVP7vyLYgMEdEB8EFXQBzF6KYTA1tYWdnd3ndjODVur1cLS0pJWgMk0p/J9ZSnv6SCJ6JUtxemH0CGF9Kui85H/rBMJHE7z+WjueXKg+KyFgBAxkAoit9Y6Gzybnp7G0tKScm2S7TXp71XlTjK9gOLaTw30yDIAZGWmxQhsqiOQZgi4toNvn+80MjKCsbGxrH6/CMBl5JHJH1CVMKcp/2EYZu+AbO7LWv4V/yab27Ljj4+P8fLlS0cAOKvHiiJ/FMe8yIbpJnGTAFgWabP5LtmmRgFKqjo3zljjE9wGrNmk3aXHO9HAm3O6FhcXjcJLZeZH0wD/jRaghYXepMNhAtVV3w3Vu13Hu0Qp7wGQ1fel/6U4ujs7O9ja2nKk3JDYUudbWJj6Ghg8TE0sYHR0BAIRGBjAOCAiiEggjAQOT1/h0at/g7OrvaG+Z4+P4Pb0z4OBY3SkDd9vJZzH9VUgiiKcXRzhKjjBq6NP3GQZYFteXkan03ljjZT5WjoxP936LvtZFxyiEABFf1SXkZDvNHB5eenKBoYU8I+Pj2N0dBStVgu+7yv3+GKkvjg/imXLeStmAKh8mOJ8181JVfa07Jz5e7m8vBxaHQBHAAyQqUT+6gQE+ZcgXwdmIzRWd4SuKuiwVUevA3w1qSFQFOdJLS0P2NnZeYOtd1bfBjY/P29M8x+GVpR1ElJ1rkPFzdTmXaEeW5bwVGU8FH9++vQpdnd3XbRqgG1ydAn3b/2XAASmxhcyMSkBAc5yEdIoAhhDN+ji6HQXz1//NfZPHw7lPY+PzOPBwn8FBo6J8TmMteJ6Wsa9xNsTPQIEyT2fvMLzgx9h7+QLN2kG1O7du4exsbFr640MQOX9AioBUCwlKGYNyHwRWbaATANA54fq9oT8tVxeXiIIAlc2MIA2MTGB8fFx+L6f/Y9CMnHO3wheFueRquSkWNOvIwNMIN8E8PO/z2Om4nmfPHmCIAgcAeCsnOVF/sqm36sWa1uSgAr+m8ocqIMUoHxH1VZjdZEJNudNf//y5Uvs7+/j/PzcvTw1bWS3bt3C4uKi0nkqG622yfqoO5Mkf6xMjLDM+9xkOYAq3Y5y/rxzWoV8k9UXyiwMQzx8+BAnJyfuBRow870xfLz8u2DgaI/Nxa2jOE8cHgGGeI+MRBRnAYj4L2EU4uh0Dy8Ofoi9ky+H6p6nxlbw3vz3wMDQHp/D6MhoUtrAwLkHxpO7FxEYeuAxvuddPN7+dzi5dNozAzeXfR/3798nrX0mX0ZHWptIUdl5ZJmnacS+GG2VlQDIarVN15F2G0gFBl23gf5YGt0fGRmB53nXCCmVNpguuq/K2qW041PNDZMGmiqrwJRFoMIP6c+vXr3C0dGRIwCc2QOPoshf1X7hAzGxDJuSDpTc9HX3OyJq85yLxx8eHmJ3dxevX792L1NJ4m1+fh6dTucN5rnJeVBH68065qppw61KylGF9qhjpfv+PENf5fy2xMrz58+xvb3tUlUHyFZn/3PMTryPybFbGB0biV2ddA6y6/NTRCIBxgAYQxRGODrbwfH5c2zs/xUiMfgRx7n2h1iZ+S4AhomxWYyPjgNgCdhnMfnBWZIBIN4oeQnDCEcn2/jZyz9BN3Sk8iDZ5OQklpeXlWn/MjClWnd15aK6dGzVmpv/nmLLtGI2ghDimj4B1d8tHiPTMOh2u+h2uwjDEEEQXPufIwfoxjm/BvA55/A8D57nodVqKeeEDQGQzhWd0r8shZ/iO6laWuqAfvFvKqBfzJTJX//JyclQ6gA4AuCGrCjyR10Q6wTJVEGyss5/mfPVVQpQd3ZCcQNtmqiwbdV4enqKw8ND7O3tufpkg/m+j1u3buHOnTtvjCtVt8I0B2wyBuqaT/0gLvpBfNmuF7qfqxAutp9xIoGDYYtT38RS51toj81hbDyOUiWuXfw8WVwC0OuFzuKsgDwZHQkcnW3jxeu/xe7J5wN9v9Pj93B37r8AA8P4+BxG/STtn/FrHh7nLCE4AoDxnhaiEBDJPR8cv8Inm38A4dzCgbF8/b+MAEiBjyydOv+3ov+i04CRCQAWywRk/y6uz3ngpFu/85mrKl0DWWp4/pqKvd5T63a7iKIIURQhDENcXV0hCAJcXV29k6WUY2NjGaD3PC9T4meMZSn8eV2cYs2+ak7kAXL6LIvPJP1fWuIsI3ZUhIKufNA0J/PnLc5H2XukE0WX/f3q6grr6+uOAHBmtk6ng9XVVbTbbeNkK+Os1kUgUK7DpLBt+z1UsEV1/OsiACgaBnWWEZQBi+n37+/v4+XLl7i4uHAvW2Hjm5mZwerq6htzrUxLvrrJOJtzyd5NisCmigBs8t3oJ+FhmwVgqj+1tW63i4cPH+Ls7My9cDdgsxPv487sL8dp/2O5numIAbEQApEIwJkHMAYRJen/aX18EiFn4IiiAEenu3i6/x9xdP5sMNe01iw+XPxNAAJjI9MYH52AQC/tn7M4CyC+p3QMoqQcohCpZQzdqys82f4PeHn4YzeZBsRSX9G0hsnWRIpOkcrfkv1XBcJMv5O1Hsyv13nQqOpWIOvfngfweaAq00KQBXKCIEAURVkZQSo6GATB0GoN5KP46X/TSH6xo5gOLBc1wnQEQB7wF5+dLEMl/3N63iJRpQvIqEgh2bG6iL7KN1JhDJ1v8fDh8OnGOAKgj5aK/C0tLV1b7FSpMLpaWCoAtqlTrgsUUL5H9V1VxfNkdT7UNmBUMcSy42Ri3VUMNpUYKNrW1haOj49xfHz8zqbBMcbQbrcxNTWV/U8FnHW94qnPVZeFYgsqZZuUjImWOWaDUE5DFdSrgzywjfw3rX3w9OlT7O3tObHOPlos+vdrGB2ZwuTEVAb8Y9E7DoAn4DitgWeIohCMpU5QmjIvEAkGIUJ0uwE29v4Sr45+MpD3fGvyYyxPfxsj/hRGW2NgzEPa6ZCBJ+9fsj4wluuAGN904m73yAFEOLs4xeNXfz50Gghvq331q181gn9T6n5RyKzo9xQ7oRTBn0nJv7hnUvzUMiSFqgSAQgDoSAXZv1NSIAxDhGH4xloehmFPR6NQ/pX/W/qzjjBJrxvAG8r5jLE3RMHTSH0KvvNR/HxGcZmsNwoBoCNvdAG74n2ZBPlUfjzFt8m3AdQJnlPPKyM58te+sbExdNm3jgDok83Pz2NpaQkTExNkQGcTgazD4ac613WLn1FAQ11g5KZAkM01mFrv6DIAit93cnKCbreLZ8+eDaVKaRXzfR937tzJNsUU/MvGUEXE6ca6qXfgJuZxU++d7X3oNAmqEpw6IoBSXmBrURTh0aNHQykONHTveiL65/stzLSXE6CPXsQbCSpGhEiE4MyHEEhE8uKEd5aUCESJcF4YBAijEM9f/xAvDn44mH7F5Fdxb+7vYSRR+wdY4qz3gBJnrHf/LNU7ENfcP86SlNy4GADHp4f44sWf4vRq202uG7SJiYmsVE0VRS2uWya9lPzv8zX5xXTutJd6HuTJvke1FlPazOZBpAr069bqYiZBkQDQ7SX5qLOODFABZJvsieL5giDIauqp5RS2GX5lCYBi2YaMAChqPujmZvH8uqi+bt/Pp+mrfi7OweKczd+jjNAwnVeXrb27u4u9veFqIesIgD4s4KnCv44tpaaAU5Uz+zaBSkT36hYGq+vabcC4Teo19RlVvScVwDk6OsL+/j52d3ffqXdvbm4O09PTaLVa6HQ6ZM0L6karyzJRnU+XqWOzDlDePdtoeb9IjCbWnabWKmrUS/e7ra0tbG9v4+rqym2IDdmd2V/CbPsB5qdvIxX8A+KotxBRBnAjEcURf5GvWY2PgwDCKIQQIUTEEEYhwjDAy8O/HVgCYLHzTby/8P3ElYvAWVznz8DAPR6XAMTx/dxcDsAYzzoBgAkwxnu6CAkdcnTyCp9s/nMnCnjDe9jCwoKyb7kOjBd1AYpR9DzAk+1DKlHAIrCVCQ8W10NdrbhKu6DoIxezZlUZAKrsvaLOQP7nPJDV6RVQ9wXZNel8tuI4y8al+DtVhoaOTNGl4pt8lmIWSb5ePl8SoCME8uBbBdpV2R6mgAGFfFARLaax0XUXSH8+Pj7GixcvHAHgrCfyt7y8jJGRkUrAsE6r0s7MBGD6cR91tO6rAjbK3meZmm3bZ6ljVY+OjvDq1at3RqSs0+lgfn4+A/+yMSo6C8UNivLM+/n+NkmYNQ3ybUkzm3KcqmtBGUKvzDN58uTJ0EUIhsEWpr6B5c63MD21CJ/7AMupjIsoKQHw4ueai34LiB5RgNipDcIuojBCKAQiEQKI8Orw7/Di4G8G8t6Xp7+D+7f+XgLckwgoOJAQAJ7nZ/oGKTEgRAjOeDxOCQEAsIQsyYHFSODg9BU+eeZEAW/Kbt++fS1zjeqLmUhMncK/bF1VRUpliv42+2aRHDCJBtrel4zMKAoPyoQRbTMAKDXmqjE09aTPEyCykjJdqTC15Z1srIo+Uv5Z64gh03fkyQwb8kQ2pnkiwlQCXBwn1e9t7yU95vLycuiEAB0B0BD4uHPnzhvp/lRgWMbpzE/YIgtXN8igiPKpFtEqegb5cxY3CNv0ZWpU1kZMjJoeVge4swH/eRLgxYsXb33f8omJCSwtLb0B/m3euWKEoClQbPvuvy2mq8UspvjpHIN+tGqkvreqe8o7K0IIfP75504ksCabnXgfq7O/iPbYPMZGR4EE/Pa8GwEgQm+apO8cj5Pdk79HkUAUhugGAcIoSI6MgfGro5/g5YBmACxPfwfvzf9KlrqfyB1mKv8e9+B5yfuUKCKkpQJx4kNcFiDSNojpnE7GsBtc4cn2/4stJwp4I3bv3j2lH1mMjqui/cVjZMrsFMCoEnjTrYsyAT8VuJdFvVVg0+R76tTqZX/XtUbU+VUUTSZKe0PKPVFT51XPUbcPy8ZZ5vvoWvfJCAmqD1QkB4rER2rFrBVZRoEslV9FvhQJA+qzU/1+bW1tqEptHQFQo8lE/iipQrLeqBTg2m+HndKLm0oO9DNjQHeddY2njlCoeq+6nr66VC2ZHR0d4fHjx2+tHkCr1cKdO3eU4F+12dmIQN5UOnwd313XXOw3UaByam0IPer5i+9SXc87f57NzU3s7Ow4kcAKNupP4StLv4XRkUm0x6Yz9ft8ujtjDJEQYCkwQloDzxJNAAERhQjDCN0gQCTSvuE8gcwcW0c/xouDvx5YAuDe/K/03DgRlzeIJLPB8+Me3h6PCQ/GYmjPwMDyabg5MqTnGsYnPL88x+NX/x77p2tu0vXRfN/HgwcPlH6XSuzOJG6Xb8dWBFxFTQBTmYHNfmnKVihm3enIWNu12VbkVRXhVl2H7Pd5IK0iGqoQAKaSEFOphs5fp/ocOjFl03fIMg1UBI5K96FIVMg0Horfm5/XsqwGXQA1r4cgu9aNjQ2cnp46AuBds1Tkb3x8vHQkuErrsaqp/U12C6gj3beO76pDjbxf0UebuWDa8Iv2+vVrrK+vv6FcO+zmeR7u3bsHzjlmZ2e1YF/WB9bUa9aG4Co7jyjPj1IPqksLrPM9VL1TdbdRpEYemmzXWfXdlSkor62tvTNlObWCI28cHy//LlpeC9NTS1lqPwOSEgABEQkwzuL/Mt4jALJ0eCCKQgRhgCgUCMIAoQhigMz8zDXaOvzRwGoALHW+jfdv/f1MuDCKUmI3Tu9nHoPvt9BKFMJ7bQ5j1f94HobZeIhMOyHWD4jPC5yeH+Lz5//aiQL20aamprC6uqr0WVSgU7UWFQX3TN2QVCCqSDpQWlnrIvSyvViVCabr6qRK8c93PZDV0avWaWqmg+xaTdmvqvOp+tOrotQ6HQDdfZiAf5FkMrVIzusBUER1TdpElOxhXaeBPIjX6abJdB90Y6367vS4w8NDbG1tOQLgXbGJiQnMzs5iZWXl2uJISfuxbWdFAd5NReiaqrdt2kx9vvtJTsgYyroIGp36bPG7wjDMIpBvk83NzWFmZgbT09NvtM2hjJuuLk1VR1gXWKwbmJpUlJsAwVXXrjLn1WXdFPsW133PtiUcMv0JANje3sbLly+dSKCFrc7+EubaH2C2s4wsWp30t78uApjUuaeOTu73IhIIwi6CoBtnBAiBUAQAREIAxOfcOvwxXhwOJgGwMPUx3r/167mobpg4drHGAWMefN8H5wxe1josyZRgPNEEiJD1BxSp4/wmoDk8eYVPN/+FEwXsky0uLmJubo5EdprWuWKtff4zKlBVBPpUYUAKaFPV7etqslVEgi7ardL4ke0RujRxSp2+6np1GlLUtsGq4J5JW0qXHq+q65f5Orp5olLUN42nzN/SZVvkz0NteakiynR6Bqr9XNd9ILWLi4uh0gFwBEBJS0X+bt++fU3kT0cA2EQPqaJddQFUEyNq6vNZJxlABbtlyBEdGWACH1Xu2xbo1V1GULTLy0tsbGy8NdHH6elpzM/PY2JiAqOjo1oQWmSK0xS9QVC6r0PdnjrvmgLsTRF5VTQy+nVPpmchIwDS36+vr79znTrKgd5vYKnzLUxPLmRE37VUYsavidalkW1xzfHhCMMQQXCFIAwBkYrghQAERCokKAS2Dv8GLw9/NJBjMT/5VdyZ/SX4fDy73p7FQB9MwPN8+J4HniNGWSIKGP+bJ0RA8q6IfLlEb7yOzrbx6eY/daKAfbCVlRVMTU1pVcl1QFhFDFC1j1Tfq4pSq3wtis9I6YxDVbq3WaN1ooO2GbUqJX/ZdcrIg2KGhqrWXaWcT0m9VwnrUe5NRiTYjI/M7y5mF5g+qypnkY27qvRBRSLIMjlMekSyIMPnn3/uCIC32aanp7GysoJ2uy1dhFWM3E2266OCA9O19gMola3npTrkNw32yswDk8qsbNM1bWAnJyfY3NwcelHAdruNxcVFjI6OYnJykkT8mNriyDZ0VU0ZxQGpq35fRdIN9CajaXlKKcsZ1HXT5GTphDpVkZUwDPHFF184kUCFzU58gNXZX8Tk2DxGRltIa/7jGvYQAE8i2z1hu/jf6e+S4yKOIAoRdLtJa8DU0YuSyDlPPh/i5cEP8eroJwNLANye/jn4Xhsea+UmYY8AiCDgMQ7f98A4h+clKgDJPTMIgHnJh+L/MfDcmMa6ApxxXFyeYWPvPzlRwD7Yxx9/TNqbZKBWR/wWW7jJiIH0Z5U+FWXNzp9LBvR0QLtK+2WQ5VOWAAAgAElEQVSV8KAO1OtAtYxEVnUKkrU8pGTiyTJDdUEgGXilgPIy+yiFWKCCfhufSCaiqyKeiq0lVeRC/hmpsh9Uc5C6zz958gSXl5eOAHjbLC/y53me9EWglADYAtZ+OOjFRZ3a+7LstdpG+Zu4xyq123URHE0QCtT6awA4Pj7G+vr60KYf50X/0nZJ1Pr3JoClypmgElGU+n3b+npVL95BaWGoq0c0ZTbUTSCWISBs3jcTAZBaWqLztul0VLFY9O+3MToyhcmJaQgRZrXsKViHYFk0O1W7T6P/aU27EBG6VwEiESEKo+xv+RaBnMXAuRscY/v4swEnAH4eDAwj/lSicYA4pT9mP8DAwRBnRni+B8YZOGfgzOsdB4BxDhFFAIsAcCACBNLxScoFEOH04gRPtv8c+6eP3KRsyNrtNu7evVtqfc8DbpXvpgLYsjRwWfSXoqKvUvvX6QvI1kOTBoJq3S52O5AREjLARxWYzZ9LVz5oyq5V7cumkgBT9F6Vsm96fqp9WFcKoCIITGOn8kOKkXXZ3FUFFGTgPy/GqCvH0D0zqq+0s7MzNO1+HQFAtLm5OaysrGB8fFzr+MkIgH452nUpfA9KOrRpsern9zZRP2yTYkYR2qEs/rLxOzg4wNOnT4euM0Aq+ud5Hqanp6Ublw1JUvWZUz7T9FpQhgyqMk+p46Sr0yy7/tioUJchPaqIDZqIAJM4UbqXPHr0CEdHR+/8/huL/v0DeN4IZiaXkhT1KGt5h5QAyKXup8RACoiFEIjCCGHURRSFCIMo+z3L8gMSRQHGcBUe49XhT7B9/NlAj82tyY+xPP3z4IzB4xO9ewCS8cnyIeDzFjyPw/d8MJ5kAYi0VCB1CCNA8N4Ys5gsEFmHAI7js1188eLPnChgU8TO/DwWFhaMa4+p771sDdT5B7oAVp5UUKmz61KmTW2iZT+n35mP2OoIAJPoYPF3KuBOLdOkrvc2EXTb9nmykhDd91AJHFN2pOq6bTIGVGr/FOLHFGSR3YuqJMD0OZvsy+PjYzx//twRAG+DTUxMoNPp4NatWxgfHyelf5omSxklcRM4qZIerEvFsr2PugEzRWCk6ndTQYEtmKpLP4AKUKh9y2Ub+zCKAuZF/2x61lI236ZJp7IpdXXOl7q/t2xpC6VciqJzUOaaqnRkqUIAyNoIqUiA58+fY39/H91u953dh2PRv/cxO7WEfIu6uF0fyxEACexlLNfXPkqyAgSiKEAQxMr/SYA8D5WTf3IE0RXC6ASfPv/nQ+Ei3Zn9JcxM3APnY/DYyPX5lCM2GDh834fHOTzPj9X/kywBpOAfIgb8EQAmsvERIsyyKgCGw5MtfPb8jxBEl3BWr62srEjb2Kqim1S/qBid1wUWdGQlxc+1BbDUoIjNXqwjBZoOdJn0EVRj17RYr87vKRv4oO7tFOxges6yAIRJu0x37cWuAWWIk/zvLi8v8fjxY0cADLN5nofZ2VlMT09jfHz8WuS/rsWpCceyitPaZIS9rs2ijlaFTQKuuoQNq36n7XVcXFzg2bNnQyMKmBf9GxsbKw2w625XV/Zd6kd2CzWi3WTGS780RIqOpSlNsp8aA7YOXhRFODw8xN7eHg4ODt65vfjW5Me4Pf1ddCbn4XEPAmnUOgJjXi7SH8bV6zxW+AdD/F/Ebf+iSCDodhGGIaJUIC+p+ee5tn9CAN3wBF+++le4DI6HYox8bwwfL/9DAAwt3k7E/Hq6BikpEmdGAD5vwR9pgSfZE4x7WclAVhIA3iuLYBys4DmGYYCj0218svmHzmGs2e7du4d2u03yh1QEYjGSXlznijXVeWBPFftT9Uw3taAzHUstC6OUJJj2VV2XAp0Youl7TJmZtvsvJZ3edD6bLEjdz6Z5YRs5p7QNLH6PKjCoE/+liDRSnrtqbNLjHj58OBTle44AkNjMzAxmZ2fBGMPExIQU/KtABmWhsZlQ1FRYGZNnCygGKfW/KbAzrN9ZB0FgOsfJyQmeP3+O4+PBdnpT0b+xsTFMTk72raVdVaXhKoRVv0Fqk6C8DgKhTDaH7djaPG+KwCFlnsjOAcTigIeHhzg4OMDr16+vqUW/zZaK/k2MzmN0NBW5SxTr49z+RAcgjVBzcO4ltf4ijv4jzgYIk8h/mAjbQeS8oDQDQABX0QleHvwtdk8+H6qxmhq7jffmvw/GGFp8MmvtV9RKgIjAmQ/f9+B5PhjPvyvpv5M1S6T7Bs+VCMQHCghcXl7g6e5fDqxGwjCa7/v48MMPSSnyKiCsIwSKpIAK8ERRpFVTV+1tphpx1TVROgHI1k5d1oMJpNt2xilLHtS9f9qSEbpz6n6vKtswEQsyQG2zv6oyf6n+mi6jpJgVkP+c53lK/QwKOZT+fWNjYyiEfB0BULBUVEwF/k2qz03U3NqC/zILS5551S3cw2xlopAUQRPK3CgD7CitXuoiCtLPHR0dDbQoYF70T5YiqdoYqIKAqghJGQBYtXVd1bWjDGgeBEKsXymbOuem7POhZvpQdRTy50pJgN3d3bemfafOUtG/kdYkJsc71/E6EoE6kUS6hQBjIin3vy4gFYUCYRQgDMIk+h8WnCCWieEF0Rn2Th7i+cFfD+WY3Zr8Gpanv5NE+dvX7pInqfsRQnBwcM+D7/ngHs9AP081FFivu0Lu/657jsl8Pr04wboTBazNJicnjQKAKh+tCOplgMXUg10FKikdAWTXWKY7DjVSrjrepkR0kPSuTACzDLmgGzdqXb9pb1Zdky7YSXlWZX0NFUFiamVoIhlkOE/2mb29Pbx69coRAMNmCwsL6HQ6yrR/06SlRlvrcp6rEgCyBXsYMgFkLHTTNfdl0oibEJMzsb5VQefBwQGePHkycClMqeif7/uYmZlR3n8VYFY3ODddV92K/KreuLL5aaNeXyaFrykyoW6NkbJOR51rF9UBSkmAra0tnJ6evrX7cCz697vwPB/Tk0tvOi1J6j7AE3V/AaSigMiTfkAYdhFGEYIgjoRHaWu7RNQu/gxHiC7C8Aw/e/nHCKOroR27WA/gPXh8HJy1ELf1Y72xQRjTAUm2hO974J53rRMCT0oCWNJGkLH8+8JyxwIQAqcXr50oYE02NzeH5eVlIzBXpU3n0/1Vwmk6lX6ZYKuMWDCRElSAR+lioNtjbIT/dKRI03uWzl9T7ddUAT7Kd5vAsUkFX3Xdunmha8cn2w/zJJMps4TS5aD4M+dc2gFC5RvpnmGxq0D+70dHR9jc3HQEwDDZ7OwsZmdnr9UVU+qoVXUkqtqmIgtFFbVTpUzVQTiUBTlvQ9mAafFrum1fnefVqfBSiaxBFQWcn5/HzMwMOp2OdvEtq/JuIzzXbwBcVeiuX+C2sY2KqLVi+65SlanLvsemGl2T6JDscykJsL6+/ta2Cbwz+0uYm3yAqfFb8Hw/HYHsP0JESRSa9/7EYmALxiCiWPgvCEMEQRdRGCJKGwIkNe3xmAYxBcA4gvAEa7v/DqeXww1ifT6Gj2//LgAPvtcGF4lwXza3g3gkGeCzFhhnaPl+Igoosq4IcVJEnP6fOegiBZdJy8D0mTCOo9MdfLb5z5woYNW5f+cOpqamtNlkKj9Qtsao1iOZPyoDw6rrMLWGMxEY+WOp2QUyskPVHYCSHk/RJaCCeB0ZYkvG64SLy3RToPoqFE0A3bMvtu+jjrvpGnWEiQxfyXy5dK4U54xuD0+Pk7V61F3zxcXFUAgBOgIgsXa7jaWlJamomKqFhI7hqgP4mWpkTC/v2wLIBxmQ9KM9YFVChpK5UJzDl5eX2NzcHBjRMZXoXzH10Rb81zHX+kWC2aSgV7mmm/psP99dVTusMh1abJ8hZZ7K2svmHeQwDPHs2bOh69xBIvomv4qV6Z9He2werZFWErmOa87TKHaUKNLHunWJG8Pi6DQES8oDIoRBhCAIEEZxP/v4HGlCfHIcBEJxjpcHf4Pdky/eijGcmbiPO7O/CIDD55PZuIEBkQiT7Ie4KMDjHlq+D5+3wD2W/C0VU4wygJ9vm3D9fYjPHkUCx2c7+MnmHziHsoK9//77UmFbVZ01BajLMjxN0XVVT/rieqgSE7QhXm324TJdnvq1P1U5tw0w74dvW9dxlPul+CyqdoeyzN/8sbrSBB1JRgkK6giRzz//fPB9IUcAACMjI1hdXcX4+DgmJibIDmQTtbVlUv/rfCFNdbfUmup+AIGm2vfJPiNLoasKkm4SLKVMaRE45+97UEQB6xb9q+tZ3nRbvbo6f+iEo+oG/Tq1aGpUX+co2UblqfWH1Gdt25Ejf25VVEIVHQvDEGtra2+VHkAKXEdHZjExNg7k4H/eVcmE6VJgK6Iseh3/PR6fIAgRRWGPFMiIBJ5B10CcY//ky6Gt+1fZUuc7WJj6GJxxcDaRlTz0tBR4QgFE8BI9AM/3k0QBBs59IIqJlawbQHaG610BRFImcHl5mYgCfuKQfEn72te+Zr0/qCLIunZ/6dqiW5eraFLVebxNaUGV72qqA04TALxOwF+l01FZv1en1l/mu4o+takFYPG6ZJnZsvdEdR/Fe1hfXx94IUBHAABYXFzE7OwsOp2OUeSvOBl16f+2rFaVtG3dS1InMLH5Dqqqq+4looxBFcFCau1Tk2QO5Tn1MyuiWMt0k6KAtqJ/pveraUG8stoUlHnfb8KoKRG/OrQW6nqvVOfqVzkVRQ9AF9m7uLjAw4cPcXk5/GnXI/4kPlr6LbRaE5gan3vDTREIE8ietqeLslp2CAHBQgjBktZ/MQFwFXQRREEc72csLh9IMwmSaHgYneNnL/9oqOv+ZcaZj2+s/AACgMdaYKzVG878uAoBj3lo+S1wHosDMjAwnnRGyNYBkR3P4WW/Y4UU7NOLUzze/rc4OFt3aN7SxsfHcf/+ffIarKrzV627KuV/E5hS7WE2rf2oe4yunZ0u25bSBk8X4KLuwTo/lHKusro6lA4FlFIMFZZR+cFUjSsdqK/SNtCU2aJT6S9eX7E8oCiIqXqGstJakwbC1tYW9vf3HQEwyDY9PY2FhQXMzs5aOWq2L7Js4dI5fJTUf4oIR50g39bBrdLy6yaYUCqYqRus1Xm/ZXQhdLXvjDG8fv36RkQB86J/MvCvA04U56ZsNwjb46sQQbapkSqlWlNGiy1JZtt+z+RIlJ3ndRFvNusg5fw2pINtOUDxPCcnJ0PTd1hn85Mf4c7cL2B6YjmpV8+T63E7uzgy7QEQiEQIzrwYzguBCAEY4jZOQRAgCAMEUTcD/PGxeQ0AgSA8xePdfz/0df8qG2vN4sPF3wDA4HkTceaDiFP8wdAD8eDwuA+Pc3i+B99LWy6KTDsgtqQ1HNKSgOTfyXimbuXG7l9jfec/OERvabOzs9cEACnrpkkpXgWadK3bdHX7eZ9WVRdNab2qA6myzlo2frFuDS4GAGxAvK4UwqbmnUry6sC4zXfrSt0o2WkpCLYRgNT5ZLqxVQn0mT4r821UWQBUDQbdnm8a5+Pj44EXAnynCYCxsTGsrKxgZmYGnueRHUSdGF8d4KGMw1qXAj11AW0K/JuuR5dp8LZoIOhIo7ypUoPrAkappaJj/RY1mZubw8zMDKanp6XvZ92AUjfXKYSCabypzlEd0eeqALauuVOGYKQSIHXdg03Ep+z36e5J5kgDIAsVAcCTJ0+wu7s71GvercmP8NHKfw2PF0T/rs0L/kYdegxAYyAbhRGCMEIYhuiGXSBLe0/S1hmLDwUQRqfYPv7ZW9/DPq8H4PEJqcuXagRwzmM9AM+Px4rzJGsCuWeSPIdr7QGTTIzkmFeHP8MXL/5Ph+gtbXl5GXNzc2SBPVlUP69yngdCMmV93dqoiuwW/ZKy2atNZXvprqlqKUFd5YLU81Cfl+112WqR6cgK3XFlSwNtr61Y7lL8mypIJPPzZERYmfbe5+fnWF9fdwTAoAKs+/fva+v+i+khqtYXNnWnVRx800JQV9p6UyRF04sl5Zy6lLWyNVBlo8hVCJa6nhE10nx5eYnnz5/3LaVJJfpXx/1SW9lQy1CK56ybhKjjHbipjgayqIVtRkOV9YXiQFGyCcoII9lmCeiu01ReJYTAw4cPb1yvo4rdnvkOPrz96/K+84kqfdziL+zV8TOWwFeBKAoRRQLdJPovIAARJWfKHS8EInQRRVf49Pk/fSdcoKXOt7Ew9XVw5oGz0Ry90msRyMAhGOAzDs9vwfeTUgDGIFjumaTCi4zF+gopIZA63ABeHX2OL57/mUP0lvbee++h3W6T1jxKCz9TFFylC2BL0tbpI1Ja+lLWWmr0WAdkdQQ+5WdKR4Ay+7Bt5kL+OIrYoK4tuA0BoBtDWQaCbo6bWv/l53WePJd1iUjneT6AphL2o+y/snu9urrC2tqaIwAG0RYWFjA3N4fJyUmt02VKx6kbwNlEqcqCf5Pg1k0TAHWD8DpT9qn1UE0AM9OmXhcZoLJ+iQLmRf9UzlAT46t7p2xEkVQij3WQf1Wee5m2dTZdJWyiGnWNiY14oI1OiaoGsSypZvq3rn6Xuraen5/j0aNHN6bXUdVW576LB0vf790fY1m5uhD5dTwpdWCxEJ1I6vqjKEIUhOgGV9nvUsG6uDwgBrkRIoTROR6++lNcBkfvhL/DmY+vr/wg+7fHRhPaJKVPwsQhjIG87/to+X6sAyBisJ+1BeSJzoIQAO9F/ZOaAoAx7Bx9js8dAWBtH3zwAcbGxrRp38VUaZmQr0rkV7ZuFgNdRYKAknqu2zNt0uFNtecqskM1VraEsszHMpVrUdreUfda6vnKtCek7CumGn7dWOpq9U0kgcnfoZZ5yogLXaRfll0sExOktNqUPYeHDx+i2+06AmCQrNPpYGFhATMzM1q2yfSS65zesilSVEBtW/9vUyfddI1uFaBCqS8yLbi2NeDUmirqddjWVJcFc1X62qs+f3h4iGfPnuH8/LyRd7PVauHu3btotVqYmprqK3FUd5q7bclA1ectO34QunVQHRBbgUaKgFUdKaZNd3bQ9YCWOSS6Z3Z8fIxHjx5dSwseGvCz9D2szv0CRNprPqlTRwpoGE/U5uP2fzE7wCGiEAIhgkCg271CJEJkje5TYJq0tgOAQJzi2f5f4fB8453ye2I9gN8EEMFnk2As3woxbgsIxNUU3PPQarXgMZ6J/DHGsvEH0GsRmIxrPCNjYcad4y9cCYCl+b6Pjz76iAyEVeu7rFa/CIpUxxa/V9UzXQV6VKQs1YeSAXxK1L5Jf7SOz6vG2ESU2Pytqh9UpiyA6neX3SNtswWLHQB0vrapZDufKZD+W9U5S/Xz5uYmjo4Gl2R+5wiAkZER3LlzBxMTExgdHTW+EFRnUrUg5/8tU5Ksa/GxBXq6TANZXXkdXQrqdpzrWoSrsLRlQNeggDAKKJFdW6oHULfoWF70b3p6utKmqpuHtoRN2bG0AaJ1pt3X8V41kcXUT5LRVkjRdo2tc+xNJWW6aIpsHj9+/BivX78ePgJg8Xu4Pfsd5bPhCfCP9yeWDgJEFCIIuwiC+L+pR5O2+kvb3wFAKM7w6uhTbB9/9k6CzIWpr2Op8w0AHD5Ls6t64n1pzgVDLAboeR4834tzBa7NTQZEAhEiqUO9c/SlIwAsbWpqCnfv3iWDQBWAk0UzqeseVc+KGl23iYib1jpVaUI/iQDq9eqIDyqZ0q/9qIoeAPW4fuoByMbQlNEn07iglkPoCIG9vT28evXKEQADswEuLGB+fl6bWmzjEFeNwlOAmMw5VE1wCrgp23PTNk2+boDVNJCy1WmgMN03CfirfI8sLTBzosMQR0dHtdc3zc/PY2ZmBlNTU/A8z8hyV1Hmt3EWmtRpaIrY6vd3215jHRkQda4rTTgmlEymvDiXCeBTnfRut4u1tTWcnJwMKQHQaz/XSyvviQCmTQHT44IgQBh1EQQRQhEBIkqyBxIiW0QxDcAiRNHlO1P3r7I7s7+EmYn74Gwk1gNIuiuk48UEwDgHZ3HHBb/lx6RLovoft1nkcUkARCwfmHRmEMnYbx9/6TQALG1ubi7rAKCr3y6K/hWBiw0YN5GNVJ/X1i9U+Uy6NZ7S7YDq99pE4VVrbtnWh2X2c1PXHZsSWF3HJyp41j1LajtBXRmBrbC6KaM23wazmB1AyaYpi4lOT0+xsTG4mWbvFAEwNzeH+fl5ZXTRlF6uq/83tVRRgakmnFNq7Q9VdMoWGDcNbusUBaSer4x4oO132Kr69xu05X8+Pz/HixcvahMFzIv+FTNzbJyauubQTXSWqPs762hXV9f3U+vqTXX7qtZW/SAA6ng2Jk2ZYgZWWbJkGPUAPlj6PlZnfz6u3BdhpkwvEhDPGM9FApFoBDCEQRi3/AvCOJ09P6botQ8UuMQXW//qnan7V5nvjeHj5f8GnHF4rJ2NNWOxjyKQlFsIAb/lwfdH0PJ8RCIZW5YjaJKWgulYp89p++hzlwFgaSsrK5lvqtIJka0l+fmeJwFkLfqK2QHpedI1JyUXVO39ZB1LKISAKY1ftv7JfCdbYT9qBidVR0YnSlenL6yLUlPKK6gkBqUkQQfeVULINoKIJo0JE/CXifup0vyLf1ORQtQMQplWQP76Ly8v+949yxEAEmu321haWsLMzIwxBcTWYZalzduIhpm+q4n0VIqQV53dCupymN8ms8moqEs4rcp3Fb/z5OQEm5ublUUBdaJ/MiGWMpk0NuNvW8rRdLp8nc+c0l6yiXmuc1zqAu+2av0y0b0611kbAqaJTJDNzU1sbW0NDwGw+H2szP5ckrKfRJkTFyVWm09r0GPXJRWxEyJCEIQIuwGiRPgvkwhAWgLAsL73f+PwfN0hTQBTY7dxf/7X4bHRbHzS0UpdQw4Gv9VCyx8B5ywTVuTZuwMw1htpkXACDAyvT5/is81/6Qbawu7fv3+tI5WpFZluDSuKBObBiSrduZhBQN0rbPxUFTlsu9/VWY7az2zNpjS3qNdcNoW/zHF1aIwV90aK6C/lvaH6C/mMG865ssxGR6D87Gc/u9ES33eeABgZGcHq6ira7baypVhxklEXPh1LRYnEm1qdUMGATZqO7rgqkX/ZtZdNS65bRE1HctRZD15GTKWpevSyoKy4MesIs6OjI2xsbJQWBRwdHcXKygparRY6nY7Ve0bd7Gzfpbo34iZKCahK/HWUtVC+ryoJIluDTfdRxnFUzYuqWQCUZ6xSmC6bDWGyMAzx+PFjHB4eDg0BcHvmOwCui8tlMD4b4x4BAABhFEIIgaurS0SRyH4vsv8X2Dn+FC+OfuhQZs4Wpr6F253/7BroT8eagYMxgVarBd/3EwFG3ns2okfGcMavPSeA4fDsOT559i/cIFusKV/72teMa5NK+V+V2qyrX9b5VyrCgLrHlgXVTehjUY5rwu8y+Zk2XQD6RQDUTRBUITls9/EibtMJn1MzpMtoOBT/vr6+jrOzM0cA3JQtLi5iZmbmDYBhU79PccJV7GqZ8zcZmVJ9po7a3LpSjinHqVLmbToeqF78uhbcmyYC+kEqlBUF1In+lSGdypbZ2JIGsg2AmqFBbalDAdpVav7LRMubmvfU76asNVUIlTqvW1drmP97lQwAymcuLi7w8OFDXF5eDgcBMPtz8X2lHQDS+8yQf6xM7nEvjvOL+O+pAGAYRj2XJpvrET57+b8hjLpwlnf+GL61+j9kagqpyj8SrQXOWEIAtAAAnHsQSSZG9s4w1lt3c/vXwdkmPnUEANnGx8dx//59khaITjHfVrRaRhhQ0s+pXbIoay6lvJISVDKlqVO/26YcwKZE1zZTgkIQUHxxWRRdNmeotfsUwkLnf5vKKmTXTGkrWOzwJRsb1T3Lggs6XTWVHyJ7d7a2tmorlXUEgKV1Op2MADAthhR1UyppQH1JTQtyFYeUcj6q6Ibs+LLCXFWi5FUAiIkNV82BMot28XnK6tpUz6YMsGoC6FOBbSoK+PjxY6trSEX/Op0OPM+rb1EjpJ7V2aaynwr+uuhBlWgx5Z2vu3SgakZC2TVG9q5TBLKqEq6ma8un45qiCjaWtgasu2tH3fZ+UgKQAsm01jytLU9F6kQUgjEOiPhXURhnB1x1rxBEQdJGUICDxwcIgfX9/8ul/xdscvQ2Hiz8VgLkYxIg1gCIwFkc9W/5PlqtVtZ6UYgoLgPgXjopM2Im/ScDw8HZM3z67I/cIBNtdnYWy8vLJOJYlz6fj4Ka2hXn15zi3pFvd1bUJMmT7Tat7GRgjLIv6wCfye+qQgDYtH/WXZ9t63AKULb9ftM5dASADqjr8JAuA4J6fVVJGKr4oGnsip0B8uOmarOZz5J99uyZIwD6bWNjY5mwigxg2LKmNqCoLDCoUzSkjENqUq1WsWCmBbyOmu0yjLJN7RDl3usG1UVAQln8+qWLYCJDimInL1++xN7eHuncedE/WVlOUwJ2VUsGmnj+dZJjFBEdm4wD2/XHhoSgbsJV1kpKummZ6EzVNdf2eZuiE6bzPH36FDs7OwO9X8ddAH5Ocf9JnXq69iAC4CUygQxBFIsAhmGYiP6JXBtAgZ2Tz/Di8P9zSDMPOice4O7s30dPbyFVT4hzAlpeC77ng3sePM6T5P8kw0L0ugBcfxdi0ibOAHAEANVu3759TZ9KBbLyYn06QGhKUVatK7LjqcLRZf01W+KWsv5T9w5qmaANADeJDlJAaRUfpGp6fpmMtLLlmVX2b93fKeWrOmFiFRlP6cpT/Pns7Azr64NJPr+1BABjDPfv35cKi9XhpJn6kqomiE0/U2pac13RSJu0ZSpJUBfAqPLsTMr6lAwJmw2wXwD9pgQSVd97enpKEgXUif4N+r2Xub6yaf9V3t2mSkgomQcq9ekmQHRdmTKmNaDs9dsSxrYEHyWjDBgOPYCvLP8GFjofJeJ+RTCSgEvBESUAn3MvSxaIohDdboAwDBEhSAAtzwDryeUW1nadKn3e7s39GmbG38u5gjxxByMweM2S2fwAACAASURBVPA9H57PwTmHx30ICIgoya5gfszH5AiD1JVkYDg828Snm3/sBplod+/exeTkZOl1vyjgV1bI2Wb9qypwXfRXqWsZNUOzCkFQds8xtdWjEvY2WahV9bBU90ANnqmu3ZShYLo3E8hWzRWZZgZF18KkLWQixXTP4ac//akjAPppCwsLmJ2dxdTUlPVLQ2Ehqf1SVRNN1rOVmiakq3WpCq4pIlY2i2Kdgn11gyWbjIC6UsZ1ZIGqRKGpGmxdfbXtwptamu6kEgXUif5V0eSgtIexLU+hpur1k7yglCmVcZbquAdVGU2ZTAAZKDdFx6p0L6nSTaDqeFH2kDoIo7Ozs4FuDfjx7d/B/OSD+L6TeHM+ip+NFZL9TyBuXcdiAiDsBuiGAaKshSCHQFz2cBkc4YtXLiJ9jXBZ+AcYH7mV/BRnAEQJYeKxFnzPg+/7YJyBM44oEgCLU/09zmP3MSnNSLMBhAjBmIcjJwJotaZ//PHHxr2LIo6sO5ZaQ20LTFV+AuU4k2gbNVWfSgCoWnpTAXsVMsGkS2UT6FONLbWOX5V1aqOYb9Nu0BbUmyLtphR9yvgV22Da4IEihtONHQA8evRoIHV43koCYHp6Grdu3cLs7GztjiLVSVQ55bLof1XwbJPOayOGR73/firXq1LcKP1CVUCzzuvX9eUtQ7CUjUo2XSqgm1OHh4d48uQJgiC49pm86N/MzIwyddE0TlVaDpUBhbZihHVGeCnn1xE5pns3ZStVjbDL9C/KELIAlOcpKzplcw6qk2JDelDWfVUGAeXZyI45OjrCo0ePsrrFQSMA5tof5AgAlqjP45pAXRpxTsXr0uODboAoitANr5Lf9zIJGBi+2P5jXHRfO8SZjMi3V//HbHyQwP903D02gpbnw/e9ZL5xRCJCnB3AwDgHBMv97AGJfgADx+H5piMAiDYyMoIHDx4YydD8uixLUbYB56psAdP+VJUAMJ1HRUZQQL+NT6rqKEMR9i0THCqrF2A6D1VzQDeXdPuV6VyUFHndfFEdY6s3ZFLvl2lwUTTAiv5LXhtDF9QrXtuLFy9wcHDgCICmbXR0FKurq5iYmMD4+HjfhblkkX2bRbiMw1i32FdZoFQHmG8arFIWt7Jt4/pR1lB3aUXZenAdEFGJAs7NzWF2dhadTkdalkEBUmVJp7pEHk1jdtMZL/0qraF+j01rozJZWWWcL9V8LgOydZlYpusus44U180ynS8ePXo0kM7Ix7d/G7Pt+2+4KCkJkKabixwJwBKRP4G4E0AYBOiKK0Akf0tdHAFsHvwlXp996RAnYgHA92/9RoEoiRIyRcBnLfh+nAEAwQDGIEQUi/zlxpVfm6u9+Xx4vonPNv/EDTTBOp0O7ty5o12rZP6jjBC1IZhNQZQy0e+mgkI2JK9O00DVOYFy/SZRRWrP+zJ15HUH3Mpk5FEwQh1+PBUPlZ071MxFHSEkm1e653N4eIgXL144AqBpW1xcxPz8fFZPVafgl00tlExQIs9G5c9jw3ZR1DfLOphNtM8qvlxV68mqHEdtd1LnhlVW6bwfUesy4IT6DC4uLq6JAqaif+Pj4xgfH792n/lopIogUy3cZcbnprUDZA5KHcKAJoDcZOkCNaJddVMv23mkDgfTlKlT5p2kkpM6oVBbYctut4u1tTWcnJwM1N791du/g7n2++muiGt16UzkwGrazYBnZIAQAlEYxu0ARTdWpAePxQOSyPTh+Qaevf5zhzgBzEw8wL2Z72Xjc33OAJxxeL4Hz+NgzEMsqsiSEoC49V9KvHDGk1Ok81vg8Pw5Ptt0JRcUW11dzdrgykCmbH+krueq0iZTNmUV/0PXNk3X0pVSDkVdw1WZEZRobZWAVplsW5s9mjK2lM9R9+Cyn2uKnKCOiey55LGWKlNXdh26LIc8Oafq9JX6w2tra44AaNLm5uYwPz//Rk9xFdtW5oWvo3923nTgv6rjbKo3l6UKV2HW+mnUlCUKIUDZ9KjnrZrNQd0s+hXpLUuGMcZwcnKCzc1NRFGUif5NTEyQGFZZv3TdmPS7Q0LdY1enUCCFCCijj9AvMkU2Dvk5oMueKtuVpQ5SpI6Wff1YC4FYsHNtbW2g9AA+vv07mJ96kLSiE9d602frChgiESWtAP3czQqEYYQg6OIqvEwSBJKodUIcnHf3sLbzrx3iRCwAOD3+fjI+iOv4kXiDTMDnI/A8Ds/nSZYFS8iCEAKAx73kuSQlAEmWRpqZcXzxEp9s/DM30AR77733MjFc1Z6W/o3aT734X1MZlsq/kBGPNiBXR4aaesFTs7ZMdf2qDArV3kglbykdAOouL6UQJDblasWxMmUgqMZHltEpI7KKLSVVc880BsVzFb+3KP5N9XdMJQ+U/VfWPhMYTCHAt4YAaLfbWF5exvT0tJKNy0/gIvCuU2xJxdDJJoypIwClTWFZpVdVjTzFuTQxbnXoLDTpHNcFzE2AoPh8dUC1KVBfdU5T9BRUz/vo6Ajdblcr+ketK2tiDOoEanXNeZvU7iolEnWmFJbNeKmS0aTTjihDwtXZOaHsGNW9Bul+t7m5ia2trcEhAFZ+B/NTH/bq/FkS8c/PDREL/sW16rFCfSREXMEeRQjDEJfBRXy/iQggg5dpBfzkxf/kECeAD279NiZGbiU1+941LQXGgBFvDJ7vg8c5/2DXJxM492JNACbAGM86N6Tz7PRyF3/39A/cQBPWiq9//etG8CrzA6lrRdHfNO25+VpnUxS0DKFMEXdV7Qm66L2JPFABYpP4ISXrjNotSjcOFFKGurfprlF1jyrArMqcVf2N8ryp/oIp8CUjBGy1fsqKbuZ9fMrzevz48cAJAb4VBMDIyAhWVlbQbrevpRfrFgcKy2R6QctEzGULua3gRVUCQPd5GZuVf7H6LfxX5Z5UDK0ONMlefNuNtriZUloRVgUEddTz2ZIbQohrEXoZaBVC4PT0FJOTk2Rgokt3tgE+qpTHOt/pKuNYnC82LePeVme4zvZVZZ5tHd0+dP2C+/U8KWVFYRjiyZMnA6MH8NXbv4W5yQeJS5K2lku604soiUQnzyjJXO/dEwOiCEEYohtexuL0YJkoXdJHEF9u/wkugnddCJDhm7f/+3RWAtfgvQDjHD5vYaQ1kgP/yXEsfSo8LgfIz/GcCODp1Z4jAIi+ayoASPFBVaWkuqCTKXNRVW5HKR+oaz80rdU6sUPTOYv+nYmcNUXxdeWslNZ3FF+kiUzPqnX/OrKe0s6RCvht2ybqiHxqm16dj148RgX4Tb72y5cvB057560gABYXFzEzM/NGyz9TanaTUVhVmmpxMskEnaht91S10TaAx9ZJLeto29a516kJUJa0sFXgH1TA1kRmgW1LSBvhlbKEXD/e66bNdg5RNt5+3nud74AteK5aekPZH2TOMyVbo059k7red8YYzs/P8ejRI1xcXNz43P949XcwP/lhDkgygHGIKMp+FqLQe16kUWsGEQkEYYgg6CKKIiR5AdfcnReHf4X9d1wIsDN2D/dnfx35LgnXCQDA5yPw/RY4x7VOAen0jNszRjnugF0jFE4v9/CTjT90CN/0LDodrK6uKte8vOX9Q9m+SAGURXJd1Y6a0haNcs11kAG2x5X9mw0AN2UqqIgCVURbl0GgEiukZA7U1UVMNUbUwJZN1puN2KJOFFfnP6ieS9lSW8oxBwcHePnypSMA6l5AUwJA9VCoDhq1xVyZBcpUg16chNRJl95bGSV304tJFdwyLWZ1gvI6nGJd79sqYMmUelU206NfZQy2+gk2m39drfTqAqm211QnOUJlpev4PhuhqDJR96YBa93kZBWnT0UAyO6FKmDZj3IBE9F6cnKCR48eIQzDG93Lv7H6DzHTvo+4HV0MMhkQ1/yLRBQwG/covYEsA4AxjiAMEARXiMIIgqXHpQ0D489+8vIfv9Og887M38fsxINMTwGIwFhSBiAA7gGe14LPPYAzMAGwrOY/TOr/kzkqIjDOwfMdFwCcXu7ixy4DwGjLy8uYn58ngbsi2ZuCr2LNsaz22rb22bR3l1GtN/mSsnWTum/pSgNsPkvxgUyluLpAha3fa1q7KXuE7nnJSAvTuU1CuDYZ1rrP6Uo2VHNTpltRFNEsBlvzJIbpGeZT/nWEnOzn8/NzrK+vOwKgLhsbG8PKygqmp6fheV7ldJA6WEtdqxHV4lZMsZcpVdq8hHVF+6kOdhUwrwOQTUYudSI3ZcCP6vNlQJKtqms/rAz4omwINkBoWKL4tpkjTX9/cX2q0nVCBmqbqFnPE5xVCcq6CQDqtRdJXcreURdxYmsbGxvY3t6+0ffmW3d/gMnRJaRR+6KKP2Mp8EyzAeL68ygKkCamh1HcCjCMwp5DmNMBEBDYOv4hdk4+fScBZ3tkEffnfyOJ4Pfa/zF44EnHBcY5Wq0WPM+P6/0ZS7IpAMZz60dGvLxJrp9e7uLvNv6JQ/gmMubOHXQ6HWXduW1gSqfJRKljVwUpqO3xbIAvNXPBJFAoux9TxL2MD2K6HxsdgDIivHVlssq00ah6TKZ7santpwJnajazLXFf9C1MPr0sS1snMim7j0ETAhxaAoAxhvv372N8fBztdlubAtuE0FeZl61uEFiV1NCNVfG6q+oUUOq/TSC6idqzOuraqnzWxII2AUTreGYmtt4kdljnu1iHen4/sg5Mgp4216Biy20yMqoSTNRyDJ0CNTUjgppqWAcBYPq7riNBlffQVNZVdS3Q3WMYhnj8+DEODw9vbE//5p3fw9TYMnoaAL2oskCU1fzHWQECTKTV6WHixHBAROgGXYRhhFBEGXlQrHP/Yvv/QBgNTgeEvgHOme9heuzetbFFIqgIxuEB8DwPnteC5/Gs3IKB99YXxoA0A4OlZRi941IC4CfPXAmAyT744AOMjY1ZgUXVnmJTHmdbRlfH/li2Y0DZ+6mjFKDKPZj6ypcBv2WAseq6yrYDpPpc/S6HtSWwVNerE2ZX6VypyIKira2tDZQQ4NASAAsLC5idncX09HRjUbWqUaAqn7FJ76yLAKCk4NQF0soe1zTorQrs+rHI2TLYdYF/3bwwpTjbpBeWfcd04jz9IAPKakOo1J7rBnsycqAp1fkyY2aKMtmQDmVJFBXpaGq3VUbkU9fKqKk1X2dnZ2d49OjRjbUG/Obd30Nn7HbskCRCf2mkXyDK0szT6LPIlOfDZFxivYBu0EUQhlkWQJwbkBMUhMDe2efYOvrrdwpszrW/gpXOryQZFDxpsZhkVCQtFhlj8DyOlj+aYPtEfBEx5vc8nokw5ksregSAlxAAO44AMFir1cJXvvIVKbiSpe0X10BdWaMJMObXINl6rFJUp9S0V/ELdL6F7D5sQb6umwA1e5aajm7rm9VVekoty5CRRlT/wwSyTXsildigHEshg1QZv7o5qpsv1IzV4u9evHiB168HR4R2KAmATqeTEQB1gso6a78pqSqqVoUyBqroLNap/K97MdN/q9rHVGF3qfoDNmqrdQEb23PJxNgobVgogid1AMK6SJGyNeyyBVzWdsYGBOtY3TpKMaqSAbZrik1qvo2Apq1abZ1jU3eXE1sxwLrKnFTOok49O98pQ9Uqqao+SN2EwNHRER49evQGMOgPAfADdMaWk3HO1fyLCAIiAfhIwL/IAdgQAANnHJGIEHRjEcAwiomCCGGiZp9vVcexvv9nOL282bKHvjl6jOMbK78PFo1l9x9LJCb6CknLRZ958HwPvueDcZY9B4/HwD4SIiZihIBgMZEQK2OHSUeA+LwnlztOBJDgx965c8eYNiwT8DORuyoQXzyXrJ65CF5UwNZEFFDWJkpqvg4EUogQHWCkjLuJdKmLALclMmwAv+46KWJ4xTEwCezl8Ux+rql0KigaBbL26bYt1PNdq2TvDnUumYJjqnfj9evXePHihSMAytro6ChWV1cxPj6OsbGxymnpdYEhUy25qX5L1wXAJDpSh9NoAiwm8GBLtui+zzbl3xYol1WtlTn3w9IWsepGpTLZQkxhmnWsKTX1vKxia5OEiak0wpRCVqfTIHPk6iaX6pxzphIum3TXshoMZVWiy6TLlikN6AcpsLa2diNRim/e+e/QHl1MgDoy16R3L3EcXyQEQBqITlXqGXic0B6GCMMQURShG3V7HQUylwfgzMPhxRM8e/0X7wTYXOp8G3MT34YPL+fwiTe8QY/78H0PnHvgYBBMZARCb67zJAFAAIwnLRkjMNbTbbjsHuFvnvzPDuXrnsnSEubn542ZY6q9ThbVLCNoV5awbnqvkAF01bXaErfUz9loalE+Z5M9Qfn+qrpbqr+Z/DmVP1w3MW0zJsVsPZX4O6Wzj649c1n/gTGG09NTPH361BEAZW1xcRFzc3Not9tWk/smFrYqUXHbGp2yC4Ap6lhHHXCZsVAtLmU1FlRiHVX7vpq+qwzgaxIY1AkuVKyorbZCkyC0acX/ft2PTeS7TGSCSqb0u7yiSGRQHdUqegMmJ1mWul9W06EfpUO25+92u1hbW8PJyUl/CYC7v4fJ0YU3XJT4+gUQsUwdICk8B2NAlJQAQKQRlxBBGEFEAlfhVY4AYOAJSZCecvPoL3Bwtv5WA8326CLuz30fTEwU3L28+8fhcQ7P52CMw/f8eIhZWl7hXV/XkVvfIRLwn/YIZLjsHjsCwGCrq6vodDqk97ZsZyqZTkAx26hqhlZTe1sdLQFtyQEV2OxXe11KF4Uq3Q9M/j+lfl7m29l2BahLK62JPdEU4S92XqNiJQC4vLzE48ePHQFQxubm5jA/P4/p6enSL3siKtzYhJIxspT2IBQRKVn6TV0TXweUihNcxwD2UyzGpoOAbas023owyuZLXfT7pRRPGTfTs6F0UaCIx5j6u9psPHUD07rntEm0qJ8943XPpcy4NQVo62jFarO+6OYXtb61jKNDycSiZEDI9jmbteXs7Axra2t91QP49t3fx+TYIvKCfWnafqz0zzPAmZUIJJSAEAIMPpAcKwCEQYRudAVEqVq9l3g7EcC8ZIBC/HT7D99qQcC7s7+C6dEPsy4KEGFvLJM2iR7z4Pl+rAHge2ACEEykXRcTAiAZu4RKQe5JMX69DeBl4AgAk6UCgLL9X7X/2QjBqcAkNV1fl91XRcSu2OVK58dR6vgpPkydwtw6gE6tVS9zLSZtH2oWiak8mdoS0hQsS39Wad1Qui9Q8Aq1xSHFx7PReSh2bTMRSunPX375JYIgcASAjbXbbSwtLWF6etoonKR6IThL3IU+37EqEmxqZ2LTGotSw6M7p05hVsUkUxzspgBtGcDSlOq/bTubpubYTbL4FPBlEhIapOu2jdyW7UBiox7fVNp+leiL7biVee9sxid/PVW6HFA0KeokosqQkDrjyaVEFZbe4+NjPHz4sG+RmW/f/UcxARCjVCQqgBAirlMX4ElLuh4hgCQLXQjEXQEYg0AIiHjsut0AYdRNpOp40k8gSMiCuIPA7umn2Dr627cSZM63v4Klzi/Cx0g8Xog1EXptAEMIRGjxEXheC5ynWf1JxJ8nPgeL2yxHopcR0MvCYFmHhtQug2P87bojAFSWCgDqQLOuBl0FVkx7bwpW8ucqtqM2AdUyBIBpj7FR8jeVAKgCU9TrpV4ntfa+zH1XIQBsRPVMBIAqq5Oy96tEAWWBrrK+IaUblQ2JThVQ1GXUmMiDp0+f4vT01BEAVBsZGcHq6ira7TZGR0fJL8n1lDWg5TFchc2lI1MU2nVkgC4Vi9oiStd2yyYCLlusKKk8NseVfQa2ZR51AaYyNedl0oApYnBNCvvZECWmVDWbaLaM2ddpCVTVoegnCWNKkatrvbGdH1RHpY5r0z3fsqSfjSCgLbnyxh5CfBds3l9KlwxdO03d9bQ8hiAUpTZ4xhjCMMSTJ09wcHDQl/fnm3d+PykBiHLuSdrqL+tEnynOQ7BrujlIatAjEYCBIQoFgjBAGAVJy/pUUDBKatV58jPw5C0UBGSM4+u3fwAuxmIl/0Q7ISNX0n8xwOct+K04gyJO5/eSsU59knReh/HPIp2LMQPDGIPICUdehif40fo/dkhfYe12G++9914pYFPGj9OdX0YSqOqnq+5LtnsnhXSwzQCokzinilOX8SXKkPO27XupGmaqaykTaLQtTSxThizbt3XdEHSkvim4o9ubZde+t7eH7e3B2GuGggBII/9TU1NGxkg1CTyeKDJXuFvbdl7UCVvVEbb9HLX1FoVt7OeCWkcrFZsUd0qKWh33ViUqKmMfm2xLSCmlKKb4UdISVePdFOFh8x5RIxhlnp8toWSzzqjIRpu1pF/vOeUZlX1eZdcwm57aZbqjVO3OoIpupcZZAuSjcvMLiGsW19bWcH5+3gcC4AdZBkAGUZNi/bj1H8A9jigME0KAZSAVaVcAce0BIYqirCWgyABwTBTkICwOL9bfOkHApc53cGvy22CCx2OV76gABjAejwKL4Psj4NwHY2k7P561+ovLBJC0A+y5jPnxLs6rq+AEP974Xx3SV9j8/DwWFxdJbfNUWZ2mrCFKzTjVV6hbXLcItFQdC/qlA2DjH1L84zIAXPVMqRketqUgKjLaFntQSQ9VxlydYs6UIIEO9FO6AOiegSkoJYTA2dnZwAgBDjwB0Ol0sLi4+EbdP70Wshc3iAbkTlURJooza5PCXrVNianNCnURtb1WG6BSVgjFZvGvQnpUiXqqFkxKbVRVsohyXTISjtLtQrXQFomDPHitg3iistr9WgMogntl77lqL9/inKW8K2WFqlRzR7belSnhKZMZVKYbgE1rxibWKNmay5ldGYDs/CcnJ3j06BHCMOwDAbCUgXckwnIxcM/3rheIovhaOPcQRWEhgy5OWRcARBQhCLuIQiAUURIFj+KU9uzc8bPZOPgLHJwNjkBTFWuPLuL9W78OiLFYoT8TU0yi+MlYcsbBOeD7Iz2xRSYAwcE4T8ovwgT8IyNdknYMuWqNvCsZdwFwBIDa7t27h3a7XTpQJEup1u2xMpCtW69NwKlKCUC+JlyV9SojN6lq+KaWgZT70Y2lbK+09ceoZQSUwFwZHYYyQoeqDgEqrGGKmlMICtvnZQoE6HxL1bhS55rsO1T2+eefN76fDj0BMDY2hpWVFXQ6HXieR3rwptYodTjOdR1nSvNRpQyX+c4yL4pscaa2KLQB/1SWtCzQKzsH6ow619FaTjefKCnHVa+5bBp7sX+rqndwce6lx9WhPG8DgqtYWS0AHcliUtqtSnrZjuFNtls0OYtlAX1dmT517BlliGObziFl5v2zZ88aT1u8ngEgMlX5WLcnBGNe1vYvbjvHAPBrEep47egC4OAsVvwPwy7CIIIQSIiDCIz5yYAkJQHJz5+8/F8Qie7wA8y5X0Vn9MMUciWgPVlPRYRYBJDD9zwwLuB7rWQipXPLy9xDISJw7qczKBljAc4YItHrACDSOQ7gvHuEv3MEgPI9/vrXv05+T3VEuWntUnUkKtu1xMZP0fkHVP0UKoilHGtToqcLfOmy02yzz6gRZ8p+Rknj1+0pKoFxmQglZT+RjUmUlAnZBHfq8tFMJaoyP8Lm2mQZKyoSYH19fSB0AAaaAPjggw8wOjqKdrtt3UJOxXTaOqc2YLAq6UDJZigjBFa2x7hKp0AGUFRkQFlRNRXLauPklu3HXRYI2KZRUVKTTXXwtgCtyXZ7tmJ3pt/VCfwpm3ITm0xTxFC/gL9pA22CMDORi1UIQdtIkmoN6Ecbo0ES9gzDED/96U8b7QrwzTu/h3ahDaDIQsy41oc+LRJg6JUIMB4L10VRF4zxDLRGYRdhKBCJKC4fECIDrJmqfUIAbJ38CK+GXBCwM7aKe3O/Bib8rItCQpskEF7EkX/mwfd9cM6z6H8m6JdlW0QJeOwRJkCsvRBFUTLuLC8rAAjgIjjCj586AkD6fDod3L1717j2qdauqhoApuhqU2Cr7PpGLeEylTqY1Oht1/G6M7psugw0QVRTukxQ/FfdWFLKPZv0V01ETxWsQvFdUtvf38fW1pYjAFTWarXw/vvvo9Pp3FgdapOfNwFvVZuUJp394oudzwCoCuRtNqgyL3/VdN5+9yGlfr+uvSRFRKyJhbXMd+pEWKjXVdZhKDseNtktTad42zhcFGHOsoQoBRDXoWysIxbKjjM1S6XqvLJtpXkT+02Z793Y2MDOzk5j3/WVpd/E/OSHyVinUeu0n6G4pjYfA1MkXQFy80IgFgFMhOoY44hEiCgKISLgKuzGGe6ICo4Qz9oJrO396dAKAjLG8Y2VfwQuroslF1YDMMbgey14jIN5rDcGEKn4AhiAKMm0iEsqcinZyM/HN+flZXCEH2/87w7tS2x1dRUzMzPkvVIGLKgBqaIGTD6z0yQ8Xafluw/IACA13V13rA3xQY3o9gv8685NJayr7h2mZ1FWI0D292I3iiZBvwqYU8vpVO9V0S+3Cf6cnZ1hfX3dEQAqm5qawkcffTRQoN/kvNooptex0NQh8qVyfk1RaJs2KmXGvir4V6nbNrXA1NH+z5TdUXbja4oIqLoY635nW5/Y5DiUfYay99yWaGgi0lyFxKtjrE0g31TrV4cYYNkawipkVx3z6ybt9evXePy4uRr5Bwu/idn2+/B9P4k0I0tbz9Tmst71KfDMgaI02p3U9V+bW1FcVBAGXXSjKzDBkTW5T7MMkq4A++ePsPn6Pw4luFzufAe3Jr+TifxliorJ2CV6/uDcg+/54DzNCPAy4iUuifASDQnWcxOzd1QUCAB2fSwZcH75Gj/Z/CcO7Uvs/v37mJiYIPuW1Lpq6tomU/mnkPNl9/diGzgVKFf9rANplEi5Tk/A5L/mCRJVnbtp/G3HWSdKZ9Ld0c0RKvGg+7tOo0CXAaArMa4780Qn8JcvQVCNvW7uqzpl5LEYNdgyCDoAA0sAvPfee1hYWCitkm7zUKntHuokFmyE8Sjg2jNcQwAAIABJREFUv0y6rO4aioyt7rw2XQ0ogKZK+rRNHZpswbZJWdOp+NtuotR0KJteubaES936FzowVHe3grIZEHVElqnrSJWxNNX/U+egao3QRYKaIJ5sSEwZWUB5z6gpkzpCiqLqq3No6yYZq44/lVyU3d/5+Tl++tOfNrbn35n9Zcy1P8DE6CyyuvXelWc/i1y6OUsyBETmzhTuJVO95xACCJO2gJG4fvYIAhwMUUIuPDv4f4ZOEDAW/vs1QIwlo8EzwoTn/u0xD57ngXs8w+0McT0/5yxzDVPhvx7BkmQEXCNmIgjBivgfOydfYu3Vv3VoX/KepfX/FGE2maiYrKa/KLJn6vik209s/Cfb/Zviz9vU48tIAlu9ABvwrFvbKQHBqiKKVN2Dslm2lJbOVNE8U5eKuvyusntgFdxmEt6ktEzc2NjAycmJIwBkA/Xd7363r99XR1StThKgDgBRJYquaxdj026k6oLUT1BYdryp/dirdGOgljdUBZQmxrjJukEbAoHCbFcR3huUdaXua6gr08FEPuX/ZgPyqVGBOnRNbHRdTE5X02tMXc+r6tz98ssvcXx83Mh3+nwUH9/+b9HyJzDqj6JXAgAIEUCI+OcYjKYZATwZh+K4pNGYqEAeRAiDAFEkEKXEQaJoz/LuEPPw6YvhEgS8N/er6Iw9yKXy59v2Je2QGQNnDF5S+5/NoVRDIUpaLDKeEQC9cY1SiiXXAjB64zq6QRefb/3LoS2jaNLy9f+U9qCyqKWMrKWuudSuJf0CYjYEpEmYz0YfSve91MCc6bO23a907RBNRAzFdzL5cyYSw7QPysh5WfmJbP71gwTQPR9K2aSJoFIRJarndXBwgBcvXjgCoGgzMzN48OAB2Zku67jWrYJal4NWJwAps3Ck6S2qLgAUJk9Va1OlvsgWcDdFApjAo61II4VhVM0tquqsaSx0aW11pDGrhHiqdnqo2o3CJABZRnXfJuOkrvWJWtvWBIisOh5l7t30rCnjX4WsqaPG32Ydq+tZVXX6d3Z2sLGx0dg6Oj/5VaxO/wLGR2eT6026AERhIuyXRLKjEEhoAJaNTZrNnxAASTlAlIwbT/QAwjAmAIIozEreWT4fIBnjreMf4dXRj4YDWI6t4t7898Ax1iMA4ubH2d0JAD73wDiHx70s2p+OE+deUgKQCi32sivYNacx/VxUcCOTyNbuf8KLw+EWUmzK7t69m7W0Nr3fqp7pRW2mIvBSgcni99ik/VeplzbtO5QItwl0UggA22g8xac2AW3q+WwV+8v4XzoCgPJ52Xwq+r15UlEFuKtkX9pkUMjKTmwFfU33kMdLNgKHjDGcnZ01WlI3tATA6uoqlpeX38kNwhQ5t3UuqW1Pir8rgn9KzZJuodc5tGWzBeoCKGWfURWxOVswTlnUy2xAFCBWVajFdh7W8cxsATS1F67tnFORNCanqCyRZEqJL96PbW9dyjtGGUfZpmna2FXzkNJVw0RA6uaLKQLSJGAvM9/qAvyyz56cnOCLL75oFiTN/Spm2/cx3urkotBxhJ5xDhFFiQhg+nPYYwpyKe3pv7POAQmYjaIIURQiCiOEIkwIAJ7o5Ius171AhLXdwRcEjIX/fgCG0eTOeY7Q6Kn/MzC0/BYY5+DcyzmAESDi8cryBTJBxTDJuPCSZ4BskDNyISsViHDePcYnz/7grWil2IR9+OGHGBsbk65tunVEt0YWTZZFpWrFS/UnbIRNqZlVsmPTf+cDUKZ2uCrdneLeZvI1KFoCFCCqaqlXVV+BUrJL8Qd0GgMmAkD2WdnzKD6va9lGoLfk0xEWVBJHV6prwiqUjIji2Mt8EpUv8ejRI1xeXjoCIG9f/epXMTk5WauDT3mZ6swKoE62qurcOgLB5ByanPiiqIWKIKiaykON5lGcd9nmZht5rLPmzcZxp9yr6Z6aSKmqCiJMm2oZcK1rjVjH2qAaA0p9VxU9B9trtm09ST2HTkipTLcNSotQGdiXOWA2EQyK01clY6fK3L2J99H23ZLZZ5991qjTMj1+D3fnfhmjrQ5a3mgPpGYuC0Oces6zLgHZdaddAxggorhFnRBR0tceSIv/o0ggDAKEIkAooixq3gPO8bfun32JZwMuCLjU+TYWpn7uehZDznhyb5x74JzH9f+JyF8yKL2a/mtzDGDJODPWy5PIZkUhWyAMu/jy1b/BwdkTh/QlNjo6ig8//FBKaJqAAmVvsQF7/TZq/b7qOvPrdD4Srdp3ZfdMba1X1k8tG8Wv4xnVQfKaskJ0bch1c1Y23+vM+C07DrJsGoqoumrOygi3YtZr8XPb29uNdtYZOgJgbGwM3/jGN8iToaq6vA041E1cSv1xnf3ZZVHFIstWdaE2pV/pVC9V5IpM1KYMwWMCXDYK3jelAaHbFGwW/KogWrYoypjcJsaiDCurIwKo40qdXzakURWG3wbI2wJtSoZNPvJSh/AqpbOICezrWveo/q5ai1WOic07SClDq7tjQ62bvUX2Q945Kn7mxYsXjfcwXpn5Rdya/BDtsVtJ5D6NNseK/mBR1rpPiDCDumk9f3ZvEEmhAE9E7MLk90AUhQjDEFGUprmzLFqeZgJwxrBz/Cm2Tz5BNzwfOFA5P/kR3pv9XpzVkCMwolxKPiDgcx+c+/A9r6fsnz3bMB677OhkHYjCeCREXD7RS7Jg6GUWpL9heP76x3i6N5zdE/pht27dwuLionG9KYIQm/VYlT1oqi+vsqaU2e+KnZlMpPD/z96bNtlxZNmB5/rLRCYysXMBiyRAEgQJVrG6umtrqac1JpNJNqP5MiYzjdn8Q5nNtzGbLzKZST2SptVLdXet3MlikSguAEjsiUwA+eLOhwh3v/f6dY+IzAS45TPrLiLz5XsRHh4efs4995yx/cDUtsn9nmcLPO/F62lKRXyvGGVq7OHUotEUFePYnvsg4833Mxe9+dcy2Rx7htauW4tQICLcunULly9fPiQA4uvMmTN46aWX9rw4HdSm66B6Yw8iO3MvTF5tsk/px9oL6KzJnrz3tyJhxv5+Sm/b2HEf9EPwcc/RObGTtcVpv3P9UcmbW470U/r/DrqdZK4z/lwQOEV6XruGc6sOY8B1DuEzdbNV64+Tm4Gu6yarJmrj/Tiq93v5vK8zCTDXNDP+/lHHAQLASljHa9/7d1hdOYq1lc2hip/bAZiXYAZCWCR3esQWAWn8l86JRGJAB2agYx5aAaIhoLxOfSpA/6zpwfLl6/8frt/7AMvu/ld+Hc9sXsSTm6/h+PqzatPayTUjjgIBK4sFFouV3twvRiSGHP2nCHXklgkaPiStE3DWWRDu7z7Ab//4H/Bg9y4OX/7r3LlzOHHiRNPgrrbnmVK4mmKkN3VPOLUveo4k21M4TvVBqBnKTXnvnLV+LO56CnBvjf2U6L+p16BGrE+Rrc9tAbDP670YftcUBlOxzF7mX2uPMGWOtjDEXCLdO8/t7W188MEHhwRAfF24cAGnT5/e88aztWjuVe65VzfxqTfFo2DBxhbV2o0lq78t4DXHB8AeizWB825oj1EdY0fHwNFe/RQOap7sNy7wUVSVPUOTvWSzfpWM7pws3DmAcS64tOvLnE3bfsdvbMMxdZ3y7sm9HpsnffPu91o1yLsO9njH1jXPnNNKSPdbGWopG/ZD7j0KcuIg0mXu3buHt95665HvBZ449iqePfkTrK2exGIA4tHwr8fkNKgA8namj6ljdNxhEVYGU0D7POsNBTtmcNehW3aDISCrnRElAkBXvj++/t/x5db7X0mf+4mjz+Ps8T/FifVnhxNb9EaHXQeintRg7gaJf38egQghEBaLxTAv4zN+YTaAA8Dn5dAykceb4jObs7IgxiuCCB9/8bf45OYvDlF+43Xx4kWsra25zyq572qZ/s0BnWMeKFNjZecop1rPlDlmf14SQqu1cwpgnOoBMGUdnEt8zAXjY++tHcd+2lbH2l9rZpNT0qRanghTSYm9RHzXPAvs7zxj6qnYzcr9vbnUUgN88MEH2NnZOSQAAOAHP/gBjh49emAbsoPa1D2KxICD6u9tgZY5XgdTzK72SjzUDDZahjQ1p9spzvePKrf8q6joHVS//xi4n1td9j5vysO2thDOrT7X+rBamfatjckUqdwchrc176eQAlMZ5rHP2ut6NKX6VFsXvSqBR8BMMcIacw/eSzSlVSZMud+nqiQe5/pwkIq3qVGNzIz33nvvkcUByte5M38xGAKeTFuWWNEHusG8D9kgkLuhJWAwrAIA7gZTwMEIkDoECmDuCYNuucSyW2J3uZtk/72YvgMF6g3ykriegEAAd/jo+n/H9a0PHgsRsHnkSTxz8mc4dfR8nMHD/4aUksBgBAQseZlaGBZh0ff8h9CfS9zusTeP0hVO7RXJ+C/dezl1gdEnMezsbuE3H/+HQ+O/xkv2/8/Zl83Zy9TAYIsU3UshYs56NNYOOraf8Z4ntWfH2PNjr62MNef/vRQrpprg7Xd/NAdTtDzIvGftXhRkrXldU/QexDNuv9HQU+/P2h4lmlnG//bO46v0AfhaEQCbm5t47bXXDuzEpkygvppAj3/g9yHF9m7Cg6gYTVkkvWqc7Xmxm/8WuzglT7Nm/GJBypyK916ia+YsClNA6OT5OePvD5qsOqiNwRSC53GAnJbvwVgSwJyH+pxq/9Q0B0m4jMlD5f029hBsteS0/mbMm6HVv1nrL69FUNY2lTXfk1a7yEEC9oNOsaiZgu2VINrvfVwjaB91HGB8bRx5Chee+te9IWDoJexx1xKNAYly1j2nCnU2CJRZ9VHGTlgk0Nt1S3Rdh2W3O9xTAu4HTgQApOs9ZcXK5Rt/jetb76Hj3UcH/DdeHE5a9/YP2Qh9Rz4ziPt2ha7bBUBYWV1BoJ4IoOjZg+VgehgNE/s+fxnnl6P+eFAMiPVkIFOYl+i4w7uf/0fcvPeHQ5TfeD311FPV/v/W+tx6ZoyBjxYA9/wAppDI+wW4Nbf+sWfhlILCGIDcT2rTXoj7KW2C+6loj/18rhptis/B2NjW9hy1fnpvfzMVK82dp63rUyMjWkTZmIeW9RSoqR2+Sh+ArxUB8Nxzz+GZs2dbM1RfiH3GkjTlSFTz1D0Q9F+QFHNBj/q96sfDrAWHOXc+krOZ9CIuis8a/rYlgUmfKTaTwSwengzHyg/t53byAVhZJORxAgBPBOdyHkyNcsPIvPTe717nA5b7Tz3+moRvDqHRIormEhr76aFvAch9kSA1kOVdf+tSLoCVNcSR/fAFK95YM6ogsbHGFH9j1js1/uJzPOBeJITEv5Uk3dQKA+rGWB6x2IO0UHxfy1eBQkjXiEfut309HL/C3n+eOber97cYJ/nbu1tbjzwOML6eP/3PcGbjAjaPPjGA3QGaMidDO+YuzQPmPtaOCaCh57+XuxM6dEgVbkEaMAPLbgleLvv5SxFYLxFN7tIzq7/RB7UBg2iBRSC8f/U/4ca9g/FGyMD/3GB8CAXQwVGJwGmNWXa7gxJiBQRGoICw6OMNQwi96gFDCwT68WDuBkJgIW+gVP0Hs5lLrNQUn938Ff5waPw3+nrhhRewubnpPk9q5OsUxdGYv5FdD8fSm8ZUhfsBtC3AP/acl8+dmpnhfloFp6jn5ioALHkzJ1t+jBQfe5bWzreVojBVjj9n72iJ+rH9VW1u7sdzwtsHTmmJbs21sfP3iKnWPfXOO+9guVx+twmAV195BcePHy82MlQjASaAjse54aLWcc8A/7NAnjMes/rKzd/WslfnsGutXvc0Ni3A4d3cw/tdF/AJoD4RGsxpUzuW61ojR/YLxu0c4ZnAYSyKrXbd5lYBp/Sn7yeGZRKI3SNrP8dIcC75VpAAQkVE0w7QvcbNh1aFkPQqQZZ9rlXVLfh3N5Px/RM3USzIWbsxm5r80Vpfavc/jRC2zXtmL4CdfKTdG6j1lWWPlJzy7DjQpzrNvQ+bK5M64F//+jfY3T34qrd99YaA/ztWF5tYP3Isg+B+povbMYLyLvWmR8PAQCvp+vS9872rfeydZx7It27wBRik79Egj1kob8BZaTC47IXBIf/29h/xxd2390wE9MD/pzi98YKYT6E/LjHhIhEiIxK7ricrFmGl71QYQD8FPcPU8jNc7xBW0HU8cAr9d/bPy2ioGNQ9QkTY3r2HNy7/X3iwPDT+G3se/eAHP5gMtucY206pOHvKq9r7W2bOByHRHgPDU80Dp/Z2T4kJrBEpUwHuFGPqqT5F+xnbqdeqNc5zfj+meBhLaGopXaYWgeZ6ALSwRsvUvLZ/mjLXxgpRzIyPPvoIW1tb310CgIjwk5/82K3y+vsPKjY4+91E8fCAK8DqQQB1eYRU30dS7UEgNrj5mCg/zAnVsSsmt5qQYus6Fo3mLC7sfBeNMLuZGcPQl5hBQ9d1WCwW2hAsfUZvZhQ3KNHMaKwFQDPgsWo0AYCJE4wbe8XcU0iGVHsDvXU4Msb6hwaoK8go2eYyMkd4n/fwHBaegAMzv+tG4tm8NokpjHN78aysEzRvjahtDqL8uuviObRbJ2RfOw0ApwWs9XUQ8uj0hxCGYT15RuJ+LElBqq4jU82gateiRWKkW5B8IkARE611kfWKVtsUzb2/43U76OflwXvduLSICwr6TcvH+OKLLx7L/uCJY6/ieyd/jM21M1iERY4FBKlnd29kJwgAkVVPg2y9/3cfh7ccou76+w1JrdNx1z+DBrd8jq0QzOBopJfmPPUF8/SwCLiz8zGu3X1nMhFwdPU0nj315ziz8WJ/n4Uw3EvZryDK8QctwtAAgNSOEAKG8wr5XqB8jJo4IXWppbKifxYP601ssxjGs49g7P/sgyt/hat33jhE+COvEydO4Pz587MSe1rASb5/rrHxHJ+f/WTbTyW3vWfe3M+Ox+mZznpGiGPE/5x2UvUcneBrMMekd7/r/F5iI+3eY4yomkLa1Ej/FnFy0M+6KYTXXtokvKp/rQW6dZ7Xr19/5NG6X2sC4PTpU3j5woU9mGnAB9VzpdguGVCqfccsAyQ4dxn3kgNwSQZZgyFnW0YOi0A18CfGLG7i44aYOwMOCG6FvEUORBl+HJwszayDnUy2hAQ6psmbI+Ab+myqYMRXLaS8Z66blNn3JxdpaoM3d6KwvHZsr5xzrnsnq+xcGjMwcxdEM8lpwnHMbWWR32HnLKMt5Z7Kxk4drzmMcdzvkwtSJ6620HnjaNyrGYRzJspGHvLJII2giDXv3rBjokgAAeZb8r2sEKA0w2Hml5TCyfXCPnws+bmMbRLOpqHrOkOE0tDSPJBjEwimos5t/qM2L5vzsSCIeJTs2yvZXHsWTf0cdg9juoLuxs2b+OCDRxsHKF/nzvwFzmxewOb66UQAKNIUi0F5sSxHQ94PKSJQKzZ64Ey9AoA7dN1yuG7Dc3JIF+gTBDIwpjCQbZGQHhoMQMCt7cu4dqeuCFhfPYWnjv8AZ4//MEXvdaJNhdETAB2nPL5h0tJADhAwfH8YSI78rJJV0ZDu0P4eWgyqgsEgkfMTCuiGiEAWYxsGw8WeULly6238/up/PkT3E17PP/88Tp06VQWl0iis9Syrqe2mSqunRs+Ngcj9mFd7UX4SIMYWuDpJ2faemQqIW5X/Kc7/3nOxpi70jr+lRKztS1vHZ1sKayTLFEw11jJdu84t5WltvFpqk/0ktU1JY9gLgTamqPW+wyZ8eH+/vb2NDz/88LtLAFy48BLOiPi/qrFTARRp7D+bE8ZfSPr/jdVmHyTscbRRb10YBU0j4H/OzcHIFez8e/2dcqNeZW7lRt7s5mn4jFBxb5VjKUmAlno1VjdrVSrWZbf0vwnwCFRvH77eTc5pgWWEUFkAJ8wFFsZKLSAgK/GteWKBUwsUW7f+/fTUzyEDavOYKoz7HJDeWngnn9cE8mLqwzNGaBWrE+k1pTaWHev5JedWJACoRlaJOSAVAzVirVXZzpX8EqB635tJim5aJJ9cY4V6JoyY+LUISTYEHe2B/M3EIJdrS5WEbRtwWoA997AkEeOB/wjWp7a+2Wvggf85lZGtrXt46+23H9seYX31FC4+/b/h6JGTWFksoCvbmQjS1flUERjWwiVAnTAB7IabNFNYfdG8r8D3RACGHvuHw1zrCQDi2EoQCYC8NgcKieYjIty49xGu3n4Dt7Y/EsD/dZw98Sd5zRMquP7WHxQAYaE9AIZndT/lw+DwH9JoSMIjKXiCjPzjTPYNbQORfGDuwHF8QL1B4GCaOKxU2F0u8d7n/xE37j3+Des38fXSSy9hc3NzFJRIgnNMMj4lQcD73ZgHwOSt7ERg5cX5je3Lay0LU5zyPXLEEtAtMF7bP3n+VDXDVm+85efUWjjky6uaj8VI18j6MeJD/m5MqdAqII0ZS3rXYY7vwPw9GUaJl9q+v7VnbqVRjJFcrVaTt95667H7AHxtCIDXf/D9FP83BUigQQJQ2ozPq4z4v6cKXGMjAR78eGubvBGgPr36M9760HKElcA+vb/TBMBY5SuqCORi13lgmDQ4bZ8j6b+BNgnUC2qAlMprXM9VoJLVDl0G/h5AMkC09w3IiI7Q7oWuzYF4qB3LudOWnXuKDpcxNXPBlVC3iBUBaPaywLYMNedKrFpM+tRxGnt4HlRyBiasF2PAk4eqIlVAIMy1mXo+bK/PzOSQ0b55v4TcHJvskEvQXINRJlTmcn3e6aWxZrJUNVAy/6jJ9ue21iuSJG6UxPowr+rPgvCozIMJzzjvH1aRQi3iR3zfm2++hXvb249tn/D0iT/BM8d/iM2NMwNoj8+Cvk+9J53jJkoTxRSihJ2Fkz2rXg0eUgMCLVT0HbjrTQK5w3LZV82jCmARFkk5xwMpsBgq+F1KIOjheZ8W8BBPHfs+gCG2MO4dQgCGVIL8rBhaABBSAgCFfj3tuwQCQlj050QYPBAgSHI7dyxZkgkvYhqGLCYfBE1Og9Bhic9u/AYfHRr/TX4ufv/732++R8qG50jQa6B3DDSOPcOnPD/38vKAETUUnLX97FjM35wYwDnGyVPGZAr4nkpyT5kPezFttL+XZEMrHrmWbR8B7hQ/BZsKVgPWY95Te5l7Y221YzHSYyrjsWs+RoBdvnz5sUTrfu0IgPX1dfzJ66/v+UZ0wcAEialX/ar1Uc/bohkAbfuNJ4Ds0WOZUpEdAG6wG2ArBd8voyzZSlu9lhKmqeBxJNVg5Cnmn4thoSVTWq0s2pt6JG6stgkfk6bvZ4mrtY/APgAlOYJxmf3U4xxTKuwnRnCvD4Bm9dmRnakqA/bv+TEHJLK5/yLxJUk2qbJhwya3DJIU424qCoRxmVyRDCD/d8R0U641EuAX5lbmXm/1/jfJH8+U0ZB4kzZ7M2OuJgFteV57vKf3ul5wjegDqqqb1FMLVuku3j312Wef45NPP31se4VAq/jBs/8ei8URbKwdHyrTrNQ3jCWYCWHokwcN7QLWz4X7ynjvE4AE6mmQ2Pcguk8QYPBAAkTDvd4sMDnoRxKFo79ApCWWgojozQLz7cDoOBcTKBDQIY07BsVClPYP0oReLTMA/kCrgqzipKbD4HMwOAcgph0EiueY/RO6aJoYow4pVvxT0wBiY8O9B/fw5h8Pjf+mvk6cOIFz586NguL9VOPnAD7veXUQIGvMgLCldmglDFl/AO9v5qQA1I7d+7ypMcXy86ea0Xkqg9petCWVn7L38Xry7flO2b/N8aeotRN4n32QUeZ7vT9afgT7aUWYSkAAwO3bt/HHP/7xu0cAPHP2LM6de14MPmE/c4GEaZwtmUS3YBjztv1mpdcvrK7Ye5vM5t+34gVie6P1Q4Cu7OSYPEpt6bo/lUeZrjiEdgOsq9kVN367yR/bxJLwOiYJDEh9XLPq6VUnuX5DWjWDAs6NFoG5ZEA65qTmHISiPI9lrhr+jZBJU+fxvoiJ4dxWFsCyy3NnEYBl55+v6+orJvUct/79kA5TF/e5lZVqNdka+QmDxzTZjds9gGqChve96jMjISguVcfjHhxsyLQp4yETAbpknKnbh9S9B0zKHK4Rf8UD3crdy5ObTay1klZqrQL2O2vjvZdN5xzwXztvj9SsEovm53fu3sXbjykOML6eOHYpGwIuVgDkKnrqYUfo++TR594HWhHeI0OFO5JK3TK39UUfibAYhqkbSJDFMMX669d3GXS92oBjukyHjhmLxYqI2BvUBBDPXWJgcPXvxzq77vf+A4L8G34XwiIRemERErDv+/KH+cIMJPPA+LzvjQ5DVARQjEkEQlgMXhoiFhDxmFcEARD9Dgjvf35o/Dfn9fzzz+PkyZPuOj1mrjaHKBgr4FgZe+2ZObqfGXEzb32WlcV7GexjWfY2Vq9Wla0pAGp96zWQ3dpL2KjsWpTc1M/z2g5ax1Ybh5ZRpNcyMIXwroF8W9G3cY1zoiZrbRIHEQPYuoa1Z2BtDzIm6bdjO7XtZnt7Gx988MF3jwD4/qVXcfz48YzTZzRL2sp2FYDHR3DF3GzU/GHCsXRc9rKqPx4hN+ZeCL2IOvvg9H1UkB2JAmBW7fJyTN0xibnm5muczlfV75smO2WTxlSFYiBQfdSlM7lf7TYeAkKfXGemoVzVpbliZmM92RorIkRd/8EnYJobfpvIKBcpKpLn7PXW/dvmP+MxOcBrdK6LLHtrbmnPxfv3I2Fy9wng1XmOrDcHQUpOWWdqMXdxbvVrYxicyU08DzArasj2zUtykt3JJY+xVXGANssENVzwSYASmT4gE0r8B6n3WXFVCtFYNFZ0G7Dck9O35u+capD9EErXsdLsUTP1K/wOvDmDukTH/INHzG29mMjW/fFPv/r1Y4kDlK9oCHjs6BOp8t7fG10CxvHZEXPvc9tX/n1BHHU5NSCkDW1/9UIka6OhXtdhyX2Fv69OdsOzLMZAxv77QUqfogTz9zATeFAoBArJgLAnDfpEHICwWCxym57s1x+OOFEyAAAgAElEQVSeWRLoFzUCdX/2sX6EIAjC3eHfg8kfDx4AUhoM4NMbv8WH1/7qENXPeF28eBFra2vVZ4HtEZ9iimbXwSkeIFPk7GNEwxjA9s7LA1pjbv81cOyZqdXy1kc9tSZUuGvmt3as7X65RkxI0Dhm3Ni6dvbzvJ/bz289Oz0lQG0utvYX1vTOEgBe4sCUcd4rAVAD9q3rWRtb715ThLkD+Gs+A61r8f777+P+/fvfHQKAiPDzn/6kXtWZaezlb2rG3QEL3IyJklHH7V+ZgZEz4N6mGfNBYGuB0FLe4EeUcXtTrDOhXTygfiAruzVwKA2KgJpjfVYbMHPxN/4OVv9HS5Imx5HtGFbHpN0D5Y3/nPxSL5KrPoYVUmAKaqb5wLT5u3k3u76fxQlyU9nCfglyCtPADTJk4vHXZV1+L7Y9RXt/W0Dn4BD39PRDitQYyT+iEHwlTnFNnScBOQ8FlvJmGgW8npmeX/mor5E++G0RMfqzclSmlkeHMM1xeA5BV/ubqkU/UEkp4OZ1r29mYQheb1inSYOrpFFjI/Xue+/h1q3bj3Xf0BsC/i9YWz2FIytHRCpA0o4NRn4A827RE99Xu6lsHVGPkp7ZJkYCw9Hssv/bblAZDJvADik5gIjRdVGKHwQ5ZVNmIqHOghjv2wHCYC5IwmiwB/CUwXxMBIgRgbQQc6QDIHpzu6XKKo3Pu453neseWwT6MV0uO7z56f+NOzuf4vA17bW2toaLFy/u6Z6b2oKJfTy/DnIP3wL8Y0B+Clhr9U+PtQB4a6YEqa2e9SnAv6UmHSMlau+Z0oYwpW1kShrBWHtBbW56rQwtPOIRQTXD6jlzdo5z/9wozrHvbZEPreJO7XuuXLmCa9eufXcIgNOnTuGViy83sZ23OWy9z3dL154ADBMXBe3qTLMW1L3ngReT9IBky9K1XpIVlqSoOU2P7F97gGFZMsbE6URuKX80XlExlMI1XYD2KTGN7s87rgKx/b7mLGa16hsXrtbzFsGxBcpentg92qH/7yVYmEWOv370zDpubC9x/tQqfv3ZDn50dh0f33qAU0dX8LsrO9PGAr0yJABYDqe/AsJuo2Vi3nXJQ+wpJBQRUVHCTJ5fToV7zvHV55Bo67EPpObnsvjbUmljCcvqpoPLQEOqEZE1AsKA3W7ZpUrp1PGV41BVJFUqJDQR1BeklUXgI8qudmrIDINMMfeqjWdsjWmnrQ1d5Zpxw9ji+vXr+OD3j98R/ukTP8TTx3+IjSMnERbBOR8aVCBLEC2ccabi/8eYPJWKEyv3gYbn3gCMOZrI5vjA3sV/SA/gZb9mivkWSKQRIFfrl7zsg/bCAmER5f5dr+iPhn1d7u/vQX8EUivoul2h5CNDdED5BOgdEYbPCTLIsxirT67/Bh8fGv/Nej311FM4e/bsLEDpAcS5YLzlSv+oXtZErQZya8C9VvmuFV6mSrzlsY1VwceM9lqgMT5XPGVDK4YRmJ5mVPusKS0ktXHzCIBWf/8UgqA1prW2wTlxzwex9x1rrZ1KNrQLjeX4jH3+rVu3cPny5e8OAXD+3PN4ZlgkXWO8hqJ+yga6HG8qVAGMev+9F+NVl3nTtBEvjyjJYOeA4vqCRFl+aJi2eoTh9GlQl//rd9TAeOFZYKr7LZnv2BFVQS5FB+ho9hSNjShVbLxFoOvyJhrkxwF6i13/ICAFLqdIfL1xK1S8ggXj2qIyI5c+PcAArBAlsL1knkTK/YvzG/hia4lbDzp8/8waOgBPbi7SuCVPheELr23tAmC8/eV9nFpf4OmNFfy3j7aqFV4lFxuu30oAHna9iRYXVeZ+AOZsfhLpZ8C/GioJvNjrw5/eJlBeYzYySFRjJ0sZOGklQsPR3c4LPT4lkx8l/+7G0pxIqvzT1Cx5v/QviZJhGZswrnaTUZIoc8k4e4g8d3GszjM9sbgTbRXmAZjeT5W1oMmYlqToWL+o5TSmnNvW1hbeeOvxxQGm9YpW8INn/z2AgI0jpwYSgMXzPVlnDoZ4uVIuq+h9AgeBa88upiFmbwDQqdUA2b0fACXvBBoSAzh5cHTdss8soAAEQrcclALD5+YoP+qlpH2PQfYNGA6o79/vWVFOzxiZJpCTD+JakAsapNfKpEZZIoTVwQ+kE+RSf75b2zfw9mf/z6Hx39y97fnzOH78+ChgqknJayCp1t/uxbB5Zm+tVrEpMvqxavYUQ0Dv2Gv56VMB+dgxjMnMp4L+8f13fTznEgzyPKakRdgKewtIS6JmSutBre99KmEg32fbNlqf7X3PlBaOKYB7infA2PtqhFQrUcEWIuJ7t7e38f777393CIA//9lPAFSi2KA3P60N9JhCPH3mQIe7DvxUueBZr1mXR1o02xjZ0vV+P1dQxHvZKpW8yR25OI1bVpmxG5EFSDjjyGG9iEUWttSE9vVk8eZoyOThYnVYwoQsGN1/2gNZ07+ZzKBSj1jUMTGyjivXdG7s2B74HDCABQ1VdnUuWm4ehgrW5irh6JGAH509CgJw7EhQf6cY5+FvGIwFhUQG5AWxP9W7D5ZgAL/6fBvbDzts3e+wO9Sl2FStFOtOGJy0x8dYgS5UUjhMXF6NTFLXlX0vhuJn1lXfiA1QKSTLv/VUAVLhIz+zg282R821BGUF1PJOBl3HayJEze7fWYKDAk2b4JV2GNGc5FweVkCWMB6VOMZ0caO9yc5LOU/qc5HBI88vrnN/MJ0DPgHizU9JaCEDSbQux/CLju317Z/Rv3vMcYDxdfLoeZw785cgImwcOY3FSkiDkwE/p5z7oQE/tcXFKL9okic3aN1glkdhUA/E/vmBMOiwTMQCKPtPIJn5dYPEvus9AjqRxhHvncEfoO/xDzkNIMUBUlbsEcDLbvAv7L+jn9/SFJAAuWeJz2LxfOLBFyO2HTBicsHwKUPULgO4e+8qPrv1W1w7NP6b/Xr55Zexvr6+Z9AyZrjXymyvVSD3Y642BSzVHPVbCoCaQWGtPWC5XCbwNNUIUSYI1NQDLfXE2Fh7oHry/nEsjWrEjNHroR/zlIjHase9VbWf0v9fm4ct88pWn3+tlXZqytTY/TKmlmiZ/XnHMsccs/Y577//PnZ2dh7LGvWVEgDr6+v40x++PgXbFj2OFR8lsSlyorlUjyu5FXaGX3HK7u3kAMSxClWZD+8Z3yWeYdjpB9E7mDbeFemqbWVQm87CaVyeY2yD4NG9OI9UFXNlkN04RLhAS7jZk/EEiMdeARPKKd5x3i/i+IpNOtcnvxlrS0L4amwdPcZz0h6m4PmRC5SGgTWJZq8CFe0w+X1BGMqBgONr/QL4yhNreHpzFQCwudr3o3Ydt1MIhi+RJEBMPoh/DwCLEEDUf1avomXc2+0fpFfu7uK9L+9jEQi373fpb2oPG4/SahIBLniHit5rLpLGrwDM1c1dddOhbi7D4DvKEfYeIqa3nkfQPk2Y9y3AHO+DMEw4abxpTQSp+p3iPgk0snrWX13XqyVif3Z1E5hi0Pbntp+qxU1wP52Nq8W8jhp6cY2IzPdWzVTX8yioedEUPLW4r+PPLv/xE3z6+edfTaX1zF/ixNFzIBA21s/0Cj0g9d5HFUU83o4HV3zHNNDSyiSCExOxItgVCgOxgLgRH8YkiGQL9EkDyYl8GLwQFimJIMhITI7PJk79/TQk9HXo0uBnlV+OQhxoUagWH7UBpYFYMHJcyLjRvvFra/tL3Nj6Az6+/teHaH7m6+jRo7hw4UJjb0suIBtTrbXIgcf98jLOWyDLtjpMM0uuJx54IFDK/VvkhydFr4HuGhHTOsep4zYl0WFsrFqqkbHUgzFAWjPDm2KW19qn1ciGMYJpjPTZy/wdawWYc5/ViAk5TmPqhGvXruHKlSvffgLgySfO4OKFlxygw81cbnYMtVQPbzTI8iogNVYBlVZOqhk2NSp2YhdRJRgE8G2lA1QrlQbCetLggmWbAzYbk6PVy5qAgFBMyPHgXCwxLR6kr4+5XjQG0EdPJvfSj/gHTgYexWeQf2ytHuE5jvnWYqGYF+yBASpBmajWSqqEAGwcISwC4cz6Cp49sYJnjx8pwL7uF0YRZ8iC4Io/j20XBGBlQegYWHa5Lzb+bcT3vQq2v6eXzFgQ4fO7u/jk9gN8ubNE1zHuPeTx+xcNxUXl/XntYYfkQpK4j11LV6bnoHlqEDoDllBTsxPtCjVDw0RwijXMW4+mzHV2xk3GlDE7VWdL2NmHTjYu0PdxhcBtkrUNMowrhK0GSP49BbuOG2WOf7t7pGE59kqRhIoCiCj18sc3jcUTZuk3BAB11uIi/aH+PWMkBzPjxs1bePf9xxthlAoJq6dw8en/dbh+ARtrJxEWC8gWgAzgS8DbsY4QREGTljR2fkz10ihKoHv4fYgDKd3BuxQzS0w9aRXVA2KycHr+MbhL8pWssOGBkIjGh1HdgOWw0gYV3WdbpHoCIAyqiC59TlIFEHD33g10vMSHX/wVtu5fPUT0M19nz57Fk08+OQl8TJXQjwHNqWZoezH7bYFE22ZqK/5Wuq7noiY9amaCNaDlgTb7/bX0hBawHzN8HjP0mzKec8nnMS8FqQiQ5zvmy2CJkClmdVN/Phfg1z57il/EFKJkqgKmds/MvcZT7xv52trawocfPh5Pna+UAHjtlZdx+tTJxsazAlrVZnomW8lcGP61PoThRyZJ4KAklVOjBN3qHmnvgwlXxq8eacVCcgR3jm/ext/ImMcIgPrFqCgZTNSVkSFLMoDlDSjRkv1USxLE2MO93CjTyn2zFnfZe8oGmZJXcivIHyoAUnU+Otd/ZUE4ukI4vrbAK6fXcGZzIYBnBvoAsBiqtEtrmGiMpzpleJVNJxVRMJx7EMZt2rQsG3X2BEQ5dl9u7eK9G/dx+/4S93cZu90II+yQRuSMZ41wjAZbpVlWPU4uVwZ5FFRVNz4j804BzILUcCR90ISoVU6k+8uiV2YHtLPITx+PcS3udftzajDqba+9Ykmy3huaiDmop1jZM56+zx6Lu075xBSRVXHVW1X0j4ZNkiNdhCXvvA0Ma3UVOc8VVObxL375m8ceBxhfvSFgVhNurp3BYrEQoD4UEahQugCIlifk1IAYLwgGbEsA+h79gJCkF1pa3w1xgoshXi+SPrnnLaoTum7Zr3cIfXRlEsjlthzIdgYMrRtpXgdNPkG8b5D80+AhkNfZxfDv5WBk2BMCd7e/QMeML+++j89u/eMhmt/D66WXXsLGxkazGljr1ff2D3PbA8ZAWmttGNvHtNoFrMzeA+o1aXUNaI2ZrHm/a1WKa0SEFydo0wcsaGtV8Mf6/WsO+s29wATAbYkK2SJgYxPte2pS/hp4bRn5jcn+W8c/Jrmf0lbR+v4WAVAzKqyRFzVSyzuvsTkSf/7WW29huVx+ewkAIsI//9lPmqVQKevN+9CyagNqLG4RsDbALxvVQNlTagXy7PZ3FpMJDXk0hDR6hDSomRlW2TA4xlG1qED05kVwpMRc80owlcBiM+ycswd+XBAE6N0zjZMe7Y29L0vGCLHkxZVAyuMnQwMP6AGL4bOXzFiO8Vg8Mp6DMWWW/VIBzmS18sTaCi6cWcXJ9RWcWAvoOsbKIm9eJaDPmxYybe9azp+T+nz38ECEuP51nSpy9i7YQ8LAIgC7SxYtIaSmZpbPUlIldAysLIAb2x1u3HuID28+xJ37S3RmXEnEwuUFHsXPXMJgxPoiELAyHNNuAp1jfiHlQkyNjVe8j0MIMyXoeV3rOBthgirHJdYD1QJRc9ePYznlvii8EMw5VoIuqsuBtw47a3L5mKm3DEk7OGo47ttKu11HWqZTtUeXcDlRFXl/DeTiZ2xuPHeDIVoz2Bh0Ts+1KAf1rXffw83HHAeY778VnD3xIzxx7BIwAO/NtTPDvSI9ADJgjilAUiEQAbnyh6EwpFPsDpu4eH2XQ/vPovcqIQiQP5CJwiCwk20Csf2uyxGA3PeypOvCgkniQvaf4wOHEUgMIHM3JAisDO+JZoGUiASCVBFkk8S7977Ekh/izs7nuHz9b9Dxw0M0v4e97euvvz65v94CMm+tqFV+PXA7xfhvLllQA3Yt48Ixo7oWOB4zWLM/9wiUFkhsRTdLMkASAF6v/VQTOfleD2DuhaiZ4s9Qq+h775ekTM0cseWL4CkGLOHTAtKeb0ErItGbjy2APRbN6I27R9aNEQCtsa/dE/azPvzwQ2xtbX17CYAzp0/htVde9ivL3qZJbFjJbkNty8AEKb1n6Of9q/T7yroEpvpnNhcCVIy+0DaYaLF/XdclI6Pq91eql7Xjq12b1Afv/q0Gz971ydJkYzRWbI4bAeF2btibcmrfLevraI+55rhbJXkaEiUiYDUErAz9ofeXuepfA3I82g5TNxiLr5NrCzx9bBVPbgScXFvB0SOUgDgDWAx7Y+kNQcgFX8+rTRaEbaN8n5IRP18TCsmgrssgPxh/j96UcIgh7PIxJJAjFLOLIFMd8vHs7DJu7+zi6r0lvri3i1v3u/QFRVuKt/5YlYrckMg1QPbsA1gJ/TXe7XhIKYjtN8bMsFZlBZoRR7Hn2G1Lcj5MmVxGktOQZSkS1JcSlZsziDYsZUKqq9xWeuw/gMbs8czDUW5iGhV1EmtDN5apXVlbxvolq5sHSUpUohKrSxqXz5n4xkyEswvoa8+Hbrhh9CaDqmsJi2tsTRJZzHX7unL1C3zwh4++UvB19MgTeGLzIk5vXACIhnSAXHUnUXVPLSxirrBMD0lXaLhv0nrR9W32A8HaP3cpVfz7anr8+zBg+C6vg/I6RFNiM0c4AneuAALVgxLU7oZ5Ocy7kAC+pgEhwD8GQiBga+cGbmx9hC+33j2U/e/jdeLECZw7d64K5KaCijkGZy1wPgXItyq+c0mBseOeSgDYanlrbfY+05PrjwFHTwUwVeI9FaiPAcbWd4yN45hCpDZekvCw17J2bq1znnLsLaBv2xmmJiWMzRvvePbSpjGnfaG5p69895UrV/DFF198ewmAF849h+e+d7YqKZeVDCJSveN260TeDdA4raLiYyeyNK9iDRCU+Ryk7DpvqupSYnNODeKjdoO4rtGoVzqDrV6LHlHYShlRDWcX302iYiLLuVn+KN7ryEzz//gEgxtNVmSvOf9JqHoDVOPQSEARcvrJRsbc7xLVIHI1EFYXhIfLDg+X3SC3LKuMLaBvq3bu3CFgdQGcWl8BAfjTs0dxdLVXGoShwt4JAB1IA+h42MteXYpFKMF1EKBb7UUpm5DZz0zAPmjioBs+L1AmIQL1ioHlQBLEiO+O7dzJxMBu1/sEJE8uIBm+MYCdh4xffb4NIsKNnV3cf9gVAGtucoK6HoLMIiIcWRBWiPCQGQ+Xfr9iDbx5agAMRmEaYFfmdCuPXil/oFUt8T6I8nOxyNkMcbsWyHvFAmq3OiSACNkNgAK8TvXIKJOgiEoJhEotffYqGHLbqdFm5pB9avxGhn50I2ymHVXIaTmmrqqgq1T0Qkg97mpeOSSD7uzQz0KXhBZrf/zp7bt38ds33/lagLDTmy/juVM/G0iBk1hZOWL8X0g/Y9SzheGwYUZVx0DswQeDmRCEHwBzv4CGsBj+vQRAg/EfhpQAHtY9PZv7dXApmgny7ygZeuSZwxRUqw6Jdagb1ADqfFNbQ09mdMtd7Dy4g09v/RLX7rx5iOD3+Tp79iyeeuqppuzcVjvHpPxTVYdTfACmRKbNMT7bi+lxqxo7N8ZvCskQ96oyQWAKYJ1KvsjrWKumewREDfzWgKZVKkxpE6mNR/zfEEIfQ1opXrYSAaYC3ylxgdY3otViMoUA2SuYn+IfUbt+LgHv+C+M3R+PywfgKyMA/uT7r+LEieMFeiKatqixrR+x3kbVel49c7SxWDaC7j+1PaUt8Oxt1Qn1jbrqAVUbVw1wpX9B7JXOOERLkGtKB0bBeTSBs60ceeZgybHYJT48cIMyAxtODrMABah8P42QPlbN7bYi1CqoRNW2Bf8BJCqliHF2BNsmIf34C4m9kL+TPAfS4wcCjq4QNo8E/OX5TWw9YGweyZL9aHIVSEpKy0UgVtM5ubpDy+hFtT4C/I5173kNf3Y2tsw6iZuWAEWucTlnXK8MMveOgDmSLLhzv8PRVcLfXN7CvYcdtnfr5I62EZu2ZGpwbA3epCmnT1YWlW1FPoozYv9eQMltCW8OckkAFLFyGVCwmNDJNE2oKKjFPVBJlhTkXotII3+8i577yoONI6Mkbn7uOD8jbKuD3ZAW973QUDnKplxRpbQ2jxGFssVC39uaWKqqhOz6TFBkdNXnhjUZ3J5JZvAlUST+8pe/eQP3tnfwdXgtwhGc3riAZ07+CItwBEePnByM9yDi9rTWIo5XCCvJtI9TlG5clMpVQe1hAmkfB+pZVxq+O1BA1y3L/QnLtg9WJqtm92KUK5TAfIwEhNo09z3+fSpCN5xXHzm4tXMDn938Na7deetQ7n9ArwsXLmBzc7NZEfek+l58XquK6BEL3vfMkanXKslTAaYF8rV+7paT/1zAXyMeLPCKUYDyVZP1e/3a3rmPxSbWAPxYb3xtXrTUAzWFSQ2kygjGxWJRXL9a1GL8fI/UahEarXjKVtGzVa3fr0lfDby3WhG8uT8Wm+h5L4ylTzwOH4CvhABYO3IEP/+zHwr2HKZPmaobSma90Zewj8yGyz6fmXySoS4byX9MIy5cnpFGUT2ClspS8zL0kgf5vugczbLyE0iAQxab2LxBCxT8iCezwfWIgHI3z8J8zgtKY7fdApawsV/m9Fpbg8Q25KqMoarmsNiea/Oust/a3ph63hXO2dXFhdxN/xjppBKdkCevBL7rK4T1lYDzJ1bxwukj6u80udObSwGcKuISmAcxBwLpCn7HoqofzfjI9zWw66w1EZQ/T7JzQTZY5UCq4A8qAQDYXcbNfVYMLIK5b0l7eMvqtlQ+xJaHP9x4gMu3H+L+boftXfbTFMLQr+s+lJx7q7Z+yfMEjxIIulKu4/ZU9RY21tEhLGqxo0NFMVTdR9knw7hk8GTsGNcWcJkAgOxBYhuUCvICjr+KbT+A53vJRXVbAnzuBg+NMSlmEa8pCGfHU0ARed4GWxkUtpY4dpMESl8SUvYpbBYuqdRAtdVMk4wqWE4cBHddMf8AwkeffILLn341cYC115HFJp44dglPHXsNi5WjOHrkaOrr713wbQWeEYZoPWEGIEB3EARAEO/rq/qLsEA2cg1ISgGSAD4a8w2gXLRE5bWelb9EaQqZqIzYyJCfbyTf18FSnNsPdnD9ztv4/Pav8WD37iFqP8DXK6+8grW1tVlRsHOq62Ogs1WdHKtWTnFQH3tfreI5Bczv9fceMJQtAMvlshkRWKuk28/xerq987YkgATlrQjIKa8a1qhVtj1iwTM2lCqAKR4FY60CrR73VjXdEkd7ce/3PnsKwTT1VYtIrN0bLSKoNp/+8Ic/PHIfgK+EAHj6iTO4dPGl6sCWvesoNtu6MmOMwkzOPVIfcrkhJmX55G2Q5Wc70VF2EyZ2YP797GxyYaWfpGO1jDyWUPa7x81YJ0yCSvM6AbxiFcBUmCFMwtjBDqpq7rKcNo+c1e6WLClgev6zQzyUbFdLNvXmvrlRlzvraFjXsdig5eshDRnZVKDlhjigtugYhwVnzikDKFQWsYo0PP749PoCrz6xhrPHVt3vi9X2IIkhymCbnAXLLqrdEL0nr7kykKssJJIwkGMXQRbQtxeEUDrwD7Wr5FCePS3qcY8sjqmuDmGNvlkC8TxeBMKVuw/x7vX7uLG9LB9WFZBGTuJEjcRsicHT7GkYDhKXS3dJYKKQiFiPTCoquLVKuzdHJ1SpOLqgk+AOrf+CiT6txKGyieyrXufKOplPb5j/A5lTELWOvD/2W8e1kuEpxigBRMTKspgPxRg3IkxtpJ9HvMAleuQPKfePO0aSTdeFmqUA+xt9ewxfXL+Jt9///dcSmB1ffw4nj57D6c0XcWTlONaOrCMbAEYSLw51yFGbiOB+KZ4ZGaRnkJDuLEWK9WRj169pYZGiRNENrY3D+pja55gyaaBYGRbPVAAp6i84BIC8X/NVf/jwIa7eeQM3tn6POzufHqL1gy5ura3h4sWLo6DAgiMPlE4BITVgvheTvzmy/ynAfI4x3kH83AOXseovf+9V5qe0MYw5wrck5taJv2aC1zJPnDIHxvCUp9CIP48EQKuSP0f632opGZPij3kQtK5b7X6bM6daZn1TUg/G7q8pZNrj8AH4SgiA1y5ewFNnTrsDTkZXKAvAzGX/OnN9a1NfdPQmx8RNC5McNl39crNXr04XfaojJodFxZh0dS7uNzi6vAtXNu46UGQD5WUNWRFge1hztY6qlcdMLEA7EcNKXjmBaI8kAAsH5spkYwssVQumHUsn7k7+zjsGjEv3yQI6Els8pVChSpmxrA16c4WbD2DdH0+ktfKvPbmO9SOE546v6n0h/Hslqp8p4Q7CUsnJzH0gKq7BVGRlbrms2gdxbSIckEA+Ve8Lr4CBmefePZ8ALEXlHw5BxsnFO78ny+n79yw7Vh4FJD5vV/zOik+64TgiGfDxrQfYfsB498udQq3TSrHQrSs8Jqkp4GF28jYVXXY0Q8wFoVGqbyptVS65KlYA8sElwyFjHZY9gSfSPflKUYOspmHTJ9GvPRMiWlHGLuZkh57klIqVfh4PmzHZxy59TCoJDNRYf2pmnXH+M6MKxGX7Ut4sNugiEVVnAd7YTINYwblkKv25wyVlXYss3bq3jX/87Rtfa5B2ZvNlPHvq51hQwNG1U1gsVhRR1M+bhYgKHEBDt0zzaaAOs8P+INUSDUf9+j2o7wLFWNNeHdC3AGRzQRY3GMu4vzTZumGkQ/r6+Bn9POgSPS2NPhP46TrsPLyNT2/8Elfv/O4QqT+i16lTp/D888/PAtlTqvNTZMweqV8D4Pv5ztp7x1zTa9oven4AACAASURBVIDaq47yiAmzS/o61XgASUYdfy9bASQAtp8pJdseEJRVe6+VYKqPgacKiccliaExUz8L0i2p5I2rRwC4z/PKz70qeI0AKHBeZUymJBfMbXuZSpjUiDV7HcbIiJpXgVWFtEieu3fvPnIfgK+EAPjpj17HxsbRqvu/B0xYIbyy/1C+k8xGxY2vI9tPXScQ+t66XJn3crYzqCllmjIqjUfSB5SIoGghaBtjJdOq+N54c6v/x05WtpHeqO8mA2llBYK1GzflDXnX6f5Fht7ol9V7VgALRlYtDQxVvndRQaMCbBRZ5lMqaW5llJQkeYr8SGK3ZiSkkODK12Jw1P/59zZwZmMlG3rZsZU8hCAdIhhfdnHBhwHvfi4Emw+Xcn0p4XdGqCRfBHCPgDwSBOk8qc+/lt+17HpQnqL/iAqrzbTgIp9vVCoE6BaEPJek+7dOOiADQm9uL/EPn97DLiOZEgaUPejGpr0gAIte6wk9ZeWDakqGh51jXPilpM8tzOZYrQlCAwXZqqXXNrHWGlFPIYOvCiloNDJ1rMrU9zJqY9JQ+BSw6nXyFTwW1Er1jj5BwrR+2nFIPrJ2OOuCdD3lVoxIbT44RIZNcSgqFpFsIj/aNc6n37z5Dm7evvO1Bmqriw2cPHoez5z8MVYWC2ysnxFRmV326EjquU6Z50XKc3jQivmV3yPJTktL53EOyW04KdOU8klEDgIgLMSjPN/bSmlnCIB7Ozdx5dYbuHbnDex2Ozh8PbrXCy+8gOPHjzfBvwUKLdA+pSo/ped+XyBhhgfAlL9tEQAtwFzzD2gByQjSI+gnotQOMEYAtAiUVvzhFHKiVT1uKQtaXhFj3+HFJnr/VwOmIYTCuHIKyB8z/2vN45YfQ4uoqN0DU5UBU+bzXu6tmrIgjq19/e53j5asfewEwIljm/jxD1/TWeNeFVZNbLMB8joEqMZm0qRNpe2ntDnZVMnvLokFY/RmHOYKebT7ObFySkX1KYM7bXbYCbe2UDMdIQhZo/fd5FYMrSGGdwNph2VDjkBXMZV5l2lzkG0ZVKuSi/HgmmO2u8mmosoIlIZ6NiGiWKBQ2pd5xd7OKjCiRH8gR1L7wXCtcxUTWF0hPH/iCC49sZZj+SDi8Aww6C+/BtopAgzS1I60kaQEaeJGlCaAgWIsn8P6JwCvM+bZaLWl4Z2s4ENVZqmI2IskgPT3sL4YDK1ykDFfzAymWlScR9hBJSZEh25mxpvXdvDJnYd4uMuNwv602Wer6DQi1a71gtq5paskBCIL+HySMt6XFEzuPZdxp8rVhIViSgKQ4hiHY3F61cHkrAP+WlS45BO070supFY3BXHeLqzTMMOPVxRrIIja11MxueY91Ab2Vl2go+gUNTEAUh2NG0Gg18ZQN1Ost3i0npllm0n+jE+uXMV7H378jQBsaysncGbzZTxx7FWsrpzAxvpGNv1LpP+yuMVzvGQ0FFwUJAF3Xb/OkX2eyLWMEvjvDfq4TwpQ5Cty+4FtC2D5LMuODUSE7Qfb+PLOm/js1q8O+/wf0+vVV1/F2tpas+LoVQajGduUgsIYuKj9fK6z/9T32ti2sUQDf48/T/JfW7vkGNi+/wiwamkDEvjOiX6dYjon/QQ8YOqpG1qxf1PaF8Z+ZoF/KsYMhoC2D98mV4wRGi0A3ZpznmHeXsmq1nfOuc/k/Vm7NmNpHq22n9qxfPjhh4/UB+CxEwAXzj+HF577npM5jHp11shFO2YBJqUjL0rTNlXz8zZuZXSd3dHF/mm9Ycsd67WsZwnCCL65EhUbKvKRqMOESKdrWf0VWUXDpnXYRIg+bDWoSmlQd+a2IBnwDK8sIIBL8nDh28dmbMjuL5UGl8wVY5fusZtyTX7YSMdi18vaNb3sl/cl/gRffq0i3GRsnFnAXj51BBefWEvSUW/96lIV3yOy9LiFWL23pAbrrO/g+BJEIz5FZkiTPCrbAbJ8NYIt7VERVIWs3AQknwWCmQnZ40J6MSy5w4JCOpdFCKldppfdhqxCQJQB9uMaiQ3WuM29/eL3vv/FA3xw834aEwvOLOEl142mCsBjOwvTU48ksG1K8j3lHGPXj4OUHL/3kjDxcQLEq0g8EWdp7+8g1TpkolSkN0eF/GDvQZXGomwriLL/TrpVxvmoVEadXiO96hTQaGvyj62+zlt/kErLgPh/7NSOa//dIpLiOpETJEgTfpV56V4bh+Sx43P7zl380+/e/kYBt+Prz+HM5ss4efR5rK+exMrqampdywSAdhQmss9RKFaHhZKA7R4lRbHKNKJOpEd04tkSivwY9Rnm+u3u7uKLu2/jxtZHuHHv9zh8PSYyaW0Nr776arNqLAkAD4zWSbn5rQFTwMpcQ7UW4TClBWA/BIA95gigbH+9BG3y5xJ8S2O/2nFNMfNrtR7UQO1UwsW7RlP+1lMi1GTsi8WiuFZSCVD7Lhsb6M23KcZ/c0wrPeXDFHA/Fnm5F0JgTB0yhQTxWjTs333++ee4du3at4cA+PHrl3D65HHlgFxUN+TEhex/Gcx0KBTVB71REaJG4aRfgjNy8bXNsPervwVLUJb0a8yVzbyWTs2xyuQ4REtvAl2t1Wi6bKHw5DqhrJyh7oeARhWIkpFSuRvJ2fG2MilAhrOjLRsP/NxsDX64lgPgkBq6l1WrMrjZCyWjI704Sa4SKFzNKwAzXnliDc8cO4KjK7kiKhPMOIHg/r8W2kw9V8uH/Oeu0xv+MMii5UOpM9F7cbSjNzZBm7hFs0Q7/8iKzR2VR9fJdpicSLAYNsnL4ZhWFkFd7A6MBQUsByMtSUJE0B/JixCzzwUBQKl1Q6QLiGOVrQhyXkjypRs224s+0Qt373e4em8X7355f6j2cTJ/89YYd7G13hCmB7+WpAGjhEj/Gx/OliiVrv3QxpTWo77Wy+6TbTbGsASsBCdqVXEA5JOb1dYncR902UndU12xSE2J1dnU3iDbFMRFCIHQLTtT7XXICAf36UEjh2QNpl2M3YnRVKrJ31UibEsCoCS4vUhUu2amv1HsJlefCHLu/PU//Ab3Hzz4xoG4M5sX8eypn2IRVrCxfrrv2edO0zEJ1APR+aTfLOfIQI+t6/ciZOYkhO9H13sJpFY1QwCk4wi60DGQrAzG9v1b+PTGP+HqnTdw+Hq8r1OnTuHcuXNV0DoG3moV4ilS+xo48RzVa4BnDBDXgNZcx/baOdWqp7YS7DnZ27+XsX9RXm375WWLQK1KO/UcWgBwChliyYEasBwjWWqkgSVLpHeB9TGwRIB3TT2Jv0ckTHH9b8112wJgWxCmgPkxgD7VW2AK6VI7r5q6QY6nF/d49+5d/OEPf/h2EABEhH/1Fz+ddjjsVyBqFSK7gyFd9NVVGBMh2JJy2s1QcNzSaxspLy6t+I6JBoHNAywICi2fTUpR2cPIcfEm469gFkGnaliOjwbxCUSDmtdIyzvqC1+CPOxsuJ2KnIXcZG/u4j2lwaNWG5SEhlKCEByDMy5gkwKiAihE6e6/vXhCnUcYYvfSJl7cHh5wh4rvGwC/MLOUY9ANvhahabLGSQ4fEiiloqpv5dYREEb1QDAmbxL4BOFBkcgJiMURVAD5gkGVx+bJnLvSWT8pc6xXQCXlIKkcAkS1GfhPH9yBZ8NGAvhB9FZbYCuJxlih1cCu9BYIbrVAKIINQYhKpZZYmr+Ra7KqYaQhFVG5nyqt9TKWMQR7P7ek9bJyX7YeyB79tEbHOmrH/frnDEmMUPW+aery60apQkftKYLZX75ry7r7vHOj4QFFx5SAv/xkkvnx4llbVS+By6W7sny88/uP8Mnn1/BNfPWxga/iiWOvYmWxjs21k0OiRfBGVpj7IVf6ubyDQkqcyT41QRY8kAkAsnkTzOJ+W2hzRmbce7CFL++8cxjr9xW+zp07h5MnT44C88lbPH689lxjBoVeP7Y1Mxs75jGQVTOE80CdNbWTv5fGf5IAkNXwWnJArVI/R5lhiYpW9d8bZw9gW9NBSYCMtX9YwiReR+v8b48ntgPUzvcgpP9T7gM5FlPIkoOa//v5rNZne2SNdw7379/Hu+++++0gAJ5+4jT+5NLLjYosq/5j0uWtVMVUJnBEqsKIVLmj9O9+oudNfnLRFRX2YNypU8Uabafv/D0m4ooc6byJs/LbAfTG2q8eCtWDcGiOBRrZdxu3G4p1SpJiwfiRqGI6u9Bc1CrdGbmRQG6VCRJgZSCZoo+F2ZyOFqRUT5Szl3NiQOGGL75XACgV6Rb9CGKlWXg/5DaGDtZ0Us8/60KOnCkut4isLdxkz3E8v3/14jGsLHIV1157aVgX5fadcvNuAYVeCk+xwknlFdOVe5EiABEnSbmVpEu99oP7PlniRS7a8v4j1fOfPDYrVUjb5yxbBJTkejD4iSDZ3i7dEDUY/zfX77Jbe0EisNy8Q13X3Y7wXz68U1ZbU2yHgcxOnzuJMbHRiRHoy3mpXUxhUgIgbdvTQHpkik0xIcUkaEha2wR24t4wn+IQnRpVlr3xpIRUVp1ke/MZZq2Q844otYDIL4nmbpDJKsLpHiYeED6PUWm1AFypmdPxUPZRsWq5ic8youxHYZ871tdU5EOq6r7e/JEwX7UKJy59B0x6go1mzcqbcnyufXkDv33ng280oDt65Aye2HwVpzZewurqJjaObCSgXpCTpsVEAvb8XlJpRiQc/+MkDLQYftYZUaFdS/p5vPPgPr648xa+uPsOtu5fPUThX+HrlVdewfr6+ijAmAtYWs7xLQf1MdC5F+AjwYqsnh8EALMgc6xHuhapJqv90gRQPsMsIPaqtbX/rgG3lpJhCkhvZcWPVf1b88S7XtL80CorZIVdKgRaYN5TzB4UATBljB4l+B8D6bV2AI/IaRFKtfP44IMPHpkPwGMlAH706gU89cRpDWpShVb3ueWeUyOnZSNapfEKvgXuBaimhtRdbpRHjABrLt2yR1NXlPX73f548recZCrmiexgbZTXxZudrfmHwsF9TyNKZ29dMivTD3TMl+8XANF7mirEA3APUVoe98QMde07444fTdmSuZmoXhaG6aqL1uvDztLo1PdNsuKCIsoxnYuUVcdzJG3ARe5N7wDc4b//5YvHsLroHfEBVm72HVj1K0sJfJW9jwQQee0XZNhhISsX/xEBv2Wj5JiBUQD8Vj01K2m0UWKeI7LtgVUSgfTaiGQgCJrsIynr1+C3M8AyjlEkO/Tx9T9fBOlBkI/3wZLx/354V5FCnUxHKLA0lYTaSMW3VgX2jErL1Q+6jUixGlS0LevkudiSJP7EEF6KRBI5hDXHer2W2yGhpAKR9eYEyJPyJRqrGbWNrPKbdT57A2iQLclBmVAiWwfcdZxqCR5UEALkpYZ4673arJXPMHYVXzT4KpjvROmd482pThBDcl2Wl1MpCiz55BxjfJ7fubeNv/v1m98KYHd8/Vm88MS/QKAVHF09icXqioj9G9qSPBm0VErFTR5HIjKgQzeY/pN4b+g/q+vMHGYgKgTQb+a37l/H5S//BjfufYjD11f7Wltbw2uvvTYKYiQY83qsW/FlU6rQbkIUsCfJ9JR2gLHkgim93S3gbGXRY0Z38j12vNXa57QEeOfkGThaOb2XWe8RBdJFvzVu3jh6rRZeT79HmniEhWdoJ9UF8ju9in8t4q42h6a0ANTaSFr3xl7meg3g75WoqREdtYQPW0xpKWGICJ9++im++OKLbz4B8D/9+HUc2zhqNm6uprt0dje90BoomBsmVXiEo7VnouX2cdKodF+BRKFCKE2z7EZOSMwNmFcgnuoVM50TnT9dRZ3JeKChzzACJUVAiM9Ii5kcAyNvrSYHiP/iiqOe3ZCTY9vNYvNdkCpsiAhuMXkCGivVgVaY9CqPyiLFKOKU/OpdGXOWuaKhxx66ItdVqgD/8sVjOLLQVdqSgxG/R+n2H4oqb3/eXSf7vjKRFoiw2y0zyBKHFMycVKDfXksntlGSAXEj3CE7Z6c2Ber7/+X3B2NGl1y3AdWK0DFjEQIWwXqH9BXfKP+P80ISFcEg8CKeCDIerWz72V0C/+2juyVAt/Jp249kTE0TseDcZIUTvClDF8toug7G4M+tIzpV5Ur8avoUgYIlMdpfb/3B0vhOx3mi8PqQfiixoE2Oa34nHO0L7xZxMjLmUK4rTAQShGMwPjDp89m0D8E5b1v9N+yrJgDLGEQ3CaBC50h1mDzWAM8c0THX9RQkYmDZPRA2CqHWJqp8nv/tr9/Ena173wqAtwhHcHrjZTxz8kdYLBbYOHIGISwEAbAYevjFRl6qU0SMcEjPgEhmBUgPgBBCNg5OcyX2/y9w7/5NfHrjl7h25y10/PAQfX8NXrH/f07F0QNQrb58Cwg9EDnlu+ZG99V+7gHfFmEw9Zw92bqbxmT+zvbz2x5/O3by72D21/HvPJBvwZun6vCc7O1xtCKAJcivycnnZN1LA0qvws+O0bV8vyUa7PfF99UiCqd6ANQAv50zNo1gzHeiNZfHUhTG3PznKBjGrpd3L928eRMff/xoUnUeGwGweXQdf/mTP8lst3HIthJ53RNbmuyqqklRLjFAhe3foMijL3puYSXfZTWlqIh5oLHi6k3NjZ7/6pSUV8uAZZWWRHsDiqg9KvpuExAxRnax5aIIo2JWDsYKfBiAoCtXOqqKREXVq4rZHG40xswaN8pYRH/MqY+HM34QFshyhQTxgZN11ubkxxDH0lZlJcj42bMbOLHmmJ8hm9zFSnVsCVhQacQGJ30h7+8pSfIJvXQ/kgLxv6McHuaUQppXg5TeSNNZsdkauCm1gnXGT2aAofAPkKA9HZvo35cKhvQ3cd6meRZBe//vrQdLbKwuSoKKtU+D9fyI14GIsOQOt3Y6/NNn24Xjv+P/BonudXSjbQkyJCFNA+ommgE2FYCtRt0hFuWa6/rye/e24eqy34O18RTrbHIwz9F6VjmfjSWj4sacYif8S6Cl0hLnxhYeICdTxNappFoK5N/36gIAY896SxJ4XiVwKjvadJFyT77WWwG+9WNBJKh/CzLDknYyhlSuFpKISfermB9ETquc8zz/wyef490/XP5WAb3oD/DksdewsnIUG2vH+nMO+brFeFG1AnstSZ1uV0pJGrE1DznVhbkbYv3eweeHsX5fu9f58+eb/f8tkFOTkk8FFmOVy7kEQKsKa6NRZTW4Bj7nvlrSf1v5thV9L+JPxgDKz4w+AR5ItnL5GhitAefaeIwZNI4ZM7YIoanVdSv7lx4ONlHBmgTWou48I7s5lfgx1Yk9n1qc4pzPnfqe0kB9by0HXjtHjZiQr+3tbbz33nvfbALgheeewfdfOqcq9lzRWMr+TrLaVGPSlbPRSW1suuyI5W7GbBVcyo/tJpttddnt7/cVBtbk2jMLS8WTIBQMgVRvq1o0SMhvSG6oWRQZe0fiEHIVV24IIeXW5hy96S0lsSYlqiwokQWPujQlq5NjDHAxtra3WVZUATVHpEyZHIxGpKX1vpyVtORfVl+VDJ4Lk7zgeqjrm04aQf7rl44BqZ++//3SKCLI098DaU5kdUF5H1j/hYJVT34YJWBXfeTCL6KIFhPHab0BYs9/xxq0LAZgFvuebUxZamOQKfQcK3N5XnXmwRSN5uKY/Nff38Dndx5gfSXg3/3waechDu0tAgOcYtVVGPH9lw/v6tYM7+Fh5pDA6ApkekkXFkN0LpmlNUbSp6C6wHvMeaW9hbm8rp0k8RDVJBmqaiJBEytkPDWKHs6YGhIBPcO0vJh70lbDDG+RyAI55+N7u0xCyOuV1kqhwihl+HAJH5uwoAluW60n1SZlWzvYXEsk3wOICFzAKqWs6WkiROAldjjmfnC466qKzn+e37pzF3/7m7e+lYDv+PpzOHn0HM5svoTFyiY21zZE1B+J60haZaEmUJcUTJJRiykucT16+PAhrtx+Aze2fo87O58eou2v4Sv2/7ek+N7G35NST3El96rxU3LjW0qBVlXVq1KP/WwvwL/WA1+rDMtKvzceEuxPUQeMgTHv+T7Xb0GOszUIHIu2s20jcwkkD8xLQ0DvvS0/APu+2jkcpAmgPKYaMK/N5b22p3jRkLX7vPZv2/pTU2h4x/TOO+9gZ2fnm0sA/LMfvTbE/6EiM3WOSki9pQs4uNjHOnFFKABENdteTiArreGs3JVid5uXXhtcd4ijSRWVjs6qUqxLS1m+79hCsyj5s9jMS3IBw2ayk/nDMu6NLEgmZUamMfiwSTHO7AoPUwbW3HEmdKAvuo3zU/JmwDXV8oC1m7tuNtS17GrZu99JiRecvl87HjUpnanfyQqbzhTvgfqPv3cUp9YXxRjqzTcpgM95Z1+VD7NQDXj92YzcJkKO0zrJVglDwMVKvFXXSJVCYpfJMYIcDjz22kuSgOD4MZA25StIquG7ll38zn5s37pyF3//8a303v/jR2dxbH0lH5+4rlFx0M9Zp5Vn+MGN7SV+9fm2USFx0WZj4xGZDaGEUmXkkV92mrGTeyFVD0U0nr0B5AUrksb9zZaqhBcO9H0UoTxvMr4ZcVwzEEciLykMD8jC5wJo5dhZCb9+hMgqdwZbLMmOgrS0Ujzr5KdVI+xdZwAtKwxPDVNE80mfBa9SwCLhBZV4RmcC28hTh0eqPptZcxajz/P//Le/xMPd3W8t8Duz+TKePfXz1BawWPSSfmYuLz5nSsy2gpE07xwq/tx12Lp/E5/d/BWu3XkTh6+v52ttbQ2XLl1qVhPHqvN2vW2Znsm/axnxTa0Ke9XkMUf5uVXP2tjUqtg1WXxNbm9l/FZJYAkCqRpAZR/X8gKYAvBb4Lfm6dCq/k8Z5ymSdWkAyMxYLBYJmNqUAUlOhBAKosN+ds0PoUYu7MWXYm77wJSq/tSq/xzPjTECZA4pcfnyZVy/fv2bSQAQEf7tv/iZydL1K2W6Sk4CdMCp2IkbRFX7qajqd6aC6ahhiwqPBdu6N5SqkU2omQ02SIJMKDiVJZK98VS2RbDeLPYtEJxywdO4dtp9nAWiDrJarHrsB6m8IEiilJZEtbR6fsaUXJ87F327tvJfVtd82X+NRCKj3S8JARm4RAVhpEAEUPgcyJ5c93dmbOy8lqTPP39+E2tBTAKLtITiQ5reFZ9POnJMRwuKXnrOKQIBQFiEVAGXVfGu48KHYxG01wLp6aqq8TDjZ70A2Cl7S1PA9CCCjhRU6R/Gu8AC5l9cvo23rvSy2Y3VFfyfP3lGJTkkMgPkqALyKC+G/lzuGPeXjL/55F46xuSzwXbzIMaBpZIp/0cExTp/Xc89Zi6c9nmokJtOG3WTWI8KXa1l0xaeL0RnH4JJCWJ61gQmZ0HuyDi8Vt58BkfSJ8KoTkS7TAS9yfdCtIFgIBJSxUSpS0hH9JEgR5MaIKhxl/3/vqLGAHcSxKhLBjbMaJHbOTrHbwMouJqi/YqMkkFe3/Q8FMQdmeeWVGnI6+Up5KY8z//xjfdw9frNbzUAzP4Af4aVxQqObZzpr9Nwr6To3eJBKEZQxcoStnZu4crN3+DzW7857PP/mr9k//8UB/m51c+p1dG9fsacY6kBwCnu9K1/tyT2FkB5v7cVffu59j0R/EtTvykRhN75tyIS5fvmKi9asYwp8chUjccAcoz1kxjKMwG04FcSBLZf3ZtrLaJgbvW9NS/s+c9tJZgz92t9+rW2iL3c47V5cvPmTXz00UffTALg7JlT+NnrrwBjafeiBSCQ3wtdVhqMMZN5k4q3KiqjXDWnGhsoKtB6WalWGz6v+uY4+3OlUkdeJS/2uJrdJLHYvIvNMndd6kEF1yK5yBgX+WPAUbroTCBPMuwCVacwuYzmKykfvlPASPYLp0XXMW9DY7axM2e8Vogi45vdUp6qRMp5UM0GV73QnHKf/+fzm6nanjaI7LC8QALPQVSSIOTzus+eB8f9vn8/G+j1v5PtAwTj7cA6Ni4YQkf3zeutLXe9lDtK8dkAOxulqNQHEQxybvGRVc3ewyDLoVmkRXQyOm0Yiat3H+AXH9/CU8eO4OKTG3jy2JFEHNgqrCU/8jgKDdDw+f/1w7tDzryQbaseRfLz4yxTHkEm8jyU0YMF2y5kxfZ+5SIeUCc/cG29K+a7UVg5Pi2SNCwq/TLhQdwIfZU/6Kp7PEcZxcCcwD7X9Oeyv930WGnvxfJvKSl8pDKH1LMjJx5UIrwaVfviuYA6C8JWyi/I6kKaD79NQJGnhEKhpNYx+Xxlv0VL/l27v63+SP/s2nX809vvfzcqwSsncGbzZTxx7BJWVzZxdG0DMomGvckgn5UhYPv+Dr688xY+u/XLwz7/b8jr/PnzOHXq1OSqbQ0kjQEWC4Bkr/pBEQpTAU0tznCquZp8r1UxWOf/1rnYsan9TP4ujnsE0DVTQW9M9mJqOGdMxr7bU2qMfZanAJDjIH9fiwe0xoA1UO+NRYv82CsR1SIW9jIueyEALInjpXqMrQm1tgL791tbW3j//YN/jj4WAuDF587ihxfOK6BaGE1RiaJt3FfKxLbyWUgjPyf2TZn16U2styeDQw6oC2P7QUx1JkhHa2P8ZDelsoLkSYOlFjyoanUGJ9bNnsElScHGjVxVvY3vQtzgq01mHqkuyeNJtSx0Qo2RZNTiBlmE4HUvuOZfRW9EpaLG0FF4YBu1CFXNlGNiQU6+BqGoprKzYeNKrrmnTPA37Rk1h0XAz59bx5G0OJOqvGszvgxYu46T4WPhxyCk/EA2ErTFeRmbpzwAWLdsMIwR2HB8IVBVnk5KsVLem7HqnjdFmgCR6QQS/DPD1EzZVRDI85Hfv+zyz3tmPAzjzSqiUF7b+JkL6lUA95cdfvHJtr5/AxUVYjvXrSIlUHnO+qFBBTRUhp3G4EISNzEyT5Ny5mGqYt043QPFg8sA6074kUhAU3ugaNk7C7Ix5WgWIaosLEjz8cGtOIeh57pjQcAU7U5W1sdqDEIglyRkQRX/AQAAIABJREFU9yFhsRyXhK4B1TapRikkiBJJa1gcRURYIrYA6GzBPgqwTw4JjkQaC7KjSMXJKhDJerrPcwY++/I6/vHN7wYBEF/H15/D6Y2XcGrjHNZWTuLIkVVFAMQIwTT3ADzc3cXV27/D9cM+/2/c69KlS1hbW2uCZQ+4TZHs1yq7U2XPLdA5t/o6Jd9+P4aGFkyNAfOW7N8jTGQrgKz6TyEAxsiZvZAs3nulIkEVCCqRfnOPV1b9498vFouiB71GCtiftcCuPEfPKHLf4LVBtkhiaS8EQO2esPfunOhLby2YahoJPBofgMdCALz03NP44csvOGASQiFHBvzVeqY02HbzNDXOTYZOuV0g9q2jdG2XC5hXyXU207KfNAiiorZYRhCnkgdQj27yhAPKXMz042dQoeWfQfQqM2t9vJWLWx+EXKXIElLp1E7K6C0egwQKZIA+TE+4SC4AhEeCHCcpkyZVlU+ScVFJVkqBVr8PTJ88yjzvPCf15js9qAzIl9fH3RCIbOg4A/7i3ObQFqGBuZzPgbK5ntiS94SB+M5e1k+mD5iUu70GgcM4MhmjMFLO/CrBgFlJ9TPRIokKRsQ0EPPVSuy1pCufS1LFyIc56Xkke/2t1DqI3oRECmBITxD3ck4W0HnwUlWh2yp6n4H/8fGWBvMhGEUNCvM1a6THg8yBqoViLa/IhoiVyFFbBTcbuCB72w1BpkClIJnifc9mAxZJvZosHqL1iET8pF7nbd65NDZFyrpnZxzzteoG9QCJNhg9b+X64PXKyBYrq2KK62Vcx1J/aSJdWFfeKyRjMa+BghS07SOSzCksCSp8RFz/3FYC9n1xbFqAPD893lpiwEYFFzkhZuDzL27gH75jBEB8PX389WHeB6wu1qugbXd5H123xNU7bxyi6W/Ya21tDa+99tpoHro1/2oBgBYoaYGavfRTt94jK+ZTZeo1INTqk665oXukgwX13jm0yAD5O/vZ0SjQI12mjrPXi19LDrAy9tb5TjHB837nVcgteLcAX1b6a+kB8mee838t1rA236eY9dXGrjbXxtpvpipdvM+vKSimegLU/s62pci/fRQ+AI+PALj4gjBcy4AvJACgKzVq0ybQP0EDLc+xXYLQJBe2ksdUzdBRflZpWkTcoVDxqmOWlfC8OdamZrZzQDa2sgDLkNUjawtuHN1ZbN4WoYxQtFWsTpgU6Y2l7bFmFSWVz0G0Fwy7TNl7XWzUTQVcMnRyXGReva4s6Qsg/zZVzLlUMXgzngzgKf0gdOycrF+SuX523klZuc/aDqZ7QloQJfJ//twGVldCklVLFYAq8pmedAaMo61d8DMp1QlX/h60+P4GuRKKwama1BxjzvMsDGC2k9V2ZDM/qVyRwDwrV6Ai5OJYkiHTavGB8fNjS8qSdXqBqgAPPd9jpkeRJOCBwNB915TG8u8/uddfTWvWyI4SqaKKSB4lMgnEVL0JoZCLh4pDu2+KV96bFKL3gJ7r8j60hIX1YLCfr4xBnT4muV6jOEsoIimeo7zXMp9VPrrUz8m0kXE2NsnzTK+x8omoN4L9zxfDA1+eMxEKcggV35E87tkEtlAHcRk1W6yhDuiXJKm0xSEvRtKQ5Z23aYIk+zQRWKzrw3csIyEkyMHPvriBX7zx3SQADl/f/tfp06dT///UKuzcanG1cFEBG/t9taTuc3u3W0UwD+i3AL9n/OepK6xCwKviyv+zgL9F0NjP896/FwXEGEEyt0fegnQL+K37v00EsKDdnrMkDlrGd/Z4bb/+nHlUq+5Lkq12HHOuQW0cD0K5MJbk0DrmR+ED8FgIgAvPncWPXnlBV4XYiVYrNjRUVLzVkYs6merd9DZW0D3kcnPXKdkzqf7PjlmDL3OQHhkhQb51SPcnhflowZSkzVvIn985ztz9/3QK9ESzslyR6SW7KqOYDGtZyIihKrr992vgHg9YAtBAhGXs9ZXxSBB58qpWJVUfOpNc6ySQsuEZsTo4sJPJ8Krv7+2W3VC5jL8Jov8+R9lFEkP2H9seahaeClBRW/mgSpkwu9dcbuTlffDPz20irg39wy2nBwQFYilXszvGcogcjKC9lA/a7xbzE8M8MTJ9Oe/je4LIDU8kXjwXW83sHO0DQRvW1bwhhsSAjmWx0WdQA2n1i3T/L/qxuS7PIscFPoL/RYiqi+xHENUGf/fJvVwVle0SzJrUYA+oanLAqm08A0w4a4xSGlhTzUSE6flJiohjUxGnRFqqhzf57VUSVHpKG+tOT55zf1Jq6ftcVZ5zJEwR7Rqj/tQklGTf8Bk2DrCMBuxbEVIMoYms1F4TwCLk+WBVP8F4H8BU2b12NSgDS53uIRVNcEiQonpvWqFkqxRB+0EoYgBUeA7Yx66de7Xn+afXruMXbx4SAIevb+dL9v9PqWTOMTerAaGxqLipcXAt8OUpDaYA0f0SGbWqvueHIH9uJf3yHLy/seSBZxj4Vb8OYmwtSPYIAM8IsFW1997fIjEOqv+/NR5jFfa9fP6UOMbW8UxJS6gRYd5337t3D++99943kAB4/iz+9OILLpi3VQ2vesvsG8kpaS3l3PVOVY3F5lPIM2UsnZJKQgPvYrQKEFfmIBGqfoCuzDJuFqW7O5GUpgt5tZCPli7M0eU0pEUxCOm1cqojbaCVnawpfZaUgcsEBAlGcyV4qMUSq2PL8v/6g42EkV9VAiUAs60WYzDDk5VQuWmWLt+Q8l8DiGw9sWgFKPfyxfUsyCfovm0aiBEAQyRZD14WgfDz5zaGBXroY+ayd1xK6RcU1HWQPewhRBM7ae5ns9dLE8oCkEHkyguzO+U5IY38pDN/MVh5AIOa6xnIS1gkkwIk6ErxhKRbCjrwIO1HMhBMc2A4sGWSMsJdd/R6ZBpCHBn3P3yyjV3OFWBmLSdRPewEt6+aWbMhiWAjKojHdC2isSJzASQlUJVDn+NBoRzfpamhKzF1jVFttKbZyArH+fzQJL1uWZ8PqS6I6zSz7mPnkqix4DzEGDZSWbBDksRgnDpc2agckvNEpgvke0Cb4ln/GAt8Y5VfmSJ6DzBSo6SUBIpcKxJruHpZ4HoklHQMIz8zraJJqTtsRqG5l1vP80++uI6//90hAXAQr0CEF58+gVeeOYVja6tpfgdEFVRWP6Gnu8EEXLu9jZtbO7h6ewfbD3Zx8979w8E8oNelS5dw9OjRSSB3CvD24uE8gOwZCNacyceAe40Ut2Z8U+TtLTDYAlE1aXfN8M6+z3Pyt4DK6/uX/64RAFONHaekPrQMBFvXcE41eyyaz5oAWqBupe2yYm0r+R5p4IHYMcPLOeC8BaA9ks0e2xg5MOV8pt7n3n3ikVlyzD0iIP773XffPVAfgMdCALz8/Fn86JXzZUmLtQ2dkiSavniIymDcE+peZZQ91zIaDNSsxCrwzk6VLvbqOkSFFwNY7G9tFUYgLmviFHtwWUiOCz+DjrX5HeQiRplEkVUrll5hoiIofmaTimLVO0uFya0yxSq0NSSL/73sOiwWQW+QzcNMGhumtgxR2ZNtDTKasa/OdolEyROHNOFDnBQJLOIOkyQ3bXzLlg4NDlnLa5ExiifTlRMjfn4E6bvL/rgDEX767NFM2CTDy+HzuzxHF8IE7+MbO1h2jPOn17GyyHFoeo+e5cbKaV+kCwbTV14+CEmRL9I00ILsvBBrgiC3/OQKeorVc6qiZdVV+DvIXn0xJ7ICxhaDZb97P4ZQ8y1f61jJtkSBPMZuUNv8/R+3sOT+PEIAlkvWVVnOm3dGqQaSlf+cK0/Kb6GzLQ1BknEoQLWNDJR+GkRSIhkNSlElm8jpedetOuIaBzISchsjiMK3Rc0X6Ng5tcGLbTFChcLQRqXxeGPeuvz8RcipEFIVJVVMbOIkCVDRgfpZBG2wilK6r4hFdkMgmkoxSxiwVBQ5ygKb5uCafhoewHuGanUblBFqMmK0z1vxPE8EKhE+uXoDf/e793D42vvrmZMbePmZk/jphbOlV87QYrUYLumuUHKF4b7p0KeGBOpJgSu3d3B/d4mb9x7g9vZ9XLuzjRtb93Hr3oPDwZ7xiv3/ewExU+LEWoCxVmEcq8y3wLrs86/97VgLQA10tQBUfLZYkNhSA8QKvkeOpNbBhgKg1gJQG6cpUYYtk8YpbRVjIHIqgSNBu/0e+XOrAkgeRuJ77TXxDAPtv7357pk6WgJiyrjW5pH1rJjjHzD2mbX5PGeeT73Px4iSg/YBeCwEwMXnz+JPX32xzprAVhDcWmvefAtzrxS1a/rGc4GFCjduubnLksqG6Z76Q2PeQdmBnwK57QEaqFf3S+lLyGhkOQdsa0d4ARp0NVSYQHW9bpkqDtsJFEqwOUjLF4uQvpvlBhtC7juAgRBCktSzUiqwrv4NDeCxGh8N3+zNEoiwXHYKBMbrpcicprkf6+pV2uCSrpyqJtky21pVy0mbdanPBWBD2bnTmeNxLKLaI86PY0cCfvj0eqH6WBozkEWIgKzfhv/V+9dxe3sX/+bSE9hcXSAYQzUW1SFZZYykyrJjYQqnCarU+0wBy0GREGepNREUIo5CnVOLiIvzR0rkZb9+dNvvRDxeJEuW3KVrIiu1y44VeFWKDtEWQMhGg/HYdTE69+knkkI9jPu//e2VbWzvcnJwJ+HfoaTgAvVlkoo0IJbEoVQSiSjGHKko1hDjY9J1XFSoC2KKy3UyegLwEL8Xz1uSkrLST8GkEcQEjaztL9YlZaoof086GSAdl1wgzdwmzlGLiUBW66m4j7MFgPKSKYmaoL/PRLmnZ0aX3AezwohRY31LXxtvgxh9GcR3xu+RIhHZYlIyBs5G0nsAStJbnGdWhmmQqdjxkfg/Odc+uXodf3tIAMx+HVtfxctnT+HiMyfx7OnNRDCbx0l6rQLoAOxybrFbGeZSJABWhna3JTOWA3EQydwlM27cu48HDzvc2r6PG1v3cXfnIa7e3sb1uzuHF8R5nT59GufPn59Ujd2Lc/sU8F4Dkfv5PCmf98C1pwSY2o/uVT5t73aLuJCqBGuUZkG/NQO0/gAeOWDJh4MiPKZc//20V9RbG6mojtc8AaxCQP59/AxJANQMBmtA3I53iwBo3UPe3J8658aUElPjJz1yxpoDzr1Ppyg+bty4caA+AI+NAPgzQQCUgJ+KaoR0U5dAO6kGglddc6qIntO/AJ6qekgVUCc2Q9KkzjORUyDKSyQQm2alOoBuT3CYB200htyD3oN8tdsHyInz4lxFSmZryH3msirOjtIhgRYIwkP+t+yBNX3I0Vk7yXNN1UqCIBJ69eSWrkwWhjliEwm6Suao0zOsLh2jjPOTLu2cHfLlnHIzv1HG9sX3MgbGVZg9xjnxp8+sY5VyhZdZm4vlBUdXCrceLHHvwRJPbq46i6Mhm5yNer6H9N/ZtIDk7p/GsgRp+dhZq1cK4MvZm2GQ7odkqGYXSlJk25I7cb10C8GyGza2w32nFnNxTSRJEmQkmtP2kcwMu6wakL4IDzvGrz/f9iu+nU46gDGaM907he+JvEesykHjOXb7scNwjHL+d12n2nxgN3hSPSQq76BMTCazN1vWjgqBIJyvKaqCUJBq0jQzrg2WOO3d/UMeo0hcCGWHiteMpIvIVJDn3rfdyAikkFUShdLDrOfDcXSdVpmRUSc1WyhsRKQE33IOEos2jQrOl2b8XIiN+vvKRv6hJKGlr0FSM4VM4jChbI8hh+hznuefXL1xSABMfAUivPT0CXz/udN48amTSh0in/upbYVzDGuIRsDDsyPTYv3fB+6vYJc8cPKHdpz5MhKJMZF4v35nBwzg1vYDXLl1D3d3HuLKrXu4vvXdbiV44YUXVP//WGV2TPJvgYNNEJCgdS+S/lpFtVblnlIBn0tUtOL9Wp/t9ex7n+8B+jHywL5vTizglBSEgyKAZgG7BgHgzTM5v6xHgPd5LQLAax2pAe255zOFKJqiLJgSpzjld/LzvDSEKcROKzrU/u3Ozg7efvvtbxYB8MrzZ/Fnr76QvlLJVolMlTXHLcXM+Sz3ze/RBoH6wVW8j+qLoayQqMgsUQYh2xogUgxUhYXtQ9Ts9wvDF8iylImvogL822zqVBIbtP29w3vIMnwJVJ39KJE0ghpMv9iYAHKXos0GHlW4YUu5q6zmDWZ74toRAFqEbC7GUkZPqlrPKrYuR41l+Ve+rqGyoOR5E49fGwMwWysAObakrmEknphsBF4mRXSuNmSp3PQHsz5fAl44eQRPHl2kuRb7+RcL4U8xAALr2J0aPopIzJL0Wg5eA1HCzQL4d6yJHpb95laFwRl0yr9L5ntC1r6bpOMZvMb3yLQDfU+WffdJLdKxaQmIl4BTa8EiJR/o+QDo9omsYNE2/zatQo5x/H1URBARvth6iI9uPVTkmbxXpTEfqapw9s/oBJgOg/IhV/pIO9UPa2dKZ0B/cyqyTvQ8xtNZLrNCgYzbfTTMlFL31GoRFT5g3S4i7qdIwMT1IL4/kFUssK6kD5V8beoqHPGnPKCsnwPL3npp8pcJ0jT3TeSLun9NRUxOSGu/F9cXeQ3Y/TdUGk4moiAiVSE2qZQTMcCF74ZkBPSzjpRXgSZRhcKEoQdatFF0dg5rBmfS8/yPV6/jbw4JgObrmZMbuPjMSfz4pafzajP4t5CTKSp/Hu/jBREWRHgQ1znSrWAL6lUAHGeriOcMAwmW71/OySYMLIZ7YHdYW0k8PK/cuYftB0t8enMLt+49wPW7O7h3fxd37z/81l+3S5cuYWNjownEbbXQ60GeEn3WqiTW+s9bgKlV8ay59M8BbWMy9pZk3v6tBP+SELDrcwgBy+XSregDSL/zzlOqEGR7wKMwPXxUYN+75rYPvwamZb+/VH9IEsBrEfBiAWuRe2MkU6vyPUcp0VIMTCWx5qgQphBstXvbSzaoKQziv3/9618f2Bx8PATAubP4yaUXRUUXopJmeyB9qSRDbo7I3YtQ6eSmYK+S1rMFfWW1Rv44gt+0GRMAKhMDAuw60VqyIq6jvY3PMpmNpQP+ZdQSicoeLYYbGE5cYcjRiHqjrMG8rsQiuUKTUh/EcYlVryBIgHJBDSErGyQgVtfAk6eawllayKKKIkUChsIIUO35WW+acjTYYJZkgKJy3RdSSdcNECYqkoV8WCkoqJgPp9dX8OKpVeNGrkF4iP30PBicxR5ozv4I0jdjEXowlhdpFE7mgQi73XI4Nu38b+8BEpVgIcJRFao4PjbdIN4zOSZQgExCEffnOqMP37Fk7TWQ7hyBGQOF4b35s/o2h9LgzUbxSdIj9X4Ti/lPWIQ+DYCVuRzhw+sP8OX2rgJ3udLMko8T81CrmuQ5KxM8WCWHBJzIaqZ0LZBiCrM6QkoeSSR55Hs/gniYtTaQ423CvpKBxWeXaxgUcSPnESG3b0infm1Zl5MrgqyGq/hSkdYhFo5ApFQjaXbESnkw96ZjskqDnNqa3tloxH7ekIpYjG0ZsjqRAbaW3Wdyma2erYiIBLwwxNj6lgedlQwtj39s35HPic4mPsD4EZj70j7PO/E8/+PV6/gfvz0kAOyrl/ifxMWzJ/HcmWOqDY4oGx8nYk0ocGRrUZwnAT0wXw4+SfEidMPCsxgucCDCEkJgwoxOkLe7y04pQVZCT4ZHL4Ew/B9R7/vDrGVPcS358u4Odh4ucX3rPq7e7tUCOw92cfNb5DPw6quvFgRAq0o4BTC3QH4LiIwBgr0CV9cUdgYYk59Ri3EbUyZYYORJ+uO/PWm/JAC82EEviaFlTPh1f3mgHGb/LHvOPZWA1zLgVaRjS0BNcVC7trJVYCwpYIqSZi65MBY3OXY/T7kfvd9NMYesEQDx9bvf/Q67u7vfHALg1XPP4CeXXih3Dx6SAsQGtJRl2wMuqq4oZdASaMQNrtz4e0wn2c2TN1jGATn154ljkWbUSn5sNMNya1qbxKQ2vGVMlvYzEHFxae/LSTpoBa4kEwFy3TFLXkPedMeotZxV3w396QHdkESAVLXMSozOSOY1GGblJg8GSiP5gYEcNsZRiptMAoXrdpLbA2WkIqliYAaEDA0+ZUUsPmBU9AynGMI43pI0sNeTxUISCDi7uYJnjq1Cxh7Kfvf+vYyAkEDzIpACd7LSqKqC0OZ1CwPy2QADTRSwmqPMZbU1m/hlH4jo0L8IIiLQ9rkDBfCOfxekP0DQXhbxfNjIa+TfaefyvEGWBKMUCSlfCuF1QI4LCUQU5rKTfW1I/766tYsrd3fTOtAJ8B9nrSQAJWFmCUOoY9AkmQkNAERlWPo9ZMJDxCJBO8xpZRLlTTz57SFpnQNEVRrpvrReCpD3FwYHfuoJQ4KOi6S0lgQEyoA/B4lyWlMjoWOzXiDAURJIxe8SPhcpZnTwwKBAbtysWh/sgqTWMbGxATT4Z72GkfP35MUEstM+oiVcyqCwAOji83SiilYesFGlxP9QPh8oP3PK8/zy1ev469+8e4j4B9D/7OljuPS9U3jx6RPqMsX10qbTJONURQ7qGNgFlXulDjpKMq+JwG7HA4jPBKmc5/EZtxgUV4gGvcPnL2JLDedo3ziRWRB83TCxF9G4s2NcuX0PO8veb+Dyl3fx+yu3vrHX8/XXX8fq6qoLRvcqdbZAdKya2fqcMaO4KSCpJdMfA/AesJYAvqV4aLn+1/r17SsC/rg/9fwBap8/t0L8dSUAZOVf/t46/UvwTqpFbqHGYWVlRakvvDaBKSC89f6xuTrWdjFFETDFQHPOMdXuvb3GILa8BN544w08fHgwCqvHQgBcOv8MfnLpxXLQjVlajmQSbusKJJICZuxsPFzbQMqVeimFlP3N8ouUFF1uaYScN7VIGhVBWXHWPgHs7NTIXgkZ+cTZdTmIOClOFTxSUvC0wWQN5nrQthzOTUe5KbCLLEWV8vAEwAZJvRCfK4DHgz4xbiSYS2lFIE7gXrreq5aBiipDlUIFKMNgDkkR7DiZ5BJAQKROQCQmyLkp205YxCUoGbft9xcV8+CY0D21uYLVRcCTGyFt5CT4S1JgMfcTCDIAsJQ9Q7l1hwC3Kq9aGqSZoXad04CUpDEhF+kXsZIK+VEmMYCGSSd9EJTHhwCYgOx35aJ3WrY6xHsju9MPGwDWsYDxPvv/2XvXX9uu6z5sjLn2OeS9vHyKVxIvbVMP26Lil2S3LuqHZKNujCII+giMfilapEWKfm7/hX5v0cZFUqBFGyNNm7YI4NhOashxU9vyE7Fl2pJsSZZlSqIoSiYpkZe8Z+81Rz/MOcb4jbHmWnufK5riIbUBifecsx9rrzXXnHP8xu8R2S6YDqASid4J65+PHhpx3qDEEmk/P/vSgfZzpeduH6itlRJGToyN5ABKxRpArBOYzRNRnuFMHr93Gwjjz6sbMW8he05iYZmLyFjwRmPMUhi0+2lhl7zwu6lh7n4qgqKJCAzIHaeik8kBTmeOEZhGUp8boKgNQFHpY5LDva5jg2ncFUczQvXx8DlvmS4TNxgxNSSAXwASRc8NKLyxE1MlMWGW9wHAZ1GKsACdJAEBZD4SDIADHuex9fyzz3yFfvMtHAOouv6/9vgj9K6bD9jd38Y+xfV7qAXN4JDvFyaVeXTwjOG6VkgGmAG4LrDfEZDZzDYPUwg4FhHaKdDZDxwBOekD2qQ8pRX8DRB25HXiCKsdeqfkn/zOZ+jzf/nSmwYAGBW1xzqGW53m3NHOhVB2P/9GgITLmAyeqo+/THEtMo6jRQaBygFGr8NkgBGYgEDA6DyPjvGvggFwStb8awkEjP470rBnhgCOp9HvRqyANUBgODem9/pGv+exzvndgCejzxh5WeREhDXw4Fgc4Smgx8c//vGrBQC899ZN+je+5z20ljueu+REy4g1yt3UbAzHPPxCGLGHxYZuZmbQFONmP+ek8yKHOUZ5tfctgd6sx+KavRiR5J1nCZnLnDeYNHByDucnT5wUnPvjpMhR3w8bT4/QItPwG22bPE5r7nor3KjWQO3RT6qBOmzafVpuQAs77RWpjiKu285FSKCcwsVxbXcqDEu8eO6cvuzkBdAJO31JyoG565Leg7upGTPRjfOJ3vXwuRdWTPbdHBjpG7GwmaDFPePGdBrL58yMKkRnhcO4QBCtQnWNUW1CAiaOfh3QBA6vFW5IkQZdQTaSTayQtZB19Pm+0Pux1nG0IgJyAmUhus7jgVvmOd6zgv31mECAG3g9dqGmtdVaZ64dcCquN1ffg+agT/S5Fy/o5YsK5zECMkJxbtDprAKrKdyjhPGN4InBztrB91a5jHXrpFpnDxuEBWi/XswvPSdwQatATQ5U5dQ5x+MxVkEpjWWgrB0qpnFXYKB01HaueC8iUOzsoqK4JpeQTGB+HwtT0krMk48OKLSDGSnF4hvnL4xALMAGUYZPlcyekOjino0yUZ6WZGhVaAEILLp8eO9iMgL5eEKsj9J8HxZlWHIXyjqQbh1bzz/7pa/QR5966wEA73jwOn3nOx6kH3z321cMgn1tWY6rzC7xM116R908TWwDDr4PChCoHK8/d+7zysQR2DWwqIO4xmrSOEG9dzvIoEyfOSQHAfvI9glNNjB1qZFOALupeZxc9Hng//ytT9GXXrh9ZQGAUaf7lM7mqV3FnAu+pW2+TIfy1GL+ss8fFU5bQMZW/N7odxkcWDMHXNP1j95zRPs/BgDcjRnjsc7zZcGV1wIAGGnaR/r+NdYAFvN4zjIYcGpxfLcgxzEZzTdyLrfurxGQciz275R7be01Vw4AePzmQ/QTH3zS+7BCC235QueOdMSkj81dilA4jG4wikZ/FTaZufmFunfsOOr7BYr2wC9gRDGPGlgJXbFME8duXb5QnItk8oxvjHLDTTuCBIvOFGy40YCOk6v4QudbKxHE/pFQMFokzAQfxMHhCTN0FwpE7SAxaoFrjGDzjknUuJdklqXSD2MldDTGCllmozgSZLVzMtOSwRiTgWcBvu8kB4zaAAAgAElEQVTNaxPdsyv08LVdOEYbY/17H2rr2GJighrB5XGvVHtmfU0/NjVvhMIt+xm48V/U0GvEm/oLaFG5oDRpgSmjjSoACeSFj7uM+z1s1HyKCR+cUj9quJ+g642bVeu8JzlBGc9sDh66EZpKg3Q+UCNB/D6ZWxQTPuCc9XuppnnkhVdnupgrffnlg3XsBbvz4OcQADkazBv4faCwxoJPi/Gw6KbA+XyL4/3q0YUZMCG/50mCxEq7gQj05MJHgTE1IWtzag2+AGH+Z1pEqUZQFyjS6fdWMBdOYDLIm8Dfo5hvwwiAjvGZy5Xb511O/hmyQIxTIKsBADAXj5gDI3MayuytZG4qFENA0dgPi0wERRPowMgCA1PHU9bzTz39ZfqdT3z2LVH0q67/PTcfoMcfueFeFCIDFtuy+18oMwp9f1LAj0OvcwEQoWChw/qz+/I0AJxIave8gGbA3Lv3h/77zBpTtoCvNZCsIdFTwz1U/GsrAIDxvbXf0XObUOgf/H+foK+9crX8Ab7ne76HdrvdyUXFKZF5I73wqJt9arzZsSLklNi1tUJ47fej4ueUwiZ3+NeK+uwlgMcxkheMPANGXf4RADA6V8cy6i+rVb+b9IWt154iARhp/tUPAL9bjgjE77z2vltjf8QcyCyOLZO9raJ7bXxe1iPgMmAAehpsgQXHTDrXEgRGgNUnPvGJqwUAfPvNh+gnf/D9hiyH7tIwPogW1GBZmLMt69Nc+A6/bfpF3ixlJ3BO6vy8GYr7ukEMYfrsqOxdujVrAYLFktH7RYLDek0yAPwMjCt0zTVSTL2TWICyxwMpQtCDB7AjZlSHNIXhvkeCa7x3DPM55tABtVx2vGkKLzSrxPG6MStbof977okAyYSNoSODdHgOXVoOG2x00J9rilRhonc/fE7XdgXc88vCjK+goz6h6z5osDCLPRiODa4XKaugfdah1kAvzlWD+0dIGAs4Dkv/Pgc1luSov/eYxjjUa4h/RI+BdI+CiZgEkz8BKQMnT5B2XVW3j475lSh0ZdFvoGlm3WQOabjEOQmB7Xzj7xXQqNAlX9LABtVhf9zeV/rzFy5orhTN9RLYSBTPAUaxh89QMETSwikxxtLNFiOFMpFe3FSyD3Q0PF0S4N3/IbKXBOYt1+HHSFcJBn8ExZB306vdNwyf5eCZ/w59IDQBwBbVHPGaWCc5WSVwSpLhHVEqnJdXKoASwfYE60HbYDm7Sb+Hzrc5ySJ2kteXNYwxrOkYJTNucpqOFf+yuJ44zyHjYWs9/8PPfJ7+4NNPv2mLfqT4P/Ho/Q4sBpBfwMyV43zUwcYKEg4DRDsQrEa1ehW10z4EA5hpmto9O/f5zQ1sm5OlVAkgPSZ/KCAt7MnCOgZm80tRX5rqfkBMNM9Cwu34Cve5WOd0kNBIGqMqB/hf/+XVAgGefPLJBQCwVRytFbyndDEvE5l3Sif5WNF0amF6rFDdkjqMnjtiO4yK8jW3fnT6RwBgmqaQEDAq8kc/r33HU6jaxzq/l+kMXxY8yIX9Wud+qzAfJQhsMQuOAQ5boADeC3fzXUfXa82j4jJMjFMMAXPBnl9/qsngSJoyOoZPfvKTVwsAePTB++hv/Jvfv8h9p9Th882sBE0wL5rHOa6KQkGh/5lTJ2qhewTDOYvvw81aoEh68Vw4FjYCEWMZwBj5A4TBKeOrgAh64WgktSjjQiwdasKYXPvJoWATKNrUVK70tmnoxHVdv6ROoHXVBDTyq9d36Sgt4LYeCxkJXRNkPajRGHPpBU+B4otpnt28CIuYRoOmBdA094hBSprHWMzQOKGAMDvZC5cH7i309us7mgrbJtknBR7e3IUjuIMFlW4y5z45TCUWT+Ee6tp1Sl1+7Mroz6VvFjM1ePT8XDDyIC9d3xMd6bHIqVXGEYqJqYMJIBNcX2FxrweoapDdgIVJ9roczRlIsXe5CxjIiYNEOr7DnKRjijUhoH33WfPmye81zLyvleiLX9/T1y6qOXMHKQNnp/klWJBd8gmOb8xoSvn10IWstQZ5TDD1gnkTPVM8pSACaAE4DLp9ZAL5hMwA0uh8JekceqxhXhdWwF4eQbBCwhy6kAg4RHChhIJZgRFkj2WGQ+64S2KDEYCHCkCteAqGdJmtFdoA7/AcWcwLkfaPm93Imorns73pnJhXObFlLZ5Q1/M/+PTT9LFPf/5NV/i/48Hr9F3vfIg++K6bYc3OrL64oAOSJHlB73M9OfNGjS4LUXPqJzYH/l1hEk2x6cX3VLgbabaxtZvaO3YVUJSPaXE0Y5c3NhAE1vsqagIo5jVQzayyHfBMMVHH5s2ewqJj7aByKgAcL/o5+p9+9Y/p9p3DlRgD3/3d370AADSObo1GfawA23oci867Wxo1gtfYLc8F5LH3ONb5XGMKbMkncvd+q3Ofz0U2HRx9xilmgFtsidfrcYpz/VYhf1kAYOTsvyUp2AIA8HfHYvTWCvItX41TGDjHQJtTAJ5T/QFO+ewRwyT7UKx5NHzyk5+8WikAj9x/nf7mj3x/MKrigWafhzbGy6MUKFp4YLQ2alTFXHSn1VWhtJHum100sxrnLS00+Mss+GjcJWsgwGiSx43jQBPg+tixcYpOfLupWMd4riELDnT3qC+uHQzghQliRZChP5eJl/FktNQVm4kWR9fqMtKaJzd+/Du6Yi90tFogEy8MtxyciXpzBEE0kwxzrbGrZ3IBNGfs4+e+s0Lf8dB56Aypd0Ht3epYPCeNMmymMXJwMsNFWejm0cEeO9XSs6K7116gUAvo/PW1HApPvc4CBoEJESUJXdEMAjFHyY6E2EkKDvwUgAkCkCM+n7BQA821Pk+gKC9TcXM2ZqoUQZGOkfg5T1ILgTmAkk9EjoKsVWiayuK7t/fzolwZOSiROMxCn//anl7Z1wXVnEBHjoAULhZDhFvlBf3EV/PrqFZc49xbpdr1dQQ+AYlQZMpgoTSWFul4pdRhluFcrRn3QrIYJ8rUkYF5YAqtt549jodSCszvOGcwUQcPDZghZ/ugRMU3PwPWBawH6JAeGWLg6ZBYbJiggFGhi+VG4nphbvHIBND7eLDGSfhuvDineG1kuLlxsACPOzDMVgsPoY8+9Rn61Beee1MU/Ujx/7a33T/saEYspkfnMdI/GvDsvi/tNbvCJApykZv6ZfbWbiqkQSiH2laz3dTGq86buv9mYqoLaKnNKwqYo0vKXF1WZjLJfuhzFdqVDgR0dsEE4LzT/WHusPhTB4Qrd3BZlsyTPV8tEOC9732vAQBrGez472ykdmqG+lrxfKwIOlUeMCq47yYr/RspmEfFUzb8W+uajsCALS1/9sx6LQCArWL1FPDmGNPi1C74qEg+tSOP41T3AlkCsAZoZZZB7uSPEga23PePARynMia+UdDlMoyZNdBrjdI/+jeCAPle1MdnPvOZqwUAvO3+6/Q3f/QHxjdOLvdH9MTUbcxh1CG3GQzk0BTJI8Ek5FvXpLs0vTEU7syRZmdu0RoZtqC9x6zmDAqgZlWWJyBu6kb0FSgmBPK/8WQG1+q0qzQTOs/z6jrQGmi1psXnaA6GnXmBzUzeLONGyDwMqoSNb+Gy6NxV/XugfEUZrW/c2Tt0/UlYzAMM41eE3bG9Ysp7iiiMQM4ye1mfd+/E9K5H7mlMgF5AYBFRus5Z9ZBtQxV9GxamaWDkRSmRAYt/BpNDp8pL8AZY0JNLfL2EgkKSn4UWzU1KUTjSRklSQocybyg6vKN8AgGCBSOgc2hjwwwYNzhFgCQgT7bKPEA/BKZc1LlxHTIJlMYbr8eyaWfsDTBkDLKHVNiiV4dfG6I/f/6CXp2jZp9S0ZdNHZmWUWxsIJ9H8+FNoywShsIOKfWoj0eWFIIp1Mdy6R4gZWGcmIL5GDYGnGIqena5AncYr6hUaAQpGDTqsbBnA3Szw/1wvYEqWH0vMCZUO/TI4EIPigieAVOrf/3IVEgmrmDwWLpGO8q+nDGT/SeCwV+aFx14pDBeKRkBLqJOQQaX83RsY5JYHLTBTMjL2a8/9Wn69BUGAK6d7+jbHrlB3/XYQ/TedzzQzXUlRIpmFqGM2CdBQuJ7jTb+Wjd8hsbElAQ3BgpQjC7W649zP3MxNEilcIc+v2gtUA1ckJiG1It7DgB8YwrguhyicasMDC9B4lW7NluIDlKJlU3AznTQ582lNBDgX/wx3b54Y4MA73rXuwIAMHIh1yIKu6CjYkpZA7lYQqB31EXdouyfkgQwes4xEOIUGv8aFX6rG7rmeYDHhudDNf/5uEegwDEAIAPrlwEE1or+rUL+WBF5DHQ4hVK/1pHfApvWDAIVFMhjeMQEyCDXmk5+i+kwki1sdey3GDNrsXx32+XP7JURQ2ZkOrk1tvV/Onb1fGdwhZnpz/7sz64WAPDQfffS3/rQBwM1bNmJgI5DKp9xaxk2xOl1rvukVCShQ3L0CyhJ1xnj63zjY1nzfeWvwM9cOPSnYpPM9X1p9rdsakVTPTRtq6YLlZDdXfoLNMPcurxSUywUB4fsutjMyYLyHDYwhTtyLyA9qAsQZpGgQK7pDb1B6C5NzFRKLzThGmCHOfe2EDyYOtNhlkqFy4Jd6RueaGGPDvCyoA5nTYgXQ/o43zE98eA5uDT3zRi5Hh+jvlox0zswNY5d3WCjc7ppR8mjDSv8HosAjBDUDkuQqvSxqoUMbhr169aUHBAkE1WoFAndm1r79Zt83MyarY6xYmC4h8AIpWKtHV8NY4TBqC10JSl6ZDBTGDfojZE9L2IR3ztbIoHajIBINuXTuMC51nB8hz5+p8JU52pdcb0uE7v/gN3PxPTZ51+li4OsdL0d83QmQdST4zymfgC1NhmFUI2MJSLT9ZfgC8AB8EGqtxal6DCPc5kW+pKkHRoH52kFNLiX/fu1e5KTA780OQCwj7hHJFqBpMCkbuSQMZBM6lDWg+yTSUXVycXFzDQX7B2gvVMGnSn4kpisprAlH9DKbJMZBwt5EkWJGFPaCC2MFxfWr5QTbkSix0hkA8WVmMMI2F7Pf/2pT19pBsAPPPEofejJxyE+c1kcMOwNSnbzx+QGMNEs4DFSBmkKu0xH0itWPNK0TBwYL4GNwiA3gdxkNQIs3F4f2GDSWAWltAnbWFiiHjUUwPK5F/VibCc2j4Bd37Q2eaGvZTLXxlzA5BnYyzARHUqhUpj+3keeojv7+Q07Nr792799Eb2XO9nTNC0KeN3IIyNg1Dkd6a5fi+g03IfmiL1cRG6BCMcKo62uaWYcbJnu4XP1edM0hZ+bx9O8yixYK7jvhgFwtxGIfxWPLfO/Lar+ZSQAI9bAsZ8zYHVKPOAIPBsxAk41QDxFlnKqnwAex4gls5ZAgWMGgSn9t4IqtdbwmhGwpZ/5hS98YTjW37AAwNluov/43/7hYbG/pPQsf8/Rx9hodcWD5tqCGmq74BjgBSCTxZ2Z+zIU8SI5Esw7TlicZeNAi64y+raEtjUDpTy4c9OSeok66ODYjIsldsTFTbTQuDAXcZLp69bp0eLfY9U4FclK+XdpRIxY05NiRa5QPL+9GFh2RuDGkqxHoBAxqECBUNaNE1HoirWiGx27sbtHwWyya/YADLANlBW6kVuL8YRPPHxOOzAkRHOs3cRWpIQCNo0f7Z5kHXjhvPhA5GIqLkqiJQu4em9tBFBuIIkJ4TIEDpphc5uHYlZSlruBFDC+J9AaMxMdZgdNjMkA2veFX8eC5s2B+SME46MDYsGlXuLgipM/h1SCEmj/FYpUDlKOPJ+p5p8SHbuNC/FznSjmF4dKf/HivoNk8fvXCl4RRMHAUP8enOYkwqPuGaHJITXef90jQx2+Feyrs3sDaBdez3nzDSjGaNC5QzuaDPchHhYnV//GAmiFDfqCqM+HPmfSzyXQrFuHPjLFOIF2AXIQMmM1nBfxXlE/FN2yHGqlSU08iRb+GAvPF6Jlus2AjYXsLTNzJY9fZWArMHHXcsvCODIqZUbOOOmsIGMuzOEMDAMHhJeJGz4nH1vP//nvfoI+/9wLVxoA+PD7H3fgLRc2CDQaINbnRIZubx+7E8xj1DX9NFj/uXuFTCV6YxjbpfBCKqPjSKNGjS04ORPA5Vwgi7L4YjGGoBb1LI2ZoyPITHARoO/mqu1cwLwsleZKYd8xV6F5rt2rBuRD4k2JwkxzlxL9j7/yR29YEODxxx+3Iv5YobdV5GPHP/8+Mwa0kNIC+G6pzqMiPBeGl0kNOMY22NLhrxX8WuTkyL9RkZU/41Qq/5oHwNbxvV5eAJcxc7wMALD1mtxxXmMU5C7/VtE+6r6v0fxHsolj+v9jmvs1Lf0WIHDKNc7g1ejnDFzhOM7PPxVYeuaZZ64eAPCf/PUftk0r5q5roaOFEPNIcj+g+RMtuqNCkqjikI+rm64qsKDWUJAjCKBdwalnTtfqBaVu8SrFIl5ylBdoshnakLgfxEpQ+ibPUfWYt40dYC0IrABYUD1HXSEhCT1NpfgXo40TYWEqVIBO3hbp3qlvIeiddSGhk1Ywri+ZJmJXTzughQA0IY7yBLsZ0cgQbmaIC8sbKE1FNrO+ZKHevjdqEZfdQv0FFo9MRGeF6YmHz2CzvOwut418NAJEB/TCrplu4ys6hDOcF+1yYtd5KmSbM2cz+Jg3erpEOcEoTjP7AaCxpRXSUCjnTmHQ4UMdkuc0KyDDKFx+LurUGbXcA5AMlbcMm2e9F1WSQMm8LMtmMG0DnyOwQ0Wmgc8jeu/3+yaxIhTkUFAEc+P95/Yen33+olFwk7laLC0J+r5Oz2ddlMzUrqdAkEftSde/qy8FSV5okSZZXLYT5DelM1hqQLMKRPohOwBN83Cu9GvCNAO4WsjBQzUmVRBVmSFGcWYmw2dKHkveceU0P4uwrRft/Pgc4KwGDvp3ZNBgIy5slmQphxC4F0WW/v2M0gCk5C/8ASLjAKNzc9b8gmUG65HeO5VgboHxlD1BJLHc0PAP1/Nqchpfz3/xt/+Ynn3+61cYALhJH3rylhveMg8L/wCC9FY9i/QufZO6lE7hn8mv80TuH6HGsSqF2U1+/3FxSQxjfDEDCA732zRxkFC1/QqbSR9uP3ZTsUIdGxiaTDMx+pjE793wSjEJj0oV5nm29bzWaut/rUKHgzTWkSVfNLAPZQkiRPu+Pv+9j/xhSKB4ozwee+wxmqbpaDb4Mad2LezXCv7MJpimacEoWPuMLT36KDLv1OLzlIizrdduddexI5qp/bkAWwMy1qQNx8CByxgGXrbLf6r7/BZYs+ZUf5kUgGMAwAioWgMStnwsRpGC+ZiPyRBQPnAKZX9kyHcKALCWQHBq4a//zcX+iN5/jO1yDNj40pe+dLUAACKin/nQB+jhB64v86so/irEoLF3qBcGSbKkTuvrCgMzIGgxOTmbLw3s0EcgbNN4ebxYJIJHXNDCj7o+0WeZho7VEfSg0IkxbWwVkAqIG1tRdun1nhsaGxYgdprzfB6UEAWmxaNJDVIgfGBjQHweAWNB23i2KalO0a6grbSOYy8qJp7oUA/EFGPB9Hu7TxlDVniM+gv6fY6xclgALseahDFYmOndD58bswTd+kM3uLqB2lx9s6x7xGYeF00tURuOjuxZ66+mTdql0YuHNHan+GPHWaLEQ5amlDUsUn3zn1gjWCAQFP5zbRu5CZz0c4cwgg1bHYwUPckcOu/IhkATRZssyeMAp8JBA60/G3jFqXA0wNCLy5x+MBmrI2mkKQKUFrko7tKNYwRNDw8i9Lnn98A88cFYU4weBh8i7RzTDihRtTFRRCU8AgtVUY4wgAbUF0j1FGDQG6hZmUdlcpg3HHbU61ACY0FEoDuphb/LeISaiaPJCXRzbAaNoLqySijKQGyuUkBHz38pQ6r/1BkCaHKJ8zsClAjq6TkWWtd0GmsNvAAorSfcx1t4T4x55ehRQKlw17E8Sw23UpYZxXGiQHtMEUAjQr/sngJxbD3/J7/+FH3lxZeuLgDwHY/Sh95/K7KPELeH9UvnnB0xVdXXw8ZmB6Z8xQwpG0hQuHTpVAeNySn+TW4EHipFx7925dXYD5olzJ1B4HN1Zjzh4AiyLy3CpFKday9y68L3pdp84ffHPM/2nMZmaqwinGsVUL3YzyD580HHwAh7VRrr6Gf/nz8csk6+mY+bN2/SPffcs9plHhUTp9CPtehH7wD9WX+32+0CALDmsn4sGi0XY5fJut+KLBxFqY2K7ZGHwFaRvuY1sNZBPcVEEK/JZTwAtkCWNUBoVPCeAiic6oy/1rHfKvKP/W2tiB5JW5AZgGNyDYgYdfVH33Xr3K6BW2uMgmPndeuexc69Fvyj/ymD5VTWyKl+BMxMn//8a5eq87oBAP/hT3yQHrrvGmR2R2dpHhQLaLqVtxkxu903JkZRJ9AcQ+ezUAFaZl+ooEtdkldApkWH+KMUCZWNB4O+XM2ustsyFPUicUHOMVkMLt5CXe9u3TCOXTWCDYoQCfuxMYiBJTAZyEyOkEkh1emhtTZP9cmCfttmFTf1oSiDjWTtRnLoIl+hu2/67dYzawUI5HJb1xE6ooVLAw6IaKd0SCst2Uz5MOarUYqL6aAFDJOK5a2BoxNjNB7TQ/fu6OFrXsi44z/H718oGM9V6NqUZLpm9Uty6C+BGkzkjsuC/JawsVe9dQ3RTjGtfNShD7FnHOMa1W/BmDaBxo02Er6ZRNYMdi9LKGQo+FzkblpA+Pt9ql4OB4hG1O9YpdIszVUb5TpzjZ33rHkOhp/dtCAUzpqnrXGDSX6AtHgGE80CjPwK2e46niaLhPNS7KsvH+jFO3MonJd58pFVU2sFjwXs4rdrV2sFBlGFjm2L+WxdRowf7N07NBNFvnkv/HUyQQo7sk8QTFWQQK/hQcCUEEAANgqxmwei6R0DEISsE1R4IDtI35/YmSe6DoRCLnm6YHM9FH8E5qzFQY8a0iSW/jAo+6LMfIGDjRIAWhirZgp/TlEovDTP9aoVEjvIky6CGecg3pCSOsuMChHMG6zn//BXfo9efvXqZLsvGQCP0oeevBXGUgHDSovaNbuf9sV3hS0WjwHwn6x73xYIS45gnzunwoHppGamufM/7rz5+ldKAUZjGtt9Tm+spNrXTrbMdAcpm6eLaEywtDvI5VIlaldlJunEoFk1riAL1K6/7kv2h5nm7pUS9krc9krMRHc6iPd3f/kPv6lRbPnxyCOP0LVr144WfHe1MU8mgtM0GRCA/0Zg4FgywJoB31rX9ZTO9Zrb+THQ4Fgs2tbfs2P6FuvgGJCwBiyc+j5rxeQaCHOZMXHqc7f0/McAglMkAGvAhY67ETiwlnaBnfw1ACB//9z9X/MoWAO7jhn2rQF3o3GH3fzR/y5T9B+77qNrs9/v6ctf/vLVAwB+5kMfoIfvv7ZwHq6CxkKxg2YbnZEHHHwBQ68zxXtBv/cNYE4bCBtJyKMvKds6bHIGWmJBh3iOxlHoKp/1vbjLygyECBjEjTlbxwuOCDvuItFQEDpi3mV24MPygaXlcFs+Orlpjz5v192GUbuPmthgjKXmiSgXqBKKiEWmeeiMj2EgPQe6vckeDeYejmOKYcKQ+Dyvjpe7X+3GPHbjrBWYzk6GCYcXdHpowdlIDwVNNo4iNPbzPG5jSgBtPJt5YReSUud3udjFrxmkymAuxwsQwoEeLAYaXdTHEfoLlLJMO8fi1uQ/AFiETgJJKN4xChBBFzOc67IFgq4+NJktYpGZzLgPGRvI1CmF4fsymFSCg36VbnTIi86/Fl/Z48BNHo0YQ0QtHvCZl/e9COzJFgRyJ9Xui+uCherC9BTZKy7+6e9XgVbZJz0FKKr5ELhxqI3twE7iXpSIdc0lSUzUENOK2woFMie5TX+OGmeiVhrBFQ5JLGSApbLFEHxAzgqzG6WWUhYWs1rkKFCJqLRg5xv+v/a5M9/qxogSBIvQ6FCCe7wETb8sFmldt3BNW9sg2ucOjkuIFmui31891i0x8oSS8SbKODjCiyjpYSL6uY+8CQCA992yy2qyu34OJyKSDgJh7GQBNkdJUauViCYhM53V3+n9vduRxbi2+xEkIMI0Te4zM/VxjNGn6GeBhf7UDSgr+9qB8/rUzff0utbqaUcqCWoAQfHfk3qKuAGzSQhgL1Sr2F5knmtnFzTGwFyrs3Ksq6hrUN/4cqHf++yz9Jt/+qU3zNh46KGH6L777vsrAQBGRcE0TVb8IxiAxdgaPftY8ToqYE8tlEbMgRHAsFXkj6j3o9dmE7VjjIS177zmyD76+dh7fbMfa8aQ2KEfdd7XisxjAMAoXnD0WSNAAiMGt0CI/Lmj491KTzglVeFYIsMxqr8W+/M8L6j/r9U9nx937tyhr3zlK1cPAPgPfuz76O0P3QiFQOgQSlIwK41Ru8apA4YFjMc0UcylDqZS7n7N0NLJg7CuxJgEzAA2U8veagQYeI0SmiLnbBsGpmW1F/CzaCfAJQbYsTzMNURV+QF6MRO6WN1vwIsF7OBL0O5Kolspoh9pw2zd19p3QFNnEptMIWRHS6BBq/Y4m8npuFDasGp4tcONRXYp7Jsgap2YAlbfpbSufxt3sTuGBmt4RSkZFxZmevzBXaMn59re4iObOzm6MFvXGAwuzDPCkgy8Myd1XDDnf0qatHTzVkNMJHTcYaxFE0gsxiWwWXLhH4ww+/u1KL3u1C4EevM12hUNO1lLV3QJ5Ho9v9gtLimXHKUXwlDchUjGmLQQ4ittvPrzpbOEMIUkBX6bPCHHFSKtVigmNnC4hnDOWWg/C33ha3uj0pZSFrT5mjT7ljbQ59KptEXM9bNt0+5aXrKNun4/jKWU6qkjCgYio8bZEfF6zDh+gTGlhb1mkOt9G0A+lFDBhC9a7BSiIAdWkKwgmNo011w4rCVibKs2P/BwLUGzxRp8WNzTQQKIHQ0yXW6ErJSKTIRsxCHxfZjXFmgJx2n3VpKzhYhAojGzASKSaoEAACAASURBVO5F9R/BuRGBwBI8LyJDIa/nWWL393/xt96Qm+ZTHx/oAAD6gTgzpZ3bnYKGxLTjOD51HphKoVmEdsx06ECp+gvpuNJu/36u9u9am0TAGIywwW77AbbYUh07ExfwFQAPDeZFk6La55bQUfXoWl/LbP5lZQp20LE2sz+SaoCg1BqkhW3Nn0mEm+fAPNP+MHfmlNB+P0MDJALStbb5aS6FPvqpZ+j3P/vGSJW4ceMGPfjggycVyGtd8WM/jwqWaZpot9sFjwAFAJB+jdGC+f3WKP/Hiqatxyhmb/T6Ndp9PqaRpj/7AVy2879W0J/qBbDlJ3CZQm4LPDklbvFYzF9mB239Pf9treDPf88d/sxAGY2/UWG/dhxrxf8xlsvWPTh6DoISudOvBb6OibX/vZb3+da4uX37Nj3//PNXEAD40e+ldzx8vxdaKa8Z85fdFT3rjNmoyTVlUIeOoNCgo5o6gQvTJ9Dqps6JLph6XNHwicCRm7sOWkCz7EwH7ATkFAGP+kMTpUh71eJugmKAOjIv1Nx1tV+EEgLT4lmxx5FaWr1AJxKapuLJB5B9Xb1ytkJecGNqmdy1RxAWoK17gY/MgDk5u5oRX3G3Yu2GEEXHay1EnMHhnb0K8Tqe0FDSdrr3QMoyV5uDRrZtiKaJ6NaNs6ajT2DVAgpiN3QKXUvG/ljaiIuEjiC6PSOjpUpjTrDlhceiOiL5XkzXiveVg1ozaDNRy17gnlEa6gxAjHsJJMYNA819EceX2D0k4RpiQYRGg/r77O2B75dNEwOdOfk9BP8A5gHoR6GDnI3gONGmJbAW2uHOyVcDYxe9UFs62Ou1eubrB5oDiyfHzYkVx25C6uchbC7ITQhZ73Wb15oxoKh2DQACZGY0YIvDedDvVUPWrwR/DQbH8pAhHtIOOjDYgTuor2jh9C8OJDKnJAKbU9kdyQ3QcKNAsg56hfsBxgZsStGkz9cSScyStKlAxgT4h/gGVnwOFk8kIfAwCdF/sAbkFIWofaDA/HDJhHu/ZGldiPxb6eJxSlrRYxqt555SwfSzP/8bdJUfH3jiJv3Y+x5bsLXmDo7tOvhVSP0dyIzwCkemEgLMpU/EwtHcj8jlVzWtASoPmAP7ic2fAU1JbZbo79269gkArg5kFEjewNhKjdvlzg5oQHyNe6LAHGzFv3b6zcQQdmQaH0hUab+fm+Hffu7fUWAs+ijVrc1cCv3GnzxDv//n33wQgJnp/Pycdrsd3XPPPVRKMU+AtYLzWGb8KQWfPtQHAP+XZQE5anCtu39qUZI11jmzfKsI3+rUn1KAbzEILuPav+YFsAVSrBX+pxZ5a4X3KIHhFIPF3HXfKoaPxfdtFZ5b0X6jAn5E9z9FgjAyDRwxCcZ7tcvr+reAKiz68d/a6df/5hSKv4r7fL/f036/p3me6eLigu7cufPasgxeLwDg3//R76XH3/agLRIFqMLWSUj04qyX1Z9zJzG8R+jOI5IcNQTo/C9AJVBzMBJabE5RBoCO6ChLUOOdKstUAF+Bsz0XBd0fRrxhseKGWer+zjRx7LgGFgK5eVNbmJ0ua11H8DFo56HCpgJj3qp30JH+DEBBo+R3unqg5mox5MdAEkEFpTJr6oB2pfaHfn44SUEoAjmokyQq3pUEB/32mhIKZS+QOXT6/UeVXBDdvG+i+86m0DmMzJGuW+yfdWjVm3VzFNwy07d+EZxiHrtzpbjRnElTKBX/Kcu8lET/hm/mWmXtJmGXUmzziVF2ZoeQutveIfd7IXf+hVyfn70G0AMhsC8YQA2iRedNDT6dGu6bX5PFMHcwzEGAAhnwxQowDl3QuEjGBaNtfuP1ZuzyqQt2Byk9OYGNNjsD6wW9EuJcVu183j5U+vJLBytkrdOMhRw7DFJrdSACwASyZAKxdABl4WQ5SMvs1nFERtsvE0hJelduNxXzLpiKa/WnMmVBT2cQRLmMAq8GcrGDixWLVyvAo4cGGUAxNndFpgq+H37fwj6RFMj5nWF8BIlL4QT1xeIffTmcmaKfVdz5vHCSbFBYG22MLYw2SzTITd4glNZSQUPE7DoLa5mBPkGW4MC6SATeJB3n2nr+d684APADTzxKP/n+b6O5M2c0tYX7/KyZxFOPjdUxs5s4zCVE7l3CxhLoKTg2vqhHx0YAsmBufBWfS1jXBwTkOUSEWtxxf516BCirh8A8Gec9jQLVNV8Cm6cX8dVTERRYnHFOqV1WQtIiRa2bX2lXmA7zTFSFZql0OLSJ53BoEYFojIrxurUK7Uuhf/HHn6dPfOEv35B07N1uR2dnZ3R+fk7TNNH5+flmgXYZTfioWFBZgLICRr4AWR7ga209WkStOasfYwqc4nY+KtJPKcZPAQFOlQBcBgDIRd+Wq/9lruXdAlBrXf67AQC2DPlGDIH8826324z1Q0AAi/tR4Z/lBaNzPTqGY2DWqOgvpSxo/COqP3b8L3PdTr3W+/2eDocDzfNMd+7coYuLi79y9tzrBgD8jR9+kt7z2Nsgs3xJccborphNvyzgM+UwUiBjPBEtwAB/PhbCMcIPPws2g9DJcUDCu4TYDQobvBAlR8G0hwBxx45v6McKFFPk9HE09HJ0rkK3hkPEn1JS4yQd9dFYWGInCn9XoXOGf0MqjXcza6BCewSjfzc8ZoyJTJiIO5iTd7NbVjKFUrd1PMSi/iJVGc0bo2a7dAABO7ncN1o3r59ZLrN2QM0QalELxCLEstyxkNO/y3JMmcsyFAYx1omAahWNMAnjNDULGqjy+hosSF3DKlCExW5/RaM8kJpoCoHAsWbzy5L/TQlkQw138QK9cDP7w87kyAQLpTNGedcFoHA4V9qAQnaCQEcT74voj9ClLYKxd6kjAPCevXcfsAb0gNCawVhwFqGp+HmYq9CXb++pYxn2vEi1zmaJBDKQAuwbCZuc2o3/lp0QAlO46MtQIH7Pu9LeTW8YQDdBFLaCucUGkgFpU4mbDiw+fXxRyDlXPbKaGupxKFjoncwtxsCoy8E2byl7yDur0ruYSwmYCDIBoh1niExLcpkoOZG01qGMJBZm+j2m4kCSA9doGKhMseR50a8t8zK9I28G0Cx19FyRyPIpYX2LLICf/acfveIMgEfpw08+HhoTNrcxURGCeb3NCbvSNfyTe9KUAuBz30PspgKMRgXUKkXvEYa9iXf0GT6vUqXCPY6uo3QKNnFfKPX9gzyyALXfpEYMDKwCjQixvUNsGBDsQUAeWN3YT8ECDDBVAGS/P1DVDXYHAJRhoOOYEoOOiWnPhX7lj56mj78BQYAtUODs7Ix2u90qKDAqHo51MrHg16hABACyNGBUeG09ctF2SkG95fw/Yg1kbf+IIj9iGYyAhlNBh63Xr3WLLwMAHCta12jfW0kMI4bAGk1+q4C/DABwSrc9j6ljDIDMKMjSgVPOyzETwBGAhUyYkZu//jzq+o/G2N36fOTO/utR7H/TAYB3v/OROEAomnjJCjUibpxjIYB/N+o9mPo5bd+/8sh4D431MIvWsrFDLjkkcvOgWAXKNOGmikbabsg4H9KFXHqAmwHc6Gm2t2fNezcRN5eFvPOQz3PN7k+oxxONlGKj6Wkxrp3vXfECM5rJKaqGaLNqa9pxk0WRuQa1FH1/Sh2yqA0vqSCcJqcA73aTgwWlhI07gjetGCaPGGPX8ev1e+Tajm6cT3aBGbv4hO7y4NmQHOeV+F8J/AGStXiBcTbDJgop8mveFLohr92F2mUgTt3ndEwB6EGTL7iIWQ7g4xIAOrOcYOgk+kbPM55pYAwYO/6ZTk1wrliWcX8ICrkuGgof8vu6KpWWfc6ognRmMeNRhpi5iQF8g2uemQMOclAwXcPnI3iF3X9K6RjMTLf3lZ5/ZQ/XF+/3Gl9HkdGgRWatYowI9wBoY1wLtQpRfvhuWuApTRkBmIU8q3D6dwn3bjvHk0WJtmtUIqPHitYSwEodt62wicBH6QkcDrZ6NFpIcKH4HCzIjOnTgQAcq3oOoj4/bYSAVVYT0BtB5Xbtm4Eb0vy3zLMQeJUEJrssjin5I1CWNY2SdiSAGSIRnOaUTiOyvjEliSDBX379Nv3DX/2DK88A+PH33WpRfMC40L3Crm8uJu+3t/0GglyFjTmic2GL9mtFuprv2ToMMptSCiTWaPRrS7wpnYEj1dMoELwyIKF7B2iTYOoRf4AfGai9n9s6db6bqEye9OBApUsFQ8xvArKkx8FWSPpwxpGYQbGYDKCbac1NkjTPnYXTQUdPcBEDJw+l0K9+/Av0R09/9cqNq8wUUGBgKyruFIo4ggAIBuhnonngSJO9FXW3pevH4k2bQGsF+8gDIHfs10wDLxv3dzdMhbsBAEbnZg0gOAU42WJ8bLnorwEAo677moneiDFwTMqwZQKIXf081vLx4Dgefc9jTv9b5y1fX+zmZwAAu//ZcHLtGq4ZYBI17X6t9XXr7L/hAIB/64PfSd/7xDtsE4Ou2JR6KO5rFGP1Yg636xpjvC0Huuio46GId97QIMpPsMkPfT3oFnLYucbNsVghG7PY8yYM9ayyoLNCdwcNeEhjq1RXC5pUchdeLZgLLJrMy8GrzzHXcTOkqz3Dl6ybrk6/CLhk+m2c0KVnHHfasVQ7NwImZh1ws+vb9gceyzCr1hBEswV14r0Q0E01kTTdIhczAMROo5mFcb4FGIoD7yA/duMs0I/rimklduK0q2uFp7gT+W6aolt/8h1oIFJ3eh9QjXM3ys5nohMzFD4EAJSeCy3s5hoNz3DzXweu5ISggcTxiiyBfGtq930qnICi6IORs+vtudpNV0aD4DWLshlZ6IAi0IIpAcGwD+w90buj9s/bGS0WvA8QfFPqN8U4LwN0WEK6SYhxTEWeCNEzL+2DVt03KD2Sq0aWBnWwTgvNlrXdiv8W6eWMAgHAtMK42XUZkxaXJS0Ypc9FpUTmky3c/W9TmQB4E+LeqcxsGNQoq6zBCxiIL01dcZRj4QDlQYCsSKNB57QLYtBZg0eLgSj9w2WRLhM/N/tC5EI9zPklggIC90qIlh106mWwdqGMhXmZ6JHXQQJfA84bRAS6QJphVGwYo1vr+XMvvkz/6P/92JUHAD785OP2vfK8xcQ9rq7dvYVAHtDnAx3bBOCoygRRx6+FeLtn3LgPY3UrsUWHalym6bxNhuFSHQe1S1hducdg6hifSqHDoVLpLAFcFxVkUMkBEdEB9GqCzRhljqnURe+JWg2IrX1OEqltbzAf6DDXnibQZQCH2QtJMDGeawObpx3TxSwkpdA/+9hf0Ke/9AJd9ce9995L169fp2vXrm06nm8BAJkRkNkBCD6MurdrNH/UrOt4O9YRxQIfgYH82hznl4vsNUO+EUNh9Lw1EGBL1z/626kAwLEC/1QAYK0wH33msSjAtW78lkHg2mesfd8tNsCWUeBaosCpx4TXa405ka/dGr1f/62F/7Ei/xhA88ILL9Arr7yyCoa9ZQCAn/j+99AH3nur09TcIMfjjaD72Wmh2T0fLdwEdza4gU+0yExXQ9qmb5CWGU4ZGCjBYGpQ0PNyoxYb6jyg7a51ZTReyjcNugmv4cUYFUfutj9XYiqEiXgzuPFa10m/I4tFfyFlXaih+JNm/bIjG5U84hBBgYDU9iQCAyS4bSRCF7l3CvS89MagsSsq7rGRkl39+08wPnQzq0wAR8PZuiBGpcSCsINClutN1Rz6r50VeuT6LqRW+LFETbjqKiv5tbHCXMgpzdophM05du8Ko9P7GhU3gib6rwLxaDQA1pZ6T8iwkEiBluT2Xa1jCMeXpBrY6cREASzEMFILgQkdhzw4t3m2ymyaBOPEewrMEh1o4XBfRyPBJYVa7+OaNNVKycXiBwExLM4as0VgbEQQsMk+OKQ4fPX2gV7d1xAFJjIHYIe670H8bAkxXcrGmatYp9Hc/6n/GzPd04n1+4s6mNWjyuB9mEuj/avmtOvWq7QYPzL2AlkaSykYjenxgJQBmn52A+U8eKp6x5O6aaEV24IxndVSG0ySpq7rCMjW5b3GoxND4E9Abla76MZzZNAsnWY5FfaykL+hTADn9Tz/ZiPQKolhAecbZW14JnH2QPCDBqDvaD1/7msv0/92xRkAH3jiJn3oyVs2xyJYx8w09Xt16tr6SeeEwsTFC3DT8lunnqMUkTt4YN1asCUWBolMCRIZNOaQLrlpHX6XyXkjgNucVxz88XmX6Hw3+ThAw8N59j0UE9VZX+dzDyaTSKJDVjASJpCVubu20GE+0HyYqXZmYNuEV6pzhfjbDv4Wv8/2s1CdCv3zP/gcffrZF+nN8Lh27Rrde++9dO3ate3N+wkd5lF8YI4SxI7rmslaLoC3KNfY2dXCKhdHudhe68hvRaud6vx/CgBwLBXglOO5bAH/jb7+MgDAsf9ujZ8RW2DruaPnjwr8BshPq8DEWpzg2jnhRbLT2OAvd/fxZ53v1sbBqbKZF1988Q1d+L/+AMD3vZs+8J5bFiOVu+xIq8PCg2iZw42dNy1646ZmNEATgqpO89CFC1nitCz45xoj0GLhBRt6dro3hQg2DlnuuWrRjbBSq+39lG6NDAgmmnTBJbLjRrPA0nfqB6X/1thFtQlQc8UJ6YOd003RTb6CwU+kfnGM/BHxzPraNuHqPN5ogWLHUIH6X7umvwrRgShqxaGIzRvsCTbqOz3nxSmPqKvkUogg+5ip6TkFdPpWiBDTg/dMdN89ZQXtjt06LO53vdh3aYoXxMWKoDSh4HhB0z2M/wIn+toLuqlfa6YRQunXeu7miiVoOBNToEdJOU3bN7Bq5mgJB2Hyh/Fhhm0yGNP+HRadg+A4H/A8ux6xoOaUvtDGEmrN51rBiJGAOdCpuOT0ejQUHH0Wzgm7KcZTxnPpoIMOU+3cRZlBNLATgvPV3+mlO5W+fjF3AC0bZ/p8ZvdeB4Hm7p0gfVGjLhmaK9Hcj2EWp/+OCzxkTnmO/cRLNlGxomdyLTDrXFTMYBVlG2jOGbroDHMYeZZ5/n3EWXkB1uBKV6CbqmNpKoUOdTb9v4FchLF9W8X1wEgSAEuUq+CCi6Z6CyYASFGQYZFTJdBbw8+d3kMeYdoi6KrTqDuAKyQ0UbH1hRKAhmad+d+Y7LG2nj/93Av0f//GH115BsCPv+9WYg1RX3/bP/S+LglY1mJcuMsFpuJgkUpquj5/6jIBMQCMA0BYpkJTL/4PtTUHxFI13PpX6f2eEuCdV00PMiNUNBZ21Gzg0+L3jEuYfE6vcw1RoA3UxxQE9OuobhrIbR08HNrcdJhnqnWGDXn7HYl0aYAX/3N1gLkK01wK/fy/+ix97rmv0ZvlgTGDx3wAtgoz7PqjPAAlAigVGHW4j9Hac0cfjwN1/0jjHxXfW4X4qVF8dxsBeOr73S19+9Skhcu+31ZUXi7K1/T1d8MCOAY4jKQEW88fHd9awsEWUDFixmCkn+6fDocD1Vrtv2uxk6cADlet8H/dAYAf+s7H6UPf9+5AeSaiTsn0zS4WHfHEQ/eRMKtWIgBArmM23eSAQRBq78SwRhd1pfNzd2TXp85z7cVllAZkhoAA28C6Vkrfg8/GDZ+ZMcHGfiro4K7FRjU982HWrlbqyNS+adbj6py8VhzwsLMBFIvQlarUro2g4SCp4Y8k3Sy08nVzDMVPpUpUUTPbznMlp05Xcg11PlZMeEO/caYeydQNwXaTd0zK5E640k2aPALSdcEExWYpTI9em7pmk90JuhcjOmgmiB80Ay9gJCCIQpBDnrt70RMAqOI4+ZgBoVLqvetmSQGUC48lcCCpY52ZL3p/YQenpM5fvkdzDjneW5wYPNh1p3gLxgz4YfQeh3hAAbmQ+SvUGKWJ8ZW2GOVuV3WNriU3VFlQsikdN7IoMDZuRPlzI1SfE8y1X8QkTMQdDKtEz758IPQlUW0tUn8JQLd5rtD9F+v8S21RZbWzVBb0+QRuFoxn7L+dyE0jMTa1lM5wIQ4GftZt0o41u0eGjQP1NcFzTeC3Aj4omrmODhJ4H6t/BY4l1NIjAKBgHM59YazR0qMjgENAe0YZD6EWO2n4aQU0HP0+EAQQaFgqHMLcGBk5QlPXmyOIi3PCkkWwBIHQy8KAxY31/OnnXqB//GtPXXkA4ENP3krJKm4MqxfirBfvBc6jav8LRAISxPIxR6BZ/9ZYQmxFu8kKRahz+7qEhBfpSJoOY0AAOEQWMMM1vb5GFxaFEEqIdq1Vlk7x/WZkiv42CFj75rhaMkhVrx9LJGmFvaaiHGb0AphpBhCg9kQd3OPhuNs3XRn9D7/81ALMusoPZqYbN27QAw88cLQLvtUp1WJKgQBkAuh/12jaWwV1LojQxM+aDr2zigDRqIA6FQC4myJ/iwEwovWvAQ9bAMGWZn+kYz9mqLgFtmSN/RoAkAvorSIcx8kx0781cCDT+7e8B0ZUfpQEuFSwbBbd+Zjx+QhIHQ6HQPFHBsDhcNhkYaz5Jejfrlrh/7oDAB987y36ye9/d9DLIk0fNyaILluxVrz40U6GZuke6rITsTAt49SxIfxMDhs8Ee0Gp8V1VNAsjLzSBho2nkYLLxzkCoqeIyKvDr7SNxqZKszdHb0QdjbJnX/7Jl98p2YZ3TUU/71rWCUABLrJZEo+DbBhtcmyVnMdVuoxk0dn4UYgoMRCdP2cSWrTyrfufdPxX8xCLx+EZgSAZu9cGS1ZFxWScD12nSFRJiHqnZOplKD91460mfIpRZIbFZM7s+Dh67vY/SGM3mPvGlfPatYsd/QHwE5qjfjKisGOpIjvGAtpRViKAdOCaJ57B3CKBla6iQ1xkRAhlosZZ5aoHl/G+ecoGegF3Ny7VcY0IYga68AJphMgRd+/My/uJ5RV6LjN0gKlPU9d+oHUfu3GSSre8f6MUoDO2sCkgRRrB2fB6Ova9a4Qq4i+AsgawELQddftb8+/MtOduTY5jnRaJbnxo0AQe9UsPyKa69wTBdr9JsJ0CIBpLGJRBtEiLfs56df02hnTeb8++w6i7aZ2HV66aMcxTaVv+D0PvvQYQDU2K8yBcYJ+Ca3okWD4iXKPlgyBMWbIBEHgBQAenYcVyCocuvzh3BNEuZJsUDUjm0q7qyTuHYP+CcEMFOVZKMciL/DZKz8HQ4ABhSaea6t4JY8nzWCCzpkleNiwgfBZYlYRiMX7c2U9/5MvPEe/8Dt/8qYAADKjQ5sBDP4V3O+/Xelzjq7vk4JlrQifunlfY/6XDu4zERfX94MPTXv/lOHITGfT1DaxBKbDkQJj8Zta1Bdlw2k0Kqw/jHp9ccM//dvcJXAj5hb38REMI4gCiJpBprnOTR7Uv0MDKyvNh0qH2kAA6X4BtdbOApAFQOXzONN/95E/elMBAPi4//77DQhYyx4/9hjJAJQNoIyALa+BrY71qJAf5d3nQj8X4ceK+q3Cf6tLP+rkb5kNnsoAOBUAOPa4m2i5UzX9p1D/j6UArLELTokMRLf/rc9Un4oMdGx5J6y9Z9b8o95/v98vqP+nXJt8TV966SV6+eWXA4DwLQBg8PjB996in/yB9/iGZoWuTFsdX44gQP4CuoGduCzQel0l1IgGHbqVAo6rSd5sVUDMQ5MS1jvYrwVQYCEFsExyL+LmTiHEjb87pfeuvXb7+oZ/Yt9kkMXGgTETEzj/A/UZ36fv2DAnXYKJoL+PbaDhOyuaOyE9GhyGVf8v0DXbcaVrZ0wFzNy0WNUkgL1Ah5KR7tqK51cPlV7dywLoYDCJK72AL0U1mY1GSZDLbMZtzACSeKfm/vOJrp2VEMWEHWgFEQ7Vv19z+Oahg6ozRcC9e0BPbudaBh1AdDV3R2pe3NYUQDSPGtTPW3YXiWLUHxba+XgoFQI5Po+Rms7R0NK13NwN54oVsRwSKHj5eTSaN2JkHxFBGgYvzgOyOyR87tgzJOidF67nHEBJ7J7pcVeRBBK68VqUAknoGmt0nojQK/tKX7szQ9SWuIkfmHGplkZZOG0DPff87WYiNloGtFy9dlbo3qlQaBygNpyJpm5oWSY0Ges0dSF65SC0r+qpQTbIlTElVUgKNx+BfhN4tJqne+icRqp9RvCrz/HqP2IbjGAiy158Y+QmTMotAaTaOWBMqkAgOa05+I+hlAeeomaMWnRh436xsYCO+iKTBUCjsvJcijBUAPhKMqtF09ERiJ2ZdRmAtL8lFo0+PvH0c/RLv3vVAQD3ALAmQp/IJmOoOPdoYrYI4mnCzWsbx7uJqfDkaS3TBAaabPPFBCYj07QLxpmmzhNnk+n6W0IyDMxH7Ec59ftQRz2DL9Bh9vWcxBNSKji9sjsTB0NlleYIeTKBglcVXF25NL+Swpq64WkDc517Fra0xBJ14a7OEBAZMS3bffb3/+Wf0Mt39vRmfmQgYIsBsBaBikU/MgOwc3tqsZqN+o5p+kMTaFD8fyMAwCmeAd+IBCAXlktQWI4W7aPXbEk61uICTymoj9Hut2IAR4DAyJ1/KyHgGNCQ/7bGWBj5URzzBkC9P3b68d/53J9i0khEV77wf90BgO994h300z/0XVFzXzWL1jdf2EX0jTsaIvV82q5bxNiy4Mae9MOY1iwDirQW32pmVThTX5HaSaFLT7wk0mKXlgYbLI0WU2aAPmsWCZnmVhTqRji5VRvNqjvqGs1eO7619i7rMldev0MNAEAv1hPVWs8L6lwrpACwRZxVkhkNCltE4HkhKqUakNC+Q48oq76RPNTajYqY9smVm4ms0C49CvzrF83Z/CAyoDML7ah9ftuMld75Y4gyKyFbubEulLZZ6JFrLT1gNxXXU2t3lCnkM2uno7EKxIqjKtqtRId9stfNZnSEmze9LsWZIVCcFHDZR9M2ZAGo4zJGKerICJRWHpWDuejxjuzUATO8hwRSN7CoyEZ32ikqXQcuFolFS5YLfi+ihf+HJIfyXacf54Ke0rHqnlgZRMoeUIOtGXSuKq8hOAAAIABJREFUcXHwLh4z0eFQabJsbQlUft8s+LwUIherQOyeJMmNn0eMGXzu5YO9fu6bYmRt1LkaYEf9Z+3mHmahO9W72zgvTtx+d+OeEmLfROPvoGItJJ59zi5lUpxS/Ta4D/J9JXplX2lfxRIBMEpPO6Um2wggTSpaITJQ2JkJDTiQbrTKoXQteh0xEpY8Ys2lGtFDBoHckJ2eTbKSsSueLGQk4HOWn5VSYKybSoFlQn3NqCLejZe87rS1QNdFSgyXhXFmKviRnZNBDhqsb1vr+ceffo5+8Xc/+SZgADwO0Zo+j+zYDf2IhM640DT1cVbY/Ei4YBoAW9SmssXaUlB8zJcJinYAifv9M/V4PgJZm3RQDCUnCJpqCs6ud3nNh0THR61hXfPOmYTmRiFNkGEbLx5D6FuVwkv/FWMewv2/n2cHO6WxAuqs3braI0xnOhwaO2Df/QKWwHV723/wm5+ir750h94KjwceeIDuv//+S3WZkQmAEgCUAejPW53PLYr8Vqc/F9CX6byfCgac+tzLAABr6QajwnGL4j8qerOL/Vq0YP577qqvgQz4vDVZwLFjPPa3U+IEc4Gfaf869vI5WHP1P7X4V7o/egBo8b/W4V8Dut4shf/rDgC8552P0N/60e9Z/B47jtgIk5EIMscaJTmBdfmhwx1qQo18gk32LNFsqZLQrhcnlShQNUMRIkkThyBAOqvZ+Mlo4lnTT2NWhOuv0VF/qUFWRJ17ASpENAHtWJio9O9o0Vbkxb7AuW7u2c2129UKYh0KTGuvRscW607Mc6XzwnTjTHna3XRsFo9Cq+KbCWksgEpxs03M3bAMXdst8oGIiPZV6NW90L5K2PQQEe2ABVCmyU3Fihf+ws4GYCKSXhhOpdDD905wvQjcmF27LdQM/w59g4OsBUlSBdefd7ptjRN7LDyX8X9zj1bKHe2FRpg8bk9LItMOy7K5a7KaZOjl4EPUiwfqtni2PYJK2UgMiz91syfdJDOFmEVsk9pGM4EKCFJMkKNdkaJLvOywSpT2ENC3rZfHCRCBrjEWfw5sQASg9PjGzmKZQEKhDvoCPiB2T0tKOUkX6i9frR0Eay6HFbv/fcFrY652g7/mot3o+n4+BHjaEzNdO2M6m7gbUya9E7ALptSSnnrdIsJ0dgasig6SqLlg4RZ5+dK+0kGYqjRQkoSoImNLwUcuTp1XQNckNuSafezqExRMoLVWJogNUEkbFLi0JnWpDqLqfIOg8RoNHq8bJxYOAgTKeqgWHcnB+6YAWDGLhEJnxzEi07v5LrkJzIUEVmDBil4CuJZ46kbyBvBlY8FQwNdqEfn7n3mGfvn3P33lAYAPv//xKK+CDcXUx+aOS/BJMeYQOz2fNR1DGQRdUmSmvR1F003yrkdWEnOjx6se1hhsEFfLLq1SWZvuCYpFejb5AXVJkOnwq4JcFebECFr6uIrr1GH2dBON+1UgNu7z0PejeZTE/Y2aAVciKPzbHmlusoDD3FkKswOo6Xr977/zZ/TFF27TW+UxTRPduHGDbty4cdLzcxGlnX+NBUQ2wKjYOsWA75SC+xTn/bXCfkunfwqT4Bj4cAoAMDJHvCwAsFZkniIpWAMARj9jgb3WlR8xAEYd+DV/gFML8wwGrPkGIEPklGMeXfeR5h91/6ewZfTxZiv8vwkAwMP0Mz/6vdahYIpRSZI3Tdh5SeZM6MZv3ZIg5R9kGoOOHWl5giZ1tHS2to0kuYY/yxHc9IqDHEAyMECx21I4EJ6Bbg/deHKCrmaRc+qsat6wLdJEIc5qoeMj14YWpPMrcIKxLeTUP7xWBIW76vILbFLvO2/fwhb6bvjj56yBBLoxqFWoEwfaf/tm9VBrZ2ZQNFPqUXRWJzPT7UOli727oO8srkzstaQaI6bWkewb9N1uZ0WVTqyFiR65fkZTUYq/e0/oxrwQhaIneFcAYITjRsDosORxRE5xZEaTPg4O8YUpdFyyI7nKEHDj5pv4GA+IGddZhnCK6R+RX4sMjlXQje7nufsweDawUwglAIDYKaWUvIiu72g+KeBYLdhpDWACGrklfJB9o8oLbSy6X8dzkxfnAoalC4kQjP9QT6e4RzPRhOc8/8qBDhqPKsoS6QBCdRPQKmQL1XyYaVZ8gZkqJDLcuyt0fadsDh8PKCpnIvssSiCOljyNXeOFaEPxfU5shU2xQuT2Xlp8F4kxBgTkO1Mz4WhFMZ5zagyDwuiW37WDfcBIiDLkILto188z0yuMKZOsgKbdwLDkAI/rU4g4gxkTgWKMn/Q4s+j2r4kSFQt1uE9Vb67GjCOweOSn4BsbIpR6BHCM4hpIHH09zCdBnyfuK7C1nv/WJ56mX/v45644AOASAGSK6JzHSvvvY8tkYYXNqb51/n0N1iKrVjfK9I2wR8Xq2N71qCyUpzV9PzezQGqgWRWi3aTrhMoga/ezcfCg9M580+BzoNCLOEttaYIqYZ52ApbYfaX3KLKYnG3VQElmonn2CNEKESwKWDba/0yHzgZo7MPevZubH8Bc3XWgdqPmX/jYX9Cnnv0avdUe0zTR/fffT/fdd99m8ToqcEamgDkhYNRhPebUv1aY5UJ6jQa/9h5bAMAInDhFKnAMUMDPPNY5Pmbyt1a0Xrp4uwsfgG8EAFjrxp8KAKw5/K9JD0bPWTsOvD4qS9aCn6ilIKnufwsUGh3/s88++6Yr/F93AODtD91Hf/unftAdyiFuLDv54x4EaXcFsptxw4OvK6nzmvOWAxVZJGjmJBVICCYIAAHaYcfnoPM3VhUqEchGTehXoOh3lgtQ6AZS0khHJoI5dutNoF1TaZ15gcxyZBuo3l/seBUYEad5d1MgLYBYKVAEhVzX4p4Vpmu7KMGodQ6RcbWnBkin/7tzfKcA84DJobpnGB8F6hLVyO4PlS5qo2frNlhdk6du0dwWOg7aZJQBlA5CnE2FHr6284JYi9PSyMWLpAfyjY6efy1MFAixopRbvrMPUdSR90UdaLYC54UzQ0C/h9J/hYyxUEUWPu5aII8ivixacBaaiuvUM4yF8gAzPBPsynDoRFpkVO/Q77iYc3nzQ4jRZ84MYuvIGgsAuo8ZQPFCzk/NpLFzTGC2SYNOKdlnBBf06l09SbOmAN1XQRvcJCMYqR03ZQdIKrII8t2jw3r7wi9eVLqYZ2JpEpjDPJPl2ve4ktbZo76RrjRXokON4Mn5jum8FJqK+xY4zZfJ48Ub0IBACVKgRRrDpkzdVKx358ukxUsHzCY2REbBlVf2Qq8eGmhRybuXkyUJkBX9ohIaMFkpzFQRpKEQOgKmdKCZZ04QLIfrH7rYIE0gADwQTK4AoLq/RdTN4/3JAWjm4UI8V6Fd8efqnCQwZnHdykAcrhcF9NH4OWjqmRkN6HmBkW/4egSqt9bzj378L+g3Pv4XV54B8GPvu7WIXmzfX2hHhWpfi0o3/SRIAVDGCjMm/LDJzVgBrSAn0M9ww7+CjAxLBtA1S42SS9gl6NjR5sLZrgFzzRNEiBYgkhf7OhsZ8F2gmJHOnAS2GuQFeXc5UHwdOEOZlwMJ0kGR1v2v80xC4hGBdabD/uB/rzUYsTbQm+iX//jz9PEvvkBv1cf5+TndvHlzWLxuFWdY9J+dnRlIZQkuG0WrdmrXCt+1eLVRQb3WHb9bdsApkoVTAYwRA+BuinZZSQe6m+KfiBaJAGvPvYxkYK3Lv8UOuAwTYfQ5GWzIzIU1PwscZxj3h9R/1f6PDCrXHs8//zzdvv3mZhO9bgDA2+6/Tn/np38oDHh1WvYuhwT9GMZQ8aAQVvS4QOenwsZ+6Qbr76fmY6aBh+4MQwddksNf0Y2ZdomtK4JFjscEzaGIpUAfxA5MNQYBG4WZE80cbwDLc++bMIvmEwnO7Qzn14tJWORBT1pJzJ5e2Ls+cwcATLOjUgAt2JjofFfo2sRBu2wOr9IpewJUdKkGerQblujQo8kKUHkXE3sho44Hk0U9JyR0Rq3LeDELdOSIpp0akZWARraNWSEqnjfOzPTAPTs6mzgYAGKnMGyWRVKcoJdNi/g6yrF1vsFXeUQwU0LHdPJuTYXsaaT4azF/qLV1oEDDHIoRkU0ju5KK5eAUnZ5vFK5eCaGjeijmc5EBplLIklAPDKHoNVE7emF6bo4GicgswC7rOm1MWQpOjw/GnRId/gmOVeB7xcLSvRuwWNPsa+7GhHiPVvEYyOJ1rjMrhGg/C720nzsgR+Z3IFUaKNeZH9y9NPaHZv6HR3fPrtD1s0IHpaIj2MBsEYSldPlQ8laRZE03qc5+p3T8BpZSzz0vYWPCoHNurIAX7xxISUIWAWQym2LAo64VnMwUJmR/YIQeFEy6juC4L6DFrh00Q2lOBKQdhCugkc9Gew7Mxp/dvJAWSRW4xomNFWdDYZFFOPcs+AYILHPwoJFUpOuhIdiIzxluIimyxLDbT4FB5M/9pd/7U/rDP3/26gMA3/1YYISAp5/R+HfU6PjKCiqFzQ9A00CUfk/cAADTzpuRX1nQs4nU8FK6Xw2FOcgNODl4HxmLoDP3dlOP6hDuZnoUWT7AiGxsuR7fhskUlIuiyG7LKRA5NjIY3NpcERlfRAw63bkbmXZWwFzpMB9IaqX9ocbkmA5y/Monvkgfe/ov6a38ODs7o7e//e0n5cwHWWoyBFRAIMsBsHO/1nE/NVLvmAP7qdr+b0QCcDeRg2tgwKggzsXrGqX/MsyNUZd8CxwYOfFfFgA49tpTjPlGnf38mmmaFvT/CqzktVhANPtDqj8CAacwYpiZvvrVr9Irr7zypp8rXjcA4OEb1+i/+Hf+9YWzsWWnExiCERgnES3osoHOPqLYb2gUUeduBVCKmELggDcGse0xhWiG56K7clnZTBl9Xpy2j+cAO7ULLwNy5oCeA4yTEqrmdi9EwUgsG47owm0desEuljv9T2BIqKBJ3y3QeSG6vnNapNSeM27oTu0xR5prX43uWqjltV/0nyu7JACNwKxQLGZ0HjYNWgRNkFv/9QuhGUzZptJdmMGMSTstCgqItOjBqRS672yie3YcNhi+AebQ1WP27HmMakQAoCRAKTvOLzkr4NUQin92+QNhlE43hKyaEhENzMw9une1IVEqdAHVkKlKvIPGY1q8cOFIGcVNYGDKpA63e4D4GDPTRJHQpZ01cUK14hI/K2ayQ+Qg7EERaNANfYHnoS8Cvk/ontLSWd06+XDuVP6gXdFaZWEWqmDCLK37KyC3YXb6x+2LmS6qRvpJl6FIML3R4l9NAPezM352zPTQPZNfk1JafjZTAC65kQla15B5IcGK5m/NDA3Sxazr3woX9vMAoKa7lLfUgFmc8uwde9esK1QWY8vy8QDLgKKfggG11Q1WEZTNINVCKsLsBPpktCkYm5cXGjheTBYQGPduihrv9fw2zk5wAKziazMMtfAfoUFUZiyiwntax5lDB7fwEpRnwMnVf+af/e6f0lOfu/oAwI8/eSsCQOSSt4kLaNv9sZt8jrGYQJjntKvPRSNqp84Cgw0x+FhYAgB59KybkkbK4W7a0TzX7kFQ+trnkgD1kVGmWivwKcz7BSiLyHITqd4oyckPEMuq3jE0YJopGNbu7W4CjDZOIl3vX2mea2M61drjT4UO86HJB2dIV+nr2W9+5sv0m5/5Mr3VH2dnZ/SOd7zjaHd51IFVTwAttlAisNbJzwyBHO+nOezZ+O6UYzvW5T/2t7X3yse4BQaseR+MOsqXiWU89bufUoifKgE49ty1AnlNPpA9CbYAgC3mwinShPy5umfPRT+6/WvxvzaW8jE+99xzdOfOW8NI9HUDAM53E/2X/+6PBP2xHoBmyGunckZ9btqQBQflFYdiLIoyPRK1v2FBR8RyUMzzwpCQV09gMLVgDi7gQXYAqPlco0FgrTHaLDq9y+IzZt3ZJokDDcwUkcZKGLdHcRHWQscSCCiZBRLRPZPQ+cQQ/ebVpRaTB+1E9uroMGuOebHO92Hu3X34nnZOsFhLLtZeTwvdw0pbba87zEQv7yVs1qdCNO0m2xQxTFq6wE19Unn4+s7GpsUaQfoDg7kSUqlFlkXtBKZzGBepY7BFCVZjshQzaIymiFHTLNaxxWLSGSbYzQTjQXGzQqQLK3DgABwPqcY5rs+uA7SCWrHbaeElmvZBMpUZZTn1PxbW6LDvFmvSAbCWCjGhU2cqzI3Wj4ZnnS6KoF9mdiAwMJIThcUv0cCVNVHS/KNyjKy5RRNF3YB7YSXBjPT527N5KODGZJ5nBzWJaL8/WPSfdpnvO+NO0+855VVoD7nkC1ctYF4sJBPkhWcDAPqoYKKz3eRmnXZvVCIqVpxTzz7Xc3wxC93eV+hc0qJoQjBL5WDCFBhcghuF4Dg+2rQw5afofOcSgAx2gVwM5tNlaszS/HW04UAA2BhsKnmSDJDh8btsRTolu/BY6ibpd4uNPxZwUNxhGo/NU535lY12A0Df7/9f/L0/paf+/M0BAGTvHzW9ZWFLiOG+vuD52E2FdjvuoDiZcR93YFCj8kqZnNmoHbjOtFANv8UDFjes5Z78w9a1axo1W0o7403nldmKHVnILwk8ZnKUq3URwWyyABtRqIGX+uVnTISwVBvYnwADwIQRXDq1v/Y9hNB+P3cJYQMDpFaqdab9vobEFb2df/9zX6Vf/eQz9K2HMwFOKTBxblnzA1AgYK2THpsRdcEWyPF5W/T+UwGAYwX/SAJwDAA4RS4wei2t1AGXAQJOlQJsFfOvBQCw9hh1348BB2vsiJEnwKjjv8V2QN1/dvhHD4C1c5yP8ytf+cpbpvh/3QGA/+rf+5FgZLdwvGdKlH5e0GwrUNzRqVZBgzWTigUtB4qwOuigLEwmQrfEM9yx24l/q0AR1gVzKtGszzuE0A22LmHM8w1dxnRs1QzAlhu/HFUiXYNdRihq/79iBbhP2Loh1gJ7KkzXdoV2BYs6sSKndWc7JQc20of50DYjvWs+16Y3Zy4GRHAwk4IbvRcVKI8MecCHSjt2l/xDJbp9IaGjO03qhjy1TW3pHZypQBJb0+4/fP3MNvsa76duy9gVQQmKFjx68GxZ7jgGYbuVKOfadWzFs5j5F3F21Je0iVcQiNy0UuLrmXNHPWY8T8BKwQ67neNC/jwSOsxdJ56yzXGsJozAxhJq7nNnEk32nNmAoF3ujMaEAGTxqOO8GSyab0YJgCBm2Xt3KnuJEORpL4ESZqJDRxYU8Andc+jMts6XJHPCFg9YrTb1sasJHy++Mvf5pG2Qi4IbAKypTvbQZTXa2b3/HPTwylrqYFhyKewyAJcQ2ZyWMNBd/1Y7JuKppWEQUA6LUgNU4wtxkY15M9FhrjQVpjsHoYsKHQWlPLNT/EtyCMYNCf57tLgX5p5sIiF1MXfZ0fcixPUN5uDFZoRccuPH5fdbBqAdBHf5mT/fAUU0G2TS6EwOQGnW++Iah2DEmjt1iKlNYEFmsjkAtL6e/x+//hR95kvPX+kN0geeeJR+8q99mzPW+nk41Eq7UtqarmkWxK3YB9o/o29fd/rX6Fm9mvo7Yp1zdRz0NIw+4ZlERumzPYEjMLhI40wxarD9PB8OYY2Vvs5QjwF1M+AWKWxrN0f2j825IgsJps5NE0R2WmSt/c4XZPNWAn+WOvfIv/3czVDbBn+/P9ieYu5zHS4xVYj+5JkX6Jee+vy3qn8FoHY7YwJcpsOc4wFLKeYNkJ+/1clH0zWMz8vF85pcAedyZBMc68ofK6jXTAxzQX/ZyMCtgvdYzN9acTqSGJzaPc9F891EAG4xAraK/a3zMTqO7AOQ4wtHx4Sa/8PhsKD+n8J8easW/68rAEBE9J//9R+iRx+4Hkzxxl0TzyOWZFSjCxxuoebkyqybsJTeFTrw2mWvIqugAS74s2pS0maJQfdWgdqK3wMLBi5s7vdTiVpKpd0hBdNp40sdERdeTJCZxYAbP0wnGGaQqvt4ulFMi90jskp3+S897s9vSjHqsG4I5rla0TWrjtB0lEL7Q9/kUvNLYDWXkhTvJkIzJwo5arWpfda1Eg26DATQ4nPi7lreQADtwqhhH6uzMhM9cM9kXenQlacCreZmCJjpwsgSkBw716+xGxFGeryeZ04Z7BSiL8kYApS6oDXQ0xxowu79Ya69u8TRxEzcmwAL+EUXH9AXppWc9AF1nDFGUu+j6nF52JnFnGpznucSjP4Y4v6cESGRpqw504QZ60y73m0+9I3kAuAB/XvI1k457uihwMlyDUEf3XBzr8DRoC1328iouRLe/+t3Wjes9J/1XNbajLJa1Gbr/h9m91e4d+d6eRuFzeVxGCWp4NU8i7EGMDXCrl/3LCi9iFDAS8frVCZzBu/NStcrF3XlJzOVm4XopYvZrrWZP/YCYpqQzRTb98gQGG9ACnkagM8rE25GtOgmpzOTeUskcyuY/3O3pw5YbHictd/Y+no1W5vAtE19ciQBndj1rFDsB1CUPYEDx0kANxKLTcCHApNmxuwfmB9W1vOf+9U/oKe/crUd2T/wxKP0E08+HsAcZVEV6sCxGpuWydJZuCgYRuB7MdkcgzEr6i+jrByVpBkriJKLd9+7lMQEiGaubmqrzYFDlwWoTGkO87B7jRD+rtIiFlZnVm9+CE1TMXmB3w9Q2Ff3idB7p60rLrWa+wGUwrQ/NJq/7jH2+z2pSaH5AOxrGL9MRJ/4FgAwBAHe+c53DovirUYZdv7VE0ABAdraR0IhPSqot+L2LgsAnMIY2PrbiEmwxRY4NQlg9Le1gn50/rY8A0b/vszftkz11gr7U5gCa3XUsKG68n5bf1PgIF87jPdTIEBBgGPsC/37l770pTet0/8bBwD46X+Nbj5w/SQqhiLHnLTnWFBjpy/SPyV0XHWBrVDEI1DAnUI/MutAFsKi+xG6lxzymM2JHYvoru0tnG8ud1yeSuzOOm2cbVOHBUJwvSZ/H9ZMbVthIz2ZKJlhKAOjds+AbkSn5j+I/N9/T+mMBjRRY9P263dqMUPFXf8h2kxdfNvi34r/mgYmfr85cXWRQo6G+Ls6h/MqQnRnJnrl0Mq+iYjOdmQLmU0uMPloQXDjfGrmcMxhHE499s82vQEM4gVIxbgpY6SNe5GK4BWDo3gwjKtxzGls39xdkbGQUcBJmRszdNHJCrkawAUDCwjNxHyz74yT1vnHNmbQWwNQ04619rgqBxIY2A4ZWLC/VRr6efj+GX0RynqGLmcGB/bkKfgyxEjB/jkQo0np79bpF4EM+DiKSwcZsCAT6OiqjhzlGCoBYjBlnCvRS3cO4V5m8lQNzc5u1Fk/r+cT01mhcF8QM+39ZBDWwAwSDu3um8KIIguk1hb7ORU9P01xPxUoYixWk023nM0ZJ6A9MzF97dXZChylPhudXhMD+gSkcYC9vl+JKOJAGTZJzLDzFJ3wkbWDawf1iDYivb9icS1QPbfoVQJQO4LHuk5VkKoUmNPrRmeIeWk0iuBBLMqSMVvaAMR1bVT8I8C9Ta38nz/yr+iZ51+68gDAh953q/lhTCWALm6aV2jqhoCahqGDZTcVK3KZi93/rauq6EBbRAxkha697i0KQ0Y2I5MKvQCcSs99TpmmqRX60mU4kCqDQNhcm2dMTEARA21brGFNCqHIJvNkIzamIEa24nqoDEEGtozFPM+1b8al6/+l6/+rmQNedDPUvNb/6bMv0i987OlvVf3pMU0TPfbYY0e71nn9nKbJqP9nZ2cGCIyAzfy+2IFdo+xfxqTwVADgWGJA/l2WK5wqARjPmbLZvT/le54SHTii8p9C6z8lMeCUjv5aFN8WALB2LtzjpCyYfPp7NAUspdjYyo7/ygIYeVOsAQDPPvtsBxjfeo/XFQD4Oz/9Q/T2B+8LcUhLWotv1iXsxCGGi6K7cf4W1m3kTEpkW9Rww4UdXkwAIKBgtnxd6MhBtwS7gw7wJ61p2kQymFBhERU2aFaUZd27x/bZxlqZENCyLGbuxxYzp34D0aAnTabgqeWmbu215xPTPVOBZADqMW36vYXqLE6NJrG0gKkQ7Q/txt0fKhUWqpXtueiE7zKKVpxUYpIedyRwLjN/V+ZKO4n52bN0fXE/T7uJadqVHllWTGKihcJUGiBx/7074ipmGoixYNqpEwiu51BkuPkZpkhgBrxZmyVXeQE7Lc1XpuTmHZkn0b+CQiHqhpkkHrWkH6qmds31vwTzsLjAKJvDu9xTz6c2M8cBeIZmhRU8EKwziaAcMHf0+VEC5OMEDf4sUUHi8aL5Xo6rYqCoYna80mrzhiXcjyonKWWFJUAml0GJj88HDgq151ZQGDgwY2BJZ4xUEfp6BwDU06ABBdULxTrTPFea52asV0Xo/rOJzvqYNnYEM8lUFhYhi/QUIZpIzDeBwXlfvS123XiSi3Tn/9I6pKU0BgCcP6U844RYunv6ofrY2M9Cd2DeYZ4aoMhNT13Ud6SDB7HjzQHg1M4/QWcSDQups0KCnGNYGK9tImLxvdzQKWjicxqThGQANYqz7nsB41OY5GbsqImbTOJaMlPU5w83QRl0AwaNAVHEIMeKnawZNuNr6/l//wu/TV9/5eKKAwA36cNP3lrEEjsbsRWzZ31voqC4RoPqGlDU+Z+ECk9pIw7Stn5/lDLBWCjRQJAEKLRx3sUkBrJ7Q/dSDtBbIlGfnDC1xRop6DHR0dipODBdoMGh3hUK7BkIoKAeNFl0zGLjQ5kO7m3SI007g3CeK811bjKGWukAKQAOeDN97qsv0f/1e5/9VsW/AgIgE+CUAhxNAEcsgK3iOxfU2JHNz7+MBOBYh38r+m/0/mveBGv/vgyAcayQPvU6HOvSbxX2axKAtWMZMQRGjIFRjN8aAHDsPKjMJEv71hgJOp7Q5f9wOJj+f2ts4fs888wzmz4O3wIAXsPHf/pTH6Rbj9w/NCaKxnxL9/rlRaQFVXmxMGuXczB4tgZpNg7ELv2mr0B4XdZMJtM4cMxWAAAgAElEQVQldMdFbbhgZJQvjFhkmBVaL9qwG6pFD+7yUE6BoETILA+dKT2uGpB5ZqF7CjvDgNyQjsCJ3q9HnyzV4V/08/x957maCeDIA2ByAgMd9FxIvD6RwVtpmqNRoVDLHaf+fUohOjtzc5vmwOzFssYpXjufPI4xdc3UsZk6QMHMoG/GuLzuQN6p0THhgGPnL4BSjWqp13eea5ggXdYRc7yty00uAcBulR9bAxdm1egxL/TO1vUJMU7aTVoCBYjSYtGthQqyZZSRMBX/NxO3yCeOnVtOmzyUq1dy6QNSTRnkBMwoyqGg0c0aV9tU12rUdYH7aZpKK4QpUf/h3o2MAAcsnUWDd5B6NMA9GKQBYiybKo3JMvcYLwXcmh5WDFw47A90cVBgotCN8y7v0WFIRPtOX0YgTZZQIxWN0IPzbf4I/dgLCU27BvcZkNp1zWrYiADYBJEBTE6BDou7EF3Mlfa1sw2s6zk5SwKKe8fhIrOg6N8Fs8w9WcCiAHuBwxhTBmsQJEsuUllcZpK6PuyI0cgQUPR+gvXEgIAaNy9oMohrUQCs0/qWTW5dFubrJtNyvRqB0JHeK8GUcG09/2//6W9deQDgB564ST/+5GOBHaNAza4b+u36+DwrDmRyL5aJWxygzjmq90ezyzK1+F9Wg0CQ2+QNvo4RfJ7eFwrGo0mKSgaIhOZDBf8iL/rRbDjGYboEQAt368IaGKX3mxuLUlibyMF9aowInJcl3FMOSjeaf+/8z7UDm7NJAOosNB/myFhgomdeuE3/6Lf/7FvV/kZBr0yA3Elf2yMrC0D3S+oFgIZta8W3dmO3jPi+EQBgjQ2wVcif0t0/1vHfSkFYY2mt/X1NErB2fXgRqXx3EoBTivMtAOCYRGD0vmvnaqT9x7+PACdlAWjhryDAqcaLb/Xi/3UHAP6zn/oAfdvbHmjdrKqFE5iRVafPVVm69OumRFJRjQuzdkKMMjr4khoxNfrmNVGllYaq3U+NKZzBPwAHXAEwIw5CDgW439xkm74QMTVwcaaBIZU7asf3RCqyagYZNpCor9YNTdYwq2a/MNP5rtCOq7neuwmdU+HnWs3Qi0yjXAOYQPBv2yxUof0srcuvucUlmlIdaqVKLV4MN9BZe1oK0XRYygBe2Vc69EM42zFNu8lSAFQr2br1Xuzfd17ciIQi1d/BAKf1Y8wZqmWVBTCH1yoIUAKzADv8ZnhpHRTM4G6bo0LFrq8bjonLIhhlIShPoSifkQFdLQFLOJzV+0HBhVrdk2Lqm1s3s0xgEXHw+YhnCzvRFbq3HBbEqXevCfPaGQsVjhRVLVyh46bgh9K4/RwlQA9BSjXLMpduLBolUPcRhFPQRwEgM27rcWLa8S2hqxcLUyKiF2/vwVhUDbLUrr3SLJX2FwfSW+Bsx3QvpHSoy/sB6MSBMYE0DSE6A9PSaRQHJ9Iiz7i0yEKgKnPXNYfOv2nGQX8OAA4mVmg6wMWMMqc4DtVwMP/d7wUHTzlo4T0mVcDwjxKAg9r6bBZbYawHhkdKYxEAWAnqs5HcrDEhon9AlrVp52V1404xVtBTXBQQh+NKyI8Z0ME6G1MWBOZAX6tH6/l/8/NvBgDgUfpw9wDgHDkM17gwd4CN6XwHjCVurCLunQ0Fv7B7NnUvDu7rQfSE8chHnW+mqSdo9I2Msw2cFVP7uro7m9p1qx4bql4rxtwbsLbUc2gGrwFlK2XvI4y9xf0EAzugJN+kChIqvelM8VVrYyvVue21zNir/e5w6FTfQ6XZJHltfv/y11+ln/vop75V6R/pvj7++OObBSzuBbTrr51/BQMKyFQyPT9310cF/2WK9GMSgFP+faz43/Im2AIFjhkqrnXuR53qY8X/GgCw1ilfK6a39P+nxABugQGnAgL4e21umczpCDigbv9I/9d54pjsgpnpi1/84lu++H/dAYC//VMfoFuPPOAZtuAwLUILsyMiWmjMbBDDxjSbP2Fmsi2mRMEpnKgtiESRkm+abCvafDOGOm18H+yIoYs7xohVpcWBM1k2YXLnfjHJwbLLumRFWJEIhb5i8/F7uTSgAupuxTl5YY/04xb11YvGuTbjI6HQ6a9acab3nSFv7VDnZlpH0lzQuxmiojEXM3SLMxDCzbV8Jlq0KjG/nMh9AFBycXEQuqhtmzCVrm2bClHvpGAnkbnQbip0baIWqcSao9xej0wJNIzTDRnKO3ZTMQ2uwjJoQqkbGE6FegWav+Y1O9VXdaRIfUfAA5gdMFaVyskA4GQWCoGhmGAWPUGUXr8Xp97N0e83TcULXSgWiBvDYwJDxGKgGtPZVBwogvupio/hqTvII1giFecDOMOFLeYvUqGh9AH5jhrQWQqH+Ou4H6ulXGTwrZ+/qeh9xFA0eVFVINrSi9BYTJJI6MIJRnT1z395Xw2ktMSGfs6ltszsOs+ka9u9u0JTicZxRER7nkJHeVFB9scZDczh+nXc10o7YtqdKbul/a1JQ8i7huL3D3GxcaCgmsG3KKMSojIVmkXozkGzwmMRoZIVomg6hj9TknY5aBejZAtFTTz6mgiAcrgmbS2e6JJvYEFijMR5eNlRx3Xp0O/bCebGOtik6diwNI0Fq0vWO1GJ5ZQjcUMnkRGkH6/n//U//rUoJ7mCjw8+cZM+/P5bxlLC+bIUtnlD5VUFxt806Thg2k0dAGOiwpM1F2yM9jSaZhJa+r3USGsa8VemYpIW1Pu7MaEsEmkmSwToxZhIL649jSUaxEKsMCHNFyRm4ubLem8pWwzBYpOWATOA+pwamZRk30UsqrANrsPhQFWa7p9IqM5N4rQ/9Igv4c6iae/31Zdepf/lN74FAJwCAty6dWu1AB0VjQoCqClg7iRjoYzvtUXd3yrSjxXzrzUAMOrIX5YdcAoIsHWut77/qMg/JgG4jFQAQYNjzIW7YQCs/e1YMgGmAdh62Dv9aviH3f9jx/HFL37x0pKLbwEAr8HjP/rw99F33HzINgxQT/SiYFnQtYXJd31Y3PPgRjJNJEnY8OLGrULu9oi6uIzDlmEHwOl3bo2En4vGgEbNZwLKNRYStDCwEtiwqrFcoD+DRq9wPnJwHyc0youX2/WC7pQftMxV6Pp5K/5K35GoU7F2aal3I5Gt4RRBgSJRbHOhxnWqHW+LvB85uvvrprdKkwGgBwDUXHYuzmR2OrYVT40+rV3PHTAAKLn1MzHtdoXOJqLzrv+PxnUUWAFMcC7Q/Tj7U7AXq0Hfm+QqDh45mBKj7XpXpv+tJhodNp8xj1k7OOZVIK45R/BKO/N4D7ZOkL/nlEzEjAVB7qRvwF1Hdu2zAXhTMyztxjPkGErIYXczRE8qgO4/IRjgXgbo59EWtmp8UW/SxWhQBPCUsorvVUCP64BF75qBcZZ0UMOZCAJzm38DN2lLGuP+er07ZyF69WIOxaUAcNLkNJXmw2z6/HsnlISQmZTdnkvvJK4t0kRcJeS6Yxa6jrkdEZVdK0yLxZKxFf8KeBWrEh3gY6D+Z+o9g9/HVJhu7ylQ7un/Z+9dYy3LjvOwqrXObfb0Y2bI6SGpGVLDhykOSUkk5ZdoiRSjWLIM2HFgw4okJ4GBwPmR34GT306AAAECxA8EiRBL8J8ggSwZkWLasExJNvSgRIoWKZGiRImkac1whsPpx/SD3X3PWpUfa1XVV7X3uff2TA/Z3TxHoKa777nnsffaa1d99T3gM1lDXpINPi1lGsg6QdB2wdqH1d1laTyJHjGr7s80YuH0dxDALhncpmXRglGxBGwTfb70eA+RFfAmg2nZ8GEt3m9RQMN31fsFxL1DXGe8nzMT/Y//z7+l+73Met9Tj9OH3/XEApzUqbUz/9zLgpksrcL9ABgm5WoWONhbRc0458ErtRj9P06/GGoU8JhBjyHduxOypxPUYcyLzYDvOYVjgkwozIExOCj6fX5nBmnflEyFPVCS1GTce0mmZEzvu0H26dnefYKa6gWwbVvaHjaLPM1JURev36Kf/tU/3Ff2dwgCrE3cs74bAQAFBHCN7JqiHzWtfzUAgJfzd/QBOAoAwOfmvx8VV7fr+B8JyB7xey8HADiKKbALANil8yeiOzIBPA4owAk/pxj4zWbjg85pAJij/3T6v7aO983/PQIA/Gff/256+snHrMARKM41MBebl1JGM+RTUXTYZXOt1eIGHbZrmrxicSeWjc3mVIvu1kS0mFwwZddxL6yxaGf2BAAAvYf+rUQGAVJMjWoMKQCxAaLlhMYK1FzIuTW+YBFix6qb4VV0axc7PiqheE2ddFwDTiRQxoVUT87Umk9/GzSaVjyam69AVn03t/HemBqYNCItQvW1h3C8TDKivcXMED9dummeoX6eumKZTraFStmMCfOcvljjOH/v9EGl12yqsRvQ3s/0vtqA2oQGKLNQKJNRHqemv0vK/KYw7bV/7wJGSwIpBX1SxotF+Y0JtZhrvUz9thn1FZ+YjgkQUIsTsCQyYqzM/Z8w3s+bVdRxY5OlDT3G9iFrxCazYA7FFGUCSjkuZURtqcQgRKhxsQm4gyTsplIWOTm2mN7B4ArMqOyGywW8E/L1BgAHsdH2pTsw4RpaiNBi9MqgGJEo8TkMrAkGRo4I0WHrdDj9LTpEaurfx7R65miL0KYM1s64HuPeekuqXzcSI1J18ljAHyHLrVSuUOtY0wUoDWXmoxu1n8afC3MExoI5KptfRtfrRCeGtVBvQreamNcGTvaDw39oijlMNd2XwQG7UkpoVjCZQc0zVxtcaHQ7NONZDpAb88W0fK6bbRNzbc9FjN9rlp4TOR2gUAShMH4zFLKMgDuA51OKF4s42CM43hP9eo/3c6HBAHgQAIAPPf2E+YXgXn2g6RbkJn7V0kLInPstiIeL7UscrpUB7I9JdgnSIhIiNkDAqfMqW0JGS4f1Yj4Cc/8txNRpMvKSX1KWT4qli/h1RuzJMbhn0mQllvldMAK48AB9kR3IzMEvAxuMEVvqRrhtTvtlJgDo1L+1Nn0BJPgUCckEAPYMgDsBAZ588skjjdPCWp0AAMYD5t/TBi1LlbBhjqylvnMiftQEf+25J40I3AUg7AIxdiUFHCXFOkkDvNYwZwPiDBisufqvNecI4u3yD9gFLiAAcBIGwJ1O/ddACHT9z8ACPk/Xl2r/lQGwaz3sm/97BAD40e97Nz39psdCI82MxTpO61F7SWnsC/nGs9mpzHDziVMkBgOn5aAEmmzesQHOgkl6LDK1QMTpEWrdXFEPJSNoKVFnaYXwihlXbtDwuIWIJ3R01mYdppsdqlFB1HK+aO9ETH1QDonoNRUN1kaOsDcw3SfMM3KowGspHdpNg8Toz2Uamw0JgBcGbdtpK+JaefAEqFpoElHn9WmdggCv4RbOcc7IZi602Qz0us+fbUolIqa6YWpbpSm6YVYBPQHDH0xXPqefBNNwzE0rUwvqLuBeWKGvQk+gT3Sf9u+gzRpOXKT3YBq4zPyWYBIpktcHxN0BGKCFXDAJZAYvCJoxWZWEBqCD03plE9SChWr01igcDSz9cLNF3HFqxgtIIhA00GOq16OyNpSSijTxyL7gxXrR/UeTQCiAFGMt6SSLYF9TxgqzLLSyCJ5ZBCBc4IWSbny+qbIFzG17roltb2Ofk06HXYilh7WUp/fMRDe2ZABIMHRUPw2R4WwuMZ60QSxepUFzZvYIvlqLeVuo0ZkeY7yebH0XAkozgWt/pEcVZtr2RreaA688EQwzBIzcp7iOwJAP14x6FRAhwyM29X58IjsrS8/sFAKoY4aOpoN2FggFJheHaEf88GtGfwXkKpR+368bMhkL5+vdnPt5AWoIAJjmZwLJCXg/YgZzWbgvffXyDfrf/sUn7vsC6X1PXaAPv+vJGFWqANRksahEyECrudeV4veJClGYlExlh/9MocpMTRwYRSDKmmbz1uAZKynOYtPahH2NVzDjFDPoFbuWY+0wNf+UGTUU/GkQtNv2TgfFjTSD9EejAO1yUxYJG3uAOErqNIK4T8bgcPt387/W2jAHbIMFIMmzpJPQ//qvPnPfS0++kQ81BlxrNnNjiAwA/W8GC7Krfq41dkUCHsUCuNseALua/ZOa/h0FRJyk8d3VgO/ySdg1bc8N8nERgMcxANY8AI7yBLhTMOCkv3NUwkDW/WPs367HxYsX6ebNm/uL/ZsJAPwnf+476P1vfUMwteEUg1dmId1hYgKpZaEYddf1OB2RRHXkfIExJcOx+drI2FadHDhlW+Y9Ow1WKcFGc4eGORuRdXEdtLA7cpsCf8fn1pIOjZ2CSUvhUJiPeyhml8MxFmcNeGEcacoyP8umsr2OWxd015PSaAq3rRtVWhs6NCLUixO1z1osaOTPdqtFiU8icJbXu5/3W1p8IrADRenp0oPBXQZ9NtNFuczIsgJFElGhAqyAoEWguA49ooyD479Sn3WtkFHw578VMv2ArrUhRxj/NtbVWH/u3O7O+uYVAOfVjm1gDgwHdlmZ8rsuFNcsyASgqEVgTZFwbPCHAZjGPtKcCrmswFz+YUKJVHItFhmuEyZeFCHdjN3AJZ2W+4hSzIPRmqg3QPRv0O9bwJhQ9xVkFHFidAhIJPScBYOtwLrxeDWb0pGbsBkFVs+30db99xQo0AK5UHE2jck0tiSdzEHb6LkgU9Lm8PrW18paekkVAPvQAX6CSJWmNwS72/m4lshdzufeprIaoz/P469ri2aGOoKivgcUB06IqHemQ41SpBKbXCxCV+INCUFQkFzhpKoUjx1xzwGXAQxQGQpANIETSfsOB4f/GGObisCwR4uv6TA5iz4dmSWgXjOF1gvHCPguWQsZMO0poUYkUv7Vh2Ptfv7clev0v/+L334gAIAPvfOJsDchWHVQi93HmQvViuCjXgu6L1U3EtX1RS6V0ZphU6fx3zSlJZAwWUoN3HfM84ejySkD4IDsPZZhqhvTiDxRRv0vQuykLr2CMsxxV6p1Nu7iIFCe6iJASjPKsxYE0Pz+03oj6sNjQNqQPCnV12O/0tQP3vv/+JXP0bVbh/vq/g4ejzzyCJ09e/bYHHpkAej0Xyna2JzvMlg7jl6/6/mvFgBwHBBw1PNOGgV4Ej+Ao9gMRzXPuyLzAissmf7diQlgCSlIrxwAOKm/wC7WQtb9IwCw63Hz5k26ePHi/iL/ZgMAP/I9b6c/944nwkQmFB1QuIc0AAEJABTVhorjNA0b5zV3U5wUUtSbxyIt0vMlFYV41HIzTYyShexsPjcNjrICBpQBjwPSWZHGgCZRGGUWzOLIafYEdFkSNPqLEVpKnD0obDdtmwLOfG9Wc0SlFkKDT+H9XbNOMEHrMy2gmMv5aCJbF5I2imr0FCDK1FOXb3y9x4kxyWAAZEMw34DciGkAALpB0gqqOie86s7OOPkna1CwSK5lGJfZ8WRtwmPxqNMO8xWg6OWAxT4lXT+CGR6NJ3Yu8Mq2Jhum5JgugPnhsDyC1p55N4WupMbtsLUR+0a0guBOecLU/esEu4eRok9LO2isWxuFJk9WCcoZMPIqMAQALFFAqgQtroIgeL2zx5+BtMBozhSNRvHGFAEMZO+IMRwsU5uVibP0bljLt1YGBk0vkOGj0c1sUQvutm3UpNP29taAQjVd7OKT/kMq1MTBlsJDzz+Aj/HfbRPT6GLUqnpTHGzUS2GcPI2JMq+LOZkkwqQTNmCqUwRQ1cVfDTWHKdgEMydIRzRc8rddjGHFtIy0E4omoOb5IhzuA8jCUvmXGu4VzmyPKANYm8YLGKN12XGzBfNBZbN1ND3NG16+7oAahhGdAoy2Tu7fYNIh8ENwQHfJeFP5moSpVGRRFZZAO8/38+cuXaef/FeffDAAgKefcNkLc9grkC00PABGPGyt47rQabjeNArxmNiDH0Wt7u1T62ay6+b1Y/ea4sMK0gjLEiRynAwKeRoANtj/dS8x/x017jWpTLFzqM1/BYfuPvcuj7AFp/90XfjeMpgCBWJWC8i5CkQjW4wwCfUmrvVtbTABpr+JAgAK4AqwBn/qV/+QXrx2a1/d38Gj1kpvfOMbdzbf2JSpBKDWapGAeQ/ZJSnY5bB/nATgOADguMb/qAZRnePz5z+KDZB/viv2L7Kult/xODPAtedmGv8aAHDUz08iAVgDJ076s5cbF5i1/xmw0HOlTb8CAcg4WftOL7744n76fy8AAH/p/W+jDzz9przCXTNdmKTHQkdEDccYNGcd8m290upJt8uxZx43OyKb9mkz2YNTshZw8985Ts5rKUNHt6DkUDDP00Jz6dTsGmU01YHD4dOZyX5Ab4AsP8DpljYRZi+nlPuCVHoOsVZOLZ+NFRMdqGOxFZbeTCndX7/PtnXLKkejOepODLW4w1KoS6M+vQLaNPLRZnAYA4o1HrHaVdf7AtNKoKbqBF9p3gVSCcip4DKP4aYOClsY5c/zYtGAs8CtrEZ1Epgq6AitEwwHU+bqCkZLtJAF+Boo4K8QGRAekzkcnDel2DFvqr+EZAaLc4SpSIi508ZdNZ+hoEXPgPn9wKwJM5f1OiGmZMCSGnhyQKFwpJLbFcHqOaDxdrG5coo6avcndT9NqjFiUCCZglWzL2yMlQ5U7sIORG5bTA7AGEHNskdmg4DPBc+puOqiKWi3x/S+9Q5NqUSX9ukfoGug9WbNaplSHIzb0oaybfuk+nY63B6aF4keb9cfF9f3Esgj1H2/sE0w25zEdRipd5HhDTKZLerqbdfOXCAVCo9sVhbsHRki/IBl0KcPzAB9MVqS6PZkniAyxgBy6vcpwZuFLVWiiRvpFZxcgZu7nr9qFOfR+NpSBI30modG4Yhe5iLPPQtlYbbn1wWvFJXLWMsutDDIJbyfscb1+f2GV8CEHNWWQQsEtnq6d+kPhIi+9NUr9E9+6dMPBACAEgAEWOv8g0qbKntTzGAUquu/1hLYTdrgF2Jz+CcuZo6qa6/bPR6o+XPTrGYMOBt7oeBtpNchJH7a+lANPZofd1hIQRpDy8SIzaSCKNivYGu8L0iocVDiIxbzOuuZ1g00L5N9sN02at1Nv6R3OjzcTsbBYPoN7wBnbP1fH/sjevbyjX11/zJYAOfOndsJAOh9Ss3/MB5QvUt2UeXvBgBwnHTgTgCBDAAcN+3P0ob8vF3N7xoAsOt5J2n+cZK+qylfDr1eGQBwXMN+HABwEhBg1++iHwDS/7H5X4uy1L/fvHmTXnzxxf3FfS8AAB9455P0l77n7VFzCIUHFjEUaNa8+KRrWcf5BrXTZTMVO2tgQaT7SjCuwQVZUpErWJhKzF8nmDThxD5PddYpNBGdXBpeYSwZ3FgVIQeGAs9NT3XuZCZgNB3/vSEwgGGi7pbhPW++eXJlRmKQY6+SBLFiQizf3GjNWkCI0HY7igQmsqjGwkhLlDBEKxo/Z7MRbTq7lUE4fVDtGsG6suxyzCwndmMmvGAWTmBjchIaEXb2CsoC8HUInOSpT2mKasoXEZECGsm4TnVNm7aeQNcJOnLUO4fGGAxj7L1DFjV5qgOYQWlTGuA0phgXFSaD/tzoc8CQke6Fo021JpC1Rl3uYHhIoD/FRsmABGC76L81uFY0mrHP5ASdfHWJMXMaeUjq7o7xlyzOCtGsdHF6uKU7dGdb6DUhsKYspaFwKkLE/DVkgghd2lxns2huW+qtW+PaenfwQopJlQw/JWAeTCMzZ8ILbZt/VpUlbDbj+NXN0LiU2fnoseHpG1GMTeP7kaKfkYkxvvemliB5UtC1ACijDc6tLYUbhjFoOAp/HKBNyRXQ3EaDJTeWzR4t66wy2Bv0JKakF/RSQHNAPK96D+GIa0+wAQHEaMgowGkIYBjRAlzOPgB+nbgUDiU/WbdrXiYhORb8Eubvfemrl+mnP/pgAAAfeucTcF0Co0TB5AkGF0BIuFAw/BvXBHu9wuhhwQszL0v90X228JSlgecIoazKr6dxfYw9ZzTpZeEHpHK94IYkzg5RVkE2tFUmVEHAjBOBS2K9o4wfBFAE2FjdJqoeJSozAnDUU23uy4MJ0NqWetPUE2wIx+v+/L/7Mn3++Sv76v5lsgDyNHxtur3ZbKzxH0aXZUEXvxsT+rsRA7hL1nCSiL+jfv5yJACrkqwTAhVrLIC1P+8CA45r7l/OxP4kz8vT/Zfz+3n6v+b8v/a4fPky3bixBwPvCQDge7/jSfqRP/12mybjp5BO4CQN3b8s44ZydBMah6mWFF3Ws74Yp+YdLKMUuRZaNu7hwpz0YAZtK9HSHErfp/e4kfY5Fa9cQrZ0WyBZ+LoATADlOdD/pXvMnH1ngZuu511r04HTqTMHQLWBKZM3Th1QuWkqBHIASq7XXbo70s/nYB6w6pz1Rq6/f7jts/jleZyUAckEHkYecUgLBvmcxugT5+eeZmM8iyJtFos1KM68KFytWFONuMaWBY02TM29qOZgkjUKGl4YyzFO/aD5L8zBcT47tNukORm4oYEXFl/oYYCa4chOcYM0bcJbE9rUQp40UczETJCBAdNznBITgArKOJgY+pgOw3nsdixHIRjd/JOBHmGKgTeERgbXtcuRRaKTe0nAVS0oWYBEgR69RxkbdAN9evAAyDRZgf0F8JBwXTL4Inj2OpukBhk+2swb20fcoK71TtI6bXsnac2u4bF3Tk2+xKLeaLqQakEitJla5hH5OLX3Exwa8qBxQDyHnKxBsUJD/VbQJA2zVyfrI6ldFg1qKWUwjcjXv77H12/3eS44TKfZDDbFQJvC43WInb6tTZuCiqUkANpQC8hC19CaFDFrMh+43poIpFvMVIYZoxZlSjGytCTgh+2+EX1NwqRWQbAASC9j/fKNv4KvRpTELcGPZYEWAQx98c98+QX6mV/7/fu+QHrvt08GAACJFnkHZn0sMrTRE1c2rx/SSEBOkX8MrEen7Fv0LRe7dio7eKzsGaP5O6yWCvy5r7HHqAr4QzQ1Cu0CEamy9JcBeYNKAjVRyKkAACAASURBVMpqMQ8mkt0rqJwWI8CgCD4Z8LxShuRrPHckF8hkA3QFOHuj7eEcJog42F6I/uXv/gl95plL++r+ZTwefvjhwALY1SBmBoD6ACzA0WOa9LXJ/p1M8Y9q2I9rqI8yADzKq+A4z4A7AQCOm/qvDTBfTgTgNxsAeCW/r2sjR/6p9v+oY/qVr3xl7/x/rwAA73vrG+ivf+BpmyIR49RwWZ5YIYc56uR+39j8MMaAJRt9pt3TfozB0beq2ozj6xOBYU58HSuAdDFyzKfH2B0sdJt0M8hamNapg7TRmtm+Y/IKhCkiWdFbQPupN3rVUDczCHP07PSmBGAgHF/QGerkXr/YoGCjltwpzyQUmpQuo0ERjj4NVniI6pqZbh+6eZnhQpPGq0WKFlkdCxCYwMXiepgelcrEvKFN5WHKNBtvNShDLWW35jDmiltbnSbqjFnd6HkA2n4BN3SeQNJwTmc7Dt1okkKF880BDefKjMp0DSYMH+35KrHAayJrgE1Xms33GBuZwYUQlKTQ0ExrI+XTR45NjV/VA+wrOWVjsgzMbwHdL+akaHZHtVabzBsUsRLbp8ek1EK99Uiz5jFB189cS6HD1iE1QGLLBBRf1Xv35iahrtEnMFYEY1A1k+vRS0TNMH1j0/EZGPHMA9SmX4YBCF3Amb3T4bbba/YZlTUkU8WkNhaNCOc2MzLqpOGOz+keCWIRZORAWangcj6ZP2pANhkICrC0Pg04FaiqCowNJhBBGgDuk3odCuxnQu4dcLsjC4BDDJrJxVRSoGki0j1JAMChRXweMDK0M3L2TLzvOAgJYHBhSPZAwzwy81UESHOtwuDTkRtyJr83doq+E2XFjyJCyjFWFl3TPZHEjS6dfSKL5n/tfv6pLz1PP/vrn3sgGAA/8K4nAzVe7+eVyOQ+Clpu5j2WS0wFUhaMScPm/jno+SWY4Nn9fprRmkkoRTnLpnqMKkq6UH6j9QzDfUwTAWot5qovAMRao56SWNBrwLT6ylJSyVgHptL8BIXLMqHJpDOTycQ58FhTgvqM/Gsh//vW7eEJ4Ca0fk/9xc88Q7/z5T3t95WyAI5raJEFgDKAO23ITwIAHAUUHCUHOE5ecFS03y6pgdLOXw4AkBv7XeyEXccgN82BNZTkBrtAgZNM43MM4Fos4Ekp/7veYy3WcO13jjL/O4pVsZ/+32MAwDu+7XX0n//Ad+5Geihxx1JOPTrRRjlAjE4zUzKh2FhzmpZAMcRoTEMx97zApN3Q/+Jxa6sXNnGYaOnvYrOaFy5mqfsUddzsIRZ7MfHHiC8krapbdakwkdIoQwNVxi9vgEbncWcCkyt3jcdlY7pBoPbhxMuYBhRZAA1MgcSaOTJJwED5eDa4s9gsTNLRWZjClBbNt8bfhVqLU+66KVRroU2t4NDMYXot5tHgE2Y9N2gjGXKyp8FbYT8P+Tl9nseitHbyRl8LKWtW1ChOGIAEaAjRtZuXDUcGndYmNpIkAKj/xcYImxQFtjZTduFTdbKJtTV8DczUEuBm6QdTF0tCofmS+TNds8oi0G+d0wBUhoFGQXi2CgAsBvIsDPbi9LOsTEbRtV2NtHQCTSJmuGXHliQ4z8Mw2YE7Zc9g1rr45+4iwwcgx69BioanbjAdbg+pd6HDw0bbJsPskmK6gk7nCyRY6FoYtGFvHLXx0+mc7r9K9R9roBp1XieTYr4FnAw0OTSVff4+pVjKgIaGSbszbwoPZkLrygopi30cmzadTSqYo2vYm5Rl1j2yXYLnA4LKwLDCPRgBYwFfDmye9R7TxCesOaINm3qUu+S4swL3TG/Cok+MNYaFA7soFNS04kOoQMgRVYOev9/54vP0cx+7/wGA9z51gT74zieCR5AZxPYBK9eisXbFWIrK/DKpDQN9kYtp93HvQpabgmsqAcAkk1I8GaN1B2w8yUYNNOf1XGsAhHm+n0in7dxXHDRF/xHKUUQQTcgrzBJJYjlnIA05UAlrs1Q2WY5dT12gnhNrtnrvtN0eDvO/baPWxRgBWNcxE/3aHz1Pv/755/fV/ct8oBfAUTIATARQKQCvrI21pvyoWMCTAgAn8QM4CQCQaeS7TAF3fY9dGvS1Kfyuaf8aKLHsD9bN/naZ8+362Z0CALsiAREcOKqJPwlDYO218PhgCsjYC7ZHrk0R2U//7zUA4G2vf4T+9l9836rbdUCbVxElCkZz+eGGXLHoIkC2sSCLG1miMOIFyRJMzdRptsyJpOlrGZkL7Pd7ydTfdTaB16kQG6gTPlFddKTaWbPSkXocJ5g2dTXTKJ8AjinyaP4bUE2V7q+Z8hY1Nht0lkgf14alC1KYgTJLEpIaBpJPU+PfLWlgFCCdehuvtak0Y80EMqrZoq5KoeBWXWYH0q3XmO8rs0irQpu6GY02mqgQZJEH91QmWpmfBYkGU/QI8LhxcEoeBX1FN/Y5Ca+1jKIHaMrj+d2z4tFQCdkuFsHlmc8ZuNEzURJIgA37mOpWN9/jOMVEhoMkM8PhGN4X1G2MpSzqfi+jJdtAVN5Yr34RBJCDolGfG7WNyXQA7aB7RoBsNC2+RlVjLTB9RVBPdes4PZXUBLk7bWTEIHumQxOFTb8W69ve7fy76aGnKmjMJurWaR6/wZQRjy8V99NwnX6nw22j3qaPhghtZVzrRg2fZlsCn81JFcPPoLVhvllLGZNOmyoW8wMx5lQpJLMh8nPLYc36DRsoyexgQZ/xZDwWjpmpkviUD6MS2SjNE1yd/9fU3EwbH6Ad1dnsK/CDQI8VR8VNJNFrIjTIUHxgGgoHFoqvIV0LbQKatUZ5F6Za5On8iu2Ie8gkWQCD3wVe9z0lYeTnLIrXkmOoaAG6cQIc9PGbn3+WPvKJP3ogGAAffOcTkekh7pdQ4RqoNsmHtAwmOjCGl8focSkTjCxUGY3+lLWlkrQS/GJIwZq5Ps1bxqRbPuAoM5pTrzNNXyFyaaBMM0wETgNDcmWtCyCRVhdN0LxBbaE1idZAtXKIhUVAgtOkx/xHts3YgYezCZA2ZAGtD3aAAQ3zc/72l16kX/7cs/vq/hWyANaaqtzEqZ8S+gEcZW63a2J+Jx4Ar0YM4FH/PerfdnkBIFUdnepxco3HS5MV1EsB2RS5ST6q8c/nZ00GcNIp/XHPP858cG2SfxIJQF4/evz0eCoT4Ciw4dKlS/vp/70GADz80Cn6u3/9A1agyUrh4hcSB9dh77+QBucmZ5ZtSUvggAjo7tlckGAKhxebOrRTnApVKiQsMGXVeDx31EcTsuyki3R6gYmKgDGZvvbCEEoikyEWI7JwQrfmRz8ou/O1ei6c2jD11q0hdiRep7fqqdDTLM4nRzYZF2z6yYzNxBCQPiaS7ETUNnN+mSRQpK1AmUWSaExgGEqMCYgXLTLACSiVmWhSJWnGlNHcXCHOqUSH5QpaTJxkoMEgkRtA5tx4BBY83i/+Wy1sxnooQ1CtJZp3oayFYRKnTZdOtaOkBY3pGMwZObj/Czo8w+saHAeJFCgpcBNHSTccAsozLYzoJLFrdPqKE1aU2KjrO5fkFAuTew6RUt7Y62ibgZpKHM/PVlkKyJwg8JcQSq7YAoUrFsTODBkFrizkQmZUhVR2QXkJ2XFliMTS89OGjfu4VmeT2mYsliR9+AAD1DVXzOSzTCBR/RiqUuUF/FU0DYMV4JleENAY1FqM6XHYOm1q9YbQmkdyn5RJzanQDHXxaXyYAAALQzfAEthNHDwMdN1sOwUWhTfePJUV0VeDCT07AOCyxtelaBbbuKDoExgsjgaock6AIWD1gFGmMmBAFtIhii8wRJABp1KZJHPTfTcmVkTmWFmLxYU17ixyMO9MoDNe42zSnXg//+mPfpq++NXLDwQA8OF3PRmAGrv3kadbbMAPSOn9g+2lk/1ClYccCTE2NffTg9s7zedV84Oh6RWg4JECvYzue1TsHkMkwV2fIJ64crH1LdPMpEsbUX1TAoWAFIf7eYbCKchq9Lj06dtDgWkIxpS1QDwlBdCYLdWHrcFXL6HD7SFtt41IOrXtiBIezVTUQ/7+c5fpI5/+D/vq/pXU6i/TC0Ab2JM09idp1F8OAHAU0HDUa58EAFhr/vH5t2/fplu3br3i2LnXvOY19r+jAIC15nuNWn8nAMCaAeQr+dlxIMEu4AKP73a7tal/nv7vtf/3CQBARPRffvi76E9922tTTnOerEChDvcR1Q4Hx36cYnCcfvKiqPH3Q20kTi6teWE3VFMwoOF0ECP4pmFabv7xvyVQZ3hhAEbhO8RpcmQOuKa/wAXeRYJRU9CjBkqoT/pPVTa/AFwE266TsSGwF/jMgug90tXj3R7y3d1ATqahDwcPgRFb5kDBLD06GSPAps5CZg6ojaEQ0RbOZdF/ZW/8iZhKrU7ln5tpdKKHiDtCwICDaVyx/4ek8Rkt1t2o0iP+kDbp681SC0oJ69G9GcApGmjsen6yYZmj98VALpWI9BwXSdkobJnz7RNRAtd9XshVDKwQN9zUwrGUcV3omRofjQ3UWTRUsBuh7KAAS0ffy1z1iUJqASXmiaczRJAsu1t38QYPC1vfHwSo8sPMbTA32OK62Apgb5xRl43GfdrQdxHawHWPjAsF63gCcgpkjskjhUkaGge23ml6N1rUphocSp+FdUgciFT3gwKaZFbgBMxFZ078JsWYOYvDJ+tetAAVmiCKknAK7UBtnZGQxriYkgX9WWjIxNfp7SYhXQWvUQOaaL1x1nVNEvfRDERjTCeHZshzz7tIkLThunPQ0T0KAhFsxc8m3xMKmNXqn7Mx7jIhxif2KDFwIDeawuL9hmi5Tgyw7lEy8NXLN+gffeQTD0SBZB4AImHNMTMVjUUDM9IKMr5anW2D14LLAjl4WtRSgOk2KfLgyVImUKCgmqaV8KTzb2o1vxmUtKksaRi6cmD79NbNuwd9YTJLElmUuW4hWYK/fXpsUACXIxjLaX9VhqNLH6H4b22wmOb0b6u+ANseBj1ERJ999tIeAHiFj1IKfdu3fduxTRQCACgFOIqefydMAFyDyFJZkw3ses+TaOx3SQqOAxb0M926dYtu3LhBt2/fvqvn4eDggE6fPk1nzpzZOf0/qqHGuEBMLTsuBnAtBSb/fU0ecBRYtAYaHPc+mfavf18DGvTf9tr/exgA+IF3v5l+8L1vDbRIM98utNAuh5suRZvAoHlPhRLqJZGmuDbB2XVjw/QBRc9xqlNmoYkutzhtYVrqKrGmEtDZaROOr+/FObspYDp5WfevxS/DNNInAdP8pxSLozL9cXfHbqPV9gaFubppy3xNDiZy0HebESFBQeHmQt68DoY2uNgDJb21bpNmLRga5rASAgJIUfTM4ToLns2mhihJmROSuOm4KZFmntfCYao/ZB/dYAbzFQAn8wDczM81mhk3YMrrUU3Oxvt3d8HnCDO40aFP6tVEEunQNhnnFXNJOA52UwWvisISitwGkYQl6OU4UZ17OMZIzfdj5e2S06UBBORoTIj+G2qmV4sDKLww5NQ14hIcSh4H+l4IoizyrhfUIzfsK6WY74eaxsVnejQgQ5QdgmKSnBEV9HGSkk6jlWXheyNmbhuYQMhWkuB3YM3q/LtJSyTvhSBZgL2nAMV5aJcLxMGxMUIUCFRjP/XooMnIOag1RjAWjKuMn2XJZpnHtvhKLmB+Fv0CCh22NgALA4ugsWHXyUdPCvehWDuvdoyClMPTY7bgkI6Nu4IO2ybBR4WD5KssGGIBpLNjJJCAI6v3K0bAmyL4mBk2GM7ZIf1DvWMkFGkRJF3EkcL9/LNf/hr937/62QcGAFAJAKeaRJvsWoZMT/cngn3K7jUkQ9NPEySGqb9G3mIzzJMaXOZeVSYzrSlzRV9/smpKmfGe4I+hg//NfF+8nnUFjLUri/2LAHRUSVpebwtzQFrez2ud/jDAUtPUgQB6MplpKV7Ow6Swu/t/69T6MC7ctkbbbV80M3sA4O48Xvva19JDDz10LAvg4ODAgIBMX3850X27AICjdP93wg446WfZBV4g/fzmzZt07do1Ojw8fFXPxalTp+ihhx6iM2fOHGkKuKvhdtnibgBgrYE/qsnPE/+X6wGwCwBwg/C+SAA4Ki1hP/2/hwGAR868hv7bv/a9oVHyRjwaXC2djxnM5mIhRCsGZpmCGej8EmP58Kaj08eNauBDExOLRtSxITOgzhtygWqaYXqJlNbKxaIBoz7bJ2eeTb08aUaRJp8KWgGn76cXMgttzPwOMp9phUozR6EyURClrFdzAu6LiZM62xN4JsjkH/NshA1EQFOzeTRCDjVoAZmH63qTPmmC68YfI5u8Wm64TmiGQRL5tDb5RDhLma1Qt+mxAjQci2tioU2pEJnoefECzYHAevNGlMP7aoPcegfnaNULr4M+ZWatMzFM3ylMnWOEGU1qegk3U4wBNNd0TjdWveZK8akR+bnG62LEOPVID4VRKQO4gMaelnpROMRpogbVDQMdEDGndUgMyQwC2zXUyR0c3tmm+GXBIgoNIkWgTtcS5mdHW0iQPEw9P06Hi03Mx01OWQO9e+GsIFxIlTDwo0MBXqbpIgUau57zkaOtC159NmJad7iZMkBPzJApzzBVUJ9KNyItSFeeB6VOmjPuazWxnew642JAiV5/qmEWkA45i8SbDgUnVPKvhqXmBQBO7tqQ6LEMa4RW7ivk17h5BkDainq1IGiB15cZtnan1Y9zXgJIt2R00SIuUK9tnfzjtaDJF6vmuvi7jKwvCaai2Lj5dxC7/yA+1nuKMhSiX/jE5+m3Pv9gaLDf99QF+oGnn7BG2Vj3EsFXlY3VyTxDg1aN+C3KrCFnoqmDjLngw8/1PfX+1ae8RNRYcwJaSuu35AbwJNJJ3Wi4xfxqMBHEjGulm+fGUmMrAfSJ9yE3rTSAg3kZD0nJmEwGm43Afwivz1FfjM/RW6Pb2+24r2y31CaYefuwmZxOr9nf/8pl+sinv7yv7u9C03nhwoVjAQD1AdD/og/A3QYAdrEH7oYE4LjmH39269Ytunr16qve+K+dk9OnT9O5c+cWrv9rk/zccOeG/jgA4DizvqPAh5O+9lHygTz9R/r/2mM//b/HAQAiov/6h7+H3vzYeZj40SIjvTAWOzH3tvVsTOSVDacMdUqTWSz+TINPMK3nZfFewBxPC/8Omko0EQyTf3RaJ15MXYImNRWO2adgQYfNDeHK73Qcf83XOKjFXjFPh9HITRv9uAGPSW9VIAPM64hwogaGWuF7uQ4cddpIt+2zyNLppUdzyaQuC20muIJRg4xmTKX6lFWdkcWLHo5V9Gw0ZvMLTvy5aEGmR57yO1U+5qx7trc3mG3GFtm/12JFFKE5kjbcsxjzpmjGz5E7hxPRIrtcJObcd8ymXDHBZI4RcUp1t5vfXGDmyI8RaZl+n93Jp8GeehYskVt3sc6O29rEd0FWgk9hdT/YzA9bYA0TsCKMeguNqu4HOQVBjx0CctpgbWqUOqgpIYE3gJC4htdaaYG4OJ8GYzPMPOQvPdwMu9GFTHtNElze9cPZe4uYf4P6HKDPxvi+smji9BouFo0JjYoWFYySFENRnPpskWQKvo01HzLAOcafajOFySnYvJr7Pi2NXCntudo4NY2bNHNUCtc5TtcZfAAw7g7d/h2IdWPYEHkJk0+GtbmQPhR/P2TYkESZjslAEisF5V0C5ra2NgoZwJpZScxOw16L4sVjWpUm3mMkqMfSuQzPZThE/9PP/Tpdv3n4QBRI6AGg69E8X8xRn6iQN9i1OLsPyxPVvivgKV1os6nBCNiNY4txxkYagLifBuyXo6B3Gcn4PNUkUJquIUQ2meXi1y6aDisLsISEEQGggM0ktacazM1bywSR/Xq13S+wawCAhpogAOV6vDX3ezYC2+12eAD0TtvDZPbJRL//7B4AuGsDu0ceCfTzfN/Gxl9lADma7qQgwJ0ABt8IAGDt969du0Y3btz4hjf++VFrpbNnz9L58+dXgYA7df4/CjzYNanfBSbcLXNBnf6rDEgBgKPO6376fx8AAD/83rfQB7/zqUj71OJqGjlBfxEyl9cWjW4yRlctkE28C00ETS+k74QDUmdRhTFJvMgJn89LMVEKVKBuWaBQ8+IzRumseM5D8x9PHOauexHvZlYys8txWrkBgyt0Qy8w8Q2UXGuCxJzscXKAx7XnGC8AKiTFNkp3FoRYpNXIOW9NIBJMjHmABf6gYYNGljyLXGmX+lmlD3H+iDgrqbkii6TLsgB7rzlJNJd98im6mYBBFnRo/rV41ymhTt9h3eOTGcwHgzaXKDiTlwRKSNDhQg67mlMGYzMyGqZ+FmeuDEDgcNtHZjtMxEfqgljcmp9711jrdDumecw1hUZ8EMtGyfTTp6CdmMrC4BKbLU1YcD8BDmZYfb72ZrJP3McCgDszG2Tz8YgFcDYOFaOgK+ijkyrU4gukFfikOoKLWgyzOOWaoBj2Gy9qFSNI2luHSD8JVHuVLixiOad/A4JhbbISBhXcaek6uQzGh9Lns2VmmcO0s0ugybsppFgeOsqCFNg1cEzPgQJuzAuAUoEiYt8jxb1ObVPfNmyQe7g2escJ/aRDtxbAxODdAM1Sm3TlmkzTCnxWQsmHCG02Jey9HUxP87oORQxHgK8kMBn317CnUgQE840GmS0atZrjNbVZVLBpZN4nbxqIqP3jr1yif/LLn35gCiQEABrcA0WIKg0fjBC5pX4tFfZhCJNx134yjX8Bo0xjPfXxcwSHiIaOv4eaie0ewzDUqHMK29U0lDySUAEFM/cktpg+A+oZ5SrL7CVNH0Eg0+IRw0CCp7TJWUtFJXNJ5qaggMlx+vAM2m63PgSYf9+2kQwwPIp6qA8/88xeAnA3J86PP/74zpg7IjLtP/5v19T+1WjyXw6zAIHaNclA/tm1a9fo+vXr1oDeK49aK507dy4YNh4X/Xdcg34czf843f4uUOGo91v7OSYAZAZAlgDsp//3EQDw1scfpv/qh96fjNd8WF1rpNViBrIXPryM1gMqIzNGO8VJiE4Tw2YAk3kvovzFLWN6auwX+lSbWvNOoIKsUSabjHVoCLAx8uacgtYXz5g1KlrIQ1yVU1ZxMp5d1GVliibJSDGaZGlzUgiorQqgdAGaL8Pxnk0IBOaFyWWgXfl365Mi3oBqTSH2T0BD7NNXLOx1rWDzrk0lQdPiE98Spv6te9KCgy4lNqMUpQGRXusSDSFK9GBafF42Si+v0MhBF2OO5RQ0xAhWxSaTQiQbsgxip0DBS4Cg4SVoshzEKYEBgO7W2ZcjO9U70DIbKYqRfz04sXPQp+vaRF+Iwmyu6ji9rVysEfVmLsZneuzjSAZwOrmvfY0J9IazrxhJijVTHpFJBhBq4Y7sI4wV86abKBM29JhjygfuYAr0MPwdWSOSzNowDpRCZKU6uo/po9OJu0lpaPbYRd0Gp4mZeSskGQnulqhBrrUG6rF6nbhTeaQDbuYUVeUAQbqEhi1EsP+vFK7sdMhIdcfppzfFjsdIjkZHAkaQsGFaBkPqxqYUOPcCUrHocUM7bs5VY1sJv/ZS9hb272Pu8ugzQRkrQFbZZE8stP/zef/601+iX/7df//AFEjvfeoCfeidT4TvyHBwKhH1eX+pTB5FWfy5DJIuA+5KMf2+3hfrplDv7i3AYCjs1xO78SAW0SZF4WAkSSA30ChAi7kEtlad1G0BtpFG6qrkQdd/MSYl1CZ6X1x4n2A9474wFfwAUPLVJ8tvuz0cBrK9zUFKp+22DRZgn3uZxDQmvdd87it7AOBuPh599FFjARwXBah/PqkEwOv0fuSU/k6c/+/k72vvj6DF1atX78nGfw0IOHPmDD388MM7QYCTTOpPOp0/KbBwUpABz3FmAGjjj1GAa4/nnntuP/2/HwCAWgr9vR//oJtwwRQbZQEaISYW7xUb+TAlIwARGGdxFKK/SNYN+Ux7h+yANL1DUz2dlqocYFM5ghkdmAY9mo1ZM0Jk8UFG5U4U8y7JEBA+b9AGa1Z8w6gpNy6rdRgKtTaMuirQvXnShAUnSF0AzffpZQX3dosUnCwBo/Z1naYTNBNLaQdWuziJZqs2YhPRWg8aWUQDBpVSgFFSIreCsVGOJnxlxqrpxMuKdxFbh+psLGDK5+cKJv/wtcwBOkXKsbjDeuFqk1gFkdBFV4slnThyQkgVQChzcq8TzNzQZ/YL/puePzKPh8GeQANJSxIoFKQQ2Yk396XYcNo1DVPOkmQmbibIQWtqXgfMM42jrEZTutcFWYJHR1drjikgBVy7eTJLsNhQLbRPqCHXungiBwHrYHQBDMfNnekLJgpg6gmhazzbhDsY1SWZT+vNTOsoNGQS5Dg4IZYpC5K1Yi4u7OBpEW72hmJQkD+VELOo7+t+FS4rosi0AFAyRKhi5CtMGHsC0vRac6ACgIfpHSLBtT+66y9kB8lFL6/fwJRSiQJx/D2ctDNH2YtKktgNH/W5w/y0hDQIPQdlPq+DH0VgAiQJ0IKGm/VBHF3tY7G2lMEgwIDgLuIv/8v/+5t06frNB6ZAGikAT0SZTAdpFIr0hGkz760N0h6YmGqF/R9YK6WM+zIpLX+K6HkymTrKA6DBZh7mfm2yjKoiDnP6r5G5m1Js7es9gmT40ox4XUiKEaFi01u4LudfVMKkSQPjvxFccjnc+OzBv8I0Y+MfFfgSEdq2rcldDrdbKhyz1EcMoIKaPbDjvF5SD4A9AHC3WQAXLlxYba40ChBZABgFeBIAYJfZ3q5p/kkNAfN77GIArAEAL7300n3R+K89zp8/Tw8//PDLigF8pQDArnSB43537XkaY5xNANfO5ZUrV/bT//sFACAi+mt/9h30Z7/jiXCT0yZRhGhTCQCBTDWBqRgsIKTU47Qr34QkTONcL+8xbO62nHPvsfHRhlZpyHXGY1mUT8/Ah9OOu0iKQlyeCIxSE9vT9AAAIABJREFUq1O737GREY/oYx6Z4KgTxKxvfcXCseCN1GI1ghOjfgo02h2MyLx4hOZkTtC10Dfq8XzDMGEDXX5E8t1o0FzntcnlBDIUB0AsLznU3q7rJZxUzU+N64kZrQi98Feqfyed3EVNbIG8ZXMz7gzTH5/aKBjE4GSv0U80o7mUTq1U9cGsmGu1MsRE+Xr388ShCVuLc8LJL9GS5aFTqZ4d+pErY0kKKm/wyMEgLdFpYQfACo8vJa03gCqyoofR9WfHKMVJ6XfrALgpkNG6O5krYIJAQJAdsEstkEHTQWqkYCNBo277QQIrezC0xP4LjyVbU2cmgeaRsWQ9hUk2jcZROBVHFOO7Stj7OqHZXQQiCHwjfC1pmoUVE9NsrxYGBpebf6JJpTNtOnVy0FAydRjOtbKkyFgnyfhTaQjC8zMvI+mkC3XxZBQFnQszHbY2rz8OBngZKPNJpoPOpUQw2Aw/k3mkM18kMYfEomNxP5aUQoDpGoHNQ0k+BtICTuskx+QGMDkx6UyyhsUzMonEWSYCm6oI0Refv0Q/9dFPP1AF0nunCaDezwO/pPg57yJUdXJPMSVCj1cpKm0hqhsyPpzAxH4ME4o32IVh3ZD9mw4ZNoUteWNMAhkYSA6CD5+ZkopvBLe6fw8esZ6aTtBJ9zRgBs7X91SXvlh3Wl81GcwdArBPsbLW2gRVuzX6XTr11mcySqfWxv4tXX1dxPyYtEZDgPr3nrlM//J39x4Ad/Px+OOP02azCfUCTp/RCFDjk3c14a/UA+AkTf+u1zvqtXXi/9JLL+2cMt8vj1IKnTlzhh555JGQynDSGMBcG+afrUUKHscAWEsUOEpOoPR/ZQDkBAD8Di+++CLdunVrf6HeLwDAd77pMfqJD3/XOj2YI+2tQ+QRTiPDhAjpZMlkDHXH2PxkV39sRLKBHU6Gsiu3aSLtxsgoa7abNea246RLgEStTVKzSXCcyMCALjQyOBnQ1+wyMr2jXrZYIXewqa5DxYg8vcUnDf/QM6+gefA9ekcvhGgeJ0BPXTPMGkVPm4UFGVAyfqaFqxu8DU0/AAhQIDOT0YU7gBMYqTWM7GZzqIZI0+V8TA8leDfoMTEn8GAM6GMxn4zDyQLAicso5Dr4IAz3cxMvr97s0PW8BOlApP5TmvoiYGZSFYrxYG4aBRFowEApOLksyzhNRORD3N9koMTYNVpcH1l+IIm5sNixAORAEAa/+1pOtbtVj98rkFaha84lJgjYdZPWKFOg1jRtJpUbCG17t+uomLyh+4RfIBgS9gOL8iKOwNJK4YLZ8nWelB4AH8iZD8ynZBxnPhox2k5InfIjbV/cOSWsIdP6A3OqSafKPIw5SaI/ytQg4xQaAZnghwEyDfMPYHbTscKL+8c4rjLd+YkOoeFe08HvZAGQ+8EE1kGWxciymEKwGfe+obkm860Y59DXRoHUlTL3lK20hXliiPvLpm6JPaKyB0/6wOkXB2YEp79nRlEA3eb99rc+/yz9/Mc//0AVSO976nH64NNPEJvfy3hsu/sUsei9PRoJFUYgTQJLxWoBAh8Yk6q5H4DtpypXI6YOk/ZS6txjeQJ0LqtSgK5MkKvWGhgcpWSjWZW7eWKQCM/4T9wDonkr3msC7T8Vlx1o+zxNUmW6+SsQUOeepVT/w60nlswggxELK27QrDcUJqItEf3es5foF/cmgK8qAID7IGr/FQDIzzspAPBKp/4nMR7Mj967Tfy/2eZ+d/uB0gCMaHwlAAAaQJ4UADhK538UALDGAFg75y+88MIDd+4eaABgyAA+tGj+kSLJyWwvF25hPJj0xiVnoCfjsUDHJ8//Vi2+ztGb+A1OJ1IS3Jpd158n4gXMsWzBIhU3TTkx2rAEhD7quHG6W8AjyKLgwICHwUVbmwz9vJjLGx17442cEsKuLAFjGagL+jyCOFFDA0Kl0ZOsLzqNUzJqdy4ysbBnzyv2Bk/CMWtdYPIgEF+mWkMKE7MRaTYm+JvqmkWGiW5JHSsDMpMbKII4S3Qyz3F/5ipddPWwNeQab6bFWUdzRIZYSQCC8FpyungfUVQaIUUIYEnIao6bPAemDUZpahFq0/XEBugS1yslRg4yNASiCr15pTAhLdDw6vTYwIXua76gEz6xGcDllAtNDcAmXg0Fowu+nweVtbj3AZnrNYkzLGoC+PCzM0auAQiABpIRAIsNl75wLRx+vgBY9PxoPCBcdG1KbWrxnG7dIzBylNz0P+jxOa2NiPL3YGjIXEI8qhqBBSYLsB4QcMM9vECkHjGv0vjVq6Ml48E+G41SKlx7bB4I6EmCLAZk2jCs4yDHwh1T0rQdgBxdd+bJAOhBCQyTEgw0idzospaSgFkHVTowazpwOhaKK5BD4f1TsOBbA0mEaJcBAhPT3///Pk5fvXL9gWMAfOjpJ0lE6ICdiRJiRZENQb40C3FYz8OzxqNlVUKBDKw6QWouE4juQtvZ3G421dmAc22U+UIGps0LohTff8dElkIk4IgarcZgMlaimYh28GQaRoGbWi2WtYLHTjD4xaZMP5/VCco07NS2jTrJLOo7sUoApbu+v3ca9f5MAGoymAkCbEyoT7YiJIXpc3sA4K4/Lly4QAcHBzsnu2sSgF0+APhvJ2UAZNbB2vR+DQA4SgJANFz9r127Rjdv3nygz9/BwQGdOXOGzp8/b+fmKABgF63/lQIAu1IDMgBgewY0/4eHh6vMDGamZ599dn+R3k8AABHRj33/u+m73/L6QP/G5hjzv3dRM7GQQVd204glvXOQFMDUHCm/PWhnvXHEG5s3W+PV1AMAp0xYOGF8HzZnbQXgCMGEKwWXTlW1fiwFp56zoa+Tdp9MEQvQ/rvE4mNTSpAojM8kYWqpxniu/5TwM4FpqgIenbzBGAZGDigIRMeVJM8IU1uOTAMEiCRkGeN5i8Z7nRxYGZNHMfMrPY9Ey6QHlR2o1nrEbDkgYN7PyCiZbAv8rBFI4DSxRndwsuYuGyXpgkC6cwCFAETCqSqur8zeQMlLbp6jEzqv3py1eVFAoqERIaD22cE9R2BKMPcTo9IXMK0rKV+6Vrb4KovQmjIS1MuvMYzy5aU/611sfQwfSjGwAP0PNAkDDTojg8BZRxSu7bwnick80H17stvXzUYJJRQu3zFHbor+BhqdKJBo0cHoTsAdn2iCBoXdfHHlpqu54/pdHWB0Hw0RsoZbG2PV/jKr/8agAkty39fX9XgzptYJgA8/D+pO33oPZqk5EraBoaR7RPRAT8b9voPBqj6nAuMhM5oKoRmrAzkWZwkT+KH5l5CCQEC359kQtukMp/IQk0eEAjcVxrzAxh0U5iVDBu+N2Zw2+y1wYEOM+89zl67TP/zIJx64Aum9T12gDz79pO+dC8QHpvFMdHvKBCotI4ExZSRGW0oA52stcI1NoUBhqAkYJvggiZx3UIJ7fTWXfwdLC5fg7+N7mgTTTJnaLQM4afgQbDab6XHiBrEOBDo7x+4t0NAPqr+Yz9AAXdvwLiKibWvO8CSiw233BCLDWJVFBMYMhanPdf3rf/gV+u0vfHVf3d/Fx2OPPUanTp3aCQBo839wcGC+AGuN951S9e80BUCHO8e9bmuNXnjhhQe+8c+PU6dO0dmzZ+ns2bMLqUa8tx/956Oa+KNAgJO+rtaNOQFgDQDYbrf0wgsv7C/S+w0AeP9Tj9Pf/P73BC1jblDChZx0/Luem+ObMo1xkdWeaPhOrfVCq6eoOwca9EbvE0yM++O82EueGqGOFLK+bTq1AoQEUyw/hYLTYHD/LjnPmSKlN07v0CwtTbAJmhk9D3PapzF62IgqBZd6GhgZq6EnOqlHuRE7eLHcw6PPA0FThyAQfm6Bwked0S19b4UZ4sZ4FM4Puv6bgRFoEfG9IpgRQRj9/GV2Lsxx6qiF16ZWawDQ4UCnOKhLzsV9pgoHvwNxfXGIbEo+F3mDXov464LSl0lJn/zYXecOm3+fnEeTNWzM8ZqIQBMHQEEyikyycElHFkRTWn6iOWsjh411NCUU+87mAbBKv6YFcMAs0MRzMLREF3gEJkVo4f5vDSU2or2H6zCzIzRq03s/yKAHbXd+rzWNvj/f9xqMAh0Tu+hKjn4vyKIIMX7k8Z+ekMmBPRKv9XF80RmfwV9A14PqrzsLxGVGdlWDaLOIDA1GSi3ARMHpp/hkNNyrkkwAwQCZjupqkNj6ALQIrlkBGVVJLusCbBAGKhiakFIwm4xfiUP6CZirAnjT4QZUIKISjQm7CH3yC8/Rz33sDx64AumRM6+h/+KDTweZobJMmJbSj0b+swKuGkrfx3ugms8yXCPq+6MLX4Ei3WdqrcAmojlt5cU+W5RBoB450wNAjHFSLJYPGQwKFnpt5eykASyO/YVLoYOp+w6ynBXj3pEAJNPPRFwKMCm+CrS11my9tT48MraTqVSIFutb/RUOZUQeExH94qe/TJ979tK+sr/b18Ejj9DZs2d3TufRA2Cz2SwmvsdN//Pk95UAAJkBkBv/ixcv0o0bN76lHeNPnz5NDz30EJ07dy54BOR6b5du/yRsgVcKAKje//DwMBiC5uceHh7uAYD7EQB4+Mwp+rv/6QdifnVq4vHGGOPMJFITJ3LeBXLFoUDCSSlOsLToMd0c/BpGM6G5oNncUpQX5PeIDS+ZN0E4+tBYdmhWRCJlM2a4O1VXzdZcN+gNjDq6O51cggEQ0rzRESjo3RcaX4I4sChDIEoTz9Aoz6KiLGOpNF4tgBigA8IYRLFmX4xOrBR3Qko5ZL1nDa5W1rielPreu4RLwjTLIuAfkCf4DMU9JicknX2eCmkLZvnp7vS/NkG1CXAy0DNfi2R4GRsqWjS9GHdpemo4WPp91BcAozKjO7isAg9Gf9dCmNcm7mpa5ZPdfE1lEA3TA9Cs070v1n8n3GBWPDOY8BiP52/md1fvAOZ4zcMWswA8MOrNABhN/ACqtu9zDpbFyf6SApkHkdiwDSkHBSmJB6OosWZ0ld/UApGXmGMqBnQSRRlGBrSG3r+EAXQpHBzBce8iEdqCQSSnKFKaJmQF2C8+nc5FJcaRLX1iEEi1lI/JBjBjR/B3ieCXy59EiLaa7GAAo1O9O0RDZnd+ZRu5f4c2XD5Bbp2oTLbRVlksBOwE5sBoitdI3INRhx28LiQDspF5B0tlcU307rR1vE5+6l9/iv74ucsPZJFUmOndb3od/UfveZPfs0gWJr9i997JYjLgxrkUdU6rGUFhGcBPjkPm4jRbMwgcsUl+fkCq1GVS84vWTiP2r8B0TuUAgfEyQWidtG/qAMrcsG98Ub3HMgDGtY7pL5fq+8b8HX29bWu+b8zNPjT+fTp7S6feB3C47d32BqbpUwI1l675xgN0ISH6ud/6I3rm0nXaP+7+4+zZsxYxdxQDAP93Uj3+SVkCd/Kz/PfeO126dImuXr26j4pL5/Whhx6iM2fO+F4DTf8umv8aM/pOJQBrIAACCOr4nxkA+XW+/vWv06VLe9DvvgMAiIh+4kPvoXe/+ULUBGcqOMWmEAtsdVVXxFobKaNxAxXYJnhpOrSgChNELHGslphjMaoU9T6pqahJd3pppspMd+o5MaL0/k0kNm+gfbdcaoiLy/F6kMjuhSb5VFnfME+lkZZvju6wmQqkCPhkkRdGU0RuvMWYFpCMYBhczjmcq5WJs7EMkJng099m1MVOPKmQGBIn4EyOcWZmTJbp7YTZ7A4SGBAxTQKZSgAoVE4gqQDPaRbaHNk6AGAEgYs+I++cpsyLY7lmBBkAAOZFZrJKXWj6LkiaruBr4fQagRSVZmwCnZxCM8HZrRyBGOHQkFPydHDGTWYk0GJqXDiCY8p4yRrVWjg0/Pn7LRMMwKBzGmqWJCHYqqka5RscRQYG+YQZJ23+/LGfaXxd1mBHU0cAY1QCIbELFJEFqFZKbI7NuC80PEQNU1KgMbc1RCniMd1WCqRfBOYHo08C+A9oE0MeIVrZIx2DzCsAVAyMqGgkaBPbWgB0gussRQdKAi6dXey/I5AIEM73CkBNFB30Y6JBpFfh5yYAx+y7Tsp0ASM2nl2kgO8L/i6aOODeYhKwHveHOEEDLTvvlgV0EXr+8nX6h//8Ew98sfTGR8/Qj37gHeO0qcyG3a9kK0SbAmwrcvkbSQROFDEoPNJdSGVfc6HWGqO7PHnBWVAa4yc20RfiWRNsajUQH+/1BiAxz/u5G8yOph2iWKf2Hj2JnKXna0p135tNNUlPn1R/HcjoNE+p/0PT34yF0NXtvw3vAY0xVCJfIQqDgy6j+dfr/x//8mfoxq3tvqJ/lR7qKL+rucPpv3oAYCN5XJN+EglA/veTgAMiQhcvXqRr167d987+rzYQ8NrXvtbO370AACgrCBkAa+vh+vXr9NJLL+1P4v0IAHz4PW+mH3r/20JBwWkCoXrUTfGpsyzyiL0JwQYPTb+0saKUaVwgpo3ShHIRD2YTR9dK64fVmL6qGnHQbjNzijNM8YRWMEj0MIBKDFMP0G3fQAG4QVuhzNicc2BNWBIBRR1/YBnMY6H59IGdkRzKOxSOBbLb15Ie0BGcyA3oBCL+WJbRbH1ms2vTpuyHrPXOEzykQ44Cqxgoos1sdqLXaWqtHP7dDhBj4z0bCWg0bZrDZEyM2HB5hJJ+DmSdKKiUqfg5Ak8b8crF/i4p57twXHtMPMEtb9bsfC1utJFxEm8IZHFoDPF2a3Q+pP33rs2ox7KFaTpB2sE8ZjrZDiaCnE0PPcIPJ8OZdYPvg42eashXAQij+Att22jLcC/ISvkuEibYuLf5epoFsbEwoNDlCMwFaQZSsrvE3HaQX+gEz2O/GDxWHFQVyCj01wdzEZAm4XMzowop+hxiOUeMJkOEornd4zmGY4bAlWp+Gcw3FRxT7bFpmiF60FkBbDGX6J9imeXdvxLq6qPkY6zVLs6UcMPBZGopy9jGKLGJBoEKViELR5MHuswIUri/6TE12vUEtrOsHxd7T7pzXSt4zNFXJEgjpidHTFgYL/3JP36O/ulvfO5bomA6tan0vrdcoD//p96oBBk3gRUCltCU+ggFydSQiQzmiUqR9B7ehalOQABNaXk6/2+mGSwXTODwlB+j8kL9Q5AksDHzQAe+9K7VQaKC17s2TZYOY4axbdZVuqcNVuCpgw3VurHSctuaAQLKgBzXJ9F2O5z/eU7+D7edtt19ecoEqU1KCRjxdpoxfuzzX6FPf/lrdHu7b+5ezcfBwQE99thjO5s7TABAI8C7CQDciZ+AiNDly5cfSGf/V+uBiQEKBNypB8DdlADkBACNBcyPy5cv09e//vX9CbwfAYBHz7yG/vu/8RdCY+Q50hw0iCGSD5v1vtKgkCwMBIMjMxqbMYVJDmOxG3Sec/bBBIWbG9u1DoWRrCFg0DyR60gLp0kogAxq+qTvXydV1ym26NA/KfPk3gCaJW9u4XDmizVLscnGz+ImRjK1qpEGjSV+h0loD7rSOb3OTAqUJcC5VYd21QoO1uOMOTPuolOldVpLEuO8dALDUASjF4Ab5sWMby12Mh09TnZpcSyhFhxrF3Lk85pFjaV+9+2Mc9ImvIDJoU5vtMZfNIWJel/KcoLMgUKJU+DYMpSVXHRJQBuaMBZeN4EMCR4Up4kGjphx3YzNmqkNGqO3lkhAtGZIiAkVPTaz8Lth8g9xh0HzDGsmSDqm875et71PBg/H46RNuwQgCF3kscmeRbQQSJAEgBafTCu9vudihygkO9ha677ZjdfpPpUHF+0GcaIquck3dNw/8JwbY0diJKWue91XVFak62fbG9VSppmlN+EmXSCJKA35XlKnkV4Xb6RrLdRaX4AvnIzSurICpuxIpo7akkOahKm4+4BEaQz6VTCACZFJ4+exlOnkb6ajFNhM4d6QJ+5J8tDWZD6T0dC7M4YCCIOMlLTHU2JGoCRDmzySJe1jM53mf+bXf58++YXnvqUKp7e9/mH6q3/6bWa6Wee5aCK0KQzq/8gIQCmdxYxOA1xlAwyTyuhBg+eRzHCzUCGiMqWPtRQbQshk0mgigJmy0bj/lTqyaDvEser+oAtYpXwFfEqkd0sC6F2o9+b+HyBZOTg4NUxzmWjbOpXpezISSSaI0BptW5803/F+h0RUEuiqx0cX/HZeq//2c8/Qp/791/ZV/Dfgsdls6PHHH9/5c2QAKACwywdgrdnfNZ2/UwBAROjq1at05cqVfeP/Cs71uXPn6Pz583Yu15r8tei+4+IFd/kH7AIA8v9QAqC/d/HiRbp169b+xN2PAAAR0d/+we+mdz7x2NK4DGnxTSaC7dPinjSxNhmmGIkXnKWBKlnAOKnBhN907clJ2TPb2WjCns2uE5v1FAOcBNm0lFzXiXnrDKZTWnijptcKNJ1Si8z37lZkEwAY6sTrhby6nK80bqqPDcU9TAthykUr9H9zPu9KwUc+xaTykcsWTIrBYdi4iD1EpNCbHi+g0RFY9cWhAC4G7yzYCrXE+Ll4n5nnkimkBKBpEmr+FbjIes6UmgU3To9H9Km8x00VcPjuk6I5aPdl1YUcN2SJeRIGNnQCgK1Dcw/NdEdWw2oEYLwWMsODeamB5pDAQUszM6JgGJfZBjitx+fjDeR2G1nSOhnObIaIPBNtm4Q1gH4bGLHp51QsaiuyDThMoQn2i9adOZBTLIjc6d5o5uBxoBp9pd030Kv3LnQws73V72P5XcVkDHmCb/sZuU5/gJkx+tNBSXewj5IsnExLNJKEdAG/5pT+r+ADBaM59fXoc1PEPUr3L9+LPGLMjrE1PzDVV5ZKcTAC0yfcBJYDoOKJJxz2nco+nQwJAIQRrwC1JQPa4DmpRobG4PBzqKkBavbYu8xJsF+jyJ7Q84pMIprNnVG/E6OoANNAN4ACbDtO7BMFtkSInrl4lf7RRz7xLVk8ve7caXrXk6+l97/l9RblqXT19fu5p3Xo/Vxd+yt6sLAYpV9ld3UyYoh97yzMw/xuRgDS3PMQKC2lulcAuw+JgpbuRxHNhJVV40MWoe1kYhJ1kj6B+gmkbZvMRJYezIg3dUO1Fto2NR9VCUCbAALRdtupkVAlpqbYJEpaJlNNRKjNxfgLn/wifemFPe33G/m4cOHCSIBYmepiFCDKAE5C4c/O/btAgF1Gf/q4cuXKt0Sk3zcaCHj44YcDEIAN/N0CAPJrHQUA5F7gxRdf3IM99zMA8IPf9e30w+97+5iCNonZ9qnw37a+iDHL30SbfwauesgC14KGY+Z6bFU9l15NAE13rxPLMvObewQI8N7JJWpFVYKgk6zQbM3vUOd7HG4FDLOSERRQVbXwRaMyjOzzQZoEozWRqRkM0WXZCM0nhgFgMXdiBypKMN2ThfEaQbEaNMran0NzqEaDiBBr/rHSZYPvgE1WNHe8++QXGlk9tg5qlDRpJCiywC0bGu3WHXxgAA8KTAR7iEdaTtxwCofruKNWGpIV8KbJ6LqY9PJEFDLofVONmy7yQQKNn1YQC9DKL9McKIEMOYsedNWdltGM8JmZp9wHGszwRWkpzQEitbNFzBSSoMCQI48T5qx3pMyTmhOST4wZc+rT+0g0E9T9Cq9LSYwIAQYGfk6dlOFUuwRPhZjGINhkKpuEcXoHwF3vRAWS4iHz3s8hhzUnwDwKRgjkxkECSmVsFNEDoPUZqUmeFqL+HpIAK//VSZGnEmIVmR2wFUhMcEYYB8kMgkzIEAGPsRAJSgBeaPoBRqC63Izt2tVzpIAMggRreyKaaIaIvpwAA2ZoDpb3AEgKjeaJEpiNay4285LYTc4U8I+Kusx5Tudx/sJzl+gff/RT39JF1LuefB39xe968/TFGcc/3M9nRHCDiGAj6NCIlVRaSJ3TejIvIrL9PrDWtEivdVxnauSnW25xxo0NOuz8cohTZca9RKg3mUAjJcNeMP/s3YcEsG/12diPWsF9a+qmGIV/aHsH06i1sUei108Dlp96LGxFSAVAP/Obn6fnLt/YV+/f4Mdjjz1GBwcHqz9DCcAaffy4if7LlQCoseQLL7xA16/vDSBfjcfp06fpzJkzdO7cuZDwsAYE5T/v+rfjno8pIWgAuAYUPffcc/uTdD8DAG963Tn6b/7ynwmmUnXe5Latz5si03bbjdLpVJCoZa+lhMl/Qdd5oPwbIk8CedDJAyBRvzPNd0yIMKPa0SnM1EbTLU7NE1IuBSeE0IVW5uk8TUYD7yvaKZ50PTPbIWiMOX4fwuIeCm8EAnLjqFRhStrpLkSbqskBCQgJbutijaaCNEi9LtPET4RD0akFNvo46LkbT+AQSWbmeRPc0GM/aLg9ZSePc1C1OWei3oekg42WrNpsiOqbPgWo1VcJhoEIEpv7HK0G6opF0HqTUfwVayKcnok66NAcpgx12E2H9IEYgyQ8Gg+nnMk0r4CHBrKxUZufJ9po/Gi0e15GVS2uEaYUMQiUkPSL6tvRgCatTZ9d18QwvecFcOHGdpH9oc2z5WcrPXymMTBTkrt00J9LKNDd3X5J3UfQwJo1ivIjdKXnMFEeP9v2pQ9B9r/Qz6WpGXrB21S+O0i6/Hy+His7MFCAuu8gnQRncwUO8jTa5E/AdEAQp8+JpjUnsIdRMoOUef0ISBr0Pfo0SFNfCqX6K01eoLnv3b0TVOITr6FwZwjsm5L9LoTCBD0Xrthko3fN7OGcHaVN/mQ3VUsa8L0fj22hqO3X44/SCDR1gu3B1n6tID3D+xnzqjzhFz/1Rfql3/3Svjk6f5r+1ve/08D/g8JmqhdTOMa95hDuS9XA3gju1KLDAL9J+PDCQUiUjSEwWidDwORjpdj16FG9Ku0bkpxhwidmWKjXSpuaf4+bHXT+1r2GQOZbM+BT/VIQlBPT/Pd0v2CtqcrwQyASut1devmTH/09unXY9pX7PQgA6P8ODg4WGfPHRf+9HAmA5r9/q0f6fSOBgLNnzwYg4KQN/VHPWXu+rgc2TQdzAAAgAElEQVQ1AFQfgNyL7QGABwAAICL6Oz/0Pnrq8UdSQeWO8x3iljAXHac7+jOZ02ozjkPaSNLh25wJCmIGen2mHneYNjWIRMKJDSVNp5vUQeOlTt+kSQDq1hynLl5AcIi5CsZSpvWf7wX6+EENZkPpCYrbgkZhOoWdX7ZD8+6NSp8Fe2QlWIpgIZuSablSZ/O87d01+qSa1bIoKhUsqSat8IOKk+EuPZgvUmogMAPbYiODsZs3pJvqucpoHqYFdJZeuAOqM0G0ASowbtNiTV83x5flG2RkdRQi1sbEJ7neLHghn+mmOdYuAE4rzIH4O2lzEDemxPORkzPw5zFKLjYaHSaSNdDCIyNBj6e+t6ZldKOpcgDvMKpSJTFIzkd0UYFCzaQO1Gww3kMZkUdkjuQHLGgKxCTi3oWUbP8zRU8ScZq7Tt0QqDHGQkpIwGvWIjCluzREZSNA8UcwJu/6Bv7MPa5OCYqIglvOlDCTPnKPCrsx925gkwJkRkeGqaOuAfQz0fPS5kSwcNRh9e5MBNQm6zksiymDXk8leGEggKn7WTAoZWdGaNJMmc8dn200QKF4hcQP8OkP95AcXYvJrni1OAMuGlxmDxE3doVUDzD2K0i5LCCfymaQwQuHbJIcUkwSMKzn+3/+Z79Bl67vKbd6bN71ptfSf/ydbyaN8ShoDGhsQQeR2AB9cr1+uj8UAOFVZocRgHoFbWqxGkXvoe4jwBPILraXKWNOIB/T42fFDHZ1b+ttRARq8okmbxjzEMAplVeZeSQa+s79u8/Eo7KScqLeNNv5j5/4wvP0yS9+dW/2900GAE6dOrVo3hVYzEkAOV/+KANAWRjM7mYG3Lhxg27cuEFXrlzZO/t/Ex7nz5+nU6dO0fnz500SssYKWILeR0sAMiCEBoC7AIDWGr3wwgv7k3K/AwA/8v630Qff/e0+lYTiedVJmWIUxTJujpIT7nJKpcXMtouZea0dFDfCguIs0W1N417WpkYEkXejiHUaMlC8yeMEnb4qNkkmdMQNRaVvorXWWaR60Y0baeuubxZSTbl/KWxg/WIjoHGLTdu33YsOAfM0mR1XtUig2fiVaXrWJAAiOkV1p34K1H6deNY5wTjctkSdFzPda20atZFO6REcmEZLRT8D06a6Dn6RDQ8mYBmYsSlhSp1w93QJsoFMuccmHT9vMK9MBTs2Nhp7yKHg43DssBFBnbGuW51o++R80M57dwCjgcN8mW+eNcS0cuzws6K+GS8w86joMcIS9e8I3LlkQ5agCqwVTvsBAbslFy5IpVZJjjN9ljIE1aUzcqoxbaHwNL1iMMGcoA1o/Q3QKxzM3uy6Ra+KRBBBg078nQAKKSpEYuBJA/1+bjD65Ibziv+C7rMM60a55XqMN3NSqU16Jm/gecFoVAXrStrXJTGvXCcqxuyR1FSX2eRse9z3VKoDh2QxyQ57HbnPwpCkcZAcIDklx1cO8KlEg0xLakgGs4H5RDB5de+QbEoZo/7AeZ6WjBEU+iAAQMEU0bPqBQEnggQEBDjAxHBP/19/vPHRM/Q3v/cd41g2oVNgUFw0IYiipI9gv9ooE296vSCIY1GeIGVUmQFQ+Yi5DF+B6vfUMZWNAKLVAiJ0uO3zfhin+rq/WJRpbzYgqCrbKoWIOm0PJZhcjpo9ep/YNVfc/Jbg1qD7/eFkCvzKZ/8DfeZPLu4X1jf58cgjj9CZM2divQceANr0owfAUTKANTbALgCAmenKlSt09epVunFjL/+4lxgB58+fp4ODg7viAYAMgN57iABUAAAf2+2Wvva1vRHofQ8AvO31j9Df+eHv8SkjefyQu993IqT7plz1mDkd877Q1Vx14KZbhzgnLewKZ9M5d2AnSpnuajKVaJKS8tOjM/XyDKAmODSP4k03frtA04VGRKno5kTOMR5Pp9cNnNb1w/TQyGoRWxbZz2xGa33Q1YFCrDpq/b0OUyw1DiKgDEaKc9SWo2ZawQTUBpcSjcA2M95PgIKsdH2S2DAEh35xzwhZmZpbtJPGBkqk2iLIs0iWSAkBeZ2OYxWjHtEevHdZNH96bPV3fDqpTI6oT7cXXWHW84qLv0obCidZzDwYyJrJBoSSpsqoegiNhbEZkjQiTXH1l9CsDifta8wENPTLEW0KBOIQvvVOB7Va45TXejCKJAradZuWroAfROBrwhJz6DlGL5qsYsbEZcYESyAN+F41mQodDcCMvUK2Z0oAZMSAIQX2OICgHL4bxiqWMrTOSqEnAAsU9FDjwyEPGqjgtndgnyCQMaULPUZXarzeYIqof0va88tgHTDzIoIwgwva8ESPDAG3cfeFgZQ0a8g1qSIRNBx0ETJ5lrJ01FkdCx003ePcCKYbMnNAHzHYITKd4F5HzG5ICCkOasDIwKzIoByC2wh8mcmgNZhEv/mHz9LPf/zz+ypq5XFqU+m9T12g733HGw0BrgAGa11QECAWoUZEG4ZhgkRTTiGig00Je9xgshRLwylcTDpg1yTzSBHRe+zo183Rn6bnTu99GCKTewshwLVtTa9Wlxahv5J6Ak0QQULajQOaKhdsc79rIsSTWTh8AMZzP/LvvrQ3+7tHHmfPnqWHH354dTKvzT8CAJkBsNb0HzXp13+/ePEivfTSS3ujt3v0UWulc+fO0WOPPbaQfmQQ4Kg/I0CADACMAcyPmzdv0uXLl/cn4X4HADa10N/78Q+ZUdhi00j6YHTCtkldMlFCKq8I2oWROTi7RtdBAKXA4gKthSF+bYd7OUVqZUA02Q3dRDrVUqn1ZkWhOz1jgYcmVw491IJGeIioemEdTQE5Zc8PjZ5RSKGZF2hEbTpUOMTGBSf4ELM2sow3U0faMFKMlAXAoEnGGDkKkXebpA0XNDgiinrHBABhvGCHSbm+N2Zau+SArYhykMhrny5CB5PtcNhA/937qr5cG2A94l2i9hyny+E4w8TVdf++ju18A1jCFB36gxnmLNC8MXYvBWyElFVQE1XY0x+ydMKPL1GMucTvlJsZ1Dzrccd1Skh7LjgZZQAlCNZcmqImOjjKGhRQDJIFBJg0YYSXgJ3G6JXCxBLBAUwPiS7cevwo5qv37rGWglR02FvAw8SkOx0MBXVKKGDMBRNhBPAIwLNN9QQT+17TtEv3RZZhxLXh4gAaewKBAqIM51oNy4wpYJ+3hEk2So6IwO07+T2qztikFLAnOX4mwRxVfQ4KrCl0ol6j/Jup6qRCCKzxYt4njYhLlLVIlKogKOtxlxwMVrOTfra5CAXQ9AQIbIMk+Qp6/iSFs2OfIirxQOtaxf3H76clMBgEWEH6En//Fz5Oz1/ZG28d9Xjr6x+mv/I9b7VknIoAHkpluoQ0kTrXTi0cDB2ZxrS/AEiAE/1SyhxeFLMR0nNLXIi50MaGKaORV28fW6valLfu65BUXglRmwDgO+A3p/wd78NkyRWYuNG7GyDLvCAa3M/3Zn/31uPMmTP0yCOPrNZczGwmgOoYr83gcbR+vN/p32/cuEHXrl2jK1eu7PX999kaOXv2LD366KOLJv+kKQBo7qjNv07/tT7Xx40bN+ill/YA4X0PABAR/fj3vYve+9Y3hqYGBxtqImeROATUYy3glQo/tbCZdq1NPmbZY1Nh0oAJECgC38Udq12jFuMKzT25g/s/ecY3pSKRyI2nsEnqmjYAzvYYk+UTNgpNT9QHi00MsUCQ7lpzSQ7yY9JZCD0IJR1DjxFyGnYtPHPbpw+DThAK2/la6OONwwp5w7AhjNggtkY9ZGELNmUSzluHqDBMeUCdd9axSiqNyxQ8o/ZdgSKlb67KUmZWu2DCgfjEDaejlqdeluCMNdBTazxo77yYTuN3znIFN2MTc5vWZZJlDSWt5dhwRAAO+h8CLoY1TEE3HyYErv/ODVA0upsQSXpfgcawY040vBZS15HiHKjM+fNPSnPlQtvWlowQABF0bZNOopOHAsMeoqaJ6BaPk3fBE5XAo8yIEXN6d2NDZF9se3MTMFjIWcai/z8cE5EAjtkUEfRQ2iwrWGPnB0ANN5WUKffo41qQmDWuwIBeZxjbyqzGabTK7nBwNUYwOggVb2k8jf4wiQCNTnNxqsww/HnX6LOpbeJk6mjXHkcwk+G+Ihkc7vD6cPzx93E/CMk0gtIiCeBTZZ+qlnQPdWBox3pDAJFQmiWRDTH/8JVL1+gf/POP7yuoEzxed+40vftNr6P3v+XxUZuAX4oZO3b3A8BoUYZ9Qg2A3fSYgP4/WDm16rqPEsNS6rjHqpmH1SZiz2+Tir+phba9U29DFjUo+t2MgBllW8BS0npJfZjQn8e9YcgNctHwmIlug2zzJ39pb/Z3rz0ODg7owoULCwCg2BpzDwBmDgBAlu7iPRYBgKtXr9KVK1f2jv73+ePUqVN09uxZet3rXmfr4KjYwOyHlT0AkP6PIMBLL720l4Q8KADAd3/7Bfqx73/PIvrIJ0K8KJLrpJNLyDF2k6pmjt60nPil8f0u6gp6drnxlWfIY2NDtPQvCHFT0/yvJqfwPDXeTumDU/V84jqmkD4RF5AAdGu43e1bKOZEoy5amQcEN+pMgRWI0PMLmIIWPk+kdJprEzfx6cKILCIDCNCRPmfYLw0VjcLhE1t1yofv0nt3ijLW0xxpxHrOW/PYNJ2E4jlUXfymsGnu1enY6JwwwXc5h4BEYsxJ8TtGEz2xeKiCwE0y7NNiUWASgxIR0xCzg1M9TYbztDrH7oXPBJeJmjbZxBHYGLkxz8wAM5FLlPpaFPAZx70qu4IkHP+FTiwBcAhmoMs60rN98llC4xh1+BKYGmRTMYbGE65XpsA0isZ2/r4ZjHA2TZQTYcPWUwOPJotZK4/NpK6LDvtUm6Ca+WJkxgKAosXMvzjG0CWfBxFkWEXmSGi2dVUBANKhAKwFNOYTaDGAQVkQCQhQhtdg59SoxyeQacxGiIHhIdD0I30Z2Q1cItvF4kApZqar6yqyAPr0zAhxlVMvXerShDGzA8LNWSgZDPp5NWYVx8hAZR/4e489uqdJGwJsnO6Bpv0HcFkfH/+jZ+lnP/YH+wrqDh4aF2gRtHB/K5poIlHS53KnKbubECCr9AwAAd1rNwWuu+KJH6XWYbIJ11IphbZta/saT2M+z9/Uvcr309YkDiesYhADPpEhNPaUBCLDvUuI6Pb8/V/57J/Q7375xf1iuQcfm82G3vCGN1gDxhAruQYArHkArNH+b926RdeuXaNLly6t6rz3j/v3UWuls2fP0oULF0JywBo7ABkACgDs0v+3Oay5dOkS3by5N6F9IACATSn0P/z4hxKVe4k064StMNukPzskmx+OTUl70Ahjs63T/TqN5NSTpk6BXilsN2JJOnIBl98cc7U0xYA8aEK3Z5rvUwiG+VQZJsFADzSNe5riWFcMEx2fbrkZVc4i1+YdX0ujzbIzOzYsQf87X7GBrwI2DDYlLjF7mFJEnDYjzEu6MMGEkxc3FD/P6BbOjPR4tsYzU87wO6oXxAYMJsfz3AfCp3yymDwGRgeeOaGQMoGfDTswnTZ3aJi4eFSUGraVlZtrMIhksaklgmN6nDUWUR3JawUtOfNiAo7Alk1f53VR0dCJIrvAzZ+wmfJrPphAQexcyYZ06ZrVQ21rihIzJLA+wBhQlgkfOAV1PbZToMk8FVy0iyCMggrqq+ExcGLNGMoFMihFuD4II/Qi4Ikra0GlXNnQ13weAgqPxbjJPdgkISFalQjSP8Bgbk7uXUITu1eMskPWiyUZoNkYAkgW2ef0ZL9m0MPDpROMHqbMId0hGI0Zi8wlYNveBttmgrQWd6heDxw9WhDYUGDL3hdB4wDWrGR+JlAyAOAApiKItQCaxUFLUlCAKAJWAKBmU9Le3fhSzTC3rVssYL7m/s+Pfor++LlL+wrqDh+PnT9NP/F975yAzJTNoIlouM86AMDgpaORkIV1n5weRcXPN7OzAfQke7rM9M0gZ/lZ7C4kzYz9vI2YXWUCdWf/bJvYPSM2dRzklaQJQUTBi0P/fnv+7r/57DP06S/vDb3u5cfrX/96Ojg4WDUCXgMAUIKVAYDr16/T5cuX6erVq/sD+y3weOihh4wVgENHBACUHagg0xoDAH/v+eef33tDPCgAABHR3/rQe+i7n3q9TeTMIAbMqggaKNWSxwKFgU4M04v0bRU2qMl8CbX3ejPWBlqSk3SIdCJ32Hcq9Lj5FdCjYyFWuIRmHQ3/WhtFszZqAbCYul1JBodqlufNDFIGnQHA03Srq95zTgUKyCvapL8y8EKxidFBQq0+KSOI0MImvouY+V8B2qNOD8e/+WTUQJ40wWeo5LtNLGimBDDhrAwp80hRFqEwoZfUKBFGpc1GqBSeZkfRWIugccbj7LF4ZOdhU+NravFtDY7IQveORbmZOoJbPWp4o3GZyg1iRKDfiGnR/KLMZK2JHs9HLbcWrG4Yl6Ocsss/av5z45r9E9Q7wQAs/JxEiwJkeYOILu9K2S4BQIo7oRbE1QoXZxPo9yyqjbcIvCXzo3Uxre52MkXM4b2Lx2pSCRGPzCvgCemQOVPCo0wKG21rDKeWlwCUoBS7KIz7pjuVR8ouraYtjOPap8EY7BnzJm7pC7A/FYgu1GQJ3d/QuFEAFFllCK26+eOapXAcAjBVGIxJRwO/qTGW1JkjHPadyL5xYz37TBMs8qSSmQxRolZkEX0ksgA6zbdiarFxTyGgkBPs+5pEsLYXmXRDaCXhhEJiATLF8PGVS9foH3zkE/vq6WU+NC7wB9/z5rmGhCp5DG/HuFxb1W4KesCOFOj+q9cRl8HeUQB1U0fcrkUQz8K7mT+H1x5duskIeh9JOVPtN9eOUGtucjnJicFkeCgMdE8k2zgU0GZwP+5d6DYx/dofPEOf/ZOLdHNP+b/nH294wxss+o0SuKwAwHEeABcvXqSLFy/uG7dv0cepU6fozJkz9Pjjjy/kAWsAgDIB4rBuPP+ZZ57Ze0Q8SADAD7zrSfrLf+Y7QkFCtHT9RsMijJYx2jO7E3oaflrDH0ZkFF/DaJVCyUXaFyFm1WO+M+qaCkwkK1ZwRBD5Nl35542zQoPoCBnQfcljvbDBrUEKsWwO7F1T16MTeIyF86LTC+8+9YE2BWRsRVxOYGZ1JLRtGv+3NHszs605rW8a9Zdc5vGBjamnNRAYGEFTycmkD6eAqHunmHmtjRc26ZkmO77bOF6bWowJYO78aPQH8gy9UQaZRCriKTRBEJYYUimgOMeIMtJCi02DvIvmj02gaduDJwJHIzlaiSQDJkBuEHMKAKfjH5GISLln5hjPaccQndj9u+g6NdCMPb+aArtEFtpp/4xCm1pp2xqh2aZ/VyFSTwYh8HoYlPViTA1vTNUcixH0IVkkS2gBrd4e0R9BYFLnRpy2tjn7KHCc6oqEz6VFOe4CEUgZ102tg13VO5gHihf6NIFILiVofHUf0M+oU/A+v5tNw2HBbEqxNYiGrWhgZ+8Le1q0I6Tl9ZSa1xA3yCoRAa18JypVGQrd9NHMke1USkztMPlRiLtcAoyeDuIgje4NJuVRsLiAt8Zc89vme1INIGVf7PV2bACwDiADR4NFNNFVH5XoSTB+/ok/fo7+6W98bl89vcLHGx89Qz/6gXcY8FYBsO4muXNAphMCp6NOyIk2tTiSOsBiNRwc1+Opg2oxoQP0YpjaN4KET+pNjFFV5v41Ek1kgvUxZQjrr9bcGHTsUZFxdChE/+YPnqXf+dLXwtrdP+7tx+nTp3fG++m9yaO5o7b71q1bdPPmzX3Dtn/Y46GHHrLUiDWfiG6M0nUjyb3+/wEDAB498xr67/7GB6yQCU7Lgq63XkA36cEFHGn/Sp/GXPE+C/4KMVlK781T0kCVl+hArs/RRcoFinlwTTZaKEPc1vwcqIlFMy5rVCYNWIyaXWxK46ZyPRYLNnWThWeBlrBY9KP+OZsbom4edYDZ3EXIC4UQRabfO51Lu1mAzwBS6t1JPWaeY2OF5ovBFFE6Va4BKMjvra/pkgTQ8PfUoJUYD9i6GzgpU0E1xqKmDClvXGUVGhuIm12BiMKQdd8pgSFlASohZbpwjPkzoAzOmYIQqn3mRK+2xjE35GDMp7rnMs+5FabJhS5Gz/GSNgh0Ggb5A7EzF6zRC+7qcT+olkHf7XUEYheC0RqkhkRqou+ICDIgK6CYntafb0240DIGFEEZSesO4gcRYFAX7wb6WmcBIJMnJkZkE0iDaFB2AteLfqc2U1cKc9DzDxf4bueySwdj1djEW7NMDDFfueF2FEhCYykhtlPIr22CPTH7KtSV+El7P1YmVmTT6HnSfVdjCpE5U6dx4PD3mOutODjY1QODRnfTmrIJBAxax3XexI0ga6kTTFkHJPVaRd+aBrIWBCMdYCPIaAcwRCJ4HvZ+1I2lc0Jp4myGton18bMf+wP67S88t6+e7sY0bFPpfW95nP78298wNf5zH9DoWPB7UWPfPk8dAqF63y0wjbXr2a4jolo3IRll21pg10hXplSKphSZjIABMjQwuDQjT00UKsMnIN/Ped47f/kP943//rF/7B/7xx4AWHn82F94B73/7W8yN3lsJkoqIJVij8ZM2eSsQ0E5UGnIabdfA5okLXW0WjBv5hRfiyNsWmKTQwYoeHwXhybQ6NtWlI+7O2bllv+fvXfrtezKzsO+Mdc+LJLFKrJYvLPYNzb7KkqWbaUvvkAtWZZjIwFi+yGJbT0kgWMH+RFxHgIDeYyBxIgD2IBhI3EsIwni2JCs2LJbUhuSdeluNfsqsnltNllkk8UmWWevOfIw5xjjG3Otvc8pNqvDqt4L6K5inX32Xnutueac4xvfRQIRs005MxpSV0zzZg3AYNDlpcZgeCapWFYymBo7t7xZtU2CXZMUvVckgTJO701XNApXBx7SdVSUMrl/g+vJJK6HRWJJ4Y5EeD9E3JGlE3TAhxzV7f5NUlJBJpY9TyZgRp0cO63WWfXoNs16Xn49b8o5i511xIqlg3K69hWeTsFASwA4kvLCufvCsouqmozNdAAtdIUGrFTMUu2UPDpq7zJxFOKCEYDsnM9Hpc7ntubPGQ0RrRjKpn1R2LAEQIgtYf+GIQ2jDEZoFsnIIIg939HtDu+EQuNojRHhEXX9S8wc7ycBSOaYSM5vz+Z/fF8YXKls0EegKbv4MxtFBF2uAJecmDlZjNfOeCB5jqZrGGMoIsNYLgFnFhiCUOla1dpB3iG9JcaFDqwUDNIkDZdxmh833fzMJGNjEoCBbmtmqRnUAsWwdgd2NW8DmlfHaFJCGjwyteqQwmJAUlzPUrLvTIrm04hmNKlKMjhFNvVM8a202rnvhss3siSD0wmev3zj0v/PnjnCg3feho/efyfuOX8bjjZTXyvafDNTGtAoffqD776Or33nVTz98pXrcm4fuu88/uxPfrDfI8UGSPPSmPBRrPnQf/+odNo/qPif4jkwdkCZSgCl5ndEMbA+ZZkHwazYqqL59op/rs+/5F2Q5F9+7do4/IPLV/AHL712KPwPx+E4HIfjAADsPj792IP4Dz/1kej6DhtpK+6wUliZ03Le3IlHBApCXxx6u+g+GurumvEhXzk2YjVHbw2bcKHO1zRNXiBIj7CrtDmWdCPEjcSmablR1IGmaZtJW9CLFI8F8yIbSI7nhaK9nMAv2YSM6fOjjst0s66VBxIrwDaXjRofG9DURUZxaYB9P6HNtrukw7qiIVOwe+H6ZgE2ZfLir5LbtfRrMuscbvhe2PfvQ/RxAwbsO1WoX9e5t16UpBC8OW/3x/LVJd0sp8XxwycgIEI9C5nZExznFFTNmnW9VNjTtj6NR6bCCxmTNY0nUYYdOMkSFo+4JFfqyIxeGswxCDUWqf44S94wBksDBEbl7jV/p8lTJCKhgruf7MGhg5O6/XyiHb8VtZkNU9P72v3MG/Lu6CVBpw0yBlHu08Y5inpj4Jj79tGm+DgbYyv538biOHd5ERGcDnzIorDh59bc/03Lv9lMbhJpz3r1+YhiBQ0E6QWFFaMggDZAHwYjmfmwXugy0JRiIEHMAMlAAMNFZSXW0QHbBHiOOcU0ZkSdpp3c8lWDXeYdeBBTRbzw39bmk+CGfpXZUSAZCLMvePyIf2f2J/A1gdhDrVOc2SLj81fV/Dxk4akwgnz83H3p29/FP/jXv39jbG4EeOTCHXjwrtvx8J23430X7wj2C7CI1hzNRuuw5jUg4DU8+dLr+PKzl5NM7904WlzgBfzkB+5rDEU0ev3WWSME1mv0LSZaJ0o3CBQDwfrYnSYz7u1z3ZyNb7ezOnxaawMSbJWZmZVXNQ3LBMIVM4gNjsFTr1zBF5+5jCeevXzYbR+Ow3E4DscBANh/PHThLP7yH/sYLtx1h5fIYTIjg+4td1O9myZIEU4ch2cbOtvgjM7Oa+1/7vZ64cPZS0SZq7xhY7onmA0A1/xzxr0MBlEed0VFn2/gEIX8hui/OmTYm/8A65+5oEjFv+QuVosJqm70x1pWlk9wJ3vifG/vCCN9L/8sKdRxzRuu8Gww1kX11xu9lhMYcgd0jE4EbfTiHhYyy4rmm7qG2Qsfy0cXLgSyI3npUWtmjMRd+aRtEpKxpDFMXZNUNAcVOncoM5ATEWBIBnpleB5ig1sXBl8yeG3YfeIEjCJBSeac+5CzRPfTOuwsW2BWCstLuBgDlgkQZUV3OGvtjtidHcPljhp9mr4nZbiHbCEDV0Z1dxCIN/okJfEiD6Ftd9PC9N3b+7UOdMVRfxYrmbGNMg8g67CTtwiCWs/aYF0AkfY72TIwzaOJBZXTEey5cV+Kaj4gMRbsOkyluehHOoEMC4y6mZizbbT6mLF527rrNl4MlEnda833Q5JPxri85cKXAbBI0wjAExJpG15M07Nkc28ARxRDyvOgYjUJxjwTRLDwogDCgX0iWpck9gYWiQw8FzCo04q36qy3XK+FTKIaY4FYNGJrck0AACAASURBVPy8s1nEP/78V/Cb3/rOe7rgf+jC7bh04SwuXTjrbvtxH3gQ0JyDHKc7PBY+r5jcSKH47Se/i6889wq++/q7G0P18Yfvxp/+8ff5uJi0++MQu0eMxUIklV7vd8CNmGv9uZgmY/mE2WiRJmNpkq7Ggqg9opCjTitFchYIMZwkGhskj3zy8qHwPxyH43AcjgMA8A6Ov/CpD+OPfPhBTGWTadbAwrxNB/dki6MCQB0aLIp/pA0zbZxLpq6XwlFkuYOVtfTVN06m+1dyg65k/DZuMCRpM5EomNbpGjuGo1+BFQwbcoznjR0XgVEkx/f2LqCURdY3R7CxJr9QVrYmv4DodDlro7SuBN+3pO1e8Q4w2jNrCdc299zFNHO+iXSQfj0RWl4r1OZe3Kd7oDEWVLP7OncYmQ4sVJhZugJr8JvCw5gjQdE3mUp0NkvS25unxNRZB96dlzCLiuuIzlphl+gVNgxlxIt7VbBxpKRkgABbZJAFDMaA9HoMYMcIxiFJkYVMHWWQQ+T4RwNgJsnyCSvmknO+UDePED6hiDiOYrQC3EAz/r2RyaBo+fOhz1Z3hQ/vALhk5WhqYJozdgbKfLx3xbZqA/UEAHlBuAad9L/tJR1AkOz5IQm4KZQyIq5Jz87g6GDKjIJWpLMBHsuh1pgI5i8B0QA5qna2h/SfZ1BmTcbAEqm5qkdyWu3mACNJvBwYtkGtLPEYpCO9S3nU5UvbuWaAwIuf4uDgaCBaJEekGiOrEEhnjvwKXSy5DvrxWkXeFYmtJhmU48QEPzUFxZRqGLf29BV7Btv9zTIeBsIgWdfNwMB/97//Gl5/8+p7Zp9w/tYjfOSBO/GBi3fgfRfvaOsLzZ0cC+lzWKFkCmR2xyTxsxR2SX4lzh7ol+7pl1/HV194Fb//7LsXi3jx3K34Tz77UR9fkxJwuVjP+xyIxhqw2TvArRIRgbS/sO8N1JDMIExIuxdqkuOYOXB79qIRYeveV178Hr7+wqv4+vOvHnbXh+NwHI7DcQAArv347EcexGc+/CDuu3jnwuwsGauxqRKyyzVoc8xO7wDn38pgqATShI6uyIG+p6i0lStpdDmjeFfqzphhnXVmWPueNmW94zCbUI82jazpbDF+tbMO2Pl8qTdlAyDWdrIhHRvWRcmUpQhuqtZN8wqbymlQskejrmZU1F5bNQzw7LPbedlGVZLvAW/g7V5WZCdkM+QrRbDdzikSzTpsYYaH3o1s19lywN3oDER5T8wI6ghNQrFtdq6s/xVyYe8FJnIHeTvXFGVpoJOBUHFvqCCVHJsnyPTm8XpFAgMX8RKVA28mNajB8ZxFnBM/F0q0ELtmouIFqbCRhAFgvUgvvc/klNxh/K8xWLZ94xpmnIVc8mO0FjIOzP4C2fhPBmp+NpvLXiNBv84gJIZumVLShsmFJuomgzpoSjFZngJAKRpZMpKTPbxYZFM4RcTw6QiVxXM/kXN/7iSTDt5lVxQvmjwvagAMNheVKLo1ASpwQGquWY+RwIo6GH3SF1iyVcKLpUhISib3ZBhAK6rBbf4qxE6qFDFr3WJj0pQujYkkCSzYVO7jUHKkUaxLSAaVDGSY9j4VaCILoI8BBx18RmAmckDybSjEzgmTUDaSDBaKp6kMz00RwVeeegF/91e/8v/rvuCOM0e4/87b8JH778TFs2dw3/lbE3tIKcqUYzW5iIUCM+XnuOypTyJK6zmb88INT8X/NGChCPDtV67gxe+9iS8/exmvvPH2D/xdiwg+celufO6Tl9pzqYINsUCEJYkONjFgEZGxIjlJSRmcR7DljKlj5oEcSWpAa5rzOpvn9567jC8//TKeuXzlsKs+HIfjcByOAwDwzo+jqeCv/dzjuO+uO3DL0S0p65nji7CgQWKl2F+n/kOti97dsNlB1926I6Pbi88eEeZdo2SoVVfc0/kzuwdArb5Zt7idlBHNHQjblFpXf9Brslxg6n+f6VrNs2KzKURlzvFobKY4Fkbs7M/aPt6Ehm8AbcwrUha6dSVb1jY8ZiwVJFY4SLMbSnGKXjhKmF71kOIW4wWkvDkqGp2eT8X0VCzKz7p27dh2cMaM9pTcvW1Db1Fdcw0wwWLMzDXbmRGpg7KLokxpCtS1UnLjd+ZCjThJNhtz1gAV6oolLZwj0spgpmfPT4G4/l2YAj+kLkgC5Xjc5Lg621TXPj5LifM3t//R58NORsjd2u9f16pX5KhKPswYEogotTCBRNJtu6Gk5j4thuLbzdK6yzvHBxr9vFCmfQIIvbiOuauCO+b93pb89At5gnDX0Qy4QvbR5xRkVpQxkdgDZGKG1BDhNXbW7bO5CHf9uIbsoQFW4WcBSALS2Agz9cI12yvEfR9iVc3skzriSCkEnd4tcY4MyIAMEO2ZDhMzSSkPzigo8b45HjbAGo5rZN8XBygJhDLmhkkcaiXoqz9vWleiTztwUhXJe4HBZ06oYeYOo1M8fpASUpa6/5IYMm3u++//jy/g1XehsL22gn+DB+68HR978E7cddsZ3Hvu1gRsWbe6UkVaSgeZ6J6DJA+qGgBAX2uOiuC4m4/wuJutIE5eDXm8ttQOYvtU4Pefu4yvv/A9fPvl13/ga/DAXbfjL37qsVhfZ3UZjn3tCqLh03pu1paFojgDvAeExlBFGNYWGaRpxhgrIW9SBb70/Cv4/WcuHwr/w3E4DsfhOAAA797x2AN34c/85Afx8MU702aVNzV5E0u7ocH13+ncGDXJmR47SgpG+rx1mMfNKWv4w6RHCc0v2HphkKnRJRlDEWihFIEHpGKNu2vsvi6iRMeFbyytOx29RTIBdGPCFWkChk7zaP5DBay5KCfNu9flVkjnWLp2ntUp8UbdZwmD58mquk6Tox0t5xgE/lgxNBGrgDc2RuOdpIE21v2x4nqme8USjlqRctqVIt1GuQVvnMwhPDqE1oHj7PfcAS+pI5o7WrrjYeZkAY4C5I1/pBR6D8w3sqSmTikRXOBbtn26x+BNcnS+o2xE7j4OpnRj0oGBNJyzbo7nWYrA3hSUmEE59JweAUo9GI3OzMNBSHtg5+3PpoI03EiFND8PBjyNXhxp3hiMEzlS08AC9CQELnqS1wWyV0KKvut0dBHT5y9zw51/QYVgAza5qx2FbftsZvt0KUa/qtt5hhTp0hrF8TxjU2SYb7GQL41RqzZXHnXgUof5nk3auFs/5tavgcKJEebAT79fHEFIiISZNE4SCTIhNRh9E8g4IVHss8kqeyUsfAP6hSmlLBI5QOO3apOK2PzQ5uB+DgxcBzcsPgcxlpNERvJ1VFX80m9/A//iy89c/w2JAA/ffQcevPM2fOjiOTx45+3t30srrPmqGlbGUiEzEC0iCWgRIEeOlnDIn0hPb6y2qooZFOPbB2d1F/7uui8xldn4nQj8eeryFTz54mt44vlX8Nbx/I6vS4sLvAef+vADDWhTF5INTQG40bAS0FiIEenPms35PjZJDkYAI8Ohxuz67Wdexu99+yW8/C77HxyOw3E4DsfhOAAAAICf/4n34dMffhC33377wrAKC2avLnSlbEi23BQqKmnSo5DNpmEgCjBHy/G5CLUEtLeBhfS/o6mbpigvuCFd9Y32OgDhBYuEIy93J6sOblWSo6BKL3i5cIgcbqRoL6VzW7t+Y1wgNJzsLXe4MQQyo6H0LnBstqXT78ULMdaM5258CcAAPVLMOmkCCIp36Lfz7FGNthH07O/unlyIybGIjFSsOuhHRv3SuI03YlZo2jmyw7j07yRUoNuG1V2/qWAuJKlI+fXIjtXJ48ppxivu5SKLZ8OKrzqAT9FhDM38GLknyR9iWX0xBdmKXNYy5whNSVFnTboRUX8eA0nAhpk0xmwmCxM27/ZDUhHqdNokLxp8H9xjwZ6f7J4fRo2tgOZ4wXQfUzdeUkQj63vHmTmncrTvx5p9nruYtpskGhRFmlhFqq37J4TYGShULFVFk6SlvW94UzDLR7sZo7nTRy54Nk2sOsowYlQVSdN6AknGmEpjNNi1jG78cE0NQASokOdrJAlkSc8MzaEEaSUpjqq4IaIZPo5GtTZHh4cLJZ64NCODgMZ8mcifwiQDQo6XLRAlPxf2vC+AgNrSadwDg8bkuK4eHx/jb/yjX8f2Osa3/cT778Gj99+Jhy+cBeYahTeQ1hLGKQrCw8SK3O2cpVlZ1hOAI0Q6MJXNQ8NngeIBuwRtAlAlwBOX6mjT3/tzZ+/FAJICX3q2sQKe+gFYAR+67zz+3B/+oC9QE0bgkSL5DNBAnPPkLBiSN6Cx7ipH0/brmdaOIvitb7+E3/j6C3jz6vawez4ch+NwHI4DAHD9jocunMVf+NRjeOieu/yEh7SrnGncX7TtnXr+ouy+r0MXbhq079yV9Q2SyBDJpTmnl/SDo8O4d7GhS1d4KgZGPakXZnR+KRWBjf28aykpRs03nRJddq2VAAssAAG7aIVSECymrDl+18XmuFLEVKGiZyqFOm+S3ZUNMKDPMfe2pIFNafU5991ouVYM2Ua1DBKJbJinKabLOqK2GffoI5JUbLq3AEcRsnnf2IUdcsnC7LBfCzfoAlK0GXtdsAwEXAyBHfmrO4ebDCCnAWjyNvBrQp1Qvh/tmo81PMXfDfecAZMiKyyRSNr05AuRZbd2NJPrCg8vTj2iLsX3IenteRxGsUn+D5o7oRyLxwAJhqhMoehQe66tAOfX8HSa4jsR1a4V3UIsGAaPIhIP4fhddY3VDbZYwPCd2KyT5ULNrJCNCkmCZP4GnBffC6CSWEKaQJb2/tV/n68ZA7fchTeZhgwShTWT1koGbhbfyF3xMSEiZBGar4Pp/s0dn+JHa4X/HGCjNE0deY9frUrgX3vNxn9efCxblKKxgPimjVGrUwmWlEJR5wAnigxgbx28O0wCtrK4Z4PP/G+anDsxSAMU/9vnv4Lfuo7O/w/ffQf+/E892u4TFf8BwIASRtwXEwUWa4cUiQhEUkX4AXR22UTsDJGUX8/AtkmXrONtxq5bbZ87ddBh0+fYrQaIWfpnbtmsmNb0b7z4Gp787mvvOErw7jtuxccfbnGB0mU30wDa2DNYh+s4dSlKWxc6S05a6F/yjaFrOqvid5+5jC9841D4H47DcTgOxwEA+CEen37sAfz0Ry/hrrvuWPDPwwAp04ytMAiH61w0uM6TNoqyEjPGxYhnfGOIGLQz4WLG6fkMMGgGFro7dpFsLhda7aBaqzlom0u6Vs96Nk+BkMDLwlk+FxvV3cTZDHH0OQi9NVxvXchvwAqnScQ7a7axjGIvdLjuWM5dT/dFKIvCd9zIl/45rNn2nG4JD4HWcW9d2tJNFIvkAp8N0CRFZGU6NAM9YxoCEBpTNolkemofJStFSu6olpRYQPFvyCZ1HNtlRQazNVTNxKlAO5BiWfBIyQ3qpm7xHYszBkT686GyzHxeeT4i+zw6UUKa/tDLx7UYn49lwZyp4kipCeQ5gUhegGY2TgIqqPDnz+F4y8iIj/PczpXSO8KM01MC+uvm3vkvA4XcZCBTBxWsAwxEwgdrbu3emnzBDD7tNZZyIUmXr8mZnsctp0tYMY/EXqhulFY1RmylechBxQ6uZY09etpJmJoaQLatc5pfnZGiYXaY53HyTVFdxHtyvTQ5swBOeY9UiH5+BSk6c/Q/GH0HDOADxcrad6zVPEw0FVX83Uy6MCV5VvbUsLECEY9bGw0BVXVpkoiI9/N1gsxCRfxOxftJyHHMLJajT0Pek/9un/nG99/Ef/uPv3Dd1vapCP6rn/vxNt/N1eeMivxMmgTAbvOxApv+szLZnBXPFD+/SJGsGahjuRwGQ1CtXVJAnhbHqhD2POnsGRT4nHTUx8vWnuV+HuaBUrsJIQD8zpMv4cvPXMblN66dSv/xh+/Gn3r8EQd9j1hOZHMCg2oETlTVBPLwdTcQqQL4V199Dr//zOUfSL5wOA7H4Tgch+MAALyj4/YzR/jPf/oTePDinaGv1ExNsw2drgAE4z8I6VHNdMs2bmXQ5KaN9EAz5ki1MaqQ3Z4xegRQBBtv4GxTJpnvH+CD5u6MUKueO1rsG1CSMRUW7tXbWrEpUzJZtIJp6qaGHCuWr41iKpMX4pVj48hRmynqfm00qLYgM7oiU0p28Ngm8mpwHwQqisMLwAqPmmi2YdSYnZBHii4XCwwUcaUSRfoyps7emzvCarKGIU/eO+CSg6czU2TU2OfNa+kXLkzFlt2zqlimZ/Ruo+vTRcPgDeGw3va2Qt0xXcweufiHR0s5G8PvcWhuR8bE3Du1+RlkXwUbX9mE0jtedC9lYGZQal67nyU6w5x0weZtZrjIzy9/f456A/kilKHwSuc/xHfqSoa7FXnNa6Sd9Zx8BsIVPnkLeP433Z5R/oMobsPgU5M5XOn33Z38EX4RBQ2As6Jb6LxtHM61RgGRYiaDgs9Gg9HZNSClLBamBtJQlCq5t4fJZhisBqhD7Kyh8NmQLMd+7kU7a8ZTykUr4orT7yXNQ44fEgCiIB26AX4UOynkmTLOPQxSFXp+WLPPAHQASQH82DgzADxYLjnBJsVi0jn8L//id/H151+5bmv7Zz/6IP7IB+714r8MsX3B/MimtLN1+gtdfBUcHXVGFZq/i4hgmrorySjvYZlPB03Rx3eT8jSJCz9j2n0AatVOnQfmuXnIlCLYtARMzAps3ZUfib2g5CVgz+I3v/MannjuMr714mvXdP0unrsV/+lnP5ou2FFngs3kMaHknwIDBuA2LP4MSymYVfGrX3sev/PkSyF3PBzvqePixYvdH0QwTdNSojnMI6qKq1evYrvdYp5nvP322zg+Pj5cyMNxUx633347jo6OsNlssNlsUEpJz0k2qo6/z/OMeZ7xyiuv4OrVqzf9dbohAAAAePx9F/Fnf/wDuPuuc7545ZuH7B7NnSUx057q+j/OjuZOHJC7rBMZOoUBHygOKvKqvZgEvNgrtKOJjh7Ru1lzCB20z0jvH+6+klgCbPYmnVqu5NQdpnq568G0fDPMM9proaLbuksYHKPZWDDrodXNF20zViijW8ltSHZU0eJu3QWclc76c9+0UnSalND+Gu3WtL7h/B3fxVMeqsUmyaL4ARWEG0ou4IdIOCZJVtzHe2FTuGsN7thJAj5K7xhGKkQ4cheKYKssA2G/iF7oamppxcNubBg730kKKkI6McpCyoq3Rh08KBhUGa+RXSd+zkz+YJINGd6LUzxsfC7wB2V2ARYMgtlo1UTj1oHhIWQOVvvsUgh8SWW05pg8dtY2aQzfLwduKFqxzQOSKOKFwZh+lybJDAN+Hra1enEiMnowLE0VScBAmneTRHAkqJJZKFLRZEWQX1MyT03j3sCXZZRC+IlogJ0hoemgInWohWQfNpeOBor+/HMXXSQDFL0DK4MkZxmDiJTcMYIz9i9FWuqHfX90FotdX5vjfW1wRgH7FCBJH3hudtNaigEMtkVIoOYOSjtDahixIupgVdVgJpkBKj8DFs069Wv1ha98G//kN7913db0D913Hn/uJz8AnSs2kpMOAPj4jjHefj4VeJyqg4Vohb7NlptNoTU5WEwWEcug/dzTNxrLrrZEl74ONqVMxbxFN9iNcXVcO6jWkQlbewXA1f7+RyXWr9rZAFqkp/R0RgslSTx7+Q28+L038KVnTh8lWETw8UsX8DOfeKSN3Q5OCK1lNncKGqjhiT9pjRP86tcPhf+NcNx///04OjrCNE0OBCRQiyZ/Tt0ZmY3Hx8eY5xnb7RZXr17FPM8OFNTDGDgc79Hj6OjIC3z7s5SCUgpuvfXWhbRuBMPWGrz28+PjY7zyyit4/fXXb/rreMMAAJup4K//qcdx/4VzODrarL6GjaeEIv04pq5qdNEW9FLqoNrmLZtbaZo8zUXZaKKxWYzt7Ojgb3rtMULNvoBQJzckDPkWVaW+nC41sLXTwP1c6bPs/bg7pL5BiK5oFHJd10+FzZK3G13YkT7PxZjTURG+APnBzG86aqJ5xBYRSAmqbzZyLFRvhOs7d8W86B2o01E4iXdD+bVc6PDrk4cBPV22MbcrUem9TeMubL1M+s0mebDCLFOxHSpR8xNQf6/W5YazJcZrnBgt5BXQis7st5Ai3wCKB8ua0arrWmyQqVtEyC1jPNlscfR44Ima8+vDnFHceDNFxSGMHWHpGFVRzDgymQ9q8uvgjmv7rt1DguUiwkCbDDNqpvqHZAYxNwxghY1+ZiEhmXJ10GbhAzLk3GO8rhUFJbnmQ0wXHywXRQaToku8BFj8G0lmfJgUSUqMC59jE5OIPSXiu7Ph6Gi01363pO89GuvlCDxyfXcAhww6u1GrCAOh/V12yUQMWCApjRQBS8M4ljWbhGralCRQU8KbABJOKfy8LuYTAqSnYlIfJE+SiUz9bONTHdgOoLqCmC19fP6tf/pb1y3e7ZbNhP/yZz+JUhVFBhE+iLlUG8W/rcV2/81Itn3faeqGu0V8ffN7KTYPhu8IRLDdzsm/gsFX9mOZ64x5S0OKZClatTMR1AFiZw8R+4jndAO+ZzRTQaDJAXy8mZmoCL74zMv42vOv4ulTmgZaXKBH96b5IyR4kkBAwZMvX8FTl18/FP43yLHZbPDAAw9gs9mkwoX3pvsAAF3R843PAABcvXq1g5kVx8fHuHr1Kq5evYrj4+MDOHA4fmhFPnfyp2nCrbfemuuwAfxiU+61An8NABifkytXruDFF188AADvpaPFAn4Il+45713zQvE73GH1jnp3+e0/XXTDWA9u2vyZujJsCIVhn2IdKe6sRy1H+en9Sm/n2o3k2GwtujqhTx+/i/oXZDM4y/4FbWKimxNFhhWxOQow3ns0bnONvw7GUWTYx9+tqmIzTZi73jeKQFlIJ2LvHzu9yTtdbXPfXJszOsfgjdD+XoeIuSishB7srB/mGDkhWm1OXkBiAmy6y9I8L30AEgtjLIg79d+0xyrAU6+8hZevXMUfunQXjiYQdbcVa+ai4LphL8SJHo/WCdPaf4MqKbt/Uyl981khpaRzyzKFru0mCQV3Gu07loGi7KwYXQd+QncNBzBq1/GOBoDaO79cwGlyyEcypZyJiq/Ipp7sMeHRf3Rzowsfc4OxKSyy7nhbvYOqNbu4A62DZht+j5JTJd+DHpc3bKrMUJQ1/swE0mEMsXymsOadAE7btKuGKZobGw66fC5E2SAvNoDL+wfyCGmFF5uLtms3kaSoRASGmxcGtqfJWK8MXXxGFheApSqk//ckUwNCeHwg5CXbGr4H7r1ShshO7vZTlKIU6eaTwTogyC0YWQgmFIj9JBR3audQe4YdP8NVq/t4iEc9amJU1dqiSQ08ZkYU3zsHaYXkEQhzWjunWWcUFGfVMAxrjIOqil/+7W/il7/09HVby3/6E5fwyYfvwpFSN7qSZ6plzpf+lPeCf5okEIKVAl+k+FqwmSanu4PAJV8rCTMzY0cGtX2c9Httz16bcxXbbch0tNbOFgigaba5u8/RGwNowD4xcZ+MoWGRfTbHPf3y6/jmi6/hq89dxtXt/sLrzGbCH//YQ3mTp1mi4iAFgGdfeQNPPHf5UG3cQMftt9+O++67LxUsCXLXHBO9ZLthtUBSXffBWuugHh8f++cYY4DBglobaL7dHkwjD8eysLc/N5uNg1pHR0fexT9z5kxqggYDMZsnrxXyI61f12R1w8/HcX/16lU888wzN/29uKEAAKDHAj72IG677bbUrUg3mOilSm64GDqW1k3kgoMNkrRm5KiQftrB/E5PzZ2mvMGtLBUwM0LqiM+k3+ei3BZszvkeqaKh1ZbUNU3FFWsdnYabB4Bv6MkcEVgv7rhTyyCGXSc2rLICywq13EHrm/saG3XOuvcCmrsniRHQNse2R3PQo28a1QtQIdYEFoWwOUbP3HkfgI8Ue0iSBc9oTxGKHFkYUYeqiu+9tcX/88TLOJ4r/vClc/ixB88t6O6hZaeYMuvQWzHRiw7r2oafQOhV7Y0NfKmaYwBLCXCreNFSnZ2hiKKksDZelUwV1Z3qpctsrCPJRaZdw4muEYNUUehqTsCgmzDSt/MmJYCyKLKiQ7ek/utiTIuUiEPr/zc7vb85ZbfPyCaQ3Ln2eSPpz2V1o8bfJANwSP4dlj9vaQDJDJHM20Dxom4QpxlcGGn6/CzZ888gWAJ7YMwGDL9nPgXS2RC8oSzQPr+JZLCNDeeYLTCZk/6wyCuZPFrXnSMi3bxxGCMpEYHTYpANLO3asVEgA4g5/YLm40GuxQATG7s6e4XkAQbQNeBtZUPPDvhkDmmdb5ZExPeJGLdSyMjOwKCqWAlaiGJ4rvib/+Q38Nqb10cD+fj7LuKnP/4wNkOcrkg249tMcN1mu66lbxYnl9QUkuhN0+TF99RfM67nsW6LF+d5DiDPDYvMtDW6z1dzn/NM6mfGljbJzb3g93V1iIi1kmgDuBeAM5b8mQfJgtQN+r70zEv4vadexkuvv3moJH5Ej3vvvRfnz5/Pe7uhoN9V3Oxbi9YKIe6Y7vr9taLKDgYKGBQw/4F5nlFr9T8PgMGNW9Bbl958KUye0ublNi5uueWWxRjhon5tnMlK8hqPSwbCGDCwrv7IVtkFCozHM888c9P7ANxwAMCDd53FX/zMY3jknguuZVyjYyeH++7oa91r2wjMfWNlxQq77jP91wsyj3DKFOotxUWxCSBvIBRBpc7MAHFtuXduJWL2pjJ5MRq6xHC0Zn0hb0ansjR0io3GUFSPDxqZDvK/jcwB/v3C+eRzdbCDoxQxPOBTEWzn3rXU0L2Gpj86W6Grz9/BZBoKNjikNAQzhOvX1TwY1hZIjiurvZs69Z9tPYs7Ch83k1MyJ0zu6Dm6qrFAFP/sKy/he2/P+KOPnMPH7r8jtOxD9ribr0mEjVdyBRSBAyDBcqF8dyCuj3XCyO1cib7Ks8CsFUfT5MBZuIpjeEYA08sz/KPyDgAAIABJREFUyBVASZbWmGnmPMQ0cgEaEZbqXXnLAffMdGQKtBB4UCSbs8Ho7p73Tk7qfby5rKMXdgbebOfqWnflLrVmII418vyMpSQO1r8zeEDFQcxZuSvJcaAMslUqniVnvsUflMLgjI4EkGaUS4dz47lQodiUcMT3TiqZQU6kLW4O6CU08CRxyXOSrpjgNYPRUV7VIlqrm/alTi1HDbqrufkphNdBdtJfxlYWMvBTHTcOXWpC3Xx3+y9hfjpJjptMkYi+nozeDbw5kQTCcgLERIkh9tnsFcAg77jRGqViDJ7YjfvFX38CX/jGC9dl/b7r7Bn8lT/+MUx17oB1RPohzTeCMrU1YHNU+vxaWowfMUzMB8bkACLFfVqMBcUGfuGjUWl9Lm0emOeI461ZJmhMrLlqN/mLVBE3k1S4wW+RAMsMXHYjTjPzUcVMc+lkwKUqjklWVhAGlRYt+L/++tfw4msHEOBH8XjkkUe8kFo7EhN00ELvkwCsxVuvFUtrBdVJxwhKrHVuDTAI9lN1UzYGCezz53n295rneQ/Ifjh2FoDc4CzFC3kbM1a8s8be/iciODo6WtzTXQla/HlcpK8BAHYuzorWURaNnQDANE0+RkopPq/vAh12Hd/97nfx2muv3dz3/0YDAADgc5+8hE8/+gDuuvMOKtxLonFmPXts9GqNTcHYHbf4JqYFRwY0d7yDTt8mKuo+UbcU5FZfxqgy6ua5/l6zlrWQCRiGLphRPZU6tDp8n9RZpqJlnNQVuQDLTskY3gTeiQkQIhew0NzFHQu6iMVqm6BpKgu5BBeVrPf1rrPAKePqlOHlBn6u0SkrtCk3x3br5nmcYf8dIYaHxTuZLMCzqEmv3qj+0WVdczZ3+jUEx7W2jaqalppMyzQYKuwToIj0CNY7+0afNO3GACjGcgGzW2UBfvD1JjEzyUjgXUWXTigS8Gb3zszFZg2/izICGFSkVpLfmFykOGgGvx9WyHOBucYuSJFzdlMIvCoUyeYdU5KaMBgkENS5BnhSLP2iFaImaRA3CeW5I0tdQtNtv4NFekijqgeFn5kXnOwwV0oXGcA5f6od7BRPHKlz9Y79WIYLMHhtELiSzEdL2mw2iUwJR/zBtyEZhpK5oq4ZaZJkIwDdkkEiiu7k+MRIS4DLiZwxBKQO8CjjsXnXJBSac02TFCPLhuw9C421iGqdpDgTw8bQNPF8EBF9fN/MMBADa4bPR0SwnecR3SVjQviaaKyzWSumMoX/Am0AGrV3i//mH/0atvP10fj+3I+/Dx+7/zw2A8MkWRcKcLSZHAQufRPaJACb9h270z00NqkOcNDcZus5z3cmpbBrVyyGtJsgevILrWXt9duu+29RgFXzfC0DmDrPDTioNZhilca1oun/LUpwIg+ASgBtCRJT21P0sfDPf+9JfOOF7x2qmB+ho5SCD37wgzu77muMgPHna5KB03RFk9ToFIX/WLiNAABTu3f9PheAa6BEMFej4DPWAf/cAAIGEAAk6YL9ea3+BvP87kVk2lx2La+34p1/d/I5s3iha4U7X18u4NdAgV1gDRfPDNjsKrTXxvGuIn78OZ/HaQAABhfWGC389zWQzI4rV67ghRdeuKnnkxsSALjz9lvwC3/yE3jw4nkqQIPiaJ2eMHJD0nLaTd9MYeyGvvkTyMrkGTRf2wBysZTOodNguY5SQrJGmrhlcBst1zf6En+Za22dN81djUrFMVKmc3YDzwUXa1OD4ry2IBilu4ikB8aKJvZN4EQEi1Xy7+HmVSWcv6sOfgG62GCz9hnUqWydrwBnvOPqLtFCsV9I71FRoVpap9IKHLq3LZ5bU8QjF8j80LjZkgQVe5rETQTN8HEqkqPCukO/dSgLdbr5ZiTPhtEVvHdh2Xnc860FKCjEZqhuCCaeac4F74jQ0jg3TwJJpPaQfpAXhQ6sCpPHrPgCDgyMMIeUBdME0SkcaI6WiMFmmuH8HQBWlrFEh/Z4rk7vn+357FnuJoMwarubvRHowR1gLi6ygzwDHeTor63Qr0TvHkFH7ggb8DP1Asee/aPOHNp2J3Mbw/2uAsjGl6AFsnYvAvTxweySlJMuLK0ihlFVYiOJxzmGFEcgHQGypI2phCRgM004nmeSLzBzqfWGzRiPAbXcwTdgVFAkDDzXJFMpBo5kDNbZt7m0UhpLrYKj7igfXXakeStdMTJyjTSVAP6EGVEIA1nW/HNevaa5IJ6Pxi6pPr4ZZwqANc8/buhIzJ3x+Du/9Dv42nWK/Xv8fffgT370QZwpodEQGeRVHUwxvf9mMzk/QMqEzdQ3tKVFxga9NECfGGvZZ4TZM0zfT+NWaPRolpG0Yl6htbpcLJ4TdSlgrW3iYpDSzImPZ5LNdXkPStx7S66ZaU0TDXPheYBt/uHnv4qXXn/rUBn/iBxnz57FAw88cKrO7mlo/mvSgfE91rqyp+n+nwQA7JfG7f4Oa7/DAMCu4m8N6NgnbTgtm2DNQHEfmLLLgX68xqOZ3a7zlGF/Xt0TaOntwJT4fSyPNbbHLiBml9P+2n/vMq08SQLA93nXmFt7j13veRI4AABvvfUWnn766Zt6PrkhAQAA+MxHHsSf+MhDuHjhnFMZJ8nfyjZQJaH/7c9NiXgprc3EztD56IS1hXrunR2jjy/cuT16roa+vW/YOGu81top2+odZ95Ej3FqwOA27+ZhihWRdNYRgyPIkPLfMYAZrov1zTZ1lDsQoKKpk5rOlZ2lOWMwTZA6GCdSNjpptitptSt1Q70Ll1yyQ1vbCnvxTR9rbl16QOkBtSL5IJgLeJGgsG9rbSZZpMNF8mDQVKAV2Z2QkEwH3TmcO5FKPs3t37Z1TqZfvg3s43vqUVhhoJad/bMxfLBEhBz5cwc0PBdyeoYlr9fkd+DyGAg54iNFVoI8E/izWQcO+vZ2La1o8e4wFaMGXtim+ajrfS2CLwrhSOIAMVKiC6dkIGYO6a0YZBPPibqKY1yojdlC2erazerY08J0xBuip8X3XgFIBm3wwO4Ptgc0Fedh7t1Ew0r+EObvUDmmb0jesPthpqcjQ4TjS+f+vRmEcsCBKOruxj8AATxTuTcKzFMjeCtlzdelzwUhEZHk5ZI2U85CyeN+3LyECWF+vhmo0kXaA+g5RkqgSB4eFPVmEZ01sZtCgsaRsrzpEY8DzN41izSNtPmKZ6EMspVBiYbf+9bz+Aef/+p1Wa8fvvsO/Ed/9EM40jCatHUzklX6XNMlea3YL5g2E4oUZzNtyoQyFZQy9TWltPUcnWpP67mN+Xmuvs7MnbnHwOtoCMveJWwKq/3ZtX2AAUrN4LfNDQo2Dm2AgLEKTanlki0FtpoB8Nr1/ibXEVVo7/wLrU+2zv3tX/4ijueDK/uPwnHx4kVcuHDh1K/fpevf18lfsGNXQIOTusNrhe6uwncNJFgDEPbJGNYAgH0F+PUEANYK55NAmJEavwuoWetU77tm+36+q0DfB2SMXf617v1pAYDRuPw0EgD+GZ/jCPzsK/LHn4UZ8/KeP/XUU+5XcQAA3kPH0VTw1/7U47jvwh042hwNhRnTjtumvkjoesNZut3wTSkUYbcPbRTvFCJpSDJFloudrCFVp+RiyKzmTqj2DXjLcI5z4+J5jP1KhlqiyQPBig9IdOQYxHCafYlCOxubRVQghkityFTmhxkDfZw9C9DvQVwrUO47d+4mM9FinbQU1+Ha+4nTaMm93uMUO7jBGeKoq11XnxSsq03nL1R562BEZp/NdHlmQ9S6LL5nclxnjb9SZ56BEEjoZH2c9QtlbtKcKd42q3DqtxjDRLi4kNT1ZXfz0s3bjELWWARjbzuiKJ3CTBtTNhkESQYCZMiFnRcq1Lkz3wyhZ2ZMbKhDQb5e8AgBH5rMFufKhqDq16omXTb5MTBDhYoA7xUKm4DGOThTxGnuINYCEpDCxbN6Oogmc83kFyEZkPGOJM2DbpxGBWfQH2mcpH8rCahT0pZXen8d5iJmPbA3BwOntrgbeDjP1dlaZYjSY408ewW4r8Rc07jIcqe19BFLR1hgdQsWCjNrIsEgd0Mm8r4YDytwV+czA08qb2ziPln32LwWysDCSuazZGRr0gxZASc0pYDEnPu3/u/fvG6xf//+H3o/HrvvXKf+RyJIMlUFUKam4S9FWnJJmbrXiYEA7d+n/j9FloYZQGCg/TS1cQV06YVHT4rLRkZvBCCnn/hS28ErnrvRAUt0+cBc5+ZdQcwWYxd4mgYBV55o0sfEFnBJQO1SAwigxmaj9dsYaF9+9mX8ypdufsfqwwE8/PDDuO22207sZq4Vb6fthK4VoLsAgTU5wS4WwRoAsK8YF2m+HJxmsAsIYADgNNdlBEHW2A2nMTrc1wHfV8yORnb232vAykngyLUCACcBReN5jMXyCABM07T4vmPU9Hht1u7TaRgAJ92LfSDJvueAz4mP559/HleuXLlp55MbFgAAgJ94/z34mU++Dw/ec2fS6csiklvJxGxA5dJDGjnJbKBlGvUyOJtrjfzwAqGORk2b4apRiGpVyiaXZKjGWtZoaHH3W6Ow6K198eKv0RILApSYqy7MrNgrYOxYh8leBxDENhklFeljg3uMF+Oft47psnsJ5NQFz5VfoUKxe3iasHrMnRWVHJfHXXNQ18Tos2MBInTDTCevfE48oVC2MsZ7RJOLXf8GCNTki1AKR/ZZh7SsXt/x82oqNuEa05FBYp1WlyBQd5P9BKZOo9/aAjUU4XxfRQY9cr93acL2aMaIjEymg53Xn/XHZgw5gGaIjv+8WEBBcgbWx0dBrXSOU5miqERILNiBnJkNWHmPuBOaPm+S4oCB0hjkLq93Oov04kfdjNMBqYFZY2CjCj/vlBlOvhbSb/K2Nt2w+YxYuWlZ6Xl8m2o/gI9h9BGzIIwvhdhB9hxF1J6kYtw9Vcj8bqaxJgQijkCU0gDRxAZAgFhdsmHjr+4ys+qdWTOU5OLZ3WN6135p0Gf+LmVhoMhADFMItpSoEYCJODASxXzTpBs4B6xsdAmw8rQH8DzXTr6UABw52jGzQ7I/SxHgn//mN/HLX/72dVmnf+rR+/GpR+/DLVAyIO2Ud+q6l6n9bDNtXNpTSund/oKpgwHNnKo0NsbAduI1KXlnyAiuqnsxtGhX9eeH5VIGWKuyXKClgczb2b14ghEgVKTXBmr1Z90SVew+2O+EYSn8WVZVHFelyD7t80yAhLz2/trXnsO/+4PvHirkm/gQETz66KMnFvFjh378+UnU+13gwa7P5D3aLtBhl5v7CDjseu+TIgrXCtN9r19jQYzXbNe1XSskTwMAjEZ2+wr0XVT3fYZ7a9+Br8W+wnhkIYzMin3XdRfrgr/vLm8Duxan9aDgbv3a/eCknNMAB7tAAjtefvllXL5888ak3tAAAAD8/E+8H5969AHcfvZ2MmoL53A3ppLMqR0p3eacztnV4cLNG7AwbhKVpHvmjYZSUSrSzLeUAAErPqZuZlRr9YLRzrMitPhcaKnWnuVMdEUqiuw7m7ngXDO7gIGAbH5GnUKRRE+1jTBr923TlCIVwd22pue0HHjbOEXxkh8468ZYp8z0/tH1q8Nkh06vDCBkM1HMnIMsGLrXwZiw7GUuKNhMco2uNMoveIw45ZkE/ew4P8bM+f2Vscvar8lc0z3gCEKPrtMsF3G5RSrEdLVo5DhKvq55AWHGA6hoZHAgXNxLZ1xEF1JWXM6RHMgnk8yoeTAUd+PGwKTJhR2oGw/PmXcgpt9YZsyM/gR8flHwqtPlQR1w7sAVirmUBEBGR94M2VjiMKtFgQ4c8kXBmcEsHYzbSjfkVJfFxPebjXLsda1FXk4OthkYY0wWP0+N6MiZfC/S4k7Mj8XGhoqchX6BxqI9t2v7UJ4TrCObpVZC3XVxyUGAlYp5rulapqI7MZzII2KQ5wCZrQKaP2et/uyzFIGBD5MQxVqjLiNQYlHx56tkH5QwLQ3zStHMBhKP8dQFsM3af8JE/e9znfE3/8kX8Pp1iP17+O478Od/6lHcgprWSJ533LBvE0ZWLUaqdJC6dfs3m4mkaWURFxrxrVkiZtfU/WFoPQdycofSeK+DvIZ9HLbb2eeMttksqHX2zacX9lp9nBszTHx9qgFgEqh1PNck5ava5GiSTE4xeBQA//R3nsQ3v3MwBbxZj7Nnz+Khhx46sYN70nFS4X9SEc3F4a7X7uu+nta4cN+/rRVza0DEeE67GAQnAQD7rtlpPQD4M9dc8PexBXZFO65R59c8AEYWxa6u+3h91mj6a9dkVwd9/L19zIxdRfhp7sFJXf5reS74d958800888zNy6664QGADz9wF/7cH/4QHrp4p3eOoptGpnfDpsrr7FqJVstZyrahKzie56Z1FSxinRhVMEMnhUbn0x8ypEgrH3CClHedY83QI41aEc8xZErZ6xxVaEWTb6Bdp1sSfXeeqztG24axInS7bUOTExNCg5o3SlbIhhdDXE+RHNln7AkHIxiQ8WshabN13DswR5vJi4KIftLU3Ye0czdnZmNKtI57SWyLWMj20MsGSnsyVkTWSDfXbyGt5tLUcDTx4mLSjMHyf/cxbKZWpEueDQ0ldocnJwBDfNpKhwBKngdkOEhjNyZ3CZnLIFL3e0sU9K1RljEaxoRkwzwM2rcG0aqjsAyDM11EOFZP5Gjv5x0yhKN3GR1t2YQSUbCD4yMNNCCjiFS4dHDNqLtBd9MU3cagzEz3ryUHNNZAsIWGa01j0zuVQ9wou9yjA5jiRbLNPctOK3fKy5BWwJ1md+s3BgeBPEKmohgArnDzRwIcA2aJ71wpjUAUXvwykg+SXFVKYZm7R0YC3lI3BQSIxckoJVyw5EhIhuPz7GDyySWjKG1uOqC0mcpCDpGkXhSj6SXoYtOVF+fENhg7WFCPKlU7YZpTjEY7TcW9KyT5Qij+ry98Fb/29eff9bX5ls2Ev/qzn0SpFbdMkkw8eYy1gr919aV3+luGdJcB9GK/lB7j2qn9VubPGgwg1czcKJQ6IX0cbnsRvqH0mcKyOPKsUS+8e5ZP/5A6d8YdyZLa71SXYMxOOQyDQGPyzVVRZ3XAsq3H7f4Z82y2vUhHl45pDzGOcXvN3/tXX8Frb97c2dU/qseFCxdwzz33nKoAOqmLv1b47EsD2FcMn5ZJ8IP8O7DuA7DWTT+pULzWqMC1bvraOV3rMRbopy1KT+rIn1RMX+vP11gKp+nW7zu3NVnAtZzvST4L+957bSzvMyL85je/+a4mPRwAgHf5+NwnL+GPPfYgzp8/t6oD9Vzf0vTjid5sGeoiyYQMiE1uAbzTWrV6IVLImR+ITjJTVKMoiOgf2okOmfYltJHQpPXmrPixzW4mZjlJLzbsxYvz9eLdu5YrD+9c1fX/tglzxgEilcDSAtqGUz2myYALd7ZGLmy5MOO4vCJDHnzVBXDSaNdj5y1rsRkcwdDLlBXfCM5gN3f42DRHN9f09WzGVtjoL/qu6TPYVIrPOQAlyXFSDtJobFY78JFdzDUc4kknP8/NeNLufRnGlJCjvEkFZiqOmUXgHe/BADODVrkrzHRmQZYLFKeNA6Sm8e7sVCZnnaSCStcjK72zNlK7M6M9JBMUxensAQ32RpNtRIxYgB3GdtHk78AJARETyv4ZyNGNiLQSnitYxpB9GYSYLVgwKnLh0wE/MsGcSvNA4fsUbIBOjSevgoghlIUHAI879hRIz2liUtTENAovldHtmAGxvEh5ooTG92d0JjwHMj3SWQTFSsa4L4pc4KtqMjUsKa2jJO8N+25pMZUUtplkI3YOBr4GSaivJ2SxYp4IDBCzlImLvjyX1oHRReyxAQyvqthur+Jv/KPfuC6xf5/75CV88uELuMXn2rFwaFDQZio99q80sEsEG4q3sm6/MQKaQV5Jsh0GW+ckOcmAVYBRHXxysBGJLRXrY8mSIx8n1bX8gHamFrzQ9zi//jNxxkdf3z0WMgBbk980hohiO6tL8gzEqg70B5tg3NH97V/+Iq5uD6aAN9vx4IMP4ty5czsLxJN04yfpyN/Nwnjsup/U8d/HHjiNz8B4HqMp4D6qd47uzWZzYyTgvmt6mtSFte99GobBWpE7dunXOvb7vtdJoMKapv80XfldTv+8zo/X9lro+mtyln3slZHxsCZrYPbF+DlPP/00vv/97x8AgPfq8dCFs/iLn34M956/HWfO3JoHpSBpms1UjGUBx9uZNhShU5zNrA6tMKiqC5211ogV42LP6L9s8rUoNikqSNj0S0NfvO2dQ+5uLA02NG/iKV6KHwZmSIC6xCm+jzTlmvKuyTyKjJukmLt577oDKZowzQ+CoeBCotEDWT9thfjGzLOwYhBCm+gAVRQgPT1TTlPagciCSTFOQqkT3osABgXg9Pji52KU0BTFODJHuAhnUz9QXAunT3iUWH5sOenCCkMDLri7y51OK9jGaL2cyIDBjbxteh2iWDMTRDiMT9aZ7QZY3FGNzbB0x35ZdKChXLxnyrQMjILkws+0alAiAbJHA4MPrslmdk2PJdSac9sDsjMwo58/gSbZh0Ty9bfnqXcFN6W4TwSDVS6/6c9XQcTTjQvc2OGGd8jV5ztm3zDI1LqQUUn754M105LM+Eba/y70PSRUObKvPT7EKrHOJzIIwB3cBGx0s0aF6ecHaUtnMHEiRenXkT0c7DpUjUKykGu+9Ag2oYSB8G8QilIMIzoftw5aivtzVGLFKE1b5jlQejpJ2tATZsnMH1XxsQsHrjt4MZgYIsmTKCmmVvzd//eL1yX27wP3nsd/8Ec+iDNaF0kW7J1SpsZOk55jLf15mMwIUCafq0oHB8TiViuxz2hDa/Ge1uGXEcREhaBkIFg7eNNlfZtSUlJG+DPEes5UfwYP2jwc5o3anfxb5DC5WmswVOA+AlE0zQzkasgSa/IKYRfddn5ffPq7+JdffvZQMd9kx/vf/36cOXNmZ9F+Urd1F9X7NF3TtcL9JCPAXQkA74Q5wF3yXZ4DJ/3+vgJwjUkwrm/79PVr2vPxfcdCdNTzj99xX/G/dm9GJsFaV3uUA+y697s8BhhoWHPm3xUZ+YMyHE7byd83lk8DtKz9/Gb2AbgpAACgxQL+0Q/dh3vPn8UtZ84Mvd5wGnfNXmm5OqHZJb8ARFehUser5beX6EQ6dbySIzM52pMrs23Aps5CsKJBqWqKTTIblGk24ZPQD6YJTZg233WKnTq/mSYvxg14KFMZJldJm08DMMzx2HSnXIR7F5o2YkxwGJ262YlKOk1yqYWiMlfbeWa6dgAnTJcFdXWscLL7M3G0CoMg9ASMGeO2MTNvA/sdjsbjSTGuf+hJhaLTKmVOm5FUdDEzg0BVQg9MXSs2c5ROqRaPPaSJk6isAgzsid7p9kIenmCgDDLRtBBFmKZupm2KR9aLrCyM7qrvM46ssycUlFke14alF9yNW2xkrBvM1GsC0JRouNyTLOzGL2X53hSzZh16YwbXMQWE5gBZsELUWT7TAMpZkd6kJKX7jbTvM8+aHezTBgIJPIlowOguJjp+AXTuxoI+KHqxWqSldHRQy2QQISkgwEZjPnSX/55aoETbj2uH9F1jPjMTww76EZuDJ/KQP/DszuZrBsoEY0YGKU1aD7DuxGxFmiCnB4gzCNjZmhImhH0tJM2DlqAyV/J9MU+XyiAflsAlM7UoltSBGAdW2933eFBdLvL23tt5iy987Vn8n7/5rXd9Lb7r7Bn8wp/4GKaqKGKgIryotXliKsW7/qWEw/9mmnyNaMZ/sWH2jaSE1l+VvUbgch72b7BIRmbzmKxoZOCYZ4AOWLXwfRWgznO/f9UNVcPYL6QtWmf3CADJnGoNUJ1TLFpqQQemamMKKIC5y5wgOUbVpD8G3gPAr3zpaXz5mZcPVfNNctxyyy344Ac/+I6o86ftrJ729/fF/40F8kksg7EZw0X0LiM7/vlJ0YNr7vUnAQ/7QO19JoL7WBm7uuq7QI5dn71mKLg0aNadkYS7DPTG+7Wrs76rQN83ztjf4CRTx33d/n0/P60UY9/nrt0TAHjjjTfw7LM3J6B60wAAR1PBX/3Zx1EmwQMXznftfNA8N1OOj4qHHZ0aO/uAMr1u26T2zUXKc152LEuJfXQdOlfpgfXtRPUNi9aBnmMAgQJFdOheUze+/2AqpMc2d3dk4zKRTBHlbixHsHGsWEYWJXVQSvcIUDdGpLz4FcfX0VWetZpCOsqR7s9dci7azJ+BiwrvyqlimqwrWMiwLHLGVYGjTXgFxPVnI62gaJcS96kMkV/JLd8KsCKASjI7K2TiZMUeU39bBBqIkkpU6aH77e7zU3Q/Z/IyYMCgrDjLKxknguPtRDHP7BqLVEg5e0Tg2uNKjb3NVLCtNRsTakhFlFkHaWgHu0J8LIozU9QlDOjnN8S36cAWGLruYKCPJQPIz0Bk2dcUucdad0WLFXWH/96dtHhHlh3YV0055UQddwkIloVqTai+LujOwcaJ7n5hnw4qtoJBo+4pweAHAwTOQLJnvnDnZK0IR3qOzUhvBChs/gtfkfAA2JRBpoTBi4GjAYnRsK0RwUnGHG0OgCxSFRLo18eIrRWjF0gDKCOmkBMd0nzhEphKkoDMNjFAlalPQsZ+QKFkmUilMWCJ576ISYwoSns9MziCidGL3S6x2m63eP7ya/jFf/sNPHsdYv9++hMP4/GH78aR8FydWTFzbd/raBOd/mkqPe6vAQFVgc1m6s99SQOtmUJ2GmkfJ5Z40GQA6kAkEABN82ohudlgBmgXz9erPtcVYpnx2jbXbS/ka8SFdrNbEEPJqf+oDn67ILBqjxCsqLN6SoX2yMG55u6/z6GCgaGXvW1+8QvfwLOvvHGonm+C49y5c24AuCuGb5cZ3T5H9V2gwGk6/fvAh30d2V0d/JPkDPvo4GsxgLs8EE6TVz+ybJMnDU6vJV8r2vcBL9ei7T8BiKlyAAAgAElEQVTt63elDuiK6fRaQb0rQWLtPowGgmtMiZM6/muMln1F/777OLISdqVQ7AMxjo+P8a1vfeumnFduGgAAaLGAf/LjD2MqBffeeQfKNEU3PxVqldb74qY7bpSkQaVOiKAX2Bq6bNf3aqJB2+ahGB3bss/p86gt6R35WjWkBu1du2lYqxDNAMm8CkRypzF1N3vUUVAU279P09Tzi7kLGg7Y3Om2z+KIIqGyiovuQh15TwsYIr7GSW+hg6+6GJBm2lW19k09FxSdYmvbXypuKxr7wTf2nfnB5Z8lDlghUji4vZvZpQ0/mcLZNXRzQDJ1rGS+aK/nGEdZnSw1Fe21d8onctQvwrKMQeqiAjYrH2MbK4EgY+71VGShn1YdN8h8P7NW3HLLufgWiSqY4yFZmsCyGwcFiOLKoBSzUzyWjjLllXwaVheWFQ8K7yBTQgObs7F0Ik+aVsBmg8XKJpMazuOFEjlgMZtEm2BdPYZEAk6siGuR9e0LUz5UmKIlGfEJujt+dDWzeaSEqRylFwTTpNPoRfzvMX5yIZSYVVSkYoBf7DyqBoBhz99M4MsINiglkJgHSopVxCBvQe6KsLGjUGJLJA1EvW7XfPQ/ADJjpn1fcabFWqGupEmfqPPPRrLJsoRYM5VMIiulWIBlXgQW6gp76PmXX8MTz76Ef/67737s3+Pvuwc//fGHcUbU5yJrQBmwDlHv/psEoJTibv8mBZC+VoV8KFgZutDrZ3PMxt4CtrM6I4zZeSyrYKmTA14wc0EB40allCTxqXPtfgBhGmhsBqiG54aqNxOcwaeKuTNG6lyxrQgWmTGm0ADP2j0DCoBtN+xN3iCD3M6+59/91a9cl3SHw/HDPe6//36cP39+bxF4UkG1ryO6q+N+mqJ1V5d7DQzglIx9vgVrBdqoxx8L8l2d+n1UfF3seXRvwTrGDe5jD+yLEdx1305b8O8CVfaBN/s672t6/fF9doEa+14/FuBrQM14nmsyhrX/PikCc62rf1q5wHg89dRTePvttw8AwHv52EwFf/3nHvdF/IEL53t0kG0WW9Fgmyw2fxqLhNxZhvsAKJYxZLYR2/Zurg7u2kaD3c61FQNcpA4Flxt8CadmKW2qQ/O76bnI21o7TT46S951N7o/RVNZ16s9vOH67lFvA51c2JYaQ0Y5QI702ShtEUGHdQ+AiqzhXqC4Q6vdKOUusUBkIzPTgOnVfi69o5OAAVUg0evZIKxTVztTBJwh32n87GOgCbwRKtqt+AudsTNCSDICLpAR8gnuDGpyFNwxidP7cDxmTIzhuVC8w9gBDJSumQ7Wimn6my9G6RGTSMV0ZFgDZejQFwkHfGOsbM3oTkgjTgAPx/SlLi7JDFjvreQBkNe4uOYLhJ/8OYJFsZ7cYA70dn3DhGsEwbor/GzFGhnL9Wu67YkFZQqzt4jGDFaGswDIl6HSOCWMPHtkUOc9vB3Qo/2qAzOeRihD1KHft2DQpALaYgYJzOIx4EAFfZ6srDqjCWjtxoUmRWh+EhFd6HNMn8vMH2Q2ELdkOYhQdB6zLXJCTAAjQKbaC7MzOqDXzsvGlKVF9GI+G134DbIUD5e0+OcHAJdBMYTUhFhB9uzO8zKCy9gESow0njqlF/9znfH3//UTeOWNd3dDc9fZM/grf/yjuAVjBG+AU9v+TNxy1A3/IJAydSbAFLGvZerAjizmWHbpz2skErPFE2p4PTfwxjX9sljPzftiS6a5pQimMiXAp1H05w66VzJUbb+33c4hFepfw5IBwnuiht6/n/jxXN07wNYljyPt88Jx1UghgXn/kL8DAR3/wz/73UMFfYMfly5dwu23336qAvG0uv7TdNRP+ozTFs1jETm+ngu/mdi4I0ixi7Wwq/gfi/aTEg92MSiWvlvr12QsWPe9/lrYFmud9X3F8D79/2nvq53/mmfAWnF/kiHgPg+K0zj/7zJ/PA31/7Rg1q7jpZdeuil9AG4qAAAAPvzAnfgzP/EB717ff+F8GLRBXa/Niu1C0WHsRO+bxFqTVtVMnApFbilFzgk5L1tigA5J9CI0OfSdzEyxgUE3zZvWZOo2OMEDOQLRO8M1XOaFCh3Oto6c8vb+m03xTUR16nBZbPrtd7nTNVGXOD3sluluGzasTA5uDBaURxFp15xkFNb5t2sx9SIQktMA6grd2kpWPk/foqZua4AVTl9nAINAEe6+NpmEutGcXZNw9hZwDLx3WZ2foqnTO2aLCxlF+jWjIpzp2lZQTkVwdducqpkVYsZT0g3OzLF9dip2dGjnuTEoplJSUdPcvGtsqJ2KnDuRxlhhvwBVksL4eM9jmMdWkYx9+LMwGJ/pIOBlIGSX9s3o61UJPCIvBnu+vfNGemyTXzDQUUq4uVcFNlN0cpnVot1UTkp7T0t23G6rf6YLhxKbInsH8LPJfgfxb5qMO1k/7QwBMozzRV2Xmvlxwfci25vW4mwpHi92k/1ZrgG0gQwot7VFagrU6dwcA8lSgkq6aM5sZwCMdf2zcnQeGTUO0geWTHGxaeauXmj1HzioNoCkpvvP7AVNiR32DIhkqVEUnEhsF94QF9efxeymALGP2r+98NJrmHXGb33ru/j8V59719fen/vx9+GTD96FCRiSXvKGQ0pp88jUgMTN5ghlKnGNRLCZNouEA09kGCQ8Bhqpz78Y2EvMF4s5kuMBFXCAxsAtkQEM78Bxera0FSzLrmfF8Vy79KdFMSoE0lNUTOevCmy3czJIVJqTzftjtufQUmg6E2AV9GRwXYHf+Mbz+K1vvXioom/Q4+joCB/4wAeuqSt8LUX/aY+TTAT3ZdavderHrv5JdPyTOu5r53ia4yRd+q7POE0BfK2AzT69/b5zGl+/C5BYAwdOivfbBy7sYhfs8j3YxQxZGxv72BLXamT5gx5XrlzBc889d9PNLTcdAAAAn7h0N372xx7xr/jA3c0ToDlvw53HbaNaE5JeBjd48UIw3JPVTZukb7Rmjczf2HiE87PF8c0aGdgtuo3ytjmBwKQAaFTqAvHuX2Tbl1U9c1CFQbFbSl3DpUGIRZtpzx1PJmjeRaXuIwESbD5Ya01+AcrgBUUcZlO1XNwXaRva2QtCiqwjfbVQh7NIFJFRrHf6/srEYp3d1mlsdNFJLHauRuQfMTrmSudTIks+TE7CiV9WvCDMJM5c+rXrYMvgzcBUdc6yH/PfY0NN7BANenlMuAZorAA2lBzgMWopBkscyNgbO0f32LqVSqaI7NIe5x4RdWaeJoPrexRZEhFwBL6MRm+eK17MZNLYBIiYNc3mnPZMKz1EzACwJIrmP1BzkUsyAdbbC5C0+2rVbi/6piKUAkJd0kFGYbF0yWGe5DiF0hw4jpBjInUwXzRASjvQYzIFkzbYnszuB4hmbrFk/HxbUoUmE8U60jAWySSj4SS7o7PcxU30LLI1uU2y5CSYOWzeGOdq3yl3S3lDYvPp1I1Xq1pag3gkpIGN9kz4XNrd5TnmcltnAiCz0agix3By91mo6OSISaPRjykwq1FYxEh5/qXvYVtnfOHrL+DffvM77/qa+2OPXMTnPnEJZ0STSeuCpbexaD/BNE2dodf+3mI/0Sn0Jc2p0zQ1qr2CinwC62pduPTH86RLZtRw/8sQaVlR3cMlxrixe4TiMWufy7X/e/NQcUe+Pre39TxAN+njqjr7rLMG5h5RWcNk0v0EAN/DzB0UGKUQIzCt3Vfmn/72U/jGC68equkb8Lhw4QLuvffeEwv6k4r20xjgcaG2K0pvX7d6jaq/rzjb1VnfBxyMHfeTCuPTFIK7QIt9nel9FPR9Pz9NATte3zUfgX3F8xogs9bF36WFP8k3YpqmVeBkDUxYAxxOG324j/Ww65x5XPDYXZOA7BvP4zX46le/egAAbpTjxx65iM998lJDUKcJ910455uFgiU1Rh0NjM3TNDU9rBl3gQZG7SBApumGNtg2BJYlXpKhWy+aSR/LnV7X6pdcDBh7ofTCzA2WTItdg3q/7RGGgqwf964hFdPW7VSPtOKCnCL9OkOA8+MlMSEqNmUaaNM1NmXkgM+0aqN68nmatnlKLuOSovFgWcoIoyerBLyrTfRdLqBMF2rF3xgnFZNAWTwi4b2Q/QB4s5kZFxzLRgBEfwLNT4JpmzPp7F37S0WNMSrc+4H0wXbuZioIB3DannQmSrmdW7jmR/uoDCZ/vMFmWUqh4jHi9rI3hV2o/nTE/RuK/+bBMRbEwYYxSYcbAyY3+Sx3MAYCg0rgnHDtTveka7eOPIbc8Cjko0gwyrj0JAwrtAv5J9DQ8x352H10YI7AEJBOnLu9nHfOVHynOgMO9vl17cU+kAEYKxyZ5cAg01zDvJC9CDBKjSCLqLcxUjLREK24JjNMYAkQOXMDIWfSRklK83UpEdvKK5sBjx7Vl+LwJMc/+vhUcv+XSIzRAE5Cy8heEREsKEUwSUR32v2cpjLMLSxNy3KgBgw2wKFqzPHGbDPZSCE/CJMZlWHsPv/ya9jOM3732y/hV7/y7rsZ33v+NvzHn/0IbmFpEhnX2n23aL9SCo6OovAHBEdHm87qaB32abNJbCAbw0JxvfOs/TrBDTjHDRwbvE5TW/tnzcWy+X8wg8fmSwqucTBm06UK7OsCGlcGpNuY1BQDrKh1brGfdXZAp87Nw8TiROcasYACxfGsfl1VFVsD1RwQC3BMyBNACEz+h5//Gl56/a1DRX2DHQ899BDOnTt3IlX/JJrzrlz2cS+8rwO/6zPWaPq7AIh9Rfualn2UCjBIsabp36WJN7bUaOx32tjCk8CPfd3yXZ3ykzr/u86N792+ZIe1v6/FFe4z8VuLGDwJ+FjT3u8yHlwDdPbJDfaZXO57n7Xxuo/hMX7uzegDcNMCAAYC/MyPXepd4QkPXDyfjJE4N5xvtFGks4FdaPYruQjb7xnDwFyJza3XNmhMA40OrIZrvZRh8xzZ7lGMh574eG7vt7rBLiVRqM2ozLKwi7QNpNFux01p7RRZTQ8BUvGJle7Z1L0GnMLes8uZ8WD0TO9ad6DDctGV2Av80NrPGk0dnrEdEgekTZ99J8+jj/oLQ0pXUO+7o7ubsnm0Vu6oRPd56DD1glvZ14BAhNb558kn5Cfq7uxhTmbRVXZfRpd783EYTRbdGZ5AAwYk2sZ0zKZnY4Iwg1RitHDXjLutuVCGb7Cn0t2+JUeWFUR0npLunS34Zi/aNOVxy5CuEa7+JKHgsVw1b+TtfYLi4EBCYjn0c3FK+tyiu7L6I0cUCpZsFgO5bOynLmUJWQwzajiS0GnGSUdJXW02N6RkEFAMouniK0mBwoMkzOpmulbsLeByGCqkzNUc1KmGJygoddqFpB/jZgk7qY3eiadUFBhzgaRBafwQcpOBhDEJRXO0IEmnWNY1Ffj3bOarPY9eemqMhJFkhWCi567WnjKC0H3b/Gh589XlS7LwRTDfGVVJOnfvzrk5oqbJSQaPkFdevYLvb7f47SdfxL954vnrss7ee/42/KXPPIYC9etTWVpio6e7/k8ircCf2vq12WwgaJIA7UA4pMCh1xRxG+yRwcJ2EVVqT0OsZfaaYGzxcyEEOm0mcUmBAzwaiTsG6isCNGqpLnNn1BSKA1Rno9nnNVZAYwUZYM+Svkb9r24o3MZ8e+DmmQwBO8BkMYJLv0xNDJj/6Ze+iOO5HqrqG+j4yEc+srMQOk13e5db+65O/Ri3t6tIWgMX1sCENRPAk1gHJ5kJntRh3wWC7CoOTyr4d12nNZbAO70n+4CFfUyEXcDFWNjvYmycliWyj4a/j01yWuf/fefyTnX+I/Ayjr9rOV5++WW8/PLNFa16UwMAAPCpDz+An3r0fgiafu+Bi+fT13dHfowFZDiKO+W1hJGcSFlFvmLzm7OiQcZ/Tu0kiruZ/ggV6hYvH+7Dmgp67pBGZ5ScgXXI59bc4beNmoMSEKKl5vi0QFSHfGkvOItn2x+VqRcg4bdgHUOLmJu7S/OoU/VuRiVKt+QEby9iLBWhrNF6hZzFCxRtw2WbbadUD4sTRxQ6OOMRbtHBLfsiV6RtZo0+bLR/LqRluP/53Nm/PBICwO7jEqkNOnRQWdqSJR9WeBZywEdKJrAbyx1MA7tq6mAPcgRBArWykyscAKlpUxDnsL7I6YJuz1KcrMPORnw2rZkx59SNI3M3G67hT6Z0g7O4MWRsTBZmmkCdMVAGY1DvRFsCBY85scUxNumVDRqJTu+pB5Jz4JNpZaddT6UkrxAbN9W9ITSZB5oERhLoRBnjlPnRrkXPKq/83EnqfrLhXhkkHkqeKuM8BZKAZJ9Q9jqoSYvvzurI44/nUh/jg88IG9Sx9Kn2v1vxbp8d7BdigsDi/yY3gh0BRi/O6d5Jfz5YlmMopJQcOYmBvTVeFyUZWPt+bR579XtX8Prbx/idp65f8W8AwC985rE+npDYJ1UNxBAc3VKw6VF/gEkACoBWTJepQEr3AnB2F0d9UtFPc+X47GraDMYzydd6BAN5TV5uTKkootSeiFjN+wit1ZMYrKjfbreo6jCqJ2q4/MMi/og1ojVeI+hsgo5Sa+0eANAOqLb1yUwFQb4SIMDvy89exq986ZlDVX2DHGfPnsUjjzyyszi8Fp3zLsr3Ltr6Pg3+rvi+fQX0tcYK7mMv7AKO9xW411qkX+vvnAa0OE1Bf1Khv++e7Cuy93kG7LqGa4kHY0G9r4Bfux+7DP12RQruuranBU5O+qzT3qMrV67gmWdurrnzpgcAAOCnHr0fn37sgdZtKBPuv/u8d8E4D501+BbHFznYZOyEDgBobNaYQt/eu3pqAG/wNt1J+Lg7nZr21jaaEKKzkqnPSN1h7ac5sweVGcmEj3XNtfNnTY8uYP16VOCKcKbmiDxNGsxciMlg4mWfLaRjLQQgTKTPXmh0dkS6jV4BSiVKpYIHyA3AIpI3d4huv8ediaDOmtgHhYyhWJvrgIt18Qb5BheSrDldZM6PhoBkRAZkc0YjPUxUeOvwMLN/gOWouzGdcgZ7FE1sVtjGxsAMGBgNoPtaybDMUxawpJSN0Yccf2fO3YU6v5IK/MwiGfXNzbyT/Bdok1/GgpnApDVtmnXaC8UQ5oUPKwCbJLdxo//bHLIx0K22osbN+MTSOPrzQiCUVTwzdYlLojRnACe65Ux/7tdlrkNnmAALkxxIpDBUYpEIxnsyPoMypC5kuQQX2lawM3Dk46OnldTKdNIo/FiGlH0VbK6I+EbrjvPc5yCIjorw2MiYZt9c/K2rW4oMGxj6d0o5mSkuNj56QPhcbRAd54jVtMI3TA9T0oaEtAxDHCASgCd4/fUreO3tYwDA//hLX2wd5ut03Hf+NvzlTz+W5rVpklS0bybBpjv9iwjK1Fz+y1QwSfuzLX+Tr4uctmCssdq9U0qJf09sNwdaQtNv67mCU2lyskfImWgt0YgQToCgSBsiIjiaYj037xgz+DVJlY1xkwBWMgDUHg/oDJb+PNZq8YEmSwopCXdKq6LPEYoZox+AJkaMjc3Pf+05/Ls/+O6hur4BjosXL+Kee+7ZWyid5r/LGGkNXLOB3i799UjTX2MS7CqoTwMKnCamb60zv4uKfhra/mnlAacFP64FNDgNWHAaE7zTfPa1yEb2gQNrRfboMbYPWFn7nNOAGrtYBvvu02kjK9fO44knnjgAADfi8e89ej8+9dgDUA1PgDRQtS4HS1QTqbvKDuQYNrNu3IfoYIBdqoFFvrpviGt0hxjFB3W3kmZ1OFfXfveNOdOurZtkqQKqFIE1FNRKkoSZup45Nk2THjPTyQGgZNd+bcUOt/eUKJ1R3Pm38T6ssRSmoWOqYMdnpA4wu24ze4ET1kcHdb7XkdudHeib4aNmUzsAUHEZhGtCwRTmAiSqcUTXcZa7DHFptnGT1KIvA+NkdL8XLjGGXmoYx0GoB9kNqAqZG2JwN58KpQcoG89Z7nbf/Pa0APtkVS5wkKLXmjxmdimE9PFpYFQsxOPiBZLiaCpS/RHtTJ1dOcVc4Jsxoz1rzD5w88ohds+jL4lWYNdHNQznLEljrv254sWKkwrI96Eqm4Dm6DMDadwrQ7Mho/+3ZMZGqkMpapHN9oSYJdYZt3OdCsUkslljL0Amuk9cxNvnWaxfpu6rM5qcij3EjdrNKpLBTWZ+MHjjT4mwSaO6pKbwNUekHxjQaeO1JjPH+J7hJRD+FzYEps6eGllkDpR63meMzXGjY9GfVTM1aGTcQFkSEsyL7712BVeu/nCKfwcAPvMRmn/Qi3Q4G2qamvZ/6gyAaZr6I1OclbaZNu7VMBt7jMZwi8rLa+nsCT107WgiSBs6yLDjCWmSFFlNZanjOiFwZo4Iujlh0/Pbm1vqD2rIl9rval8nao7lpUKoPc8BDjT5Ce87GpCgSoakAhx34GxmS1JlT5qSTC7/2e8+hW9+53uHCvs9fpj+/510i0cTvd3r4Okd03cxCE4CJ3YVWCaTWXOuzyxaTTIBWZG+jt3q5PG14h0wnsNakboPXOFz20ef31fQntSZX7tea6/n898HpqyZ/O0DMdbuCb+W78Xa+fHvjd4MpzEB3Ac+rIE+a9dqPNfTSEd2fea3v/1tfP/73z8AADfi8Sc+9hB+4v33QgS4fbPBhbvOZa00O4nTxpPjtyRlnYvT3PNGbexAxsbVCniOdKq9kC1BEByi+5o5kkdtVXVKbxno2K5x5MSAZS/KNxVWNm2moYPKBR5pwlln7RRKFw5rpzliQVe1D7MCYjPl7iIPSevgFSo4QN24lq/ONPWs+97wtUo0fzMLlKXpWv/5NGSezpQI0PbucY1ZM6qkpfaOXnfWV+/qmZO4eoHORV5eEHLOtYEDdk2wkEbEE82eD8bgsM5ymgD7e/dkwtyBJ/aIxWNZoc6RfuN3WDqdE5iWAIrlUWQYmwqKNexU2ULFOjlzm8O8s1WSaj0mdOvCleFczaOjGQc2AzxLq4jYxUwhZrZFYtloBlBYrSxcnRCDYpSweOGTjOxKluJUSg3poIunG/S4scZC0pTEwJnlU+HI0awP5cQRLsJXjajoYWCd/aZLEuZ5YO5QkQ3UHvNJwOiQhsAbuQDZ8jUrJI8J1Uy76gZeJHNLMxgkXwT2h6mUzKFpUzAYGiLVWlSYCgEE4vekdHA14v7yfc0bJ2ZFBZtHWaOlwcB57fVG+weA//lffAlvHc/XfV297/xt+Cuf/Uj20unD5mgSHG2mZtZHAIBI0P2bIWsJWcwca6oxKQwQFLpezPACMng7rueyY1NnCT6m7/fxQyC3g7HEBmEjz2kqPkfUWrGtFSWxn7TJAkiWM0nBts+ntVb3AGBWikl/ajcA3M52DdSlFTY25j5Ij52JSGwAyVGi9n3+3r96Aq+9efVQZb+Hj49+9KPvqPgfi7ddDII1A72TiqK1jv8IOKwV8cxCGE0DT3LS38Uw2KfnHl9/kqv/tXTuT8MmeCed+X3AyRp4MV6Lk9gCp2EQjB31schfAwDW2JRj8X/Std03Hk8Cl9bOYRfgtXatx9ftAhpeffVVfOc737lp5pcfKQBARPBf//yP+4bg/K1HOH/+XHQUq6YNDBtEmS6fuwxrBmz8e0ExB9H8NG0MvcBdaGiXnYuWYR30VksaWnSvKXqQqX/WMawaGlfr3KZ8+bEYJYDB/AFCA2uFKPsiREHNexB/yKgTo4M2uXQvASEHbk5aENLEJ+1w7x4bDXqmWKg0BgobQemieGguz8ULgrTBTECDeJHq+tGaqe7swNyc/cODwF7bJlymxYeFVWKepO6fJCG7a6CRDez4u3HSQ2ijc8zegqqPMFGslaPW8iaYwRIgU5ELsllX6QAIR8nRMpcW66knSqDHXRkrxZ3vqTAr7EM3TGpWdHKCxNwpggaNTSXgCnW9urmyR2IGO+anxXchSTDmB41vYgrwfMFd+clAGHcEF3dHr96pWBohcjHsGmdomnMYHFLydoguKmmazTtA2Qw1+wOURUyR5mi1FQAKHK/YCxUMkZETe5NofjbzJoZZC1iMXQMcpymgS4+6JCkJF96yZ0MYBo415jACtdgE0o04DXSwikyEwMxCHWek6ExjvaxuJD3jPYOHb7/1Fl668uYPtfgfGQDuY0Fg0bQpONoUbDabJrWYml/C0WbjIId3rxAGmQK4fGUcW8x8Gq/DuJ4LRYNYp9/9JBiMJyCMPUJ4/TK2ATP4pmnjTJ/j7ez335JxHDTvWaQa1I4+JwnqPEMKsN3Wzkzq63EHDmrXgKkouv8k0KVDW9U+z3ZgwJJOWDqV3Tx8HP3tX/4Srm4PpoDvxePs2bO4dOnS3sJxVzdzLZd+Te9/mni00Thtl5v/vq41n9doArhWpO0qWPcV8WtgwfjafWDD2vleS7G+Tw6xr4u97xxOurbvREKwi0Wwzy/gpDjEUsqJ770v1nHXGF0znmSmwy6PifVEr9NLZnZd87fffhtPPvnkAQC4UY+jqeCv/dzj/t/nzxzh3Pk7FhrsGGRI7uDVnexzV40nGI7cy9zlXJDz5mLZxacIH6LIQ0YNbNDzx4g5K3SK5CK6FcI06VZG6mySLG4uVhHUZWMeuDEbwgQQZnq3OPdcJHHXkTOwpyJOBT+e54hs7Jum2Wn5ZeiUaPJEUNKUp3ujDODkCD8rtay77B1uj+mD65fDyE5ci9qKa7i22oyhrHCoZoJHhRQI8ACWGmuh+5S66FDXuNp7ej52IRduKtRsDE9kJumAQ1qAc5e2SI5SGyMMDdTwulZHnfTaRmT5s2zMNXYikLrBCewgincG5+KzWKtvQJ5RwWOhIIaAd+eR2Dprmx4HXMauhWuX7ZloyRogdg3HjjmzR4FSFKJhSsYgjzFUIg8eCzBAyZ9ilFuEe/zIvoi5hz0ARuYDF7l23TddB22FrckB5jnACqUIMzZyNB29sgEiBnmLs5njeyWjPB07E0pgSLxmKrKMGlzcS1KzN3IAACAASURBVHVDQI9dg3oU37bTrjcTbxZKYhZ48gNRyRWa4gR5rOaNDyipYS3acjC/9I3JW3jp9begqvg7v/LDK/4NAPhLn3nM42UZlDKA+9YzE6Zpg2mzwdGmU/2leAHeTG67bw75IcyqC3YQaOykaz1EvfImZ/RCifUcaY6bOmsLw7zBkhBWEtj9KjI1Hf52TgC1x+DWiLI0mUB8n+rmmBw37O9hYKWKmwUXackkbe3ohqd9Q7BV9odREF2JwLZ2Qb/49Ev4l7//LA7He++4ePEi7rvvvr26+DWa865icQQH9kXqnbao31d4rRXdawXrSAtfo4nvKsxPE7u39llrHe5d73HamLiT2AGn6fTvk1dcy+/vYmHsug9r+7TxdaMEQxYNgAzCTH1fsNaN33V/d0k1TvqOpwFWdl3TfQkZa6//+te/jnmeb4o55kcOADAQ4K//6cdd13vHLRvceee5RQyTF6fIncbsmi7J7Z47+EwzHPWFtjkqQukCGBz2V3S1iX5D+cJuJgUk2jIoro2p77Vy2aQpCs876Z1J4EZqiM26DBs9HdgH0LiG3BGv1CVnOiXHB4YeOzpzVRV17vRfaI8xlER7Zvf8oGsS6yLlpgvpn4fkhP6FjNrZjMGQgBPewNfB3G+tKBtD391MamhXLxz5R9oVZY5zZrXdzDAt1NRRm0pxo8KZNKhMlQ3GQkQUzlTQjQtoNLMlu9QP3fesZVi6cZsBZdWKDblxw+nbxZkrPL5F1Gm17JPgrBzb8Ooop5DknN+ua6a8VwfWymLToJoLVZfAYHBbGLwxMjtmiXh74oQVDsQySfR0ydr8Uc9faO6yAru65KQOsYV5QTWaPN9HYzVobQwaIQmDzwdFUlE6WBW6wWaZTFbSnuPjbUWRbNgpyD4F7PBvoEB0a4cNUW0eKu7PMOjkMUQ3ckFkcZI2H08lR6CO5oTmH7GZbC4pgx5fo5KUKDjZMNSJPDWAWY6i1GEs87Nnz+7bb72Fl157EwrgH3z+q7h85Yeb9X7f+dvwC5/9aNwbNoGE4Mg0/puCzdEGZ265pTEBSsFmM6U5k4FMVBsQERkaZrolJWeEzj6bcQqBQl0x38cPjU+6D5MUfx3bTqJ3/pMpYVvmunSodGlWG3fzdm6eIGbyZ4AvPWM2xue5hqShz3FzN/5jFt28rdDurxBJGs0nwKL9DAQwoKP2GFbJOZNpMvqVLz+DLz9z+VBxv8eOS5cu4Y477jjdRv4E6vKu4ngfS+A0jurXch673m+Xg/8aeLCrkL8WdsS+VIM15sAaa+Ck6/FOus27AICTXPFPo4/fVyDvukdr1P01wGSX/ICBplFWcJJr/764vtMYMO4b76f1P9hlIPn000/jypUrBwDgRj7OnjnCf/Ezn/QNxPkzR7jj3FnSBw9xJGyc5kZ0eXvvBn065LHTw1GrpsQBLuDZXGrNhG0mV2GqsDwJwLSxrA+285pYE4mlJpLerhcQsjDy8g03MResADZNqhf1sE10ZEI7QMFFcKGuDZAj1ez954GKTxdNsGZUguTSv6avdxMzz30u1E2EAwcc82ZNFKPFc/cUzhTZQeuiDmP1wmWInBvvPeCO12xAySoAi0H0yEozR6RxaN3EzRTMCaem9hvuoWQCl62wtpaLJGMCMLXcztPHOHXIcuEiMC9Ip8oC9N3suknK6Y5c+DBlZP12JTYEX1M3sSwYfh4wxMiOyRN+XiiCWYIF3X07V88QT6wOSJKUjNfG5BkpnQDBLKhu+hdsEfOcsMg06WyMIt0VnJ9PYjAxQMbF7NpKMJFUYgS3dAAJXC5RJAMeBJTa8xTjAYBwmgeBhH0TYAwmZl/ZpyvNh3b67PTOoFR21cgLv/tqINznDaConWkRZqjBpgC588+mWyd51QjqlbS5yfcoJEWtUN1MJeYTyR4ai+L/9bcAVfz9f/NVvPLGWz/0tfRekgB4Ma4tVjbmkBbzd+aWgqOjI2yONpjKhKPNJk00weaIv1tKDgPHVXOKRDKp9I/s99RkR5r9A/g2+vUXdUPBYKiEkV7M7Qigu/sYNMCmhgmsy3EYcKJUgLkm6YuxD+e59vU85IPzHDGDc61omLT2+UGJfdOf+V64zP39a9WBJcRJOMAv/ttv4tlX3jhU3e+RY7PZ4LHHHttZ+Kzta/YZoZ2k7z+NRntf0TRqwXf9zj4mw77POs257NLjn6aDvwvwOMk34CQH/Ws1Wtx3DU/zu+/ktftc+NfYHvsc/XcBRqM/wElsjWsxQNyn5T+JWcFAw65rMn72q6++iueee+4AANzoxx23HuE/+9wnfGG99/ztuPXWWwfjuNj02+ILKhwiiirHmym55fPPMuKm3vUQBL3f47z0NKYgmjLVWV7A1PGaw4xaZ3WSpJOMbqz6Jo6NvVh7OpVCdOplocdVQHETN10fddzFo46igKQLZIzIm7a1RUAVqUhdPNy0CRKJaELpmvWq62g2bwqjWG8dQ6OSCqTTVolVUCMtwgq3WqXHIEqi5NtW0WQP1l02o7cwKRv8Jly7Hd+yamiop6ngeDsnqrdvpmsU4qrALZuJZBVRmLNjvAxtXk5kwAi8INgIRbKDejV/DAXp8UMDbl2saWpykNnRmF78qaQIMNP4c0QmBsq0FRDmYTGT/4V3DUlnH0Up3NzRYrqMlg/lKMMa1HWW9AzRm37OiHHIciPVrMOc0+YOJMUJ5s44/nnjDzJ2TC4G+v+x9+a/ll3Xmdi397nvVb2a54FVRbI4iKQ4iLIlUXFseYjVbreDAGl3I3Di/JI00okbCOD/JUA7CTIAgZMgCdDooOG0Wx5kt9WSLVuUREriVCySVWSNrCrWQNZwz975Ye+19rf2Pefcc18VayDvAWyx3nt3OndP61vfYFkNKhcgLxFhBcl87zrEOTJM1eJaEiOk6JK/yYAh+48wg0i6tI7mnJqAkr9H8bLIwBYZmaICIazBmwVJUfNuqvQXxHqMl/VhGkJOOLGsLEcyHWgqTFlPTQIJFaSu6lAzQBxIX37zxg2cv/IxYgT+xfeP4f0L96YrsXfbGv6zrz9Z5DfV2BIwaTLx8A2S23/jsXHDBqysrBSHf/YMcRY44nkatKuUGR5gI1pmGoHYRFYix/4BNZBrOmAiP0FN6yq7adP4DA4ETKfKtdE5yWkdTP+PZAAsbEDZbzQxQ2IBMyNAgPg0n8QPIOri1ubUgIjE+okZUBBEnmUjZDUD5x3+17/4Ga4sTQHvi2vr1q2q/x8TNTemS8yFTpcee57jfV9B2FcMdxV5dZx1V5TgUKE9BmAYywwYC3D0ffaus/miHf/1FvB9jxvyUejq+M97D0Ou+V00/iEmwZiUiHngRNf4rQGG+nm9950eE33eF0P3I8aI69ev4/jx40sA4LPCBPgvfuWLevDavWUNGzZuUM0dm12JIVmpi0irS507V7mZ24Fsc7JDsNrUmr4I7oiRW7UxYiMqK6jjFdiJn7T+xWm7TJSJbwq1nsyp6g6wKYzzL5ndIJp5phor/dHokYazOesOI09qOcBNmkYPg5Eo+yEG7RqLZrrWFDEzgYu+EtPnjO5dpkvqSNKGq4CCR5ujoDyxEGrWpW7GMSp4IN3MmQVUAZQSz2gOq7C5z8Z7AQ7eFe1ywalqgnb5Dvk9iPk1p0HwkhH5xjFjgaQF9eHaO4+AQB1ZaEEpjIj6YBIkt7s6sCIfnEv8XjA+Fm0bjNmh1AYyLsSdXroXAuT5DL4J+NQSfVfMQKXT7xxmJDeuM8nAAh8sw3HoDkUIIVKnOf/bG0qGSSgpXeRo/ElQvT/ZELlro+uTt5IDeSzP566Ok/OzRXVtHsjO/zYIguabzuWyQXtHnw8FuGFDw9qAsUgbuAPvVBZU2Fcp2ULBBzX3K0Vn7f4fKiCX01AiIia+yd3qvH6xZ0lNPa+SUiL5CERiU1RfeXrfbYtTFy4DiKl7e+HeURIb7/D7f+8FiqqMM/M/xfwl0Nh7h5WVFaysTOD8BKsrDe2NRfqmBqBkvsljXUE33wF6GyM/mUNlznLUq3NW0iJaIlkTvWcPAMecF3jnM/MuPf7WrRaezwdg8DE9ZprXJnlDbZaYOcdJNyGJFjK7zrtk+Bfz/Q0hS5iE4RVKpGAKnU1AdEt7XCTzVCsTLPf9v/vjHy+r7/vgeuihh7Bjx47eIrJLUz2vi97XRR1Due6K4psHDvQVyF0gwhia/lChv0ihPRTFN+TqP/T4IRZCn7ncUAHepdnv+y7HAjhDfzv0GefJEEqs9fD76PIZ4EK8DyDokoAsAtT4KtlrKJpyHvgh/37rrbcwnU6XAMBn4dq5eQN+95ee1n/v2boJa2sbqQAkUyr6t3f1olaQ1kjO4kJj5QKJaeZWV2MPezEkB3Tu6vkOOo0pwDWzuORbM6rgKzMy7VQzLSZKZJa3xl20kPDnssVtdjaOSZYAI6conUbQUUo0/NK1daTf1WKY5RMAXB2LFkGu8+WkIx+9jQGNK91akSwkdkaHzqySaQT1FYh1gyvTs6OyKsR4SqUgdLgVrbeDM671zKJoGo9p25rDL0tC9D652c5pocWH3J1OzzENIRvbQbO2herMHVX5olqmuHMxzXp/152Jy6DRuQsfYc+urfC+MQu90HIbZyP75FAbQqJCSweNC6U6hUHuhRK9ReqB4pNQCvRoXON5KRTNv0Q4hmojDl3xR9SxDMRmQKWH17O2g6GccxqIM4U7dVSJ2cDmZG2I8D6aTj4DB4yYROqYS8EVsulhoUS73oNV2ejT83H0YEkgiRrVKIWOFFF1UcjjuZZcuUpmocUyrcG8flhTVe7uOk10KMaIZQ4A0Ri8pfSW4s1hYiwdZiRCM/eI/43yfaupZtaus5mmc7UXRDF7rBlLyQ0+4PTFK4gx3tPOP1+/+aWH8cyBnQp4lKjCYnI58WldmzTJCyBFA04wmTSJFeCc2WOFIeSyLCJ52bR21lYEjpnCQdMZYEwpFUgmFka652UdVSlALqobAyInrwmZl8y4YQDSueRdAzIFFmZW8h2JRQ6W2U3F9K+wg5IEIP0+eQZEw3oScKQlpl1L4GBLxb8jhpjjdSZGfO+t0/jbt88uK/B7fD388MPYtGnT3CKxq1gaMkYb0wGf1x2fR9seEydo9lRJ1xoAF+rnZ1bDWMnBGPBhLMtg0XvW1cEeU8xykTwEHsxjX4zp6s/r4I/p1tevX2v/+163a8z00fPHyim0lhkRMznGz4Gv06dP4+LFi0sA4LNy7di8Ab/7i0/rgWLPtk3YtLaWo6SC0ZanQ6Z1n2aqsXQ7pWiJ2ZF9kgtrq6G29GGgOAcbB08USmQxPEpd3pQVDaBKEDARWZV2VGj5BRCoD9dRO6FlMlkZhFCCG0LYtAOoZoCY6RaGUBy/xXFbaZJwpiBVqhii3lcBCoQmCUDp8oXWm+9Lfk0uiKQIUEq6E3279TVoiKY74yztHB04oe8rRMwAPTYNgcAAJ4Vp5QmgL+XUwGm2cKnNBnPxGlOmesiu8zx+OHlAMs5jLDGXUaPZnCluU9cqYpLj1ALiDBDFiQJBc7wjLly4jGu3bmFlMsG+XdsrgKYUU67q9LIrPDvTo4p9YyM6ockL9dzl/PkkpwiG/l1QdmtQKa+ZzB/TvE1a3OKBwAVzDYpooVl0JGZzCWYcwDBapI4R3bmATjPaZ2JYOGIisQFp7V9QmCyVIyUbFXYxUDj2ryMulPXESnduAzFcXJWKgpkOLbM3DBCK9P2xJ4iCkL4AbazhZwC1gFYU/6drgDP0bB7r7LofBUQDZqUKCgyUe2r8XmKkjnPxDVEghLTn6RdJGuRcVAkE32fu/McY8cc/ehdvnr50X+yfzxzaiX/w/MNG8jIT8ek8VhuPZpLu4cpkgsnKKpx3WGkmcHkfKAcz630SFJCJJZqPJVTiykffH6eeCBiq/hy0nzdNSWhJcoOyFyh7KRuFalxlBihWJo0C4ohACK1ZV8r6W9byNrSFcaUpH8WUdjoN8D6P/3yGUAlQlkWl95slAkn0r6y/ltgBIbMBBVhIsgY360ya38v/98N38daZj5aHwnt0ra2t4dFHH124wBxjjjav+113aft08XV3ta8jP1R0zdO6D/3dWBr/vM9+O0DIbRVecxgbXV3vRQrfIZZBV+d9HtA0FAs4ZC7ZNT6GTAqHfCvG3tMuwGLIe2DonvW9/uXLl3Hy5MklAPCZAgE2bcB//g3LBNi4cSMVKhHJbLfoh0tBbLO17cCKdAayha0OMjoEiLK3PoyykZW4VHPsoK8K4NK19jPxXxyLxjFdM7Ep7BquUWXFVZ/jq8oGEZVSHIM1T+OCOs50utJnm/ji9C+j1MYVAkK1b1WnXA6NhWbsFHzhrqivZQZ84IfterMkgSUY0vlJUgsqBlA8BFT7a3m/xhBQSrFGTL+EtUFUZtXBV8WmfK9eu9YFKGCqK8NHjY4RT6kM0XgJaFa841zsAvaE3ImKlPDgvWW4xBhx5eoVXLh6Xb+Pzaur2LNruwEvpBhqKYqP5wonW6QaqdBWa3lJYcFE1f3qPOBIOQKHQNRxAekimIZuP5dF5HOcoM9O3szuibbzy69RxnzUjrMUp44oy5zs4cngrKDatF7o/UqfKQYLVDhy74yEdNVdGHQoRFxtnJfjOUHjJ8aqSEfRy5vfw9QaJkJRPgvLNmKwNAqma3f5Kchcks5moNg1V8W9KaWfzESDRoBm8M2lhIq05hPLoUu2ESOxdXIqRS6+nDCphHWAWoohN8arFpwZXInl0uL0xSsAIv7VD47j+NnL983e2XiP3/+NF3SMe07FkW/JOfgmfb+NTxGAqyspEWCyMkHTNEZqpIa0BMy1uX0u35d2tgkcLzGB3kipZoHF7GtCPiuGXo061aRIA2R6+AxaiOkea8oSwJ7YZUWWE4pcjPC4CAeENq2FUcDbTPWPxXcoAQJFitK2kRgCch7JiQfEqgmImIoMILMKocBKnInM/d+/8zo+vHp9eSi8B9eePXuwd+/euZT6oWg/Xtf5d0Oa8CFPgD4a/5D+fGwRPdRxH4oCHDJ8WwRkmBcl2Hf/uwCY2/EAmFd0zpMY9D1+zN/0FdFDxXMtAaj9HJi1UI/R2kiw77v1JOGd52FRsyVqlklX4sEYBksf6PH6668/8HGASwCgug7t3Ix/+NIT+YDqsH/nVjRNo7Q5pnZrcQrrfh4qF26x4RNqfRQNcjY1Y9OvOqe6mAyCoqpKcVkXJqgPQPnw6zu0/55y39P7L128WqLAFNpONJUywgNlGXMH11dZ3bErs5kO+DVg0Wf+Z4AXKXBgncjrjjOipYrbRdrODi2iyABPDl7amYtxBmSoYw/1M1WRbvIeI7EHxLE/1MZN9WYEy/JAVZBLckQjBX+cdV8skpHqjRiQIVFidTHOwIM6uytjID3njRuf4MzFq/iLn53Exas38B995TEAwK7Na9i6dYt53QJewBy+YcAYGHlB6NgkinFYtE71sRjwsVGn6cZqR7BsFp7kJ6zZ54HF+4SaeVYeHApukeM/Mzc8fSad7k7YAyUizjiYExuCO4ul216Pl9I9D+RDwHOX1w7r1p8e0BDAKLGAmvxRrVciUwnki1Jo0Zbaz27v7KEgczowfbknEi8aH4DCoJDJF2K0lP56zpBBIx8aWHdfT0KW+jhiF4HMGaM53NTxmak+dM5lmZesIYXRJfNiemuKc5evIYSAv/zZ+/jxe+fvu73zP3zxUTx1YLsmkxRDVOh+OvHAZJKK/8Y3aBqPpknFfzOZ5Eg9Ziu5ThmIgGfZwU7XCJk/hqlDz8PxqLw/gfbZIv+h9TLKyxTGls80IyegTe7A63AVDwNl0gQDTIunDKXD5jlSvF3UZFd+HzL9PyZwIQanXgGJfVBkAC3tPUGKHTWHDagTMXhfef3URfybH7+3PBDeg+vhhx/G5s2be7ukXd33oaJ4XkE4Ty8vme519N7YqMB59PYhgKPrvCmgBr+/eQDC0L2Y14W/naJ+nhxjXhFeF8xDDvddRepQV7vvvc17jr4x1uVL0Xe/uhIs+r6nRe/fGKBjbBLE0HOcOHECV65cWQIAn7XroZ2b8dsvPZEO7I3Hvh1btFhz5CbcRsBj1oGeO96S2V0XbEF1sZm+V8UA+srgy3S8qi6ddIxZLCru5IKSxXrywtKYuXPfZIO0QJpG/ty1FIAp6eweLrTNprFBXAZ8IPphrHLeefJ5YzwI7XT6CrVjjbO6LcdKk2++nwoA0A5xikKUWC8p5EuhUQzPmGJaG7D1UrgoP56ZAPIZpm3pJsr3I5IHT5+tHpN8eOzb+EsR4lWz61y1MQcy2CJ2htwjpu5z3JUUmR+cv4TvvH4S3z+W9KTPHdmNX332MJxzWV6zyXQLZTx57zDxTQE/FHgr3dDYcfjxufvdBjERK/PHsgOoqAdnrYOi5mx3Qx3KndzXJIlQCQ6cjfoCm4yV070Y2hWDzwgbmNEl7eCccqeAgTAmEE3tAnTp/zvo932JHDLWBJCI5KguxXsZh7NAkDcbP2aM1iL5ciDazyrslRLJGWfAN2XizJhTggp/Vzm9hxKriEp6QeAFdxCYMcWAJT9vnUggAFKTTdxAhf4MIMOMmxhRG83XPgenL1xGjAF//upJvHLiw/ty33zm0C78/eeOGF29zJtI6TGrK5kF0Hg41yQNfeOxMlnBZNKkgtoLIO2UwRFyxGbxUCjSDZFMtCFLlSqPGgaiQpz1jJD4xaZQ2cy80sg8D/WL8ZnFUPZp8SmICppKAd/4wp7jfZAGXmFjReQOflRQUaJj07iKCuzKvYjB+uw4FzGdln2xzetpCBEtNxhiMRfl1KAlAHBvrq74vzGF4lDxOy//fOi/udNad3RrE9m+IrXWYHelK9UGg12u7ut199f5PSfSb+zzzfs+xgAfXV30sQ788153jNHfUFG+SDE9tlveVfDPu9f8d10pFvMMGof8KsawPOaNt8uXL+P9999fAgCfxevJAzvw9198RG/TgZ1bMZk09egvBWnW1sHVWenWxE3Nsag7zdFY0uFibbt2qDg72pWCk/N/9WDehdaS63SJpypd82JcaH0PIskPIhkHic6aD8ZT1eyWwsR3IbuGvs006cpACzBeC3r4ycCCdrkj4BsyHJOoNqKPSgcuhFJUlwluafDOO7RtnNE9c9Fd8uSp+HMuHSIdcHMaMKGOFuvMTWGBkhfvfDHIk0JJzO64iORCwjIw0JmwEPJhmK30xEgxUo40mwK62uSSutNF7mD9HADg1PlLuNVO8QffegW32kLRfe7IbvzKFw/De48j+3Zml/0yDhonDuzQMSQacaDkcM8CY9DyjudSpOirrnEXSarB5n2+imiz4Eo0rJdW6OR0c0z3HEwxn2WlBElB6IodlPnjMTP+GleKT11vpEogM9I6Q76mirKruhTPAsREYQSRbIfjCTn6zgAnee4Ii6UlkzUBcFgGYZIKSb6DDplSCLboN8wjOeCRKz9Ii10zmmR9deR7ojGqoCQGlSBJV94b4KumiQdiZDBzq/4urUSHDUWtO/vpC1cQQotv//QkXnnvw/t2z2y8w+//xpfKuIoFCJMiWMwgnU/a+aZpctc9GwF6j5WViTW8pO6+gE7iuVP0+N4A0l3gkOyN0nWvD6ECIpbdgIC8KmJX4v8a79FGIGZNf9B1Wca9rOFlTUcIiC4XOpCxJIaZQTv3jD7I2E7rRciSkmAkOOLXIeycto1omhQN2EZ5b1FlFNERW4FYazEuGQD36tq1axf2798/qsM8RktdJ7bUBdQY+voizIEhBkD9HF1AQB+1e2xBvh5vgHl/O4/1cMeKsQW/7/U8bpFEgrGd9C4pypAxZV8KRQ0WjQFJusZzV8xkH9ugy69gTEoFANy8eRPHjh1bAgCf1eux/dvxWy8+qhv+/p1b0Uy8PYzDduZLDrUtZm1mu6euRFVQdhwq+ZDLnfeuqCXUhbSb8fgxgAQbm5VcbmvCJwew0vm3nXB12ZfC2nRc6jzxrLNFcewvHTlKOshFh4IcxiiN6L5hDiJMBZBG/1UO4g5FSzpxvhT9OVeZv0PvrOGYRo7RgZ+L9zq+a4ZyHKGHRm5GymNFX1oM56quUqWvlvfQuCw3obETo91YlfEPG99Xkhzy4dpZnwRHn1EeI+//1PlLuDG9hf/pz36Kazdu2QO2c/hnv/FCXmwbHNq7g+QqbqYKLJFWMB1cu3Fkerkcanlx4++5ihCUgoXnKY+HYrZXHP09+3eAPByI9ROzoZiCaAAlWpQOoVD8pSs443xPYBGzGRTC03hQy0xnmUpd4JdYwgJYGYmCuc/cnbbmlAIcMqClJmj0ey68rNY4EkMARKkm7w6AzDGjzkMGKbRYlrQS8tsQjT3HZ7I/SymwLVjD87jbz6WKXu3SEVZsC2tsyOthKsw0gcORN0h+e6cvXEXbtvjrt07j+8fO3Pd75q8/dwQvHNpl1l1JuGiy/GXSeDTe5W6/S93/RlIBEiNgMplocsmEmFqatBNblaAwcBur76Sm/HcxYBxnmDr6Gfk9qMRG1hzv0eToXGEmWVNO5CI/2/BFRwaU0bACBdBggEwPZnm/CkrZj8rOEhp/zPuBjDth3UgqTpsZAiF/xja/60DvRdmAeZy+9sFF/PESALjr15EjR7Bt27ZBp/KhosZVkbh9xfS8jim/LrPtuiII66KtCwDoimIeMmNbpCifV+j3RdfN654Pvbd5TvJjqPh9BnRD9P4hivo8Q7uxIFJfBGEfg2BIBlAX+fN8KOR8VXsEDAFNXZ+BWStd82KIAdDFQOm7n++88w6uXbu2BAA+syDAvm34rZ87qtrMfTu2aBejPvw7Mj5qc6eKO3tdHXA98IXYqXuP1YGaHb3bUCFYVSQcO4FrVny0LAF5P9470/Uq0WulW1w6BVA3eNsJLjGFNQDhXG2o1FV0wBT/XMiUCLBsupS7H66SmM4QVwAAIABJREFUBviOWDx+j10bHsdPaVfQAUUl6WYyuuV9eu+LWSHKoT4d5r2NEauKTLu4MIhDT1bN0tpoLtZMCWAmscJ3+EVodwsliixmvbwwBfiQCtiOOz+H3P+rV67i4sc38H9/702cvvRx53ziyM2VyQQHd2+34JBQaSWPXdIdcrJAIMPJkryQD/9kOFkzIGY2fYqeVP8D7VIXbwktTsktnjX3PPfhLGOnXlmZJh9i+ozO2/EbSUMUzXdFG1QGZ+qxb9MmnEqQuEivs57V68BEZpaCQNax2s8iovgipM4ussN62egZROG1QwGDNprkFJumMMuWkAJ52sZsiGkp9tY8s/y3N4kKtsvPEYuxypkvoBsMc0BkLjWbQhIPIrN8jMEcZkzmYjZ8i5iVkJy5cAVtbPHdNx6M4h9IMoDffO6IKcBNooUDVrzH6kqSmfmmgc+gq3MOk8kEk6aBb5oMLpfcEE1FULAYBjCf6WBWqTgMdvV6Agj7K5DRryvzICWCOJMaIUW8MJHE76F4p8jBtq1GtUMIra5Rt6ZTZaIorKHGfq0mrEh0YATQTgOcR5EAxKh7doxAaIM+21SiV8mYMEgyhfoRFQ+AJQBwd6+mafDUU0/NLV6HOru1Q3/dVR0qXOdFoQ39zTwmQf26Y5z9xz5X170ZmxE/r6BfhFUwBgAY+m6HwIIhAGGsVKDLIb/r3/O8A7qet0QEzxb3Xc/dBwbVQMGYwn2eNKEGwsaAP2NBh0uXLuGDDz5YAgCf5eu5I7vxa88dzi7hDQ7s2ka0+TyYYzT6/rrILxMlmQkVt2vq1FWGZoGcvLlQFBok0xFLEWm14Oxiz2WodGKSTjL9bNrKxpHc0FulbkI7Ob5jggtQsOLFDbnW2ZOTs6uYCKDCwlUFsBac0tlzSisunaAq3YD+yzun4Mk0hJzHDGMOVQCRCixRl/oSOwhiNjDIwRF/MR+mIuIMjdXQtWMFDLBXRK46RQsq9NYQJZIKpM2eBVXqAt0RM8VTzr1QsMVsDtGYWCfvg8jdTFBxapeNa9c+xvkrn+Bf/eA43jk37E6+Z+safuff/wIQgS2rq9i1a5s+cVcKAJB04dM2lFelk73TWEKStNBgUECDojLl87bZkLOATqnbvDIhzW7NnIEbZJrU2kVPzBPnUmQfgxrGhI/etymCCfgwcYkk63G0ZpgDH3lNWLeB2U1NDBlTQRJK5zbEGZrwNKdCgCIq2W+B2UCRGBR9RqIccQjYeZqeE8Zwr4BWBIGQ8aqVxRSZCzuvC7NJk1ykw1utoxE1nZGNW1EMBclcRZJLxEOkBgDL/Q82zg7A6Yup8//j987jL3/24OgMRQYQQh0TWdallcwAaCbJCDC6tK/6JknsJpNJWrsnTZ47wuiJcN5n8zthnbSUJhIKuy7MelLo2KW9WNZx7tp7kiEZ0Dwb97LZZPpMWdKnxTfUfyDmjr6s75pgIo67sSQIhTboupDW56Bgk+yDMZLZoBhbxuR90jgUSRWAW9OgLADvE5uiBIBE3GpjlpTZ7zDEiNdPXcK3XlkCAHfz2rp1Kw4fPrzYAX6Aat1XLPYVT0OUfnZh73q9oY4qewH0xQYOAQF9Bf68KL1FrjsdCbjeyL4xmvp57I0xzIQ+o76u1x0jgVgkeWAIwOkbH4swIYYkA11GhWMYKX1Shk8++QTHjx9fAgCf9evZI7vwa88eSQcU32Dfzi3pMCCFQxftsNKqlq67yyZH0RSuTV0wulntL2rnfAfqVNAEA+cmsxY/ErUxmZjFfBiO2llghTvpA8nITwtvcraXrpbQGCNpqrVDJt2REFMHhw7a4gVQZ63Lv7w4kcfubHNHXQxr9lby4PXARwVVZwpBLrxTfnJ2tc76UZhiZraTWIpLMWpzqiGI1HGq/fhr3Tmq1IaucSLGY10eBUwxNYfaiBmdv11cMRMlqV3aPL4CIiQb48bNmzj30VX829c+wA+Onx01n9hjY9+2zdi4tjZ34yy56mWeSTpAKx11ouyrA3uICroF0l7XZnsFhAE9Pz1GDuoMkOR/tG1QZtA0u9171g/AOvqXOE8GGMjg0VlYy7AY6I3L0zsyKZW5KaZrbJYWmcHinJWICOtD/ASoGGLknqNBvaFmyxgvRozc1ZcIVS28ab2qXdvT+0+lUb2xO8pZbEMkhkSSF0h5Hcjd3alcyVVmaWVeFuq/0+/LGMYZZkYuQj0XiZVvRp2sEGeZWCmysLjBR0ScuXgVbWjx8jtn8VevnXrg9spvPP0QvvLoXiMdCbyfIYFuqysuxR56l5IA8v/GGLGyskIme6XgFg8+75ymSkQxqxBqPKw8i0F21xUpCbsesgTOZfmB7IsCvgqoNs0xUI23cjRhPsj4TwBg3lklqlOlAVHfO8ibQjQ7Mjda1fvHArLHkhSDKJGAhe3mad4J4Waan8+79N/qf0Gg2RunLuFf//jd5cHvLl6HDx/G9u3bR7vo9+Wtz66Vs93arr/pe506gm2og76IBn8eWHG7Rft6ivqhx8wrhPuAj7HPNc/ob16hvghr4XZ0/2PBia6ifEwSwFBU37zvYZaV5wdBhno+DI3vrjkGAMeOHcP16w9mZOoSAFjgeunJA/jaY/sBB6w0Dfbv2pYdf6kzTrE/4q7L+kHVmqrjPNSgjV32uesknTSNN+rolLOGuBgwWW216G27qV9BO1/1gh7JNU3pzrHobs2EyMXhTFpBx5ArxQs0ezuZfJVCV5gOOrFJ814kEsUlv8kRTpKJLkWQdCJLjFmRaGjR5Ip7N1OTS3c06oGUO78hRPP9cYe1UOzrAhydh1GTW23zA/XewDHd3xt2CGenWz2zZVuAouAcR+xB8s+9dnEB28VzxJ5o2xYfXPgI3339g4VpypoMAId9O7Zgw8YNFRhjmSdmbhCAo52wumB1VvjPUpdpW/TqKW+7OG0Xpgeo025ZB2ZjciU1gUd5ej0YXTo0eSBoyoLp6NM8lu+r7vwnXwxUpk4wnhi1/0gkrT2DY4ZJQAkPddEv95sBKuciOBYt5KJCvq+6o29MqXJRN83UZv15pGhLwMQpqodA/hngkjN79uVQ8owvKSsxzrIAImZBAFljHaWXsFlqpwFoLN4HssaAO96BbqYr8pIawHWELkjn/+V3zuI7r596IPfJR/Zuwz/6ymNaSAdOo8jf84bMAJDi3/nkC5KAtQl845M0QKQADDYjmshNBkw5KlT21sqjccYY06yPMSJGp94iYswKSsNQLT5HS2agMebu/4TWKemyawJABgfaNsX8NU3adzzvP7R+hRgRM1sI5GnRhpBZSlAWjow1YbuJMWBLQCMQMCVQgNcrGa5vLCUAd/364he/OJfCPaaA7ctw7yvy+5zPuwCA+nnqokg6/V2eAH2mf13/rtkCfSyAeQX3WLO7PgBjEcp+Xyd5HjNiqOM/7/X6jPX6vvshsKFLGtA17obMCPu697WEg+UpMo667olGMlcg1DzGRR+41SU9mAdIdbEk+e8+/PBDnDlz5oFcc5YAwILXVx/fj68/eSAXfB77d2yBb7xS85guXBtb1C3n2rzNdtdsASAu3yZOK9amXxFtSMVsQz93SvMjV3nE7HIPeHg6jJbiJyDRlWEjtWnw9C0u+We5MJLiuA2J4ugirKN8jkJUfwFns9KZ1sttOGYXSPnlXSroHBLlsbhPe81Q5px0pljXs6EUyMVx3fvSIQ+ZUtk09rthszh9LpGJzMgbamo9rHt1EAq3lQ6guieqiyWdcsj09sJAyRFpIaBpCpuBO6Muyybk3qnRH3c66b2fPHcRMbQzjv9jr68/eQBffWw/miZJa5qmQeNLF91Sv6LplhoPiky1lsdx15+7ct4AcGUURJSuuXTLa9p8vXJyKgd7AHgCrrS7OLPSzr6vGsgTEEPG2Yq3RncsJzJFu+j/aYPj+dQ0RRIQAptq1hte4d+wyzpcJSmgscmfxWz6WVrhnENDHiJl7FbpFMxKoEkiLA9NKTHfa5mXUY0/i0mkRMU5KdhmDBQtI4mjXS0zIcwYuYocqZ4fnsGWDAp7Mh0FMTjOXLyCNqSO8j//1isKUj1oV+M9/ttvPg/aOjI7K5sBwqV0FJ/WlaZpsLIyyeaZmUHlksN+0zTp5/l+Tnyj96gLTOY6X5IqohrpRXQs81lWJSCw18SYkndazScyKI1V4k8jwDPLAEP52wJQBOMN5LxDmLZln0A0saaOZX2Iic5Psro2kAFmtAa+MTMwQkzzQuZUG+wE4LVyCQDc3auL/r+IJnkRRsC8DPd5BdG8gnmouB0CAIbo10N/O+QdMFQMj7mni3T172hhNgIAGDNO5pkRjgEixkYR1oV1HePX9R5Y3z/vfgyBTl3fzTz6fxcAsAiLQq7r168/sDKAJQCwThDga48fgHPA6qTBvp1b0wGTqlV2phaqKHejLPU9dbD0MOmdlQNHKysoXbRoD67UpSxdQ9s1kAPazMLIDuoRnRGCBgWIqBzmo4mzkkN83UlvoxTlPtMaS1HBlMnSaRVqdClwGDyY5FjFNptpzRqJoKMTCeO2zsZr3PH2VIAY0CAXEmDAIsSZrmLTeO3GF503SS0iJR6YhcjeM/mhJgfUOe5wlebaHsZZrhFDJFd62Pg2/bKoNjYRerZgOvvhR7g+vYX/5ds/xdXrt9Y1l1YnDf6bbz6fDsxNgyN7d5a5Q8aMcn8dg1SuRDua7gF18uX7NfISilZURokvBpaI/PwwyQ0AyIW7INlqmJf9M6RAQIfJjTl3S9qD92YpLrTcit6BQu+VokgYMKJjRxf1E8weiAoE1YBi7YwfDL2uxNchm/ilJMBoojyjifIkyQ3JUqYhkPfGrAeCehs4YsJ0OQPyd0z0vxTPVthDAgrU32mjc8+yBJzQvQk8aSpHYWYf1QkINg2m+LU02TTUUdRkjBFnLl1FyHTyf/4nD27xL9cvPv0QvnZ0r5qK1rF2EQ4rjcPKik9Fd47UE5190/jECMgpAd7ZzBjf4WthQF1BmZXWLuCwOOpn4zwFS9OaMZk0eY667H1TZEVOqfzOuP9qfKDGlzr1K0lxgMEw1oprP5TiD5YghGCMOMU7JIRUtKuvQGSvk0gmk+l3bSRgLcYylmUfJkAtVOkJyxjAu3sdOnQI27dv7y18hnTmXdTmupCp3dD7nqN+/rrbWZsNDhVSYzvziwAMY9gRQ538RYu7ofc79v2t9zUXlQksAiwM/X6eKWCfmSAqkHPItLBvHA+N777PMQ/MqmUBNfjQBxT1gVld9+bYsWO4efPmEgD4vFy/9PRD+Lmj+7KpW4P9O7aUzg8Xv0QT9ZUxoCP9rBlQcnCs4lzUZK56XKgitmqHcgDZaZpQWFhNdzHeEp1zNI7nkg8fybCPC1Xrkl2K9IYp9PnQUTsyy42Sfak0YJLr8rTNB/CmFGeNx4zbtxzUJVrLe6LeVxb4Kcc5HcCZ2h8rAKUuoOQQycU7m8vNdBLBXWAyYczU6cbbxa02THPV4ilMkABL51Z3+AK96IGvMTraYGjcVgduv395Hw6mWQ5E4PLlq7h84wb+r+++hdOXbi8GZefmDfjdX3wazgMTP8GhfTvSmA5iQFny5znG0ecucjKigxnLkQ7EdQNfqN6s9Y3R2OlVHXUGhEBAxGxkond2YQ0xonG+cvovn4nHl3GBp+dQ7XAGzMRroBSaZaz5HONpx7EzUXxQLbMALAWU0Kg6khGh8opQvwsz9iJJIfLci44MGQv138Q7SiE3420QS6RiJMaFo+9estPz83vnswcIKMqtjGlhIwVzrz3YY8E56/wWea6QzjvSuhdmYoQys4qiCR3M05rDw9lLVzFtWzgA/+OfvYrrt9oHfn98aOcW/Kdff0Lp/7WkI0Zgw8RjZdKktdd5NJMmr8uJUTdpmuSF4X1mDBQQoPbwKEV0kexUeFaSrBjZXDGAdM5jQqanMjIg61+I9FnSPGyMGW9h3KnnRQZxBIAQNh+DmcJmkvcj40lB28xKiDkqEMQC0EI/lD03tNYANeTXn4ZIUaJRE2r69vMlAHB3r0cffRSbNm3qLDK6CpW+Ir0vAq2v+z3PA6AvepCBhSEwYKiwHfpc8xgAY/9u0fSA9QINY2n+Q67zY1ICFgUObqf4n/ceFk0x6AN5+jT/Q8V5l8SgHvfzEi+GQKehedElkzl37hzOnz+/BAA+L5dzDl9/cj++cnQ/IpInwMHd20oeLx0w9KBeHaDTQcd2BGun7siHUSo8ppqDDev6DTFDc9pla5wv0WjZWd73UGpEt1q01qFEMcWSX8+u6DHGIoOQqDOhZuf/Fp3kTDePjNGEpl8b4BXTN2jsWKR7kjpv0MI3aFe9rly5iEn/v3TZnS2ymYkg3Xfj3m0LpbIQFdAhUhtdqPVtLsAbXaSgzsx9RaUcyrwvGlHuIHtfmAYwXbByo0PFPhEac3oduwyI+SEMo6R03K5fv4Fzl6/hj3/0Lt44demOzKc9Wzfid37hKQDA1o2r2Ll9a2FnODcj4/V08Gly0RtiZaCl9yIxbBqfWCaSqADjzxBNbCYX5N55isUsZp4u63gnjSvd7iBxhen+Romeg1NGgIBpLRWGM7FpRN1P31M0MqHidh5qYo5ZD3i0yxLUeGeAQMv0KFOm8c74PrCbeR215ujBdeSlYY64wlCYiqzGWfPJSEVV6pi3KrEoczWY71fXGjJtDLF81pnNngoyZyo3T5KEAtAZsDabwglgybwnAXqLNKlIrhhka7Nc7NzFVPzDAf/Dn76KG5+B4l+u/+TrT+DQjs2WQUZr9Ip3aCap8G6aJtPvPZrMBogZePaNp6Lf0fgt3xOD7bzH8mt7I12BAkYiF0LW/gsbQLw2IqKdaxR5a9N+0iunec3zIzn887pSTC/TBnArBN1jvSsfKMRE/0/gn0SkltSgNqDsFTGB6I48P9pYCnwxEQxkJMz7OZ8J/s/vvonzVz5ZHvTuwrVp0yYcPXp0sBNZx6LVBds8U7W+fPNa59/XdeXHD0X41Rr+LkCgfq4xBfQ8Xf3Qfeh6D/MK17FgQV+awqIFcd/7HmISDH1Xfa+96PvqSxkY0x0fel9DEYNdDIM+kGOev0UfoDUEigz5OvS9xscff4x3333wTFOXAMBtXs8c2oVvvnAEMaRM4wM7t5YNtXGV83jViNYJVUAAjk/qKlK6vj2qpUvNRgcinSh0eI8oVFl21bebBIgWS8VksBRWVHnocqCOGn3WgVqb7jgVnlI4VYZ/ck1D1FjC1CF2lZN3ZgrQ1bYVG8JnaQQJdrnTPosg5og5ZxcJjuKLdNDiAojvn4M1OCsghDfFnpFTxJKA4LM23s8snkVT7SiCTA2hYjctXB7rMy2Z2SesQ2cw5NZ0ijMXL+OvXv8ALx8/d0fnkiYDxBQVuGXLZu3614GHGm9XFQKNt/ncbShyGf65RXtLh7c4i1eGSIBhhsRYvDaki6jSmk7mQMyd4dIV9sY1nuIEJY6PN7dQ4hqFjt5S8Z88EKwTOde+Mk3lbxpfpCyRZCAikRB2BRuqmfmA2RSMEhPoNAWDGUIqT/Be4wYjMU2kY66JCvnvClMjzm5bVVwk+xg4ol0LcAgyGWTpklh7ytokgJFIsiyIW3wFmJWjwBQlGjQ5YjKNK5iC8vylq7jVtvjum6fw0xMX8PHN6Wdqb/ylpx/C14/uV1ibAWyBhVYmPo1F3ySqfwYAYsgJCc4DLnsGpMVKGQIxR0+yKaOufSAmHBnyWnNLkoTlbnnjSkRnoGSbSAyDkBNHFLyeWVeLnE9Sf9IcLIhRDAHO+xTpx5KewMVT1uq3Yaa44sIwxsIqSPKDsma1OSFB/65KoYhM/c+D9rtvnsLfvn12ebi7S9f+/fuxa9euucXXkO550W7xPN34EF163uvEmXhkN5ddMK9w6wMSujrz8zr384r6IZ34vOcd+/2NiV8c+o7nFc9DjIAxMYNjzPyGAImhe9cHJvD5uwan6jE4z8SylgD0sVT6WAVD303fPX7jjTcwnT5Ye/gSALgD19rqBF84uAPfeOYQGt9g/86teneV8oly+GMzOTlYKDU3/zxwoUsa9JgpxXDJyXySKbJtDKbrpAO180t3pB0PWuxNQ0jRbq4U1dz5YDdk7gJ2Tw7SFFdOdwwUONVcB+3KALZ4KPcGxUArWrNAOag11NFjTwTufhZH8+JmLpJbzjxnZ2T+fN4lQysx3fMawWa/40iu7ZJZrXRkQA+RfN9KLrUzGmk+tAmopAADszY4Zk7YH0w/N/cUM6kPdjGlSL08Tj/48DJePn7mU8smf/7h3fjlZw7DO4cDu7ZhMplosc9pGlIEtKGMk2Re2JrCVDrKjat1ws6wTWLdPazutwGUJB2BzOJKjBsnNNSpHAMuxBojWZI09HmyE7l8Ry0ZNIaY1gCnXcpckOaClceE0+gxzBSrcIWyDjLp9Pz5RDKS6dA+vy+nDujRuKxHcmVnw7Ni9uk7zTfrf9ddUzbDFPDKUzyGjhfnDBtEmBt1ckmo1skIqHmmdOprg8iyPuS1hb7fAgyULjJTvaXz/8N3z+InJy/g7Ecffyb3xUO7NuN3XnrSFP7McUvjorCmfAPdGyW9BdkBWtZQOGS2gIP3jQKj4huADkNV3n4Eio2ICG1Uvx3ZM7x3aKctReoGAnyCiesERW7WyRkRAbFYcqR9VlhrEo2YUQxJCUjgLhQsUMPBzHhJUpIS2ycMt/K6iZEk7+Bm9iXSdJi8ZwUCq8nHEwBw/OxH+KMfLuP/7ub1yCOPYNOmTYNFXl+XvqvY7GMDjOlY9xXaXQXTmEJpXle3r2hbpOAeMu6bd0/7QIU7afY3NolgXQXcyISHMY8f02kfE28477mG3uOQVGIeqNFnelmP3yGjyiH5w7xxdfr0aVy8eHEJAHxer61rq/jKY/vw3JE92LV5FRs3rlW+VUxLZFO6oC7m/He1QZkULmyapYOQ0H0bu9Vh7AEYE7OQDzbel8x5x5nq4INCdzHDjv6cI287ks50UhkBrs//PMnq2K1Zt/50QNKOCkTZOzvYRf/bUCc2knmTgCKqwXeW5s9xdOI1oLRt6uKLSdgktagq468sq6h8CbhTK3LXPtpVbcbjs3s0u5Lz8xqTOOn8u9JFNmPCOUyapjjO58P7yXMXEdoW//O3f4prN259KnOo8Q7/7DdeyGPI46Hd2+B9Y4rHVAzARKqZxA0a5ymeLlLH0Cnzpe68a3Qm3RctWEmrHum9tiKz8Y0W2pwAAIrmk8LG+NkRPuarjlzNMpmJo8mgjGR9O9hmpOjdjcEjSW5QeXHU8ZoMUM10dwjE4zFXsu67NngrJzAJCuhyCI7wTbnvjjr4woBgtoo6r8doJEK9Zpr02RmYM4wrovMnxkej3gOewRjnCsuAxqCvgKtPrn+C7799Dj94+wzOXv7sU6x/68tH8cUD22msR9LoZ5AxJD8W50qn3ufBLICAmANKse+9JyNXRwBBGl2JedGUdRGFjZEMFp1JNhE2jqzTTqjyBJBpDK/MAAHC2awSVrZXDHiL/4ojXwwBrzRKM8/pto0lVSIjy+nxZZ3QsZeff9rmtSBLAcR8VgwAW1nf8+Qv/hxlzv3Lv3sb752/sjzM3aVr48aNeOyxx+bSmfu6s0PF9RBdn8GE+nnrDiyfNYbc/ccWwOvtqK/3b8YCC2NSF+Z17Mc+9k4kCoxlZCwa57coSLAeMGHIYLLrOxly9O/6fV/xXgNkQ+N4TFIA/+zq1as4ceLEEgD4vF8P7dyMFx/diycP7sKuTatY3bBhxonemS6szRfnQlOBAOrIBQAT6tapK7UrkVzcxfa5MJYDiaGgx44JR27x3jnTwTQZ1l2T0dkIL5C8oBgOlUOyDMBJ4xGyczLHAZb74aHhXh3dWgYolMJf6bh5wQnRRg6q27IvB3tL5WeNGbQjzRRqeT/cSdXP6ZzRAnOb2pPRWVCzSCriyOSRn0vo2hPRwAfW60ebWT6zoDlTBAam55K2VTpo5z/8CJ+009ty/B97rU48/umvP58PIw0O52QA/izChCn63NrV3RbNHIcnRUSsHO4F7ND7KF1Bcn1XOYFzhvGhcyEkirtxbqZVVujqqv33hWbBa0RJZyjFL+fKs0QjmE3J3iftuxqTThhmgBbKBCryxpDGJPmEsHFnFDM/ks0QZmiNE91MggiDinKvfPW92qhPpz4KoULzHZkjFuf1IpeQdYiNQSNsAkC9NolPRqwPMDOHuFlZTpGfADdu3sKr753Dd988hfcvXP3c7IVff/IAfuGJA2hi8YOBArEwUrNE+af5mNdo33hKkEjF9iR7BIjZophfevKvgZqclkSHiIhJ0+jjxVw3AeiWdSWsDQMMEEBWf+v8swS4TiFY4CT7/cQQcxJOSgfy3uHWdKppEjLf27Yl8D2o0Z+s7YGM/3xes9ognyM/RvaUSECu7CG0n8ua/8rJC/j2T08uD3B38Tp48CB27do12Nkek28+VPDPK3K6uvBdr9PFBBjr8j/GSX3M33YVcX3vd57B4dgirwucWSSmb+izjQUu5lH0x7juD42NeZ+jD5zqkgeMGWtd0pK+6Mp5Y38eSFb7QwxJCbruUe25oZ5EHa/51ltvPVAygCUA8CleB3Zsxs8d3YunDu7Czi0bsbKyUnKy851P+dSSs14G4K02YOKc6Vb1UWzT4Cw9b+6ycNdPHLX54FzilGwRwrRdbw49FXW8+vfMpqUmhLabLB/Ec0yYo5KFXMudFkQ2jq6msosGXrWSRFPuQhujGqwFLQR87uR1/W1ZkGxsmcsxjnpw1ESG4s5eFjmnlFCzAHUcjjlWQp4rfYcRt9qcqU1Ov8K4mFnkq8IEzqYdJPlDzNGMVABlHOHSR1dw+fpN/D9/ffuO/2OvXVs24nd/KZkCrvoG+3bvmNFQS3GXl2n9mRYWZgFn80bMAADFwA9mPMsNDHmeMsuAQQB2J+9l2bDIAAAgAElEQVSjPkoHnPX7XDqo3p6duqXAT/50+bFRncDhZk33GmEwuOLE7wyoUDr8LEdxHIUIp3R59gEwPibUIVeTQk4W8eV5SvTk7H1mg8oQrTkZUMY4g2cl9UQAm9z5bTyBQeX+qeRKgVAoGBpCKaTkQxZwhbXiZY4IC0DWNLNWkrlo27Y4/9HH+NYr7+LVEx9+7vbAQzs34z/+2hPY4GZN+FReFQsQ1kycGata2OcOf5MTA+Q7leIf2YhW/fu1+C9yE/XPyPIhUMIFQ14hBoQ2+WUUjb0wrezaEQiIlPGiPgKk55+GAOX3seeOOPsrMJAlBxkwcTFms0wQ9V+SJZyeIUwyDICbIcK5iFuiT4lAKzI4lZkVn5AYgf/+T1/FrQc8fvJBux5//HFs2LBhoe70emjk8/wExgAGXUZ783TTY3T+Xc8/VAD3Feu3a/q3KMtgnknd2Ps9r+Cd9530Ffm3CwDMK+r7uvdjivSu+84AQB8wUydbhBBGMQ6GJCBjZA7z/CzketBkAEsA4C5czxzaiV9//mFsaBrs3LoJvmlK9nvO+E37roP3kXTcljEgtD8vndtceDaOteRVsUfdUZM9nf84UeG7J7Y4mjt6Pu98dq0unVEpKA39tceIsJ7wJe5IstZt3jPLCFzlJ8Bu3b7qLuprkKkex5CBOrD8PJG0o+yDwPdHmA6+6pQKEBOyH0PIVMymoW5xB5rsCdSQjqhQ3eX+GEYARTd59kGo7ynTvVHp2UkTK27ommlNH+jGjRv48MrH+Nc/fOeOOf4vAqD9468/AeeA7Rs2YNv2zXlcQp3YQe9fC8RIIIqpVa2UpDZr4/FeACeo1lY3HzJ95M46/9zP08zp15C+u2mIaFzpOMsXJu9FxhHT90HgmKPxLlF4Wri7MlfU8JDminTcpyF5JZTIRUncIF8NKt5lAEUQI4YlKXkNKXpuO1kCx49yjCV/rsqDQSQcgeQ3cjs8dfoBax5qYuMcsTVcBQwxGSF/Xuerjd4VGUmoYtS04ITDpUtX8WevncSrJz7EJ58xg79Frt988VE8cWAHNlR7jPeSpFBg5MY7OJ+9VRpXNPzeZ6C8obXP54Lc03foEmMg/1EkA9f09049PCTStaz7kdbLOAMSqvSrDQWgilDDPgay2iCAYETMVP0oQCXtidNpQE4xzWkBZS3zTgxsBdhN60AbisRIGQMhsxvymaBF8Rio4395zEui0J/+5AR+9v7F5WHtLl6TyQRPPfVUr7a4Lk7qrmmfG3uXA/9Q/FlXITUvLm1eEdxHvx4LYoylx69HMjCviFvP+1i0AB3zs76/ue2ibwGTyDv1d30gwBiwoM8noA9gGYqB7ANNhubf0FioX+vy5cs4efLBYVEtAYC7dK2tTvDUwZ34xhcPYfNKg+3btpaeHcfquVgOpvnw7p11yw4hzKQJhErryp22WufrKqnBzIJX0e+5u180z15pkaADMJvTFZaCNbNzpKMXw0Nr7GVj9FwVEyaUTOnwK6WbNjHRg2rkE3dtKmaAFE4hBvICEKf3aL0LYDt99r54+JzoYNqCQPV4p9nQhdoNA06wNroulCIZRgo1lDue1r0+GsZFSSWAdW3Ph0yJTgsxF/+XP8b33jyFvzl25p7Mm2cP78avPXcYiMC2tRVs2bI107hLZR+zUZbXRINW/Rk8MScKXb6MP8Nk6Rhz0m0Tii4icrym0M2jiUhUQAUVxRbR0OhB3UBQhz51/7ITbkU9LvMsFpCMGAMMGvCg0zmgbril88oFNCgYo2l8/izBrBl9m6sYD3KcIAN3PIelyyrj1WsHFQbwipF9FoqUIcRE4xZZRurKQ3PaeQ7L/JhI1ze/tnee7r/d3AUM4mKJWrDa3ZV4RgYpvHe4evUqvv3aKbx8/OynLpd5EK5/7wsH8JXH9mMCYOI4PaLEKjbOISCo5n+S3VyluE4dfK9r+sQ3pqMviRYTcc6Vzr4rwJPP7IE2JtB8MvEIgdz0ZRTFZCabovdCeSztoSE/h6zPFlh1CBkkZ8PcAjRHmiuJJSCRoCEmwCC9RwsatzkuUvDBViRzGQ8oz13kOTEmTxzDAisuBggx4vXTl/CtH7+3PKTd5Wvfvn3Ys2dPb6FT/7wupr2y37qLoSGn9KFOp/HTyWDCeij0Xb/vYsett7jvkkjMAwLGMgDGPtfY+L2+zzwvBnFeMb3I+77bmv95fzsEMg3dryG/i3kAwbxowlomwKBbLVHokw289tprg8yEJQDwOb62ra3i5x/bh2cPZ6PAtY2Vs/AsUhqpW8WGV2pexl1O+la5UyLdDe5OtqFQxxvqvBu9jNG3187BNPCjNQMTOi//nmUHMRYDvsw47qRd15nmWsiFaGOMCAip71OZ6NFqtIWqm3WTDkVbrJ0is5iQGVmIiM4ILWhDLm1GSRswm08VZ+ZdcTLnbHLtLFZFiTy35kXTLA6UM1+07Bw3F01xK7RaAWKQjblu3LiBc5c/QQwRf/Anr9xTauhzRxIIEAKwdcMKdu/aVsavuddkiBlD7ham77zW/UfS8YtsorBJyKhOs7n9rB4zF54RFlhgk0K+CpgUc2FLcpJYDCq50wxYU0ki+9jNSMAcFHNAfhqRE8j4BiqzRE+SHwIZbeEC62tAYyvQ+qSdVGLq6OcnwEuSDDKDu4PyXwpFBsBk/ZCiiUFGHduBIg2Jql+zBmBME2ldgJh8oqQfZLC2HASsHvyTTz7B94+fw8ufE4O/sdeGlQb/1X/wHACHDXkhbQWEpQ2rxEEmcBYuRbZ67ymG1RUwyAGTZqLgz+pkUlguGbCTOaHAWGZzTJomec64wsJiJlXMhbjMcwXQKaY3AWQZUo4uz+k2rTvEwmEZgTAHYo4EDbmoB5DNCYPej+k0ALTitxq5W+ZnG1BSBEKSDERiF91iUBMqkNA1IzrgD//qDVy8dn05UO/ydfToUaytrXUWJn2dey566y4/N376NPxdRVj9mL7idGzm+no9AdZD3x8CFBb1GRgqwsdSwOeBGYsWzfM08GOYGvMM8uq/XRREmgeuzCvShz4r/22oG3wDz93lB8Fn9DFjqitOcAyAderUqQdGBrAEAO7RtX3TKl564gCeObwb2zasYOPaRu0ooio8Qqposht5odZyp567ixztJSVq4C5a/urFMM26okel47KeWidJfuLSQS2H91h3xqk4ZbDCwc1EezHFHQ6zqQeOo5ZgC1rviBJpDzusvZafFwO/qhByXBR4RVECpRpIh4kBCHGElux063JQCm3QgiG58TWzoBSx1rSJD24ljrEABtzdKXFp3nSNGVDhxIhYyRxuXL+O81c+BiI+Vcf/sVfjHX7vmy9ocbp1wwq2bdtSOm+uGGROs/mbLT1Ldxv15k50cKuJtU74coiXMS7jPASY6DzvqWjPneagsZWVFKHWtBOclM75qdNZ/AIiSl2dpQz8fYv+vS7SdW3I71NAP5e7/BRlpmaToUgbQpvc+IX1o0Z9kV1BYBIBvPfGs8T8IWCNAYkNBFjNPW/AUvB7A4aV2d5UzCGgov4Dxome11nu9HM0JroMNGUuZwlAO53ix+9+/gz+Frke2rkZ//jrT8IBmFRgD0e+pshLWot9ZvY4n8dtjnIFOf/TmAlwyvbw3qdVXEBOJPNA1eQ7j8YD0zZWqSI81yMxR6J65ghYIHPdAH0hGh8IBsWKFIdiM8kfpxhpCgjQpjmvqQPp8dNpTMBZSOvEtM3rH7GDgkhlyPxTAfo8ll99/wL+/CdL47+7fU0mEzz55JMLP67uxvfFAvYViGOL1r4s9TFa7r7nH2IoDBVj6wEAxsYJzuviL9LZvpPRget5b2NTAIYK/DHfz5j7MUTbH/P7LiBmHltlkWvIjLAGQ2q/rnnf9YOUBrAEAO7xJUaBXzi4C7u2bMTK6kSp2BpnRMWqSuuJBq6ab8wapAmFWVyIpbj3jrX26efTNnQa180gY3TomaWac6xWOdB4cvos8UaWilx3TESf3ztypfauJmmhc1cRirzA5YO8YxBBC+igIIAcRFvW0jOM4uh5syV6KWxABbij7qrtJFp0Mlr5Q36C4hlRx8BZJ22TQMCd7GDj2MxiLd+cA27euI4zl64hRuB/+7c/w0cf37w/uoiTBv/1N59Xf4ltG1exffsWjUwUbzfOna8XbNbCMgsmAVmlaI7BxsEpuESrZeeBC0UTnLTv5P4NSS5IPb5IRpEh04yla5nYIJaiLuNI51ysQA2S3EjEZOQ4vqrQNWZ80SklXzXOkone5rnqYaJBRRYhGvjGWwCSWU0m+aJnM29DxMrEFxlRFddXfDe8xnSW9+Gp6Ck+AmoIyIarHuQoH2fW057Tgq4PisRlxsyr75zBqyc/xCufQ4O/Ra/nj+zGrzx7GCtIKTYh1iw2WSMzU0w0/nn9FMd/WQ+ls980DogO0Tl4RHjfZAO//HtN+BAfgRwjiNR1F9K8sADaEIg1JEw5s12a+VbLTcqYhzLZTDJJHlMhs1gEZOCIweLyn+aCxHzyawj425JnEIPa02DB9a7D8r1md31er3379mH37t2ju759nc4xhn59Rmp9a/GYInJMcX27f/NpP+enUbT33fsx93leEbzoa6/n7xc1iFzkffQV0GP/ZoxB5FA6Rh8AVFP+ax+jLvCq67vh137jjTeSZGsJACyvMdczh3bi159LRoHbtq5hkqOPZBCWGCtvCg6h2rKmnyeLyQPIB2jp9E3bkDoievCJlL9cDNBCiGgaZ+LJkqtwmHHllvfY6iTiQniWyiOv5V2i3DL4oPFdxBYQYzw5TMmZLJCme8Z1PBZtKTswS3EjmnLukDtfDAcD6VWZNixu6SBdqHO2a8zFOcBMB1/FkdjfI3bRroaNU1hjzbO7FLO5uCW5aiqy8vd/6ybOXrqGECP+xfeP3XfdzN1bN+J3fuEpvVfbNqxiWwYBlMYebLRbostG0Fel4z9GMRKsDkiuFO2WR18AItaQM7VfxmWbC2SOqfRVAgOndbADvo1m5I2udP2loyf652nbzqzkHOnJoJmwfVoC/Oquuqsc8c2YpDldX5wGUDqPxSSU40xLgRVKpKaCKCXSsIA0Fghhw7VYJSnYmFUyQEMVTxhCcYWvQBywKZwvYCGcw6WLV/Hnr7+P798jb4wH8Wq8wz/99efh4LDRVacPx/cXyQMAqbh3RP0X80+XAehkLpnWa58jAr3+XfEPENCaZSog6Ujar2IGai23RACAxs0C8cW0083KvJg5QHIY8bFIBX9hEiS/gaLhb9tQQLYYC5AQBTRTLAptDLgZkglg44BbISUAeNqrnEsyAQFN//TVk/jZ+xeWA/MeXI8++ig2bdo0WOyNcYHvkgFwsdJFW/YdXkFdz1vroBcpRsdEtA0VUEPFaBfVe1HX/773ski3vO95x8bT9RWWfZ+7D1AYI/MY+z4XBZyG3uvQv4fMDfvYCCx96dPqjwVO5kk/+mIE5wEN8rMHJQ1gCQDcR9fa6gRfOLgD33jmMDY1DXbs2KzFSEuoVCTHejG8EoCgngicoa1dUfo7753N0w7F6AqxbBhdBYoM9la7JUVLiaqhpoZsgBbwEvOket6qu8LmX3KQYo8DliMo/ZcXEBQnc7lfBURhU0WKGCPKpMRLpfc8a5jIgAQXhM7VHWeoiZz4Cjh672yg2MVaiBXN33tLG2ewgjvfTN+OkSmgMDGGgMONmzdw7tI1vHX6Et7M/3c/Xvu3b8KXHtmDpw/tRIzA9o2r2LJ1S6YJ21hIOHb3LnPFMFCQjLIqO3D1iWAJSeyIwGRwx2tSR8w6/8LwaIhhIt+3jm9nZTTM02DNPxtI2ti5auNz5b2YtQLF86GlrqR3s8WLjDuODtUNUTqbmmJSjDCZZRA6mEQs7wFR/qMBqgqLR4sv70z0Ihdcct8CAQXBAKI2HaV+LzUQ49ARCZALzKvXruEvXz+FHywN/tZ1iRQAEZh0+KJ4Mgn03iENP6dMgOLo77IxYN53fIPJpCH2mFfATYBaAQmCvIATb5W2zD+KhhW5Dc/ZqKBUyoKeZJad2aviLLihMbd5kE3bFjHvG1L4h+zoJya3krohDK6QgTNhCErsoBNpEBJLqQ0BLYxvZTHlzQvW66cu4t8sjf/uybVhwwY8/vjjc43k6iKDi/15nfwhOcBQAdOVINBX6A0V6DXFuk+ffztMgPVG/vUV3uu55hXWd4phsB7DvfXIGOaBBPNAiCEgYgiY6HqOIc39kD6/K3miBouG5BJD4Ev9HH2f/9q1a3jvvft/fV0CAPfhtWl1gucf3oOXnjyALasNNm/erDpZPpPWA1O6c6V7CKX2cwEiBbsUzS0Zz3FxqyCBcyZPm43K9LF1oe6sfp8BiVhRm2MFVKgkgIovp50fZ8zVim67dP41p5uzxVGov3XnnYGBGAJaJIdnjmRz+cApj1HjuEp6kAAbWwhFFHf91KAsZnWmWNJM9WDYBhPfwOY/l5x0RwaNUro4A/oUE7kaFAq50Hvz/XP46zdP463Tlx6YuLJNqxM8sncbHt+/HV9+eC+2bd+corByfF+Ms5uW0eKSkVdkbWM+vAeSTITIfg8um27NxitGQgNSGoRNwBBPAQsc2IQNX72m79i4VOfP9PrKnLNmMai5mnO41bbqYq+pAuol4iiSj+EOrmvoc6lkpXR5eeMVAGHKOjqi93tiyHB8Gn9uKbCa7FchgEptKuic9fZo8lpwq21njFZ5savNRhlIkk9+/fp1/PXbS4O/O3G99OQBfO3x/ViFBWscbEyjpM0I6U2SKZI0rtGkDBmzwgaQsckxgKL/T2wBZEZOSfkoqTSBWCyeaPmFvSbMG8y8d14zgr5ukqM4U7iDWGiIMYESwtfLRX8IbXp8iGijQH/Aramw8PLzZVZXzGyfKXX+QesJnxn+8Duv48LVpfHfvbhq9/+661n/rNYgdxXXXYXPGJf1voKW5Yl15GBXsT+mgzymqB9TMM6LixtKBriTRfntfp5FCvux7IhFP/M8hsdYz4f6nLXI5x6SAwx9xprp0ufUP+/92zQjP/g6XfO1D4A6duwYbt68eV+vRUsA4D6+tm9axdeeOICnD+3C9o0TbNq4lg7OIBpwPvyGULrHdaHNTticN590044otem3UypEvKuM/ADTeZd/Whf1Upiw5r0uxGaous4aBJpCTN3tYaIIywbp6EBnNdRcTBWdcPm3siucDTh32dRP/BSETsoGjEpDlmzoEE19oUwKWP1AOaTaAoT1064GR8xCRw6nEKmFM93fYmyFzGwoFOmTF67gtZMf4uXjp3HuAS9otq6t4sWH9+LZR/bisQM7FUCS7niXczyvfiFmzTssG6YAK7bjzoU/U8eLiR0M48JuaDAulsVM0Jp1eUpp0IyKGK3jXuQ4TU4ncDNFraYSUDfS1z4SoRTmUvpL11FAAp/nm3bL8+M8OfezOWYtdSmylMoAkeaJgBzGHNQ7tG0qpNhVIEQoa0cZBx3eAcbLIZs3pudK60FhD9hDTDud4gfvnMPfvLU0+LtT19rqBP/k156FpgIARsvOrJaJd/BNmYvCpKr/TzwhnEvGf+IT0PjGxOM5ij01YF/+R6tjNY2f5CMRdOiqj0QFRLPcjNMhBDBjqYCC0CjeIA4gCUAGpUMkuVt6bfU6CUVKIJ8uhQZEhLx3NHmut7wWAvjuW6fxt2+fXQ7Ee3QN0f+79My1Q3+fod9Qd3K9efJDdOyh979ooTrPyb5+7jGsiaGC9tPo0i9aePcBNWM67Iu89pBEYB5DY14qwBDrZCywMCRp7QJ2uiIxu8CHeSkYddylAF/zxjPLDoZMKs+ePYsPP7y/vYGWAMADcBWjwJ3YuWUjViYrZGwV1JTOEdXdUaY3H3raYM3lqJ4vjyPjLDl4mU4bMKM3N07oVf6xHvL5kC4T1lvZQQhkouTSoX/SuGIOBijtXgpwKN063Q+vsXZBddBaYBv2QNEbs5ZbuvDStZfCJHkbUOyfc5Y5Xi04xs2ccqKDMYryhXKdT35c9LNvgWpJOflPf+Yqwzg300VwzuHtM5fwt2+9j7/7jB4AD+3agq8c3YuXnjqMlZWVssBHYp1EK3MRAzxADt0ZYuNCnjqNgTXneox3hX0gBaYvCQ5NHqslMtDS9CXeUl6rRFBa88lQH7wUoHLKIpBilwsQzv6ufSx43qTNUPwFiuP5RAz1aC5bpgBm/UDUgcSaANaHFAZnpPNv4/kKWOk90GbX9khRm45ZRVTsiwSozZ9J1hIjtjBztXirvPLOWfzoxHm8ttRJ3/HriQM78JtfegTOAavO6bqqkaQCIAPZ0C+tYysrIs3xaJrMjMoAlM9+GCLHaprGxPtFlQNkgDdT7J12060EYJZimubqpMneNCT38t7T3hJJLlAAAga2eU2XFSRIwR/zgPeS3kIpJKF487i8n7dkHKu5FZSMIjIdROCts5fxRz98ZzkA79El9P+homKow9gXj9alg+4rZLqKp7rA4sfXZmjzCrexRfx6AIChxw3JGxZJHphXhM8rrBf1DOh7jrEAwHo+0xBwMG/8LfLdD4Ebff/u6sR3PXdXKkVfukCXbKYPZOP/HQMY9X2mB0EGsAQAHqDrmUM78fj+HXjmwE5s374pdTfUuKsUkaV7WLp4pQMetds1S710cE4ysAuFPm1QpbOZGu65ywzSzJP+XybwtA05Oi926nA5Nsw5yTiOmIZsUOiLtthMWgFABBSo3MbFfIxp1Ko/1k6tp0NYyoaWxyaDtNLll8JtotF9pbQRt2bNWCcqdtFIezoc0mKiqQ0e4qFQa/7UFb1G/rVzDOpeludNoGbEmY+u4SfvnsPLx8/g/JXPB3150+oETx/aha8+vh+PHdxj2DHsAZBHoVLmuXg2VH3qvHsauyAghvXoDtaHABWwVjrm0eieHclZ4Gad+2Pk9w9N42D5gGUmFDCqSB9cZzauFj2hIIji8K+bJHmDGHdxNkcjs1D22neV/l+V9+pjUmQ/mIn/jFrQdMWc6n85ZxFQWHPGECuvEVexBQBc+uga/uL1D/A3x04vN51P8fraE/vx0hMHMKnjZvPIKB4uaYw23qluP80NB0cyAGSZloAITePgfaMsKC/0/7zHxBDUmLJtg4mxLcwVBqKSX0AbbcSfgGb1gZXZAL5DX62jUwCpIOaAgcDItN5MA5v/JclAfqbk9p8jACOAJr9mkPVK9xSHf/l3b+O981eWg+8eXUz/H2sW1ycPGIpSGyp+u/7GG8+b+UXmmM5212e607F5Y59jvR3/uyEZGHPvxvx+zPteVHKw3ve7Xg+AMUyVvojKoefoKvqHtPxdbBoGJqyMuB/kePPNN+9rGcASAHgArxce3oNffuYQNjYNtm/bDHYe4sO/ZxduROqWQ/PLCxuyDIUmRyS1JO4VCqEkBuVzlynqvaffu2Kw17lBwcatpeJslr41aVzSdoO01KSXj2SAZDuYFBuWwQx9HL0vMVJKdOA0JQRwkHQAZQCIczhAOvNiAjhtg96HUhiVQr3JbtW15jpQSLn6GRAtWopNXyOS9AWkeMX8vvKPX333LL73+km8deajz/V8ObRrC37+kX34hWePANl0y2WHcVnMZe449JnFlE6jgF5tCAZEk3HtK+p5zQ7xnrruFLfH1bv30HHNzJUQLLOkFPDkyYHakyIaaYGMf+kkSgdcpEXMaml88hCRwll0+ECJKmWvDHmcjGN28OdEBJWjQHTRLHtx+p4E7PC1NhA2EQEWo9Hvs+4sz8oUyjNcvfIx/t2x00uDv7t0ra1O8F/+6rMIMWKNjGYdgZiyzE2aNO5SGk0BmsTsz2eqvwPgmyaxBZq0JrYhYDJpzFobtOCHYbqVKMtUrFsPDsvuKV4wOabP5bGkMjeoqWjsOWwpZyCEwlKKCfxr25T8kZUBCohMW6BFgIvp9Vyeoy1AsbqYSQD40Xsf4ts/PbkcePfweuSRR7B58+ZeivUYh/sxBVafXv92i767XbiPBRbu1GvfzYL/boIKixbid/P1x4IJQ0yLMXKXecU+P56L/T7pAftzMIjGvz9z5sx9LQNYAgAP6LVpdYLnHt6Nl544iC0rDTZvWdMMeO6CyxGXafGF+RqM+zV3QbvcYeXn2umGdR3nyDU51EttwhF2sQIOkp+SL07JoG5nIId2FBd7W3SJsznrL/P7pIxkoW8qnTL/rM4wr8EE0RXLPS33zFL8y+ebpT67yjU9chFk2cho1TXemc/J+n755MUoLR1Kj52+hB8cO4VXT5x/YAz97uacObpvO547sgsvPn7IMABMfFwIxNiAGoVJhryAPMWFm0z84EzUn24gmAWpnJGQRC18G18YOFx8mE0MZcwJwCWGnLXzPUsBzJhSenBhRjgTnxiyLCf9biIbYp2GIPehY6/31G63XhxR1ytruBjK3CEvgDYCK9l47VYbMCG3/yCO8VVMm8Q8ChDA80jYMU3j8fHHH+P7x88vDf7uwfX4/u34B19+NFH9q0SNEC1YPGmSBERSaXwGAHScZXDLOYdJ0+ROeZonkywPaBVtKsCuYfnkot67IpNjh3/2VoGDWffl5xqDGyOliTCYFyyoEIsXAAiAkEjbtA8ip9FE43khiSOBwLc6zUI+2h/8ySu41YbloLtH14YNG3D06NG5HcmuwqmPCj6UBFD/nDul2jSgf8+LkxujqR8qoscCGUPJBkPd3XmPWyTJoO99D4EqY+L2FjFI7KOfr7eLP89boO9zzEuOGOtzMAZ0GPMe6zjxmtbfNV+G/AHmzZs+uUJXMkD9Pq9cuYITJ04sAYDl9elcbBS4bcMEmzatmY6G/G9DncbSuUPRuaMUA+LY3aihoEdA0MN40zRZtx/VqIw7od6Tez5KZ1FeJuRTlJB3AzulR2Qn//TzFHWXJzkZBzKln3XYUqgJq0GYCOXMFykayan5EpuIaYcVxcdApAiuY3Et9x2zGNQAACAASURBVJD6nB2Z7OqTYBafcvDk8ow3dxOPFpkmne7PqQtX8bOT5/HD42dx7sqygBlzqXHgw7vx6P6dOfKRdLnOGV8M1vDy/3qy34+Gug5jQMkaeOnMF6FBGrcNaeGR56wwRmb2WNO5LJ1SeyC0xmoyXxopUCCdcatBNXM32sQNHfvkbF4DDerlQfNYCqBiICiRmAwUlI8VSX4ghb4xJ4SkBYCiQ6nAV79SC4aWP3GYTqd4eWnwd8+vX3r6EF58dA8mEZ2ApwVNHSZN/rUXFo/PjKnEBnA5M9C5ZOLndacpiTIxBrRta4A+mfsNS2LEyDZL37yHAk3CBvACniOauapAWvYYCSGaKMvWxLvm9JsQkLx6yvtFLv5lLgtzKFkFhMSQy9KkllhgamQZIv78pyfws/cvLgfbPbz27t2LPXv2dBateh7pyV3v0+LPK+a6ihmmSw+Z0dXvbxFt+zz39jsFANSF2BggY+xrLBqnN3Qf5mnJF+3UL/K+x/ztmEJ8zPc1Fojp+32fF0bfezTn5IE50TdGFhmvfUaFffID+ff9nAawBAA+I9eBHZvx5Uf34smHdmLPljX4rGf3vIkAWiBzkcBxRxy9JbrpmagmlEO7o4Je2QGkj7Eu9XTApw59iKUr6MitWMzYUufemXhA6bw2Pn0I6ehJsT9tg/ns8lkDAQaF8VDo1txZLRrt7LyvBnz5d852QuVFdDOlLhEXfoU6ypMvaVpRFTGNoWwz4wB4++xH+P6bJ/GD4+eWE+A2rkO7tuCrR/fh688cyQVB6c7J3iOyklgV0x7ZsCyS1py8MLgwVjd6Bdsonqt2sqfxIx4CMnZkbANsYBnsuEYVM5kLbzHQ5HGYCvQyH9WcMyNZjXcd5lFQs71ipgldY0rHVNzXo4KJMQSEahMCMZCQTeB8tfErw6FiPjhf/ArKpl28AI32H0DbtvjJe+fxo/fO4bVlUXTPr91bN+J3fuGpZAhYsZ4kHlKIYLJ/NI3X8SYGmMm4UyQ6PscExuyVE415nrB6JsIcczZCNYHJGSAwfi5O50sk8JzncUMH0lh1nERyEzsYMwlQCBqryX4ZqdtPrLcY0OYIX/gi+/KujHcxv3z91CV865X3lgPtHl+PPPIINm3aNFhE1RrjOra4qwjroiwPFYV1scOP6+sar5c2v2gk4O1e87T+t5sCcKc+w9jnmQd63Kn3tQjtf16E35h7u6jMoMsHo/5519ieR//vuqdjEhQWAQzuZxnAEgD4jF1PHtiBpx7aiacP7sSOLWvpQOQLhVh7IZGL/0whjsHGlqHkxXuUqCVQwRHY6RjF2Kt06W1HFEhFrRRGSkOmf0vXUI3aMnUfSGZI6aBTuq6+LtaiZQrMLBq5qCH2mx6Y5PDEz1vM4TJzwcHG9VEXkmUHyBRmkR3IZhsye2JmUeEJGTm+rryHUxev4ifvncXLx89+bgz97tYlEoEvPbIHLzx2sEQ85u+L5Ryy0IcYtSMohpFC35dxZTX1Put6xUAyFCAt/5ECchSDOWl8YuZESheIqJgiZcyWxAxHBXthtEyaQiF2ZPinY17AQS5uMighMy9ogkZUYIHhsK54T00moZZ914FBDE5lfdHNPwJtDGikc+sqjR5Xj7SOCJjw4aWr+MvX38f3j51ZDvj76HruyG786hcPowEwKRhZNd+g3izyfyoH844kcB7NxOtYbiZNAaMiEEILiY1Ne0pbALEYMW2DMtYiCmOgkX2G0kMcXE5fLZIZ6e6zL0+JJrVguuy/EsHpsgeNpgQEGMnXNHsOTLOHj4cF4VXuQqy8P/zOG7h47fpykN3Di93/+wCAsR3beW7ut2O2N5b631f0LfK4Rczu5rns9wEAizrkL1rgzvv3GNbEeu7t7TAX5n3mMbT/9dyfvvswNuFgnlyha/z3SUTq8cEGrfNALJ6vQ6wZ+dnVq1fv2zSAJQDwGb1eeHgPfuXZw1hxHnt3bcUt6YireVcxCarNLECdfclHt1TgXKQkzrQWDhpvxnxcOjCxMRqzCsxEzYepNgiqLaBBer0YirlgSTIoXaM2iGu0M4ZpxQnaduDZIRp0kGtjcaKeyVkHZnwTAmzqQuOdiaASgEHz3imKzmeaKNgNHsX5OsSIHx0/g79+4/3PvaHf3boO79qCLz+yF1/9wkNYWVlR1oUMAO+K3wWjN5Fo+bO0/w4DGQe46LTjHXlyUnqHaN0tzMaJG1GLfHlfk0z1LxKVZAgqEplWY80E+ApGjuCdU6kA55WLxlnmhXbYc8EtXgkcf8lAIVleFG+EXLy1xHRxZO43aVIRl9zaOwx5aGa66n5553D5ylX86U/fx6snPlx6Y9yHV+Mdfu+bLwAOWKmkAMoIAzDxydsBLhkDShzkxCfqf4Qz6Ri+8WQsmbw9Qmh1/hYQqWj7o8aA2vFljTUDGFkraS4EchF4az4MMBuPmw+gIQaEtsjZYvUaMs+utwmsb0ju4oktFPL/vnriAv58afx3z6+HHnoI27dvHyyyuzTKXfrkPsf+vszyoQJ83nupY4QXofyPfcyYTPh5hdmYDu8Y/XxXUbceycKYIn89OvjbiSccc0/HFt/r/Z6G9PRj/34MwDX0OP7fLv+AoTnZJTcYGg9yvfXWW/elDGAJAHyGr02rEzx5cAe+8cwhbJ402L59K261LSZUnMJ0J6Sb12gWtqG8g2LSXAkfiOiIzIDt9BlqM+xjAWtcpGZhOejIudT1E/+iiS+Lhpgi+RzPF6Pt7mvh4spJr41Rn4Mz3iM4qimqXCBQ8cc6ad+hATKHu2BpS0GKJpC3gBM9czECkAn5zrmP8PKxD/DqiQvLouUezqGj+7bjucO78OLjD4FhIOdikY3kCSGdPBlbNsoOKBnhqbue9PJsxFQ2JJHJcERZ3yZnPDCcZQlIjnqkorzNUqBJluxE043PwJcmfwQ15Guq+FATo0c558zAiWQbKBTlKUWs+cycCMbUMoMbrjp4Wat/WmcoOz4Xam0Ably/ju+8eQavnjiPsx99vBzQ93ORtHMzfvtrTyBGYNXFTrlZSWFx6tMhMYEiNSuRgC4xRZzMxZIoIcCWALOl0IZKvpK0hwECZ8anI8YXA7wl8rNU/VLkzyZVFCkLA9UJzKa4TYn1ixHTCPgYEbJfz0r2Pogkx4kAonf4g28tjf/uh+vo0aNYW1vrLBrqgqIuuMcUynUx01XEDxVmXNiMKSjHdOHHFGR9xfDQY4c+x/1+jS3c7xQAsJ57u6gc4HakDGNes6/TPs/xf8znHQIxhkwP+8CAvvl65swZnD9/fgkALK+7f21dW8VXHtuH5x7eg+0bJ1hbWzMNiVgXuJnG7FVfmwpwOYjFGLXDooZh+XHcpeDDDhcGokGGoQZnrWYMxnANFGsnWmQxMXRkviTd/pIXXiQIpWMvZoDFW0CNzEpZZxMLOAKQ3pcYKrIOVN6ruLC37ayur2idS/ScFHuIDqcvXcVPTywN/e7XefTiI3vwxSN78PjBXSZu0sUyBtjzgRkBoJpADcS8dReXIgAEhsm8C7HWxZcud5PzzdnTAshGgs4pSwV5biRZDxuXidll0uhHY65nu/ltBr/YlC8ib4ghGsO92LFmyGvqJimvw74HKN1Ukebw44SB5OsEg/yaN2/dwo/ePY+/eev00uDvAbqeO7Ibv/rsYawaeAdGVuKcw0RMYXMRLbG0vvEaKev9rAFUzNp/QZZl7W4ZMeY5JpGcIRqfCgFwQwgIDvCxMsmElcBIUe4rHAuxOPdLYkXysKHPnNMMGudwQxgwcIml5niPLV42APCtnyyN/+6Ha+PGjXj88ccHC+ramK/W/c8AviPM0eqrdv3v+l1fATUmUrB+/Lxiar2F870s/sd0wscWnOsxUFwPQHInPuedBD7u5GveDgDRBSaMSXKo/13P1a6/vXbt2n0pA1gCAJ+j6+COzXjx0b144uAO7N68ESurE+P0rQU8HSgsNXe2EDEReHIkk3glLv4BQ5OEc9phnOkkxmhc8fn1WAec5AmwxntZ1+zJcE05BhFK69QItcCTlY2iKL4vdNB9qECCmiU6BBRQoG2jMX6L/DwkAYgAjp2+iL949V28eXpJ8X8QrkO7tuDnH92Ll54+nIoRMvwLIaJI1J1JAigFPbQoTsVuUMM6Yato91yLfK+jWZ3xAY3nY+AtkE6+zdpkNjKT1wkUfylAg/cebdtmlkLp7AeZcxm8C6H4gDQVIAgC1IQBJPOdN0kxLlMgL86aXTIQ6CIsqEavJ0Dgj46fxasnP8Rr719YDtQH7Gq8w+/9vRcSCwDRmNuxmaaMrdTxT7KApnGZ7cIeAR4htgrGcmaHdwnoVjwgEBDFvhdk7Mcd+zpCMMRCw2eZWEQCg51zaHzq7Dv6Oz6FOWcNAGPM0pz8+5BBv0AOo8ZkNP/4Z0vjv/vmYvr/vMKk7iLWdOWhQq+Pvj4v/u52C8jb0bL3FcVjXmfRjvfYgm7Mv4c++50qyOuYufUWwfNAiLGfdZHvsus+LwKCzAMFWLM/FPE3VPx3AVaLfnddsoK+635MA1gCAJ/D65lDu/CFgzsw8Q0O7t6CAzs260EfVPTbfHrqyEsBD1cZIaEUChUlmP0BQqTJS0VGiSd0Sq9h6UAdxaYu5ybTOW2UnDag7yUfnGJELtqsWZJqi2G1m2oMKCwEOaiFaA0W3UzpM7OQixN7DAGnLl1L3f53loZ+D+olEoEXHt6NLz120MT1iWO/SAAcLbdlfrkMmBVTQaE3O2M4GRWw0o5+lrLMbGaaNiG042hc1GtDPQBElS7AXTG/zJKfaP0/XMXUYZAgxXc6Ixuy5nzEOtI1QnR25J4gtGYBDIV+J4ADIs5euoab04APPryMExeu4gfHzy4H5oNcMO3cjN9+6Qm4GDHJP2vzvJAxJcwS9W5xLpnLuix5QTKS9M6hbadayBfzVpGDiQSsjDdm0CQTTNg4SxPxKR3c0sEHChgg/yvjf9pKCk96bjbCFbCD0whCiIh5r2mFwcAgSE7FmAYCBgH8H//uDVy4ujT+u+cHbOfwzDPPzC2a+mjEYwrYLrnAmEJ33t8PSQ/6KP/zGASL6NbnFfRjn2ueCd3Y72bec9+NsXS797bru10vALBoROCdAACGvqex30dXokCfrn+ej8IQA6C+zp49e9+lASwBgOWFLRtXsGFlgoM7N2NtZYL9OzZj//ZN2LDS4PDurXpgl/itW6HFim90sAeQWSBJABwd1lw9gZzDpGm0Y++c/RsGIeTQ450tGIRurAVJfpx0JwVgCDGiIWNC1d1HOwOEbCpmaL6yFA8hoGka+gwwtG5d6EhiwGCAFEs/ee8cvrc09PvMXQd2bMLzh/bgl58/YmI4Y+QISlsACwOAmSZFApAKH4mCnNnEaHw7QqBk7jnnMA2tGvcpYEU0e51vFUtndqMoKSECkkmxz4CgeoXAxiIWtkMkw8HyXttMcQZFHoYYFJz78PJ13GoD3r9wBSc+vIIrn9zEtRu3cOriVc1HX16fneulJw7gq4/vx0p2upckmogqjtZ5NJmu5n0BAcSN3zmXTfWiuvXLniPzs2kcpu1szK0U/Tq1ssElM8KSHADwTZGIxZBAiBAj2hbZa8NpIoUy3CTuBUlCFB2n10DZeAIUxBgx1ejRwjAoSRfpZ9978zT+9u0lCHY/XBs3bsRjjz02qijpKmTYY2ieS3nNHOhiDAwBAFzILJKPvt5idj2PvxeU/zvRyb+b7/3TACY+TXr+0Out1ytiPbKMPqCiBtjqOdnlndEVWXjt2jW88847SwBgeT0417a1VaxOGhzcuRkbMziwZ9saVpsGa6sN9mzbpBReLSBI91zLAFLxE7RDGa2tmhYGEUW/LCZkvo4OY40yKoaCKb2hiQVmEWB9tukuReqIWpMm3YhAtEt6reiiMYyS/z5+5hJefvsUfnJyaej3Wb+KceBOfPmJQ4b6XzMAJL+8+EM440jOngJQSnRhCYhnBgNnMH9dZUujPxpTO5Bu1rdDvQIApfsXmnSZT3VhH6tIUAfrOyK/O/vRx2gDcOHqJ7h24xbev3AVlz+5gY9vTJdF/ufwWlud4J/82rMAgBUCj+rTihhl+jJo1YPFe4db0yQHm4a0P0wasw2YuRirONpSdLAHDSwAjEL7D5QAkEBo69Jfy4KU/Rajem7oYwkciAI8RCudcZ6K//zfx858hD/64bvLAXSfXPv378fu3btHF7dDncyuon5MkbVe470h+vntyAcelOL/ThbiY6QZi5j33W0AYL0gwKf5enWBPgZwqV3/h7w0+Opj2QyZgHddr7/+OqbT++f8vwQAltdtXVvXVrF76xr2btuE/ds2Ye/2BA6srjTYv2OTLf7zaGtjyHpmGP8AKSDyLDInsDr6Rn0AUNgCcqCqqcyiU2ZasWgoG+e1yypShUb1yIXqnyilruSpx0p36arc6ujw/oWreO3kefzonaWh3+d5frzw8B48c2gXHju4q6ROoDiLQ+MoqQNoAILKsVnGWhU5yGyYSBGeRSYTs0dBluCQJwZLfGR+CHNAYjE9b3KV1EfnYIwWIENJ6zj/0SeYhoiLV6/jyvWb+OBiKvLPfvQxLl27sRwsy8tcTxzYgd988RE0SK73ergyHjNpAfbO5+i9vKdkb4B0NksSmCZ36cUwVubRrSnR8glADvl1GufAOJv31hBWPAXYgE869xwxqJ4B+XN4SswRsK/xHm2IxjOjyQCGgA4eFXktv0YL4P/9u+N47/yV5eC5T65HHnkEmzdvHiz451HMuWip94MuJ/86/q9POjAvr72PEt1Hi66d0bu6oGNAhCFpQh+Q0fd8i5i6jdG3jwVQ+h67nsfM+5x9xewQ8LPI/ZknCVhPasEi399QYd9Hve+L9+vzBxj72C4wp+u1+65Tp07hwoX7x5toCQAsr0/tEvbAgSwt2Ld9U2YPeBzdt2PGMZ0nqBQeIZa4NMCOVk4mkAMbqAh3VSHSJTUQOnM6tAkoUACLEBMA0DSeXN8dpQzM+AHi7TOXloZ+y2vmOrRrC77y6F587anDqVCJeZzHqBFlaqYZy7iOZPglhUQbUmHiYAe0jmVJ2sjj2lPnv47rq2n/taZfflbPNwbZBLA7c+kaLn9yExeuXNcCf9nFX17rvb72xH689MQBTOqx40jWQviy9z4bAMIa/0UY0742QAGDQmRxxvumDRErjSeQjSNxYfwpFDSLJXFGvV6djfeTPahFlKBblalFma/OGR+BQKYB7v9n701jNUvS9KAn4ny5Z96bN/fMyq2ytqyq3ns807Pg8QyexcYgYWT/sIyEQcJIiB8IEPwACfGDn0hIiEXCSJYNeJBlGzwIzMCMZ4yZ6e6Zbnd3VXVtuVQulft67828mfmdCH5EvEvEF3HO+W4ulZV5QuquvPd+y1kizjnP8z7v85Qe4jzwows38Y8/uDBOmudkbNq0Ca+99tpgoFdSAAyN8tPqgLwiyckpHVF/fcBOg/wSCOoiD2ombV3As/ZzV178kyYA1hNdOBSArzcqsY8oWc8+ruf49JEBQ+fBEBJmvQaItfWie/d1MoYm0DShlW9PLXJziIfC8vLyc5UGMBIA4/hCxtaNE2zdtAEHd23H5g0N9i9sw97FLdjQWPYjYHMwl7UM8EOVY0kygxqImV9uNEbyZKseobgCCjEjbH2IVWuMjVUdkUezyaDRUlKPy7dW8cH5a/jh2Wujod84euf+q/sW8dUju/CNE4e4bx66laVwk2ZDMd1aY1JiTFf0SXKvTQObGGOGjE+jPmsdayl90iJ1u3rnHqbO4/bqg1DFv7ky9uOP46mNLRsn+Dd+5V0YeGxQD3vcKgOZxyERQ/wynBNTSZqXTfQGcORdk1vBaBPANHGz8pCrK/ziwu8zAOKiTB9sKCvrk/xtqKutMSHiDwZovJAJU/2oploWDABnDf7b3/kJHrVunDTPydi9ezf279/fCQyGGLr19ebPY5w3D4AqvaYGXJ+G5HyIEWKfQ/4QkN0HiOdRKvSB9j6yomvfnxkonGPuPInPGfIZte8ampQwhIQYSk7kCQRdhEhpvnz88cfPTRvASACM47kcuXpg/+I2HFjahs0bJzi0tI2VATMeAPx81J8ZS+0HRmWJk7s0INUbfmB08QFSVVHfO3cN3x0N/caxzrFjy0Z88+genDyyG8f3Lc081OkkCmvSfmV99dbO6Emfv26HUW7+rGhR64aUAldurwap/uoaVtYe4qPPb2Fl7eEI8MfxhYzX9y/iz3/rOIzzsMp0NQa3htlPihlj0JhgnskpG4qs1UIyInfpDkLQWcdp2vgdxnt4jrGMa82D30OeHQ3FwUZlwiMPTExYd2QMaylOFzFJJu6MZ0YhJfmaSGa3Xloc+BoBwMHg/37vPH46xl4+V+PYsWPYvn17FbSXQMwQYDVzf0Ddqb/r9+sB0M+CAJj3s+b9/seR4c/z+j7wP5QweJoky5B9nqfKPiReckhMX21O95ECQ9UTte8pqXGGkndDCZLnqQ1gJADG8aUlBw4uRfXAzm3Yu7AFk8Zi68YJ9sVYQ93P7PlhT8A/r4Bs0fLDX3zgm2ZVlbPX7uCfnb48GvqN44mOdw7vwjuHlvCN1w6hsQFEUPzZxIaqoHOAtR4Ws9K01isAQg79SOM5YQyu3FqFA3BreQ0rDx7i4ljFH8dzPv65k4fw9WN7sAFQvhNhZrfRQHMS41/JjC+xnvGksElBfh4jK8SywQZj8DCqBED/pYjLaCBACTUG0SNGJ3jEP5BBIanIGjINVGReY4MCZ+qiisF4TD0widGfen9glVmnsfjw4k38ox+fGyfJczQ2bdqE119/fRB4y8F/DYBpSXKJUNASf/1ZpZiyGogaGr1XA1bzRNUNjWzre/+8gL7rc/oAe9dnrQdYz/v+vmM7r9/DeuIZ85+HVsBrAHpoLOB6WmT6zuEQ0q0UtZmb/w0xE6TvWl5exvnz50cCYBzjeBpjx5aN2BONCfcubMHexa3Y1DTYsMHiwM5tCe5PDAQ5G13komTQdOn2Cj66cAM/OnttNPQbx1Ofv984ugevH1zEG4f2JsZ6crNL0ydgUmLr8u0VtA64tSIgn/rxL9wYTcLG8eUau3dsxl/5xbcAD0yUA2taGUKokrO83uNRBPQWUnXXen+D0B5gC431FgZTJgDCZ7T6++jhD9SrH15L5EDr5b7SRtKAWvld8uDpOQpTL/TWAxOLaOTpWbUAAFNO6zD42//vR7i1ujZOkudpvu7ejYMHDxYBQFev+pDe+K7++yGgeagxX97j/CQJgKHAvws0ridXfsgxmhfwrrfVYj1+ATUSoe8z+o7tPAaCQ8wi5yUxhgL22v7k6oC8f3+Iv0LJYHNoukDfes1/99FHH6Ft25EAGMc4nuXQrQUaMGW3B2hrv7v31vDZ6Kw8ji9gHNy5DVs3TtA0VrTPvn4lv/dwrOKP48UcXzmyG3/mncMAPDZAImTpGt7GXvuJNaGi3jpMI3CnBBeK3zNGvGBIvs99/PETnfNwNrTMUK+9j/4AjVIAmFj5N7HXgLaBDP3ouY90ZI0J75+GmIGg7nGe2wRcTNyQlh7Zbt7eeC147/wN/N77o/Hf8zaOHz+OrVu3zg0c6HV9EuS8J7kPfOfkQl/1fx5wqz9vHqD/pCTtXUB9CAifRyreZ3LXd277jvOQ8/0sWgHmbQ0ZMq/ned88BEAXSdMXrZkTAEPUFfka0n/LVTi1ceHCBdy9e3ckAMYxjnGMYxzjGMc4ukZjDf7t3/haANTeYwLp73cRJMOE3vwkjo/NMCXaD15X8KOxoGoRoAcjp6L7LKSXX16j2gbU+2xMKXBJpGDk8JwvPnR59QFGKXrCdgYPAGsAZ0QG/l//Xz8ejf+eszGZTPDWW2/1grou8NVVte8CuH1kgE4E0K0BQ+LRngSAe1rgdR6n/cepPve9b57WhC6J/NB0hqHEwOPu17MkAoYQU7Xj1UVy1ciBGunRRyzN2xKh33v37l1cuPDFE7cjATCOcYxjHOMYxzie+3FoaRv+lZ97PVbVPTZGWb9ToNm7UEE3uk9G9+sbcIyrV1J6gyjxj6SB87EqrxQAMCaJi22p8q+IAv1aihPkVBpjYnXf8zZbGNxYXQsqAA88bFusPZxi6j0eTR3uPZhiee0hvAdWHk4xnbaYOo+79x+OHjTP4SD5f59UvC/+Tlf4S73PXYAzjzurgccu4DlPdvy80v6+bPra9w/9rPVG6c0DPoeoCZ4k4TE0EnK90YZDFAl9r+s7R/P26fcpIvraG0rnqGa6WevjH0LG6AjBnISrHY8PP/zwC28DGAmAcYxjHOMYxzjG8aUYXzmyG7/y7mF5iIlVfRsN8xprIjh3bLxnKKov8crw0RzTJxJ/+ptTcgDjxRSWPGKoDn9tZY0fph5OW9x72MI5h0etw8qDKVbWHsF5j9WHUzyatjAAHjmPew8eYfVBAPDOj49hL8o4fvw4tm/fXgQYJbM+XY0vVSc1qNfv1f8eCt5KgKQm3Z9X7t4HRmvgqQ88DgXgXYB1vdF+fWaJfcSB/lkbOJZInXnA71CiYAjh1BeP15c00XUOa68d2mIwhLAorZeued1HPuWeAqXzVVMjdPlm5Nt+/vz5L7wNYCQAxjGOcYxjHOMYx5diWBNaAQCwEoCM+ijFRUz/PJzzEbyL9N67IKe/ufqAIwMftQG8t86FyvvDKe6uPeK4PQLwI3gfR21MJhOcPHmyCtT6gGMXuC0Byj6jvsepQg+pfM673esGKnNm0/dVrId+T5dvwBBPgT6CYEgF/ln0/A/5nq759Tj+BH0O/ENNEPuIh6Hf1dcWMNQnoI/guH37Ni5evDgSAOMYxzjGMY5xjGMcQ8bi1k04tLQteYgx2YONHvcePsKjqRvB+zie6tDu/30EQKnirwFE3qOvXc27DM9K312qmta2pwZuh4Cy5vYFiwAAIABJREFUx4nE88/BWhwaVzhU2eCcS4iaockMj9Ne8CzNAp8k+TCkPaAP0NfUHl0RgvpY5aSa/jlfI1rRUTunfefogw8++ELP00gAjGMc4xjHOMYxjnGMYxyPMY4dO4bt27cXQXcNZNRATJ/ZWw68Sw7kJUBaSxcouZuXQFaNOOgjI+ZJHZjHjf9pEQDzOvLnf9dtHXkkXVefeB+gnedYPSlwPuT4D0ks6PMPWK9nQ1fVvmSMqcH7kJaCfI2tl6zIfz5//jzu3LkzEgDjGMc4xjGOcYxjHOMYx5dtkPt/18P/kN7gEqDOjfxKICX3BNAAlIgHAkR5ZbME7Gvgrg8kzlMxHwL8nlVFe4iR3RACIP99jQAYkj0/5Bg+T8dnHrPBoakYQ+MWS/OwVo3PVRmlz8zXU6nqX3rv0P00xuDWrVtfaBvASACMYxzjGMc4xjGOcYxjHOscu3btwsGDB6tAsdZPXAMReUW/1p+cmwnmoGNoFfdJAcj1eAc8zmufKWBS4L1vX/PXrsekbh5Q/TSP13o+f17fhiexfSWVRJ/5oa7ql4i62vfUzkfJRLBrbXyRbQAjATCOcYxjHOMYxzjGMY5xrHMcOXIECwsLnQQAAXUgdRbXFf6cGOgyocvlzfS7GlnQFRtYAmU18JmDnL4qaO33Q8wLnyRZ0dcz3vW5fYCvpM7ICYAuImZoRbxvu7qImXlSD+bZnnkNDEtu+0OIoyHqga7PrbUd6P/2tWeUCJ2uc1Bq/dHb9tlnn2FlZWUkAMYxjnGMYxzjGMc4xjGOL8vI5f8lENAlBSbgkUvFNSDpAsP6fZpcqAGQoWaBXTLqLhA9FDwOqXQPeX1XVF0XYBzir6CJla4Yxtp7am0d9Bn6XPURKENBce3YDY1J7NuOrp77vjmUv6aPhJnXl6Hr3HaZYdY+uy/6T48SedCVLOC9x82bN3H58uWRABjHOMYxji/Vgx/1hJkQO7Z90yS9qub/5ruA/Ox9uBHcvvdwPKDjGMc4xvElG0tLSzh06FAVrHX18OeV4hpozwFkzUyu1o8/RCY9pLI+NMP9Scuah6oHauBxCCGRf26tr7z2nqEGcaX3l3wZctf59Rr/zdN6MfR895E2QxUVc4PWHiIql/bX9r8E8GuEV67w6Nuuvs/Lx09/+tMvpA1gJADGMY5xvLRj++YNOLC4BScP7kRjDSaNweZJAPF0md84aVKJpXcwMLDGYM+OzTAGMMbC+fgwBrrQe8CYcIX1Hsba8KOXbHKoz7ux+iAQAasPcOveQ1y7ex/Xl9dw5/5DrKw9Gk/WOMYxjnE8h+Pw4cNYXFzsBaw1AFSrYHYB+vw71pPjPi/omBdIP0ng/yTAYl8OfBeIHWrkmH9PTRlQGiUFyLyV/nmO4bzz5kn065fOwxDVwno/v0sp0gXOS/3+pW3vM3AccnzPnj2L1dXVkQAYxzjGMY6ndsEzwBv7F3Dy4E4sbduEvTs2wyCTopkA4p33MAawJkr9AEwaC/iQH+4BNNbAe3o/3dwD+PfOw8dLLJEEclNw/LNzDsYaJg6c92ishTXy87W793Hv4RR37j/Eg6nD2WvLuLGyhlurD8aTOo5xjGMcX9Cw1uLtt98uPviXnMNrYKQvD74W59cnO+4yQusCx1156jXQ3EUy1ADsEMl/H1DvOrZD5PRdoDlXY3TJ2elc1Pq9+8D5PITFPOdgKHEwRFnQR6IMUZ10fV7ftvWBej1P89i+0vkZshZrpn6ldV5rA+kiNW7cuPGFtAGMBMA4xjGOFxrwH921Ha8sbcWRXdtwZPd2WGvgnbqBI94sjGHg3zoPa8BkgI+fZWOlP9w0wu8MDIwNlX5rwvudc1nVX7ZH/h0uv877QDJE0oBvUAhKAaMICX0Tstbg1soanPe4ufoQN1fWcO3ufVxbXsPy2qNRNTCOcYxjHE95LCws4MiRI70gokvyP7QHnkBMXsEsuZiXwGsf+OwCYl0Gan0EwDyV0T5SYKiRXR+5MmT7S0Z+tZ793NyxD7SX5OklcqHWstHlPfCkCIC+udy1b/O0Xwxtaegia0omfrWoxZzMqX1+l+t/3/rLPSK65uba2hpOnTo1EgDjGMc4xvG4gP/Qzq04vGsrjhHgh4/AOwD91nlYG6vzSCVeLrkJhQu5ZbIAsPH1rXN8BQ3V/PyG4tHYJrwOHsYIGeBcC2ssEJUD3kMIAEOXZgBRaWAANMQwF24+HoDlzwmvurG8huUHj3Dn3iOcv7GCjy/fxsOpGyfJOMYxjnE8oUHu/31jXpDYBbb6Kuw134Eu8D2P8/48WfVPok89Vz10vX5oFX2oH0KNYNAGfjVVw5D9yYka+rkG8LvOXY3oqe3PUPVA7W/raQ+YV9I/jyFi6W+1pIWS/L8E2oduc5c3xZD5eOrUKaytrY0EwDieJCAyWNq6ETu2bMSBxS04uHMrtm6cYPumCbZu2qBAS1wUECBCEhrnPZbvPxRg4j0eTFue1K0H1h61AICH0xYPHrXU9gzvHZbXpgyqHj5qsfIg/Hx9eQ33Hk7HkzSOxxoLmzfgzQOLOL57O47u2Y5GP+jAM5Z2LlTNrQmEgJb5G+rVB+Cosm8MvCdnZhMBPd1gg9SfyAVqE6CrquEbgYV3Do4APLk0eyIgxAMA0R8AXkVFeQcflQU+bqCBYpNprVqTXsy9Z6WB84AN/AROXV3GmWt38dPPb2H1wbj2xjGOcYxjvcNai3feeWcQeKmZufV5A9SATgnoa2DZZTxWi3qr9bt3beM8AG6IU33Xvj7Oc/DQ15XAYs21fh6w2rVPJQCaf06XumKeOMO+ebWeYzuU9BhCGg2Jpxx6/qy11VhNOtZE5NTIkTypoWb42EV+ldoD8vFFtAGMBMALBPK3b96A7Zs34I39C1jYshEbGot9C1sikA83hjaaj3GkCXyoaJIs2gbA4mPF0kbkQMDERImzrnL6CEoCoAGmbcuAxjnP/dHUEx3U0gGAnb2xgs9vruLCrVWcvb7yhThhjuPLNbZtmuDg4la8dWAndm7diH07tsDa0I9PoJmBsgFgAhhm4BxL5UR8+QiQibSyhsr6Nq4TqsanUkr6PQF9QtzULqBJBfIW8N7DNjastdhawL0EsR0ACK0GNqoMjImeA7Q+o0dAYw2mrYP6Gr6ge+fDPnkiC9K16LzHmWvLuHhzFaeu3sWl2/fGiTWOcYxjHHMMkv8PBUddGet9UWw1sFKSKJeq9zXPgCFV7xoIX49RXe14lKqk88rpayCuCyzT92iAnx/HGglSq/4PeY6tkQ0lkNklye8zL+xTkPRV0OfxiVgv4K/Nw/XMv3x7S9V4fey63PtL7v9dsYf5PCr5gOSxnjS+iDaAkQD4koL8w7u2Yde2Tdi6cYK9C1tYoqwnJU28AP7pRgG00aRMQHuc4AA865GjAqBp4JyTG03sdfaxGtq2oUI5mdiIf3wAJRF8icEauGLaqgXAPdVxKp66uozPb63i9LVlXL5zfzzx4wAA7Nm+Ge8eWsLu7ZtwbM92rt5HXI2miWytAVy03iMwbq029VMtANoDAIYb9ENlnYQDZO4n81VfPV1cN+QVQCoa532svAt7PGksz31SCBABkCgAjKwxSRSYjQpyACyA1jlMmia5lAcfArCPgffhdY1qZzAGaNtwLbh89z6u3V3Dh5du4/TVu+OEG8c4xjGOnnH06FEsLi52Zpf3AeK+lABtXJYDiBzYlr4zB3Nd8u4a+Op6Lq0B+xrI7QKdQ439ukiHPhDa1xJhVIGs1u9f+syaP0AXoK6RE10gs4tE6gPMpZ70PiA/lAAY6h/Qdz77yKKhBEDJuG+IV0TpvTkhVdrv/PNrxoBdhMjp06dx//6zwz0jAfCcjkNL23Bk1zYcWNyKXds3Ys/2WMmPYMSpyiUhHXIlB4C2dVz5J0AQKvASb2atGJmB3cpDxd+10ZncaEmSh/eGo8woEs0am4B8ryuh8Xuc8ymgiTOPAI1UPsM7WwdcuXMPN1ce4sKtVXx69e4oWX7Jxu7tm/HuoZ04sLgVBxe3JsDVKFk//Q5R7t9EkoonelQAcHXfCOFFKhiakqyKoZsxkQCRSHBeqAWdDkAXUstqG595CRCBYHi9iZmgl8uw1w8h2YOTgdoaMGHQthHYiwghknxiSsiqhbhPjRVTQR97Huhace3uGq7evYcz15bx0aXRN2Ac4xjHOErj3XffHQSSu9zja+CtK8e8JCfP+8e7jNsepy9/Hil+lyqh7zsfx7ivK5KvCxAPISP6gH1XH37X/tYIgC41Q5/iYIj/Qx8hkFe4c1A75L3zzpshhFAXoVI7133S/RrB0DUfh3537Xzofbhx4wYuXbo0EgAv2zAGeHP/Trz9yhJ2bd+EfQubudcYXsnoASj8LIA/VjR1VTHgifD3xiqDMO+TvmWS+TvnMZk0HGOmAXr4XscoRCY0vQYM5L3zaBqbyI6TCzs8LEIF0xjtyB6+x5EDuxdDNu+By3fu4+ryGj69chfnbq4wyBnHizOO7d6OE3sXsHfHZhzauRXGA94EYqh1RFyJat478q4I6hRqL+EbKgwcXDLPNGCnnn5D3gCq/18u0kbeEKvpjSKuTFwI1Kef4HWq6sc3No2N71FkBgKhR5/lEUg1SgTwcS0aIvMimZZfwsN2gYkDrvArbw/AoLHyoEFERfBGsEys6G3+9OpdnLm2jA8u3hxJuHGMYxzjALBjxw4cPXq0E5wOBSRdoKMLeJTAYl+veMl8bj3ga14CoO8zWdmWeRh0vbYGZEvEiH5/LsOugfA+QP24BEn+GfMQEUNNHYfG7PUd3yFgt/bernaFxyGh+to/ai0o5A1QiugbkhCwnrjEWmuC/tv9+/efaRvASAB8kTeQzRtweNd2fPXILry2f4HNvHTfMIMVrrgDk0bHggmQAMyMxFgDHucFaMPrmIzwDh/QFKiYypNYVfZz51MCItYGwJKyibKdzkvbQdpDrUxrGDwp+XLc9jZKmoHgwg4Ap6/fxZW7a/j81j2cvbE8TqgvMeh/59ASdm7dhP07NovCBUHizhjchJ52ssOj6ja8AGlqBaA2AOeBplHyfL4ppix9MPOTOW/jWrPWYEPTcLsBtdHQRokxH60hAd9EQGjzPvInSG8i0RQwVuGnbRtAOr3Xy7VAyD1R0tCa0pQAXT9a8gJwQgSQj4esz0DsTRobEwpkH/kIOQdvgLPXVnD+5go+uXwH15bXxsk7jnGM46UcR48exY4dO2YAQakS2iUPH+ILUPt9V8zYEEDV1XteyzfvqpKWPncIyVDr09bbUQJffRVbve19UX59x6rmED8kEq8LOHapO3JlQc2sruTt0EV4lIBv7fX696XjWdu3nIAY4h8wxLhyyHeWCIC8J7+0n/k6yttuSvvfpUTR39Fl8Kjf9+mnn+LBgwcjAfAijleWtuHVvTvw6t4FvLJrK4OYNF/c84M5PdwLUI+u3iyBVnmTETLIwqOLhudoMGtMrF5KZRFGHMXD92FmWujKptVAIqvCO+/Qxu1vrJZ/0QVZKo/FC2JgLti0zcGpimrcNi9V3kBOAFfv3seN1Qe4eGsVH1+5M8qWn+NhjMFre3fgzf2LWNq2CXt3bAZggiokztucACBATUoXWQthHtBcsxbKnV/mKzL5mr70No2oXPjv5ACrovuM0fPQM8kQ5qmsUQbVHmiaBt6FdhqnTDABAeUayFNLjb5RNDFpwDlwKgErD4AkJUCvayZJnGOCwbBvgZAA8EKAkDKBHhD0euX9j//45PId/PjcDXx0+c44qccxjnG8VOO1117D5s2be4FuFyjtAzk5UBsC3koVz9L31oBnCTDqbZmHAKgB23lIChrT6bT4/bVjoF9bq1L3gech29p1HIaOvnaGIQ70eX96jWiofUZte+RZwCbV8dr+DyWKhngAlNZEn/dBbbtKBEAXGVb6nHkSMUoGk/p7tDJFf+bFixdx69atkQB4McAO8Mb+RbzzyhKWtm3CgcWtscrnBNgoN3Atx6eHdgHhMesbIhsORXSDtvWYNGFCTVsnMl/4xJCP5ctUIYW4kZPBmZbqa7kzEwYzF1EkKgPajzaaB1pr4aYtmkkDxKok0wpeHMphKMvco20BGD9j9gYfgU4Ehx6xL5tuXPBoPXD6yh1cuLWKD8fs8+dibN7Q4I19izi8axve2r/I88sYgzaeW6OAuYv/awBMyKE/znmJ+QteEY0lQgowVjni67XFQBowSk5vYGKLgcj9rTWJhwYBZk3CEVg2Jqwkbh2AGAsSsOYHmNirLw+C7LfJwNxyMkGqcnDOMxFA+9I6x9ul2xGImGPw7mVbpq1jIg4JKadvcuIhAmNCKgjFChooxVC4mX52fRnvX7yN9y/eGif6OMYxjhd+bNy4EW+88cZg8FGqhA5VBNRAtAb3NQXC0Kz7oSC8D3j1VWRr4LRWldf74JwrAvWax0L+OXlvfumc9EnY9fvybR56LrvUInmVeAiBUop+LIH/vhaUrghEAsz5sZqHEBmaNlCLS1xPJGDX95cUHUPTFfL50kWIlIiZLkLk7t27OH/+/EgAfFmHSPuXcGLvDoS+W6kk0kO806Z8vIhtABWx2Z/i+XRuuGHHcQIPJgFUBvlFRbUVGOkVDoZ+YhKm4870zKAeae7n1ws1gnht0EaO4xSzZo2P/fyhKuopZc2IOkBIDg/X0udHJ3UjlX+XLMYwhaetT2a0iSVkimP76PJtXLx1byQDnvHYv7AFBxa34sDCZrxzcAnK6o7BvqPfmQjM1d+nABoT/jf14b+AwVR5RBgjoFQb3LHRJEzi4K8j87TMn8kACCBv1HqTizQiURUUO7T+aP5TCw79TG03ZuahRda/1T4B2c3AabAOWTO0vYBn00EDwESZIK1VrxI9PFSyAGKsILcOtZg0TWI8qONDpf3BJMTktHUhgtFYXLi5ig8v3cb3z1wbJ/84xjGOF3YsLi7i8OHDvXntparhUPA9xFE/N2arkQJdows01gBaDVT1VbBr31HzCsj3kxKp9Ofl0vjSZ5cM83LTxC5lRlflW5MLXQZvXSB4vaaBpe0vnVcCoaV0g5rkX29zrrzoOh41cL5eAqC2z33JA/ocl46zJoRydUDNE2JIO0yulKm1GdTO67OMAxwJgCc0DixuxYl9O/DavkUcWtoaq+D64idO+FzlgzzcU+9/ScrTqsreJJqIASaJMYMCNXJyTQHwxNpl4WYilUANRhRAV/3GenLTBYXUC/QRpBoQwzHH++E9QmUR4Kroo+k0wBPjWa0QDAMNWk+90FBGbUH+33qlBohbbpVTvPHS93z6+jLO31jBe5/fGsmAJzyWtgbzytf3LWDXtk3YtW2zkrfLrJTZFcBoC5H7+6hqsRH0WwRZf6j0Q4HX0NvPTnsgYkuk7TbJehVuS5IAiDiw0hdfuMnYaDBA8zon3KBk9wl77H3Sa2CQqnmQAXLt7pneBLM1p1Q25K8x0dUNIwQjXxfUScgfltrWsaKICIZJYwMp2caHrvwGZhBTRTwaIhEhZN3vf3QJf/Tp1XFRjGMc43jhxpEjRzj+r1Rxr0XIdUW7dYHz/JmrBIZqldKhjvFDSIkS0BwC4Eq/L1XPNXgisK/f27ZtP6hRx6Wr77qvQlz7uStrPs+BH0K05AC0FgU4dJ6UjsUQwK+PuT7HNJ/z4zokirCLGOoC9n0EwJDPLVXp++IOhwD8Lp+PLh+PUqtJzU/i008/xdra0/dYGgmAxxwn9i7gW8d348S+Re5DDg/pDhMykFBVbqqaEyCgPn9jpfc/VQoY7tNtGovWKT8ALdtVZ5RjzVRlUpvtNY1lUz/NpIkjeSQeYqU16anSueQM7mOlMgc3auIHWXWLEDAgPdG0v6HlwSlzw/j+GHWYVPld3FbrMZ1GqbgFLCymBIg08aE80LW9wZnryzh3cwXvj2TAYwH+1/YuYGnrRuzavhmTuAamzsHCwJNDvwL/1DtvYz/81EumPRE5wc1erlDeqIq3AvRQ/fk63hLwCXNNQNt5WnlB1UISel3VNmpx6SQAAbji/M+Sewgo1zGXzldujnGuQyV30Lq3RowvTX6DztqCWhc8A6atS9aw18Se0UkBoUXGmtBK4VGIaFJpITCGey8D4aAcpCnaMyMtnEOMEAX+8JMr+PH5m7h97+G4YMYxjnG8EOP111/n/v8cnA1xhp83ErD071pvfs0jYKgj/7MaXR4IpW3MAXIXmKoBuFLVPzfWq7UXdAH5kgKgVgWvJRB0AfsaGdMHnruq0CWyIQf5+riVjuU8BECfY/565uMQY8EayK+1GnR9z5B2k751PoSI+/zzz5+JD8BIAKxjWGPwlcM7cfLgEl7dtz0+tNuk0t62Dtam8mMAaEkGr/rkDRvzERCIJIATczCo/uIcoFhlJOaon1r1Eofv8TCQ77TK4MsolzOqArI5oHIxJxjkYZKoMSgTMyFAPFdGrbGRWKA4NhdnXviiR5HVzQ3IiBhovY9936HyGwBmvPBG0D+xYd/bKBW3BnjkPBoIcKTj4/3sAjh9fRnnbqzgp5dGMqAK+Ldtwr4dAfDv2rYJu7dvTuLlAKnsEwHF5pMK/IfefgXKAbQANhgB2LoNhdZRAL/6wioSj2A6Ca7U28QAiC7whgkqq2M1nShKfCQbGlpXSjqQp1v46EGQrnNRI2hzP9r+tL1GVf+R3chUioFV/h3k2cHKHLUtjbFxm3yRFNEpBmwSGskD+j5qxWgjocdknjIS1eogF9eyhbREkKGgNaJ6+u6nV/Hj8zdxayQCxjGOcXyJhzEG7777bhXA1HqyS4CiiyzQsu0acCt9HzBrblf7zsclAdYT66b3o9beUKqo56A/VwOUKrBdZnolYqCLkKj1f/eREF3bN6Rfv0To9M2f0rGsEQS1z2Aj5MKx6WsBGEIKPI112Qfk833LyY8utUwpIaCrnaOPlOs6h8/KB2AkAOYYmzY0+MorS/iz777CILvlh94Acq01EWyDAX8DAxsjtryO4oMp9omlwMVwtZEf3rMLmjViVBYexmMcICkDCmeZXNXTqYDqRYPBkfcz1dKSXIfAvomlzdAbrU39YouEJhKyC75zXpmxiXv5VHsEOCISIrgk2bgxaOFhI+ZqWFUxY3GAlkBf/P2Z63dx7sYqPnjJyYAE8G/fiN3bNjPI9Sq3nv6PjquBGMtNnZA3VNB35PgPjybOuzaeI6MxpjbVi/NFfx8BbWtlXZCDPvll6H/zfGUQna0HiMHkJEb/JVF+OgmAGYPUdJC2CYjtCMqLglYzK3T4y+mz7azcHlBy0rS6T+0HtJ2NlfOiY/5otLGXv9EAnQ02qZIBvn4ZlTTinIMLiwwmtmI4WtOpM6KsM69bccIff3L+Jv747HVcuXN/vKGMYxzj+NKNhYUFHDt2bOZhvwReu8ziaoZupepsnxM6tWCWwF2XId+Qnuzae2tAu7RPNSDaZVqY/5y3BOifhwDDEiFQA4c14N8V7Vj6eUiMY+n9JV+B/FzWohPz5/i8h52esWsmgHnPf94O0Afwh/x+qBqg79z1KT70cSylQ9QMALvIoNo67vPD6EpwyI/J2toaPv3005EAeB7Glo0TfOe1vfjZE/tif2wTzOoSgy2TOvb7NDaLpbEmkAQ2PEUHoBrl+MHEa1YqRqDBGgsXYRQX3lVfsPc+URJoqbRXFUen3PfZYE99n+Sre+gMtDx3XCatgVH6fxcd+4wBjFeAx0CMBJH3KXtFHvi0Z9w7jn+Tz9EXBYoZNCxJ9t5g6j02KFm1V0ZqTgG3aYxQ3GAECBFwOnt9GZ/fuYcrd+/jsxsrL3RV48iurdi3YzMOLG7Fzi1B3g+kLvXwukVF4ijbCCQbY9A00ZvBCcrlSjQMHsBjoogEPeVbBRp5bhrPcvVw7o044keATzSNVe0sDGQjMLbKZ4O2iVty2NkeM2ocUiUERUBwK9Dbp+8ZNL8tk16ZYofj99TNIv5dhAE+matkskn/dhGwEyFgoiGhJh90MgC1JlH6huW/aUJD1jWZCmqiLxh4ehUJSIZC8UiSyWe8DnJrgVIskNLIA3jvwi384OwNXLpzb7zBjGMc4/jSjP3792Pfvn29QKHm8t8HHEpAKAeCOcjsIgC6Mu/nAfkl4DYvCOrbhvyzciWFBsEayHZta5c8f7YNNt3vtm1n+vlrveKl6n5NCTLE5LHkZVAjjPSxqJE4XXNNf1aJCKj1/eeguGte1M57X3JE3zHrmpe17a2RJH3fXSKBhpJoNcKhtjY//vhjPHjwYCQAvqixZ/tmfO3ILvzc6/v4gZgfoKHdu2OVzkseuffAdNqiaYy44Yt+Ofap2xDN5UK7gKUueqMvTDYBWroaz47dejIRELImixQTobFcTEzSr0yqAA8tFUbiN5BM5rifZP3H/ftJnzRgIqBxSj3QWMuAQUcMhqp+SgKwb4Ahs8FY6SQSgOTSrU+c/9pW5NOONlhVUZ1XFdXIqEgcXdr6AAA3Vx7g9v2H+Pz2PVy4tYord7+8Vcztmzfg4OIWHNq5FTs2TfDmwUVpwYhkFQBsmBg4p9IXvEnmhVHzYBor+tb4SAjESr8B+0MQOUMtG0TGNErZooEsvEfTRBPICDRpHVkV+2dypgEpkG/UnJc1rC7GsvBiqoAV0J+sv7QXTvt5UDvEzI3GA95IWoZX6J4q8Nq8EPAwXowHvUsYOvbpoLVEiQVU4Vc7JNJ/eGUaKkRdohAyUtk3VkhGrr4grE94TRQ43p/WtRIpGo936+Q6MmmEAEDcr9NX7+KPztzAhZsr4w1nHOMYx3M/Xn31VWzbtq2XUO8C3kNM83LAX+rjzgmALkDdBb7XK+XvAz1Deru7trcUdydku0te1ye57yMvavtS6+nvIzq6PAVqCo4uoqVWSR5iuNh1vPMKv6781xQHtZaJobL/rir+PPvS9fl95710TEqy/i5yY8j+lkiugoPHAAAgAElEQVSH/FyXvvfixYu4efPmSAA863Fs93Z8/eguvPPKTpB7f6setq0JAd6UH24UMJ+2FJUVMr9NdLBvmgDwQzU8IB+S8HLbgIngyYVTo3O/CVyTDF5UzbESx6BaHNBpuydN9B9wJKM2SqEQKuzJxIYyMDcK2CgpNAFFNlzjXHANPATIUwSggVRGrU2l5OH46Rg1j6nzmHAUoktAmnMaLIZc9UCKGK52andzrf138X2NCfLz0Jfuo2Fg3D+EPmjCX7mi4uryfdy9/xDnbq7izPVlLK89eq4B/4GFLXh930KIqVzaymoUOkZyg9E591JJ9zPEiFw+JtZgGlkVatmYxvdZTSy5IDP3PoB3Kr4bKwqOAN4N2tazAz9tV9MYnpvGBMUAzXejnPppvnIFP6LZxjaypmxwJnBeKvz0PVq9wykAXjng6wcDMjGklIJMHSGfKYZ/2hfBRLUAKRRcjM6k3xv1GXmqgCSCiNIgf+gh7wGjJ6/JEzW0uSe4nYBAfGONii504VoWP5tVOE5UE877jI/xHHVqIyPA22UNvnf6Gn50/hZurT4Yb0DjGMc4nstR6v/PQUKX9Lf091KFO01Wmu2FL8m7a4CnVvWsGcl17VsfEBviyl4Cv33u7znozx3V27adUV709esPAWsl0KbPaw6eay0AXWqEEnFU25Yh/gKlUSOj8kq/SZKTuhMTutpb5gHxQwiAPhJjCPlQI3Rq57OktOjzehhKbNT8QfR7b9++/dR9AEYCQI3jexfwM8d34fie7Swl9lnslwBBkRE/atsQZWcs2tahsRSbAeUUHk3qXJDpc9++IWdzy7JcyjFn13FlqsY54F5OIGac+mNLQDRG8z6NRmNzQCV/bqxNKr02SyvQyQR+BhCH7fbqQqCBmAZs8GmsoItleB/JCTJPBMD9/4BUO1vXwrkArpyTKawXm+PP0gsxSp5jvz95BbTxfw3Czyr8kKu6DGaMVLDZNE0B46vLa1hee4gz15dx+toy7j2cfmEPKYd3bcPeha3Yt3UjFrZOcGRpGzyM6uoIhnq66m5NmpLglMpEV+apmiytK4ZBPQFHWEl4gOJeaF6Rw7/ge3oYkGhMa+W1JmbNc+tNlJoTIaGvoyxbj/OiUXMyyOVlnXiEdA2vevUNexCInB2Zm7+L7TYyW3w0+lSu/rQ2UXvgSxUUIqtXfgpxzgeyKhKIzsM2wcwTymyRVABQAJ7MP3WCgFGqG3kQzNlvpRCKexiuER4mqhl0rCkRA8YL+CcyQtZfIBsbo8lBdW31wB98fAXfPX1tvBmNYxzjeO7GwsICjh492gniS/nsWoo/RB7dBdryqLlS73xCAA9QBwzdpr5qcxfIL1WNay7/OTDT+66PpwbNebtEaduGSMiHvr4EkEsxgLXe75JfROn1XbF9feeyy+wud8QvydFLZn81sqvWItBFrNTOwXo9J2rbWWufqW1bF/lSIu2G7EdtTtX2+d69e0/dB+ClJwCsMTj5yhLe2rcDr+3bwQZXhhzxkZryOY6myx0eLQP2SdPAex/c6RubSKut7htRxnrWGjQRnGjQrMEKoXAb0Rb31xokD9NI+oZNjAhDrOKRg7/nPPQAukgl4JLqXz5DcsOzmdhCJfFN/y0XIariPor546awCILkOICOaesSsM1b4eWYti0UyRH/7HT0H1WIA6AkY8DWA1MAG6Cy6HW7BEh+HqLpSBFCgMvGuDrdjkHH7PrKGpbXHuGzG8v49OqzIQT+1Gv78Z03DoQ52raYWM++Es6FY+Ii2CcVSVoJBtqWyJmwz8bIPmuATW0etjGK4TbcPgADbGhEjUGO9vDANPph0OdPW1ELgKT9zkaVCaLLf5jLTZPOGkcpEZa2zyYtJE2MB6A14lWJPzfK06YEtD5onmtyrIkVGoc8bhOqnSU1HNTEAN9AbKQwVO8+EStEhJAvAKlqvDL8lAcgP2N4E86lStRglYNP9kd7EliTEhj0PRJLioQlSlsEoty/Da+ktBG6noU2B5e2NOgHWy+tIr/9owv46aXbI+IYxzjG8dyM/fv3Y+/evb2V7SGVQE0I1KLYav3LOTlQA/l9cvya+/zQqmvtc+cdNTVCV4ShPma5H0Ctj1srKkoKij6Q1gVS+5QdfUC4BgpL39v3/iEpCKUe//zzS+0BXX4PedvA0PaKoQTAEPIAGOYBUPtbzfk/386SD0RO/JX2ubTOa/v14Ycf4uHDp5ec9FITACcPLeFf+OphGEMP2wqwRldtyQ4nqb5U3YK5mIM1DYN/y2VVMOggab7E9ZkE0ObggWPDVJM64xKjiABjogTaiJN33s/L8vpYVY+99E2s+k9bpzwARGHgK8A89EYr5tVLb7N2MDdQDd6FiU4GYpSF3kbUqZldOt7WBmWFmWFNpb8YEdiLeiBUKhn4IkrPHZ3L+HufmgLaeAZY7aFM26xyRfcmyN6pEmrUuSUAmOSvA7i2sobVB4/wkwu3cOXufaw+ePKEwK++exjvHt6FpnVobJp3SEaJxC5R+4YmSIwiBBLzv2Seepbj83QzKUHk47mQqjOSFAutrJm2niXs1gCtQyLnp/OV3oDMjNGmMUDTNAI8mcQyiZkfg1srv0vc/uP61/GbugXGsNGdT3acAb8HbGOZeNPriLtQ1DXFGlJbyI5raR19xlS1YhCYNsYALrarGMvnK085aJ3DhiaQlGLEKefEOZ/4C9A5trFNo9Wf6VMjTzmmhokAOjRt67L549mrgC9limjT1M5PL93Gn3x2E5duj0aB4xjHOL74ceLEiWL/f+nhPs+pr4G1rqi2LmCSV42HgPyhoH4eYN8FZIa4rHd5HOS/y/v+Szn3GtB3OeSXAHUJJObtFzXQ1xcb1wcQtbqhBlR1e0jXvBqqXNDbQN+dEwG1inn+HTVfgD5CqW+ePY4HQN/vSn/r8gDIz0/p3AxpNSmdm9J3nj9/Hrdu3RoJgCc59uzYgl98fR/e3L+Do8msMTFjW/p8jXK0JuBHv28aqsILyGeDPXgGEMakffP5Uaf4QJLjOgLkyqyMHL4FRBg2DdNASAOUZGEqsKLl+zoqjD8jKh+CekDcyFN4J3FrzsUKs5+9qfnY5+xyRjpK/nWCAQewealowvskFcHEc9CqCzzJjyWyDMm+eFXlRAJ0o0mgIgKUvYBImyNabaKbYDAoFFAK1S8fItTElFADKCIgDERuf3V5DddX1nDq6jIu3Fp9IoTAr7xzGF87tBNNE6riTkn+NeFB4J96zuUCp3rxldGfUdvuo5ybYu7ob60L6g5C+F4lMFgViWc5aQJMqAmJIOCaHf1jhCAgyhb6dxoZGA0FG6mcN3wzy3wtCOwqczy52cRqtD5fWgrHRoESNSgX7UgUGC1vhwK8cX8yvwXwtqpqRHbZYBl+PJeNRULwtS54VtA8tTT5FLFBxA7PWpUCwN+pFATUfsP7Ete7Sy4MnhUCRnmKkCohbE/sy3SBEAgmh7PXqoQkiefzB59dH/0BxjGOcXyho9b/n49SJb5PEVACjgQI8zjB/DO6ouroc2qV5BLo7iMIhkSoleIGS+Co1uNf+/6SB8DMc6c6Djl4H2LI12euVyIEuqTnXfOpK46x1lbQ1zvedd67ZP819UetNaA0n4aC7BoAXm+LSZenQunvtfVQU4TUPq9W1a9ta4lcyBM89Gfcvn0b586dGwmAJzEWtmzEz53Yh28c3ZlkVTcEfCGAd2IVqqDXxZM0aRruX3ZeQEKoZpmk4k4TgwCQUUZywSDQQeC+VNWpwOYSwKalynL2CCx5gN/A/fvGJJF6utqvZdu5gZ81lvuJ9WTVsl6QpBriKeC0d4EmLlReufNOVQsxE5nWGAGGXOVU4I+MFDkJgffJK7PELK8+xsn5SBIEbCQVcO+AppGYtQDIlMTZp/GAGkQRWI4peSEKj8gA1Wudxi4KSUHz5NryA1xfWcPZGyu4eGsVd+/Pbyr4qycP4etHl8QYD7Q/XoE/IUG8aqMgwsIkkY9ysSfAvqFpRF5uTUY8CQCGAo0M/hmUepCno4hmpN+eXOOj9zybAnogmloGYDqxFtM2nvu4zkRdIPOAiDSK39StD42E1SfqmeSmCCRriltn6CYQjSlswUizjdup5fBerXHddS9JBYF08nE9kwGmKbD8tIE+tkLQZ6TKFYNpjDQi01GbmBLG65crmNsYidGk643z6Q3EEJkEH70KXCQANAHlMXUOxjv2dZDoQ5WQkBwPIaD+ycdX8f0z17ilZBzjGMc4ntnz48ICjh8/3lnN6wMpXQC61hOcJE0pqXutr79r22oEwJCYtq596CM7ukCO3v8ScZC3Ouh/l8iPPCqwS1FRq7J3ERZDK7wloNhHruTnP6hf20ReX/MU6EsSKIHZLuM/DfZrkXgl8qHLCyNvvSjNrxrgHzIP5yEASuutT5Zf8k/IvT36vnuelIx79+7h1KlTIwHwuOMX3zyI75zYHXqFVS8/g2+TynKTBaIephlk0EMrmf3pgpgC3VQxLD2sG2uCKZ1mOH2a0x3AuPStJ9VPlmJbduLWi0y7l6fmbuK0HmaAmvSqEqi9D2ZvSkQ8yL57ljGrie1T8z+XtThwYgGZ97Ec38feeheAOATwh4pyaAuABvQExh0wmZAvgJPjasPfXHSgTwgC6Ax1sEndJJICJEs3CgAZqChCZWxoTIi/Cy71qsJshCgIcvVImDgkefUExK6tPMCNlTXcvv8Qp66t4MqAzPRfe+cQvn50F59D6ssO6nKjiAs6ZqReMATLYYwVBAaZd7qHHJB2kRkm3Vo2dXTc/+94vQRSwMU2ChsVHRKhSeczTE2jlAjxfMHxdmtyqGkiYLbZ+gPYpM9wi4Fy/mePjTC/Jk2TtLM0sd0HCJ4Rlh7GlIIG8Co5wcykZpi8/UDFeXrvkvdCeQLQujZKvUNztG199DeAiuWj8+3Y4NEiizyk1ggV2Vli9SnlQ7fBGCXhn+EiKdaT1zjFA3puTSDfiEdTB8BF3xOXfJBXLQfWKNIvkga//c9Gf4BxjGMcz3YcOHAAe/fu7QRstcphn/N73h5Z+oz8c2qGeV1V7qHkxZDRFTM3xP2/FnPYJbXXgL6UjKCPH6UD5GkDfTLt2vEvyfbX44sw1Cyu7zVdpoK5eiD1BjJVAiDf59zYrwSWS0RHrkSYZ27VVA5D52IJiA/5vJKkf8h6zY0S+8iI2vmrjffffz+2SI8EwNzja0d34+0DCziya1sCZkn2Tr3fJEe1RvfLi3EeOcKbaEBGYILBcnxdqJBL/rgxAl4YREL1OEPJ2Nn0K0RvTeLiazMWU1IIBKHpuD8d50VP1FqmH2TETiL+vIBxAS+KcPApQZIzpGSuBx+N9+gYKjlxqPCTLD11YTexOlm8YRhgGkq8UakRABwpBGwEzuRnIOZvPomyC/GMgNGo1oh0OiGBPLJIOQGkzuvD7lniTt/zqAWTGIBKWlARdlRp59aFOFEI+Ed1NLeiECh+aCx+cPYq/vDjy3UC4N1D+NrhpcSckQgnUno01jJhEyr+DQP0prHs60AXCBMr0RrQc5JArOjr1ghNUKUKFAV2DaKfhKg2qHJNxoDkTUBZgbpVxSe6FpP4EYjpnFVqFLlwU0U+AbBGDO94PefMPwyrgGieMckGaZ2wym8gZdINE2dk+EntQ6yAYWNPUcpwy4wF4IQcszat4FPEZ0vsFTwmTTBOZBUEERJIk014vSlDB69aHXK/Dd3aIyoJzyoGek9Y6zG5IB67EG0YFULeM5GnDTSNSQk5/W/A4PS1ZXz/zHWcu7EyIpN1ju2bNyRryDY2eTDQ4/bq2njAvsTDmNJZnXmMTsnscSSj1v8/hADoAoxdDv5dcvTae0t/98/gpHaB0xpQyw38NKjSzv75+/NKvFYD5CoB/Zo+4JV7KzyNY9llgNdnalc6FjVVQ82PoGTsV/u51tdf8jeoKQLmIQDmAf1962Hez60RAF3tNY+7X0NIgNOnT2Nl5ek857ywBMCbB3fi3YM78fr+HVKJVvJm7cyv+5Tb+KAd+nFTF3C6iRIwI9k9RfdZrRaAuMmHfn2FMI300As4ViZzXjnZ+xTIlnqXBfDrqmaoEFqrKrUMbOLfnYBU+tyWpMZGAzkTJfMkl1cXnsRRXGBZLpkngIkIwm1MTZgGnXyiMiAyJLj7q4t5BAsbJlb1jsu5JGlwo1saOMMtQhQCppDUAOeCkz21EWgHdK/i0Dxvfzh2VhnaTWxwz7fcRhDj6xTAtBZwrTyQGerq8HKwGX/FdgKrfBLgDT69uYp/+CdnqvP+17/yCr5+ZNeMFwSddwKhdKJoHmqA6rxDYxuJnKSLVYx9g5Gef4oD5IdMcq+HkXOuYuhmY+eoN1zFCULWGUXN6ahBaotpjA1tHXr+Q47ZhAGNOOKTfwYnZURyg8mW3GHfGnhvYitE3K/YBkPvaV1GaJlZpY7lHROQTDGD1Csvbv0R+Md5JIoimbeUdKAWFX+fV2kjUBGJZC9Cvf2SGhIORutdqvyJ+4oZ81KfED0U3UjKA2nDiWSIBVyr9ls9wAnxk0YIxo6dmTuUsWpJG+D7Z67jo0t3cenOaBQ47/hL33kDxgAbJxPs27WYtL7ksNAAOHX5Fv7pB+dw7e54rL8sY3HrJvzC20fwG996Xa4PzrNiTgUHwRiDc5eu4f0L1/B//PCz8eBlD/Bf+9rXenvdu8BXVwRf7fVdOfK1z67J1msgstS/XPqcGggeAopL5ECt/aEk5dej1vuf71MphrEGrodIzms/d6kJhrj6l0BiF+DsIoxK56ML8GvVX/46TRiUZO4lgF/b5tLPQ2T7Xeen7+chFX89R2pO/yVFwNDtHvr3kuKF/n3t2jVcvnx5JACGjD07tuAXXtuHNw/skAfqpHqV3PfglMM+ATJrLKxtsslOD842BeYxEix1CZ81CCMwkQBi5RcgeeBSevXKXV4T+E0sR1OPuSy+VNYOHyTCZCwYZMsaIIgjuNU901bM77SEms0BIdVakfaCK+zsNO5F1j5tHQM4NqIzKu4QwRiMeuaJCGBjRlWdJdDAkvEIXLwXkiSoJsQUsLEUI0e9754d2x2QnDtShUya2Z5r7ZUg5m1a3eFVJKI4vrPNobJFaBrD4MnzMZTKvU5koC87c30F/6Dj4ezXv/IKvn50l8Td8XdZUTuYVBWiLwLJNSsxRQy/CMZzAsA06KT2D6ud7L1T+2OYQJpdm17WjOqnYSWJ8Vxhn8S2G5n7Vn0uWE1BBIeWolEkoE9IJyHJrLFs4Odi6kXpNmLZnDLrISQDPlqPbOxnkhi9TMATyMcY2UdKC/IsII8McfAnlUma8EGkEW27zSWoEKUDrVma446JRolKbL1PVDrpTdAzcYOsvYGMDE1GgoR2Fy8tUFAPelFFEiUO6bzToh0jCiZqFfEe+NH5m/jkyl2cvT4qAoaMAzu34i/93BvYtHEDjuzfIz4y3oe0idjGBPXA86ht0RiD989dxR9+eAHvn782HsjndPz8ySP46rF9eOfInniPNkn8KBDWd6O8SUy84J+7fB1/43ffw61R9SFEyuIijh071gtShlR1azLjkjt8CRyXJOq1RIASAdAnyx8CuuYhALoy6PP9q/073/f8+NHzh1YD5Ocljwp8XEKo6zz3xfcNaQ94UsqNkjS/FP2XS9kJAOeqiFIqQB8BUALPJeJpCLkxlADoq84PSXCo+WzkCohaa8m8217a/9XV1afmA/DCEAALWzbi51/bi3dfWQLBdG5lVi5b5FieSF9deMOkaUL/swIs1ugTLhJfqAfjPFLLR+Chimv1I697iH1WcxHMy9/ZRjO1SSQdvDJw42o8gQQlEW4yhsuprPHZiZeBO9426es1Jv8cywA6bGeI7aMeYFYiAMobgG3fpMffgwkGrgICM4aBel/aWCVu2OxN3u+pn9xIZR6QvmLqpdYqEEBH1SlywEj1l5zRddWczrn2UpCbjgLXTiaG85kDO9I5kfudfXZ9BX+/gwD4ja8exjeO7i643lM7gBGneAKQZOTnJd6vdSreMYsBpCx33QKiPR+8qvizwaMnAsql7vEQc01q0EgNMV0GtAF48rfwWV+8qHRENh/adaAY3da1aJqGZf1WtUjQd2nQm1/EifDjuEKvCEKvCUP5HN2WYxnk6wcSSHRo9LnQ1Tnx3UASXZh4BCBV5yRZo5XrkDUa7IuUH0rWnzxIxhQO2smJFQUDESNe9c74AmngYquOXhOBHHDx9UEVRM+5xuh2laAaocTEJqq2SJFz5voyPvj8Nj68dGdELR3jl04ewnfeOITD+3cHBZuO+FTXIlqzWilEZM5nV+8EMuCji1hdezge1Oeh2n/yCN44tAsnDuzidkOXGMYpwhySmGJYBRTuCf/gDz/AP37//HhQiTAb0P9fA8RdVd8uQDg0NaAPVJZAzrw91kMqqfN8d/7emldBSTlQUgDkwD4nSUrEwbMcz6oNo2tu5r3/pap/zQeg1LpRmuf5a0vr40kfoyExgvMSOvn+daUezGMKWVsXfe99Wj4ALwQB8KffPICfeXUPP+xmBv5CAiRmduAKPgBsmEwY9GtwR6Bg2krFmToDCPBJTJaYivlMnp5c7JD2HfvsFIjy1XMFlAgINuCKBmoJcUAS5gh4KId90lh4CBATa21Iv7FCmqZ041IAorFCWKRZrGIup6XbLEu2ht3Abaw+t8mFOj6AenJsN+KzH4kPyXhPjdFsiEMPMnqH6EIvUY7T1kWHcigHcqXYiK8m8sA2lmMHdcuGdnw0tJ8e2MCAUhEg7BOhY92i0WFyfFIgGyTn1HqARF1ytocA+M2vHcG3j++JPAMBd8ttADSXN8T908Bv9kKUSr2NAXtc0D7ysXcOTdNw/JxcrOK6iFJ7bnvxYuQHUyHSvBwDveba1mEy0aQBtZR41XIQ0waiCZ61hg0ZEwJPJXnMut8bXvO6TcCpB2adguCdxCvS3DQ2u0lqbwZgxlhRUyM6KaOxaaSlbmHSZp9UPtdsPhtdKkJAiCsNxFVrQfyuNiYLGBVnSdcYSb9wnOBgTHo91C1MGkDOtBcArAIIbRFtnKtEHoFZDKeudxKvKOvamuARcPrqMn584eaYGpCNTRsa/Du/+U0c3r9b5pFSXXlE40ul/qKIypDE4fl6SXPqR2eu4Pd+chZnr47mjM96HN2zgF965yh+5o1DaSKL0dduk7UMer4+NUrBQ9G9APDv/o1/NK6dOIb0/9fAwzwgIAeuJVVBrcLcVTV+ll4A+bNECejU4gzzz6i5/JdekxMDpRYK/5IaXNTc/ku97Hl7Ri6Pr4Hd2u+6WimeBQFQ2rYaSVeqwufHJVdDdLXX9AH72jrJx5kzZ56KD8CXlgDYsnGCX35rPxa3bGSDPx1NBegMc8NADSaqA6KzdziplgGBTSZsvJUaMQf0Cm1TxZFBvAkV57SqKZJ7BvTaiFAB+Nzpm+XWCFVqkldbZu9MEkfH7u7Ulx1bC9iILj4xB4mz5SolAXevXM2NUbJ8+ESFQEREOFZeScClyumV0R+7kvvUlZ2rTCqVIekRhvRoy/e7EEfXeon9i/nz/LDCjuj5RQCsmoBPUx+C/4NjcGKSODfP5xtK7eBVXB18mpcO3R+lrgG6N5yq2z5WOy0RIJDqp06XsMbgzPVl/L0/qRMAf+7rR/GNY3tSaThmo0rYSE5vm4rQoyqw7k/3dNOW3D5FkJg02977zAiPwKVTqgZ9vOJxdpAkBavnJiViyHzU5vHWqDUXGZ1GER/hXOQ3P2mBgUHS1kLXEauUP7Q+vfdomiadV9r0UPlN6HYGIr2oxYA+y6trFcd5YtZ001iJ9GCyC6qFSJXUreIUNMGUXMPMDOOYEZHa34OIFg8LUUmJy3Ag2YyaH+zv4JPmANWiAF7b4frtlNGjwbSdyoOiul6S54oB8KiVtp3GgucMRbk+aj2+d+YafnD2Bu49nI5IBsC3TxzAX/3Vr3PEp/cS4Zhaa0Ilg0RlGdI2oRmC8sot/LMzV/Ddjz/Hg0fj8X6aD/S/+PZhfPPEQRzftwB4oxJBJAaVTiKnlkBF+CrFHBGJuhXxb/7uj/DD05fHgw3gzTffxObNmzsBSJcPQI0sqAGYEsjQoKH0765c+8dpAch/roEnHUNXi+/T/filFoD8GJSOY63qT9tC79P/HZKG8KJeJ3IwXjOw64oD1OaBQ43wcqKha07X5uZQ34W+9pvadpZaU/SzXb6u+qL/5lnn+pj0KQEuX76MK1eujATA7u2b8bOv7sFXjyxxD6rTGfReS0ZLEyKSALZRkV1pOgDns6uTYrN/G6MejDmCzygHb88P5fRagjtWAxAv4C594EayLyQxboxNssS5TYBMuozIuWn/2aSNpdmpggEMJjTbpcCUF9DsUs8xdeyELGBfgfgwHuTkoRfcKiBA54haFsjwzyjjOwPMGNppCaMxPjEP03iGVQoQp3iJMBOFAIFYiWfziYcD9ytDHPGbxnJPNs0ca5EQPlSFcWTyyPtq2ABNy8F9gQDheRu3+LPry/i7f9xFABzDt17dkyhP9LwyQALIeAoo6TqtpUdtG3pEoSr2JigULINcL8c+6+sTsYQPPaiJ+ZzPiCTqRXeJl4OOioRKzkhSCjRiV/ttM5Z70jTKZE5MIq0VBUt4iPZMDObeHjByDo06MdIGAVY0cDuJTEJuD/IcT+kT0CtkiIOF5TnAFftYNad5D92KkxAtXkXz0fGw6lTPtk/4qLRJ1pDyUnB6DsQLgaN0gkzxJBGH4e/e6bVIxqiOUwvy5zIyRqVwSoNwfWjVWtUgVCdeNFbWNLX2wAM/PHcTP/jsBm6uPnipwcxf/41v4+ThPcm8Z1+WLGuaFB080fk8A1DqNTrOXt27/uCDz/CDU5dx/vrdEUE+oXFs7yJ+/uRhfOvEQSY9W0+xv3aG8NYEXGra65T/TeGpEMAPTiTlFF8AACAASURBVF3C3/q9H7/0x3zTpk04efJkEVho0FvLeh/ap5z38Zd+n6cDaKDbVX3skt93bdO8fdh9CoTcNC7f9tJ+lciEEqDPP6uv578WNfhlHUN68XMgr2P+NKAtETn58dFy/3wN9ClihnpMdBlult7bBcJr29GnDii1QOTzuZaCMISsqK1z/drV1VV88sknLy8BcGLvDnzj6C4c371DwLoVANC20rvILQAGM0ZUtrERYBgGFeTEzUAkmuCJ83d0dY890dR3qk3cKXKMpK0k/W0YzM5OOD9bcktM4FzuAJtXL1XFnoFCBC0WMtmpssM94OQn0Lrw0KYSDZC3SiA1/PLes2l9DhwDeANnupMSgUCiIzmxEelyCrAVoRK/x7VpQgABN6Me/F00/MtN0EKF2/O+sft8YziGTNoWbALKSS6vtSAkpU+qxk4i40SRkUq7k8hEtZ/a5C9JPDCYkX/Td565toz/5Xunq+vkO68fwK9/7Uh2IxRCpp22aOHRwLBBY0JUISVdSFpNVVdAlB6UE48kro0iLE3q62C0kZzkxXNqRSzj88WROIUIyokY0KCOfQaslvAb9pzQUnwiWkQl78UPAeKD4KAJv0xF4XPg79lfIWpdEkNHWrdk2iktImKAGP4efudaBxMNDvUxNibMPQbFRptLetVaYqG+gb0yrFHRiPEce2XyqWXg7Cfic8VO7LdvHe+jJh5Mwa9A1BBCtjjlj2EKtx/XOpWSINf3aetABoEcL5iD/7gGDSUzMPGhSFBj8NPPb+MnF2+/lBGCh5a249//i78Y12fqC0E+Kg5i0qhjaDk5JTlnJiEsLZO0crxPXb6JH5+9iu9+fBGPWjei+HVU8X7ujUN49+hevHNkDz+byHWLrk/iWUTmo+oWnax1NhpVCjV93SWy4D/527+H5fsvN2G2tLSEo0ePFs9LLTKuD6TV/tZnsJeDBZdFRHd9x9Osfg/xASi9LgfwOdFRipBr27ZIhFDbYV/Pf5eiYOj+PSuyYOg5y0FxFwFQi/nLFQK5R0AJWHepAEry/yGg/GnO0Xl+zgmSvvaFGpG1nutDTsB47/Hee+89cR+A55oAsMbg3Vd24u2DO3Fw51Zx1jbq4ZeAlEsfQiXBL+wimX41zSQxsLNkI22gouJCNdeqSj5J6qxt2K07MbbSFdRYMSU/AJZOqn5h+BRD6yq/VVVGjcitAvS6wumV8ZqY3lGFTVcxpTqd1oblhi8P5vkrfOIsrvv/ddXfqBSEYM7lMpCo+vt19VgdEzKYc84pdYdL4uaStAMmT6QaL9L0uA9efgcEV3wB80hM6KyKPdOVMHGG1yDUcoVWV8oaKxF0QtQQIDa8rWR6aFXCAFWadZWWiKhTV+/it/6o7gh6fO8C/uovvZH0XBNQbiJj5rzjHPeWDMDI4NBKBFxjg1+Afvh3SndvFDHCv1cPkUxgxYdMjvuL7RYWRrXGWIm/U+vCmjT6z6p+VY7KhFHJEmLSx5F9nBpAGx4ejhtjAwkCUrdQ3CV4e/lizDcA5bthwKSgrrpZdsdPo0L1tYm2d2IbJsfYL8ILAUDXGVLRNNxCZBJjTDoX+tKSEDQmJXp47mmFj1J1hDVsWZkTzBNd8nn8wObzB1NwOkBKdIb2Ab2GPF/LdBuQIgR4TshnTNtYvSSfghjb0TRCzj5qHbcJpKamsqbO3ljFTy/dxU8/v/nSgJm/8DOv489+4zVZnwkxHZUa1IKjjP841USZNiJJ1SFCTxs02qguoId4iz/86AL++JPPcfbaaNLYN47uXcA3Xj2AX373aFotNRJdSm1Bhq/hQo5KzCz4+Otnj+Qa6lOzTlojv/feWfxv3/3opT4Px48fx+LiYrWyWHvo7wLiQ4C+Br81WX9fVXseUNm1zV0O9iXw09cXnbv117a/ZFrYZQKo/9v3uscB2Y9LEjztXve8Sl1yp89BeokoKJEAOUlQq6J3JWOUtuVx5l5XO03t9SXyo/T5pSp/PieHRBrWzkWXaaL+26lTp564D8BzSQBs2TjBz766Bz/76h4Gx7ow7eMz/KSx4kqduG8jeQgxscfbcZ63VdItfUHysz4A3kfTdhMfaJyYwilZsBhrqQfpuG0hVhCJK3ZjLcffoZISoOW0XIGPcmooub41RmWHe3Zu9iBwCmVQJuRI67T7MyJpYdnp32fu4VbZnGsvhPThMO6VpyoceREo48DEQFC51UOASugn9gWiQKLB9O90td2rSMCkB9so4zfnuZISKszkpg624i8tfK3esDM3vtmLKEm2m0gQiDO9drUPZms+yqmTxABmx8Pvzlxdxt/5o0+ra2fjxOI//Be/naQ4GKPMvWI/PIE6imCjloVpTG9oGssVIqNi9cTLIb16hHkdPSF0VThrVUFUXniep+K3n/ZaGcbq3isVj4lRigZMCAquN0lLgKNkB2PFdd9qMk1Y8DYSQU2Uz2u1gDbMmzQmWRty00lmAlfnbFxs9PkEln1UCWmiRM9l7Q8iCQA+7o9hNYBeM/zVSkFAaQh0TdDqhkSFQyDckdJJyfmtVlFJDCelgnAVPoJ+LQV3Xggia+j6KdcXk8WR6msPmwKqlIrWO3mwU74jrYtmp/FaQakB8Nl68un1wxiDM7fu4cLNVfz43HU8eNTiRR3GGPwX//qvpaSzAoIunr/GqghbRWiTD4NuF/HJw4pT11umpJL3BWVWi/PXl/HZtTv44ZkrODeSAQnof/PQbrx5aBeO711M+1MhZHDbUrSttACQ0olfT61IRrUIIjURzT1BdPQm1Ub+vf/hdxKz3pdtnDx5Eps2bep9QK/1yXdJgfPnC90bXzP/K0Xg1UB0V1tCH5AfAkD7Iu9K35Ub+tWOR04QlCT7tUp/rhzIyZTaMesDaCWyowZSawRIHzDtA7191f8aEC9V5fuSAYa+p0YKlP7WB4ZrQHqIeqY2x0vEnG5305X+GjmRewXk5yyv2ved01qLTulYAsDnn3+Oq1evvrgEwO7tm/GnXt2Ddw4u8sN966HibHSGPBK2OuS9S+QbPchMmgZt8j7Dveda4u8h1TwxNBNWIe/TNdppUFf3rMiBtXRSS72hgICWEQMpGKZbvsukulyZN2mFi27+U8ong1dO+gKWjOq9JnCTkhkiy4fq5fXxgd8g7fXk9opEvuyVVDgCaT6HPlEXaKAjxm+pYZEnXwPVoz5tnRAgETwblfGeXy8Y5CtSic6b4XYQAXfOea7QiglbeM9sP7nPWjSIPLCJMzopCdoosSbQwlJbiLKE3kMqFBjgzNW7+J//8NPOdfSv/fLbOLp7e2Iyx9SMji+EeGcg6QeX42Np/yA+FeECaJIef1YJOKkme8LbNKfIvI/adJCaWXrvmJwzRuXgQeYYrXHbNOz/QcdoYk1Suaf5RVGXpGbQfh5NE1IFZkgZiJ+G8y4hhDwTgsphH3LdgVKNeJ/tIzxMNOUSfwhSl6R9u9pE0ngkLvusuojXMpK885pTxIvLEjNy0qpRJpheKY+0MskqBREUtOMbqDbCUn3hpHqh9dW2gZCkjHltQKpBCO2bVi45vj7o9Alxe3YqOtAqYggmVRgh804AgKmd4NLtVfzd7376wgKZrxzZg7/2a99M/FS4eq9iHIlMczquNU+EccIeGGuUf4uXlJColPNwqp3AA/FnImrOXbuDn5y7hh+duYI7914+ufnObZvwjVf3450je3Bi/06Zw7qNDpB7n3CMqkVRyGyv0zqotSlTQlGrlrXBEJiBFJGpSkXw3//OD/H+uWsvJfjftGkT3nrrrd7KXl51rQH+LvXAkH7pLtO/LsBYUyrMU83OQXKX8VopzaD0+UMN/krKhxLo15/bZchY8h7oqzp3Afqh+fNDwGAfaVAzdyxV8fsq97p3f4iRXw5SSyC/ti35+ewjLrqq7H2kSNfndhEQQ45hTUUyhADoMz4s+XnQ35aXl3H69OkXjwB4de8CvnlkCa/u2SEPj1ytFAkwADQm3eBcGeCNx6RpovzTxMqXBimi32ZHfa68xT7beONkplxJ/ekpOpiFGTHti4x7E/0D2jY401uTuoEbVUUXgK0l/Yad0htFTlAVOG/JIYDSKJdfnlQAbGMTAE0mdiTpFXm4YVl8Gvkm8moCvA23PPgIiBRqNhJZ5hV5I5FjXo4FxM2c8tmN2k5ePFTtLxjjIcavEfFCxM60dQK8IK0PjiXAPgE14lwefCK4bz4+wIYseQ2mCv1RRgzHvKo4msxFnhY1bU/rnGoZSL0hVCId4IFTV+/g7/QQAH/5O6/jzYM7hdxQZl0k2W4ai2nbBtJL9XRL+4ZjQOz0eYSAfpp/uUyYNpzaPRCBsHhACKimxAbvPFpF5pBSgRU1zrPXhlPO8Y30AcToR3XDgjb4NPz63PeB3LNdVOYQmCajR6nKxzkMAeReE0gQ9Y9eh+wN4T1apbYgUCyEXKpwSW/CsdpNwJ6Amkl77p3PVQJKnp0KFORhTYP4zBzQsmeHg9Ik8fEKFfr0GswPJ5Fss8ZG3wGp1m+IZotigigpDk69l8mx1iXEjsxXIQnbaavadpBFmKn2Gm8U0SCqsVM37uPvf//UCwtm/s1f/yZOHlY95HpNw7CSjFzjdY78TNiMQZIIIMc6tHnQvYUJXPWZVNkLcYM2qHoikfyjs1fw0ws38N65qy+2GgPA147vx8+8fhBvvbIr+b20FankkUjGWmuSdJYmIZClla8xhlsBRbkjLT963ZPqKVHGqTalH56+hP/x9997KQmAnTt34siRI51AeUj1vKtaWQK8XVXREhDvAtHPZD4XWhZqOedD5fiJIXKFwKgZ/Q0hRmoEzHp6/bsUFUOSFdbzHV1y+i7wqp9fc7BaqvaXiK3JZFIE9EOVJPMc17553JVQsZ7v7/NA6Kr+zztK14KuefT+++8/UR+AL4wA2LShwclDS3ht3yKOLW0Wo7Mk6kkY7mlLVf9Y7UeMX4txZsYgZrcbNrpjIGOtVPdUpY6qX04pAqSqiyiH15ntEOCQHUQ5Uapim59g6rdVSgAGCqpIlRrkKTYesxXtUL2zSaycZvDTCDOfyouRx6GlhTImVZT0WIzLqM9aSXZVlrCAh/AkMY1VVjZbVOoGksU71exNJmRQVci8x9nG1wHiZC29+IJ1bPIg5VkqyVVGTo2wSYZyovpgKbVJ8tX19+joR2TRbCHSsSy9nKnOKvk0kLo0f/D5Lfz9Pz7Tubb+wjeP41uv7uU15Dw4Ag/qXE7pmOVqGi2fhu7D1z3f4aGfExGU67+jmClr4SNB5JWXhrQdWMmkVg+/5JfBRmT0gAEiJSySzHqk0Zy6Ek2kXmMtR9VNmiZJ/UCsUdJaIFAC2CJjnTWjJO0rmhRk6bm6vlASgFetBVAkBN1UW+UbYjlNwisTNpNVhhxX5A2Tmn6m/90ofxGbrfcZFnrGHNTz+k24HpBKAOxnQCc0IbnIpVyZXFJFn9eciloUvxAw+aaVNJpscN6jbVtM4rV52raJksq1WiEUf+98MASNx/bCzVX81vfPvpBA5uDSNvwH//IvZL4LmgwzbCILo6/7Vl2EkcTOatWa9g/hB0OjzFa1EadzaLPzKDGvMvffP38Nn1y6hQ8v3MDNlftf+nOwsHUTTuzfiW+fOIC3Xtmdc3F8LU7ifY3JLYp4QTsmjlOXDA3e8/WtI3qtji9VJDHf95Uq5z/9O3+AlfsPXzoC4NixY9i5c+fMg7l+4O+qUg6p6uv3lYDMEJBQqr6XCII+QL4ecFqTyuepBn1KgRIQ72oByCumNWVACXD1ffZQ4DnvMZkH8NdUE6V/D61g136XA1j9cwnclowE9bzSzvk1v4A+U715FDRDj3uX0qGLLOjy+qgpW0oqgxrBN3SOPGkfgC+EAPiFNw/i2yf2AQAmbiq91LqyaEysDEiudR6Llzy02GByozNv2TGbM7YjaDUmidubxBLWtHVK6kztAFA90yo2UIEaAp2GY7ZSZGgMEmAoD8c2ieuT/GrL/a/FM5Q1/FL1WCTuIu3RlTNrDLyOFVTqBe0qrA3IWCZK0v7MJZhVCd7nBaL4Oou2bVlaKmZnAiobVY0wSA2JXOw1JSLBeTEITI+CT84T+xckJn/K2MzpXnOfOerKw5Ic2wAchWiRfmWaV7pyK/31Ip13PpzbxtL300HyHI/oFPBJHsriNv3u+xfx/33Snc38828cxK999QjPS6rOTVjuFdQdbay0e59Kx0v9iFqdwDFSuiklfmbSCkBrw0lV0bOEXt3kjEki+8jrQsc10mu0ESR0BRG50WT02TBg8z6v5p6cH5NUQ0kW51Q/OzLDP131l+SDtA2Hj13MzmQjydi/C5OmTFCf+5RUMBlIo7mkuUROu/BiwEnGpjS3qU2GcAOrBJTzv1FqIpEGS1sAK5WcECtMqhiT5IvTuTZWzAFJiUAGhjo7npUPaj9tZkjqdYoJUr8BLfskE8VATDmV/KE8R3xq2MgEqH+xCYA/981X8c9//URCzEpCjOE5RFfwSdPIvQuKfCoQ0TpiNzcWDPPWwZpGtXqlyjIolQ7NNw+f+Hl8ePEGLlxfxg9OX8bVO6tfmuO+tH0zvvHqfrxxaDfePLjE0nwoBVE+H1l55UTCn5hYxnVKJDxHHmvpfzzHVt3P9fOD945lanLfdup+LsSe98Dvv/cZfvuPX9z2mNp46623sGXLliJ4rYGavmrhEOOyPHd8yGtr0vDSz/PEqw2JM+uKNNRAPQdMpAbSzxn6v/n7tLw/f20pFaHLB6HkqTAEoNUIm75jNLQK3PVzfq76Kv99KoD89yVjvBycliL/Sr4BJbA8xPl/SO/80LXU5/RfU1D09fHr+M9cBaB9LHIyoDYnSl4VJeXFpUuXcOXKlS83AfAbXz+KNw8uYYNrwcZr0PpXkWW2HMcnRmj8MG1sjNgKRAEBGmPlQaaxlivMYjdWYNiMjv1LL0YMTqxRlYrUXIp625vMcZz6Vi0rGwwbW+Vub0lUWpSoa8BcKDfyQzuFMHlWBUj6gActWpNEB8pnShZ54u6vepnz3HCv9MTep7OJHvqbhAUUkoAz7yGSZhcBgo41oy8iObNXX05APXf79x6JciA8zJjkXJDKQGerS1waEmM7apkgl2WbL0qEKrt3PsZnEdlkGABT1RWZEZnJSBaS5nsF2nXWPAzwt/7JR/js+nLn+np17wL+1T99MiG5dH+7i+kMTWM5PYPc05OkB+0YrdeDzcyJVHRjmmUfEgBCJdtm0m3xo9CRg0KECWGjTQFnvp8rZyZZH6UoP2o1QCQPpy3iNYIUH5avRbSWgaBkcEnqgXhbMABWwJbngJV0BBtvkq1zSr2SWIhISwp80m4Sj4qq5qnKqZf+ao708ipVIamo6+sG1GuzB6bI+NF1JW8vyiexmBSCFR02U7WQoZisd6kua6PJ1rEWQxIp4r6lKSR+plJJqh6fEBJe9Td7SeJwSGM4YXD+5ip+6/tnXjgQs3lDg//sr/yZpGpvjUn6wfUaTFuV9HxLyVskFWef+KqwGW2mMHDqOuGze733kmahTUvDmjJMsH1y6RY+u3obn1y6iU8v3Xr+qsZ7F/HmoV04eXgPju1dFDUNtIFmaiSq7+opXjdJKyRfZymZxEgsqL4nGaUyIjPU2bzqeF2BSe7n2kCU1vzZa3fwX/3v33+pwP+mTZvw9ttvDwZufSARVeLMVMFnF0jvUwP0/W0eSfo86oTaMXIVI8maX0Dey1/q408J4LpEfggBUPrO0vmoESZd5EEfIbBeZUCXi/88hECt2l+LBiz9XDPcq21fn0JmyLx9HKVGn2fBkM/TxZ7Z5+ThbQH5vK8pKJaXl3Hq1JNrU/xCCIBf/9pRvLN/B0iMjtjjGlSmysBLx9koaf1k0ojrd2JGoZibfIEYMqPzCtTJE4xzIUaKHt7JXdc7DThSGXBjDIwlYytlgGcELITXZ7F0irHvMvRoY28/SOXAj7BIcue9oja0oVpjLZx65HdKpg31ICh50GnrAlRMW/LAomS+RvcNq4lrlZEdVIWxdVxzYoBKDunU3iGkUATWXn5nmBkOCQsNGSW1JEXXPWFSVkkSB+iB1akFzQRF7BVvpIfcJn2Us0DKqMpmaClxDG686p/dMGkSafhsOwWUqZ2bIVusMfjP/9c/mXGNz8fGicV/9C99OwGKGvxTP6kYthlRcMzyUlkUpkQX6sjEpFqfEQJcwVUb49XTLzmKW1XtcglJQp8ZjaxCrTvMFWMBqIeAJFowRJlRJCfJm4WgavghmuaRVyoVLZklcG5UpY2IMePNTCVP+2YYpV7Q1yUbFS6aSKCHcDH3zB5uTDCYEGKHHqDkJtu6lkmRRPIIUilYldMOJtKM8u8gMtWy54ImNoy0HFD7TlyP5DrO61T1i+vkEud8ki5BiphgImd47XsgMRMF0vYYq9Qmzul7RlBltM7BRNKodQ5t67ChsXjUtokSyiMqAL734ikAfu71A/jLv/SVxF+HFSTKCJTWTqvjQKPfS3I/hah9Zq6tRMqpVisoNY8Gn3RdofsuYGZIhpxwEF+W8Itz1+/g3LW7+PDCDZy6fAsPp8/eN8Aag9cOLOErx/bhxP6dOLRrO6tsnHqIm0ZfFUPtT4roMIokI/xtgcQLR8C8iSk7jhMb0odOn8xtKGKb7k98vFVbXbjOiemrAZKWtd/6px/ge598/tIQADt27MCJEyd6H9znebivVTJLIKYGbEsgaiip0FUZX28ee14w6qvSDjXkq7n+dxkF1ir7tc/P9zlPFegyqus7x11V7Xk/o4uYmVcFUAKXpSp4ngxQA/O1FoESAVBTMKz3uA2R/K9HGTCENBji19G1DV0eGaXz4r3H2toaPvzwwy83AfCbXzmMtw4sgiO3icGO1VqWSzdGPUwbNE0TDCgaqxvi+EGC46KyiDyPIIUlJh1Kgmpi5dMmE3rWJRkqxo4egnREWXJAjRhbUQUtSF1tRT6i2gfIjIdAh4mVSK6s++TM6Rgm6ok3ESQ5dqYXaSY9THuYtNILkRQ3Cih6ZbxndLUBSAz5oFIGfLaNIhv2XNEnabjzDi4SKGnlMwWXkgaApBLsnTyuSMSiILC29bxdDTmdR6BBGkyH4Mav69JkpkbAYtLYbMlkx04vWNVPnqsWtLO8Ua0v3F+rnnrTC4HH1bv38d/9P+8PWtT/8V/8UzML3KgHeDZL0yCfIxelIgclxTXKN0E7/Yty2IsHgD4m6rwl0T1qu2g+0EycNFaRZtFl3GQkHCsmHIMXPTlNotQxItkPohfYJpBzSR42xIxTA3oi1vT1ha4biTxfV8oN7Zdcb2ZUFEQEOAG2GxrL64XaKcRfQBQ7BJzDx0j8mleGXlDXO9pIk91UXGxr2RCvrzT3eT5EA0byItBmmhT7CFU91pPaq5QGnWZhNEmXXSvEQ6XwoMYeFel1TYgE1TrjhUimbWRSUi4kMAaYtj4oAL734ikA/vqvfxMnDiwxYaR8Otlsc5bss+phmjxrUkNbagtxWcwqQUudCEgxtJr4lDUp7xKfCyGrvLrekrJNDEXBJJM1Ft//9HN8eukmLt5YxtU7q9wC80Qrwxsm2Le4FYd3L+DEgSV868QBPoaBGImtJrrH2UhjjwbWrfLb8FlkZd4K4xSxro+fji9OVFCUjtJIsgodO3k/EuWWNg7NVWBnrt7Gf/N//uClIQAWFhbw2muvDQLteQWwBAC0LL5Wec5BXS0yr/S+GhivbVNeeZ8HdJaq+LVWiPy78r+1bTvTLuCzVs8kFQeoft6Q6n/X34ckCHQBxiHtFfMA3T7FRldEX1c8XxfQHEoulL6/VPnu8hDoU5LM06oyhPyo7fMQcqf2WTUjwHnbE/JCcOn7XggC4M9/9TDeOrAT2pk5mPiZ5GHXWqMYbo/Ghj7C1kvfPnyIZNM9syQZTKsQfBiThwrJI3ds+pdGUqX6e5bcWpOAJi1hpqoJtCEXIyBh5flenfQYSx8f4vdAufhOmnwyKgVBlPrrio5IN1OzwfzMUxW6baNhk42VTR8re8YkjtEUB6iVAQRsvQvkCLVf6Id/iZYTo66GzrsXYCrgxCUZ0gwKqB/Za8MbfUOWKhNJmNvWqQg8sCZZH8u02igPnILNveqhTavkBEAbNmX0SdKEnIe0rUN5piWVrzzK8LPrd/E3/+CjQWvsr/2Zt3F098JsBB2MMldL4yqdUmLQQ6DJ4tKsFUd2MVEUxQJRBqRTcaS1ptmn9qf1Dg0dZ5VAoVMbdGqGz7ZJS5ODoZudafOBqkxavmZEWb/zKgozNN00GqSYSAz5AIim3J+l87WV7D9xqZcYL/qelpQhlNGtCAqrHxKtyVQYArKJHGUdUGL46SV2M54bfTa48m5NSlxg1pzRGI9gqk+V9tQAUVQNLiEkRAVDen/18GpV9ZfaFSLomNgmPXZGt1d5Tl3QCyU1tAO3sDQaqKa30Cw60olnhzE4d2MF/9MfvVgpACf2L+Lf+o1vZwqTwgORCSS0Jk8CJy3eLZPGcguNyR4hKLmBRSrqWqHX/0QpSqjtbErkE1epbZLa472j5o3sfp4T9HIvc3AwsLhyewXX797D9bv3cOnWCi7fWsHFm8uDiIFNGybYv3MbjuxZwO6FrVjatgX7l7bhwM7tcq1UhHGq3vGcjqOVUjrS07mQFJQ+/MlRdZyiYVTLTPTo4IKBUwo2MaOFUiA5r8iUeD+3ejvUfU3HuLJZsLqf/5e//X2cv373pVEA5ATAEND3OJXzvsplH5idJxpw6N+HeBh0EQCl1+ptLZkF1vry9d/6ovy6yJMuAqGLrKgBydq+rmdOdB3z/HdD4vdKrvZ9CoAc1NZaA2pV//w9Ndf8GqlW286+uMYh7QS16nzXGu3yZKj5B1TvtQOuCbXxwhAAJw/sVCBbAE8wyrJc3XNsSGXZzEsqlgIyGdRBqmDagI3gq1HxWc6bGZZd94UaYgVxswAAIABJREFU1Yfato7jo6lanLDl9FBkzCxwSol5jiwzOodJA2ySzpKcliTQieu4RJxRm4BT0nKSAtIDET07h3YFiRjSUkXt+sz9mtGLgPqXtUu+U8oJSiTQ3gcU0UZu8dzT6YGpc8G4LzEeU8VDIg0InLlMOm7E0Zwq+5JZLRJhKDdkqIomfS5LXVU1tFEXH/ZSiMSK0QSNrtY7+bc4umcrDVCEl+F+cnpBqw1AstVpjMEPzlzFP/zBsArlX/jWq/jWq/sYjEnygVT1JBnCztwkud2mCbF4qTkJ4GKqA3tVAEm1V/esWn0Tjhd/AoCcZ68TKf5/9t41yLLrOg9ba5/b8+qeAWYADgYYvEGQBPgmQVIkrZdpibEoRi5JluUkriSWXUkpsZxHuUqVH5YVK5UfScUlmZKTStmsSiVSqFLkksp6y6IckaIeJBiCBEiQAgEQJATMA5g3Zqbv2Ss/9l5rfWvfc869PRgSmJ4+RRRnprtv33vOfq1vfQ/tAFJx/ifhkLLgRlceMccBEGg3R7HXYu4ASvA0Do8JTAsa9YXNF0wLrbAEXa+abyV2Ez5Cei507xOwkiztQHJhX3DrC1LYMgFEVAoxGOFpIVHmIGjvYdwhM0dXnj470IdghnlaNDIYZUAk9jQPITL/DwX2jM3U+Igo+snEDTYkgckgwDgxaVGWANr5/Kew9hMVc1dfp3JIpFDWScdMT584S//Xp7YXAPAff8eD9Ma7bwngis4z44YrSJUAKMMEFJNdxBhNZMxliAGUJu4WQc25muk2fhI5OOAzJLNwAAbb/VzngoLuvkaLeXogS0Tje79x8gydOHOBTp55iZ47dY7OXbxMN+3fSwfX99AN63volhs36NaDG34+Ib9PGN3LCEQBU40qi0IBbF2DuxRBcwE2im4hXXJ/mwQMRX0tXaM4EW3OCzAT1tuUYO6ilMPPK7YXUKbyPwl9/yweuYySx4e/+jz90iceu24AgCEJwCp03VW66EMFdNsFnCoQp6j/rQnfFDiwyuuvAl5goTRk3jf082PFdlvc4+u1MoCx977Mf2AqCWBIPjDWPV9FNrEVQ8FVQBp8L2Od52Ud9WVfR23/UEzgkMv9FBtgmZSllSasMnfGPvPYvVpWbK/iA9ACFENmfWP3dmrcrOItcfHiRXr88cev2hr3igAAH3pLYQDo2EiJQjd+aOBpwdu1xlqgpUPnaaQpsvoF1MNirhv1rHaG0STLI+YiXd+MkmqBH+jtkmGgxwN2ws51LfyVSlzoy3GjzrDwqAmZ62XrsQe6msQUOtJ4aLZ8c/Ax0IN0zlQNC0GHqECEJiLAocyLaafzWuJAo+W1rnvO1inRQjAHEzcxQzp9jqW7TNZ1zDlbgccczRn1eeQcjQYJARmCbGMS764q+MRM2ujS+5wFzPAscaJrChPsQsVOj4Iake0RAYc+C4A3pRuu49WSB7KEQuxX/+wJ+sIzJ1eaY++9/1b64FvvWtDvi0S9OBZvDLF0xuigRY2dHdbBABNpvZ3dwxyo+KT/FswUk5m/ITiih/hCIEiUGKUZTLkWEpm0czmAwOrc0Ocr/ntLIkYpEqiN2WRfKzDSzAEuCtR19y2A7HpdB+rYMHCROcTX4e91uVAtxsTHkT8WWYjgE6BMW+xnBQB66FSq2R01DAoFOJnZuq8+9iQwUrQbLNBtNWNDcjNUZF9UhKzc10IKCOaPCqCg1lzXEAH9Pq5xnWmdBQr+uuYIUWJ/BuoDkfMi8wZNEJ8+cZZ+8VPbx+n85v176Sd/8H0D8gsO5qwYSRlkOdB5lgY4jHO6OfRIDhGzOoCC+R0ensj9P4IcCvbuoI6CjrYBG0S01nUhkUIawJVBQuRmnPV+AIulgJsJ4T0z1sT9HBMmIlssBwmAnykIJD0cwEP1uVFmm3v5SGAWqkkgrk3aMEng+h/9U3R9ZgcYgEXn+3kBW40VpY0PirKf//6X/4heujzf9gCASgCmtPljBcUUXb8t2IYc8ldJDxgrPvOCP8cwKDGl1V/VuLD9uSkn9KH3OFRoD+n4XcJSztpDWehj/gfL/r5K8T+kXd+qmd+VeCxMyQ/GGACtXn+soF3FmX7MJHAq7m8IQJgCRfDvY0ySqa7+suJ+jD2xCjtg6P6ghHvo8+h8br9nLCljzFRz6H1funSJvvjFL17bAMD3v+0OesOtNxjl3szQuoTYvmkPsyi1mr04N8q7mhRFB2Ou3R4doB7nFgtuCl2nWtLWLHArSBOHWDvUwy/6BNBCRjUk/1WUn0MXGA+jFmEI1G0r4FnlC55JT9YFT41DulOZC52QqtFZSVaQeAapOd3smk2JdMtehJKaGlo8kX8eqp0/1Pf7509Boyu5ROrpwaN8b6kM7HBmXghkNP8EcoseNhArvMGQkI2GnQxU0I573xcHfNcLO3XZzfy8mDEquvoTQAdrQd9XT6ip6aSTFXrgfw/AAIEZnH2m4LZP9JHf/RydPHtxpTn2ljtvph96z2vtAJuIK/XT36/5bzAvRHe1Ra4VTwPGj1gIE4AyCoxhgUh6gBbc6Evh1nXJfCxy9dDoEh4CxPT41ieu792iOH30l5+r5py2qDpyZ2Beec1kJpAK4CVmMxrFIrPMs9hZj9221l3dDQVz1UKrhKnIUhyMwjFXXkxMHoNyIGpiJ4miPj6kA0i2e6PgTTiwyaK5Zdh4A0OqgDIqIcFIVC2ClGVTKM7Ji5IKAKXgAO+deQQDTETCDDIW8ACphWkBmfCQQCGRQXlQub4nnJdEvqcQEX3txFn6Pz7x5W1TwPy1N91B3/P21wapB8GcL8klsD4DoE2cQrc/2pU4OyOlRLmPzDAFk1IFkgmei5phCjlDDCEw3f8SuSwB2UtdV9ZzTdvJwNZDL5zisZKcKdiY6FID4iJzrBTG2LmSYFKI6zqC/TqOFTRT41D0NCjmfVE+oOkoCMKmBphpzxXq0zHrOkvIiZyKGNGKUkVd+8te7UAzmrkq+BuB0PK1//exZ+g3PrO9mDJbYQC03c9lbvBDxfyyLuEYmDBW/LfU+rFCeqioWLXrP3W1vlbLCrch+v6ULr/9fvUOWFZgDZ7RBlgGWwEA2r9PJTYs+/sU+DL2usui+saYH8vkAkNjsQV02qK267rBgnjMm2BZjObQa42BE2P3aZVEgTFvhKnnOvX+h5gBOPfGXP1XYQThtS0kAB9+2530wG031JuCpnveNVeDPS3LQxFmBZZ3BFPCWLxc3e9db60HiUhVx43VjfF0Yei6FOABxqI6ZE+3g8U3dj2QaNdXNcXW6YcH0ercsaCgaspmuZsAdij7YQbCWT0khS6cRbNVx/zGmIw4ao2ZYqxQMXPKYAgXf147mIVODLGKtRMZNxcx4EGLxGLql60gtIOWayP8eVkOuIMeeshX2jODMSBGqjFoyovRIoUCGCmtCmZwzZsnocDWQP8IvFcSui/Fu0HHQJc4zDylV6LfAlLM9ZD5T3/1z5cmAOi1b/eM/tGHHyIiolmlkaKnxZARn4IUXSqmaGjuFRfKWOASdL1Rt63d93mOMgAFXwjBLUJtsR/cZ6krBawySUhbyByAPR1PaZZqYp5YJz9Xd+tMQrPZDDLlBcZyZcToZwEXdAXQtGhSCQNrdVmL8wxJBgU0y3bv5j1B9KcXLF78l/mNIEYpprRQJVvv3OiyfCYFK3HTsTWKMhjgRWf+GYArpiEGSQFKBOx1DRATd+5vNhFlmURvAe9ISuD788Kaqb4oeSHL2pkICuzpPQ0mp+S0/5bhJCM0VmKif/fYs/TJrzy3LYqXPWsd/fSPfseCHGLhMFlBnHnuq6keGyAgWSy5g5nDXqlrrxl4ikc/6s6nBpWJXbqFUg78N9ujK7CDrDOqchOW4vOB3hkKJIhwiPvMljYDh9UaEVzmWfb1KvhKaCEeGQBMMYkgmGXCvDRmnDjYiQaduv9oGo6C5haTmzGJBpI9ACj084ayHNjiEkO0ZorGxdFkE41ZKcwxBMhmHTtoUe/t10+epX/+m5+5LgCAe+65Z/kheqRYmOpKThX2y6jCUx3iKbPAK+k4T+XPt1r+VUwHjU074tSPP9++/ljHfoqdMPR72tcbAx6wibVqEsDUvVuFETAVJYiF6pBjfzsep5z2xzrg7XtqO/5Dv2cIXBibE2Oyh1W79WNyiVXTOKb+fSuJD0PvbxVgbxmItmzMXLp06dqXAHz47XfSm24/ZJs1g55dO2RootYi9RjNhjpq7ATbAQFc9dUwEPpn3ulE513QnBJ0F3rLi4cowIQGdZWyyB6vJPA+Zl0xWdqsyCUbTYasw4lXL6Urr3F++iG7LllhZQADF+NDZQ4ggo+dPHMgrp2aVs88r91ybqL/FnT/ItR1hRbvlPmYc+5dPfKYPcEOsXicmGCUYl7Q6mvnwrLVIQPduqegQ1UQwanZYLiWwOW/cahHF3JmXjBJs8WiVJRGZ47a89gtCrp6jt2qDCaGOBNbw6sTZy/Qz//u57c0sf/xD78ndFuxW9VV0z3UR0ugdiNS7gAK49wRGtAJa2a3V1ttFwufE5onal3Y5yLPMbot6r+hKEZvEEHgxECvWhwCVW1WC4hcPT26lAglEa1ppuWTGy0ZzD6hQGEw6BP0J5Bsz9HdvVMAT1T3bMW2tvIZCwS2CMCALENShWeNU2R5QAJABh8GZeQgVdhA1DpZssaBJgZ5knZzHZBpgVGhKusRj+10ecsQUBF9KmxuAvCA91zZNhi3mqFT1KnZnKA8qLJZQL6kr5lJ6Od+5wt09qXL26J4eejew/SD730grF0IANo4VxaXxlvCfNZCNHGbMY+spYEDkO3nYtRzajrh4Xs5AuAqQxFxeZmnkkC6Cvi12DbDiSRnpRt5ya2fv8qF8P3omjHvxUx2kVhjqTzgV5JzLqCucNOB97Wj+H/4OJvnTB1TGM8GWmWx10m6L0Bii6XuaCFeDU/tNZgieAzeDoVNVt+bgKzDPEXqfg5nGQW9w0EUxs+vfOpx+vQTf7mtAYCNjQ26++67B4vEMU00Xsso0FNF31YK81W0xMtea6r7TkSDcXBDuvpVwIaxwnvKE6At2Md+/6oRgMveB7IOpkCNb+Y1pXMf+vMyVsBUcbsKa6DtYk+BEMuAsWUpCqsaa16N71kmhVj1taYAvbar34JbQyDY0Dy+dOkSPfHE1WNfvSIAwAffcie94+6bFrX0jRZeDX86To7QQydeHYnL11LUxFvB6p3kWepi8QKAQqsv9Og6pyEbpTbnhezw1lhNPwlq8oyqWjd81TgSIzlcQtQYshf08JOMTozyAl486HE0NmSI6gtaybjHW2Gmd1XCRuC/r6vyiz7n4hDd0PX1eZnGv3ZD1I0/g+O3Hj5z6DR6EWM073pQCgsaDRfxVlyBaUwrR/DgSIKIPgmFvNOFU+xe1u9JcD8HQ6wZCyvtYAswXiAJgCPDQA/Gj33jJP3yp76ypXn2n37Xg3TXzQdil5ccxDEjxHqw7SpltodYvVRz5ZFNgUCAx0G6iKYDp2+SuLCF6MkK+IkUs0EtlkPuBpPF9GGRTMBfUDmKdi9Rm8tmsgfIOUMUF+uRu7n/gQWQApAhYKYlyNIAQFGLCjWpxMN+JtffxmLAZT/cxBmaEZqZihUQSuUwQT5Un0vfS406dJNEZH6gAWrOtdCr8wU3e/SvCGkSBFGh4lGcCg4g0wm9Wqh+vbj7MwBHDhLoHOeG3Bwz6Cvo0jujqa9FnI67PhezNNSxo7RGrz949Ov0ice3T0Hzd//qm+l1tx0CN/nFNQWN6BjiMow6b+wUZ8Y44yIeCJUFJVXHrv4BulLkPJys48kk4rGj4GJPUNByagym4FxgTB9Yo5VFiJGyuRrrEtFCRG2Xin9Jnwdc1WtXn605kc1nw/ZzkrAOMhpvKisGjP9aUFVjclt2mO+nLVWVqxSJzXgT0410b0z1ebpHDTnYoCygXAD94huSXXrlSiQHhEnoyedP0//++49sewDgzjvvXOjQtR1SpP6uUpy1RdQqxeUYXR8Li1WM8bbSeR4r8Mfex1SawRRTYSh6z9hqUIRPFeNT4MMqMYBjRVgLBozR9qdM6MaAlqFnMhX7NzTGxgrwZdr8sQ722PgbovjHMwJZTPvUe5wa+1ORf0NmhMsYA1sp2FeVRkxFAS4z9gzNXYi+bJ+7SluG3sPly5evfQDge99yJ73zrpvqZu0H0YSHkhx1n669jXnr0nSerNtoMVy+CaMhHTWdcdSGtowCKxQhaitB5zB07uyAEbta+j2t8YPFFoYOikeIzbMetj233LqKyJ4InyWFbi92pyU4eMcosgyxeLl+HTvDRvFkbjrnUSOamoFtMV5gXliinbwQUrCm40Tz3NMsdZY6IDkHl3181oVxwJ5HLmT0TQlSiqr3F6ewBhMqYy84rRyfqQTdPtlh1XTQ4N4cO6l+uNTOWao6VstWH0ECcdH9syeeo9/87FNbmmff/4576KF7Djf3AWY+GNRZMBdLAEGCY7q4w3WfJZjz+fyVRrPqBowC/gnIPEh1kvZaWItT+HNW5/Fs4E0wwOIUZBotQIDjezbrnCquNLlUYC5MrcAwQ65eEMacSBy8I9T8Mbrm48GArDBvjT5To40WauM9cy3whw4FkdbfPmMFKXSOKvskGVPBqf1qrhrSMwhjKZuChT3eMUGBJFmg8wU6adA2C5gYKkVfjdMVIDCJRdOFcNq2G9PlBnxIoOXOOVPSyNaMEYZQYNXX/9nf/hyd2Sbd/1tu2Ec/8aGHAouHiQ3YCwwILZrZQfGiX9eCO45lBUQ1eYaZTG6na7oOTTOFtL1IPP6OIeovrMVx9JWlwf1A7DOF/dyLZI3n7Wr3VRk0YY2itulAC/dJi2Yij611twGI21T/GgPgs6+Btn56od+LAPhH5sPQZ6FEDVOr4JbAiklNlGyy9bkvdifOsMkUU3REoueSAg9IeQaATCCbNsjRxOf1z/3Ww/T8qfPbFgBYX1+nO++8c6EIxcJ4qNjHLnn735Az+jLa8yrU4GXeAkOvPdYlH/MQmKKkt/dlFbBhrJM/1AnVezoV37es8B+TKQzdh/b3DAEPU9F8q9z3IW+CKeBEGSVjRe4YADDWuV+lyz40rlvQa8xfoH0PY4V3OyemzCnH2AxjwMKyVIBV3fuH3vtY538KXBrytmiTO4aAIL02Nzfpqaeeumpr3CsCABw9uE4/+u57ae/eXXFxkfiuesGcbu/OCVCH/UAau2d6uDbX8FpMpkotRlAAixVkBOhhIyMYoTS7lKyIcSkAUZ/jITTA+BRN5dRhXfN9WQ2SpOr/oHHbVcofRhqFjlvtqBOwAfCWdkpHpuhabukEAkZvmL0O90HjiKTJcycoihnonN6ZrFrwvq/dVIGCyLtDUunaBJFxPmHFjbwwdxmAlHJvvBOFpmD+rKUxxXJ5hxaigaGxMF0I2ACRqaLyDNSmYlyZdrLxYKr68hK3mIKmPrEfwD/67x6jp45vLX9ZkwB0bdU9TfWiRJgSD1FgHN3uNRUCD4oJij8sfNFgytk2WqiTmcMR02IEIaHpnCdGmE+AtMVhQZ1RVoAFgev3pZhOZtxMde4UtsKsS6FDmtT8Dzr6agamevJUpTi9SSSqKVefHWNJXkIgMMKNjEjnD9KPuX1C7N4FekBXyURKXIwre+/KM1BLMniHOC2Y7b0mcAbXMUwkRotGjwwFIJExgbR9qoWfeYBoZzS4n/tY6tSIjDh4lqBePEZZ1m4n+IKYT0fjJWDZ5iQLMhv1qv+DLzxDn/jy9tD+ExEdPbRBP/7Bt4eOsRqf6rpWwJbSQU4cPU/8QIPmfAweNO5/YjT+2uFGM04f76Ug7cHEs+w13p02Dw4wKFTAm6EIzQCot55BOpdxvTd5Eidfe/tcfVji9+j4l8puY5J6BvGkEgLfAnEqYdjv/NBW/SeUrdPOw2CCi11/N44V87ZIhIJ93c/LlImyGp2bUr1PhDnILpLtwVTSOWB/igfU8uwUpM6NhPBnf3N7AwD79u2jW2+9dQEAmCqSsAs6lKHeAgLt900ZgE11sFsmQFsgrtKVX1a4t19vHdvHQIChom6smz/UiW+bZqtEDK5yz8b+DT/HlDngKp3zVa5Voh2n2CVT2vtl9P9levWhsYtfW+YBMFTsj70W3vexjn87npe5+W9FIrBKcsIYaGBM8+b/p4r/IYYLpl0MgTzz+ZyeeeaZaxsAICL6zgeO0ne84damqMcsWzYqf0Z6fZbqAcbQUWu05kB1s44buNe7LhoGLtAhs8Quth7atWhNtTMi0DHvq3eBdoGxw670QX1/2oFmKHK0GO1zDizyVLOL7eBj8XfJO/ykXRh0Oyc7TBtYULt23BjMSRMVp6CHxrDp2YMouoLj/+lBct47g0ITFMwoKWfr2Jufg1F/C5VXaZ7loCpWNCA1vM+9HyIrs8BoyuCeDjLVoNOWHNMSSMT04DlnOEAVIAZp6wxmU3hgMhZGahcqbLjHLnHxg1Qjx7bjGR2f/9lvPExnL25uaY699a7X0A+95/7AUElg3qigV58lLAXhAD3ATtCi1d9fNpZKcd/WDnGK3VaIuWpzwxWUEASS3BsweABoR95AH6D0C4I2QBtWWrO2/xAIpKrXD3p76Pd1xrwxD/FQIDmNufpUQHxaABctGrCCAqZ3jl4mBWwx0n5gqyhoptp9ZDIZyAldToNnMrKMSkyeUbZtLYx54pYYgFnoUPww+Ij4uHXDM3NVB7M0fQSqpU6NSSBRi34nBynZGUNtt58ab5FIT5Tg5YDzVYToI7/zCL1w/iJtl6sAAG8LNH6CNc06OMxATydj5BEU2fqgbQ/DpAiSYIzbSiv02Svo0AEoz+B0qSNT/ThElO3jgBB6AegWUtbbZM9Ri3qG+FYhDqCeMdhyNv8WTKlQ8Fc/arL9PFuKiQPgEvxV3EDTx5bPv2z+RomrH4DuN8rYEZAY1onq3WRMIPJ5TJYo5CaKIng/yaMabT8v+5gQJrpISH/BxAaVA3h6QblvP/dbD9Pzpy9sWwBg7969dPjw4cGicKzjqzHWY7KAoYJKCyn92VU7mWPF45RR2lYNBae6nqtk2k8lAkwV2EMRgEPfs+y9r/rZVkkEGGNMbKXw3+ozGAIAtqr/n3qfy4wLh9gDY8V5y3wZ+tzLfAHaz9+yDKYK+ClGxpDUYooZMcayGEuayDlT3/dLgaOp/4bmFkotmJkuX75Mzz139ZoVrxgAcPTQBv3IQ/fS+vquYFSGXTyM64lJAbABklPltLsZ8tOhuCDhapTjJlHUGHFhsa/aUu0iatcpLB4ABiSgMHqB5F1DBwQA6EB5gB3K6oGq0+LQzQY9Gk+AtkvuXs6xi5aACZCaDpvTAckomkZlzGLF3FAMEboCIxCCnReM4xKlTYPOf95n6rpSFgWzqIB+SchSNs2zdqZCARG7GIkxHscBIr+f2gVxPWlIeEjs3Z++9D/WOg7mS3YQrgWhH5w8/gr9FzBuCn0b3EUbOqhQBP/TX/2zlRMArIOxe43+u7/xbjdQa8wmuWVzgBEGxqkhmITlE1LPtVg0ym6W0XxTBXEQhNCiuJ0TWqw7zTtmxzuo4uNw1nVmItalaF5mtiMWtdiFjldilySIComJGqO8FsmO7B7ByEGIAXV6dPn5tfo+FXjArO4hho6BGbZeDGnlIksKpVQ9sIdU82/zFrq32IEXuDltgSchJrOMAX3PiWKcpcTMQkjxyODLwNaZZAyExcMlYQ67p3aoTMKkJmC0mGAvwMJVROizTx+nf/PwU7SdrqOHNug/+563uJcMsck8Cljnc0HA3wHj/XDO+PoqFpPLEJepBoJ9ZRB1ic1cTiMz+15Az+57j4im7ZQdyrwEar595xo+PxSqdKdq3zmx7ecKdgfWoHrm9IXpo82GzuZ5TJwA5CwU9IWV5BR/B0ezJ01Q3PMZmH3BmyNhskYO0bVlqmRg+DHMwRQOb84wavdzAZYUABwqh6jjwAC5+v6Ll09e8P9g2BfUhPcXfvdz2xoA2LNnD91yyy0L3eip4m1ZNxZp3FrgdF0XQIAhMGCs4F9WTA5Fno2xAsY6/sti6VaJERzzAGi/jtroqUJ9GQCwymedYgRMFWUtA2GV7vIqbIQpWvoUCND+niG9/lAnfitmgC1ghUX0UMe/9RnAInYKaFgGDgzdjyu9/8u8AqZiAHG85pzDf+16MWbuN2YsOgVubG5ubg8AgIjoux48St/++tugY90gnuLUWuLUdDOwG7/oEpwxNoq4cSBuPjZQxWcpLejh0d3daIxmuOeUPDIHezJQIRRfwvEs08QKYUfFCsXsLsHRQtlp6Oi8b8WGuHGQkBuZYYRYcSXmkAQQoozs3rkGFM0HuTEHq6U+iSTCWkFqDjl2wnMFGDpA4bQTbpICYyEolZGA9uw/GxzD6/MLxk+2YEdvBHQYx4gxxmejUZCghwz+DeAnYGyIoN8To5P3fR48oOag8Sa4V+WQ/bUT5+ijf/joFU3uf/Ij743sDnCt73MfJn8AU4IZYa5Fe2WkJE97COaSYPqm+taQXR/msxrkJTtYYzRY8b8oh2CNUEQNuYJyGMHZJQawzeUovbTdeDCzrGNf3e5ZD8HIkRFeOFQTsBICKKnMA2RxgBmnrx9Oq7FirEoJjO5LLmvhSvnV9YBIAgPATPOA+WJ+IArUiFAH3hq4BUgzPwnWIdQDB9o9AAqtyR8aDyLbiK34YNdVN3nnoQjkGPfWmpcyxWQPZSps9rnq2GOcG2a2iwj9wu8+QifObZ/uvwEAH3hz2OEtOrf6WJC4CavNdZZCJ1cglCCilwLBDtXwgRmAYKbJu5iDDI+EQiykx//VgyOY7SFTTBlFuO84vau+d/LOP+7nGAMh4pRiY+rB+UN0PyeXnSnrSeNLjSkgcbwjSIq+Jfrb+z5X+j8ZYGm3T9y7goDBiCC//t628aAhXAGiAAAgAElEQVTzUddAT9ugaGorHu8az0k1IQD2c133y5aczeOD6tr7v/7+F+jYNgYA1tbW6MiRIwvU86libpnZHh7yVS6gAICCASWlpwuAwBQVeasd5SspSA3gTmmQpt1SlpfpogNrrblfYw7py0wPp9gRbeE+ZkI4BlDo+xyin19JROAYgDIFALTF/5UAAFvRuw89T6T9e3LXIrAwZjQ4ROVHAEGfLUo9p+7fMrPBrbAfVrlwvM7n81D0z+dzM/Ab87VY+ew+8N5SSnTu3Dl68cUXtwcAcPTgOv3oe+6jjfU94WCh3Rw1TlMNMkOXwtDwWrQVKWspKFAzKo2ePBXede1upwVatsdZ+QGaMRqwMRbjFKUIHQx87Yoy6Bc1dglddhkO1311Y7c8cSikrLjQjiwcsbEro8WCOTtXF2w12MLDM5Mu6mI6RnT/LZ9fTFus9woLH9RfK/XQC0SyLGSuLu4aK7fWdbVTrjRJ1z8W+UAism6E0vdL1wPp+tjVxbaNHqZmNa4QC2DsgvuPYGFFC1GKulm3czNX3WgdjqHwcvdpag5qvpHqoVejn6hhATz6zAv0K3/6lSuaY3/3u99I9xw+YPIa674JAhX6nCjk1PfgYG+63koj1UOt0mf1sIhJDL7B5VB5o1FgatGwOsgzMUTnOXiiXgACCSKY/KFjW2MOCbK2nZpZYgCTgjvYAc/u1q1j2RZwdrmGzqMUTCS9G65d6PagphF8GbrQKSETg2PxTx4vKhQzyBFkwTUoxKOKqZs9lk+JyVnCLlA6pdV4EIwKu/o5ekw/MGNQzw9HNkR0m5cgOyEi2pxnYhbXMg+lbZCDt11EFA08UElOlgzrGFmxWZY/l5cgyPW5p0/Qr3/myW1XuBw9tEF//wNvgrg+3OlVPlbHTUJxBwP1XKNkMzG5uaYVrwDmCLEV0QakAVtmXg9FXUrW5VagV+eIr4PFJBVjI0OcbjD5VHYfsBjYrfRafyACCY2gg60utpWeMMgwEozMjN41Jba0njkq0KYAiUb/6V4q5guQLS1I4T40WcXUgJb5pCkJMCFsfU2VtaYMPZUXeKQtR6bBwH6uZwAmTzHpMeWgrj3/YpsDAEREhw8fprW1tZWL5zGq/BQlv+36d11n/+HX2uJuWQLAVME5VogNFcBYzC0z7gsmsRPFLoIJWJhjgYVFIBbgQwX6quDHkBHgWEd2mRRgq13noSJ11dfCMTBEw2+/dysygFU/Q/v6U+yEtvBf1uEfAypWec9ToMWqAMAyEGeI6q9gVd/3BgaMmUWuImFYJQ707NmzdObMmau2vr2iAAAR0V9/29307vtuGfyaUgczmAGiTtfp8ARddryBAns7HL6rnm0GGcIxJskRdov5AyqpvmZfO+hKzU3QBhSLNfJDa6S64mKUQ7SPvt9Z19XiKbkfQNJMYXcWdgZFLZayFBNBO8ylYIyGUYG64ZfiIIN5YswB1oMNHqqC43mg2rocwg2hqhkZVI/aZco13iw1efJd6qjv53ZfuClEVdedOEoLCKQLlpbApegwLEALKqCBYhfeiw+yQkWpo4nb3HhAIxMYmzTdYp1und0b14cnYLC47rX89fce+Rr90Ze+cUXz699/6D56572HbVx6lF2UaeTGByI3WtPEjfwC48PgIOnU/1qQiYMi+vuRsaJgn2bKlzGZwPiHoIh1TW9hf2TwNvDiTw3t7BnRYk59cfQvzlxZPPIwB1NDqhxb1Eu73tmd+5MVBxjFpfe2S8is4PDc/T5kp+LD37WTSNRsuuaXQAMmiO5Q7gd/T+0IEYkw5pnRLV9Cx9fBjfj8jNZsZnB2y8L7j+kGEOVneeccnOYjCMkGGjL7/Sl7AgHjocqHElOH8iNR0JWASUL087/zCJ3cZt1/IqJbD67Tf/7X3hIjZY2SqPsQQ4efDSAypRSsXbmyrYhVnhGBHjTyxH0lBxmQAPNLAltN19pUEwUUwFWwrxj4RTmDjq0E63KnPxP8gcTmpJpCCvHgfi7AXGjTbAgaE2j81655yrYwPDPnIo0hobWUzPgPU4o0ek/ymMa4jnNbw1OR1KXYiMD1NQVfIz+DEMaw1uQAIpf8+fzs3cy3zyVBJeeQoPQvfv/z2x4AeM1rXkO7du1aubgeOrgPdcfHChIt9BAAaNkBWJQPOfC3pnxtN3ZZp7+l2rdxb1N0+rbYmQICxiIAxwzRpkwDV30uU5r+MUnAqj4AWy2wVwUAhlz4xwCAVWLtrgQAmCrkh0CANj1iKO1iVQnCWFe/ZTqMsRZWAWKm5i4a9m1ubtrfkf4/ZU65amThMhCCmenEiRN08eLVO7O84gDA/UdupB966C5a27XbTb+YobMoC9pWPbRw7QxqgcdgKJRtc6OmwGsiwhrvAdO3QAEnEJnE6OzOFKiq+m+lxgWX9KbJSdTS+gm6qgy0Qn9PBNniITIJ9Lpdl7xgSxxonJlce2iZ6fp+Q8Fau2Yp6nQzHOitA9ckLjCYdJUuLtzb+g3leSWng6IeUX+fFcRUzfzECq+ZbkZcqcKUjG2BPpDaBbQDY/3calpmjITmUORxk6nxoFAXfe8EJxg4XR2Tc9yIySPRsONtPgXgbj3XcRx0u+WHPvrxR7ecAKDX+153K33vW+8Gp3laiKdEWYCgKZ84Hbu8xz6AH2GDV98KTKeo90afAwZeKsCmxXTuc/BeMCaA1GcOgV1SmSyo5smhSIe0DmXw1M+ZSYIuNnFqnpHn1hMVIM8M/nrPztbIsb4XY6HoGOCWQt3IkwIt3uZSriATMAwsahNczxozUYbOOTcdcqil6rTVeLO8EP+J0af6PjtL1vBCYojeqtRoTBhRZgwCaoHJA27kNn+rdwAHz4CGUgtj18zbKqimf24BW0+C8QL1s08d25bdf6ISA/hj3/kG2rVrFzAwsqduwFhhKPi10EZGXEv+x0x7CXIVB5KVsVcYUWyMnJzFolaRcaDSq8RdTWNJYV+pT7MAOFDYcthrKXbGmQzkk0rFc4p+TDlQE0ROyZz60Um0fFyP/0NfDP/GbHt4xvgyTpRzb0bBzCC1AU+BAvz3JhMUAwT9s4RGBxP1vQN3Cm6YDFHByCBvc6khpm5QAIeoJoUQoc+G8YgAKP7533mEjp99aVsDAAcPHqT19fWlRd8yFsCqgMEUIwDBgFYesJVu+Jg3zyo0fk8V6UdjAYdM1tqCCt/H0O9tmQ1T9Psh8GCsCJwq+qcSDFpgYtUIvbFnsUoyw1Cc5FDxu8x34kq7/0MskbFiv31f+HmGvCzacTjmLdC+JwS0xj7PGMNlWdRiy3TBDr8W+n3fBwbAkHRklXjIKwGQmJmOHTtGly9fvbjiVxwAUBbAu+49HLrYdpCF7HDiSOHEjOIUxNvse7MWsxLjwbBrydgNYzJwITcmUg6iczDcCYfncEAfSBOgWKgKIfvQEw+MnVg7m1qweA66Fylt5w9ZBqrLT9z538Q3/0R+4KCGEq5/zqDnVSq2Ful+MKTQjceOp1JFs0iIQoIpa5Nb/fowj9h1qkIxManp/gP1HxkZWjrmGkU2myXCDGejVveZUteF1/c8aY2+q50g8wEgYFiIgS/40fAIbSwQlankoUxUBoMspv/p1z99xRnlb73rNfTD3/Y6o/YvzAHIge9zBh2phEIh40JGBDFc0IGFuaoSFO3+JXt9iNesnaX5vLev6zMrHgA9dV0XHN4xEcTAlDoPZ6mzZxAUAuyAhHYD3aiSYzRmBrp8dcrHfHQD5NS0k4i6mf9e1MVrkdHS4X2tYjBaxBgylxDpgVxd8CkENoCe2uj3lWJsLpIF+POY0mz3jgQ68XgwITHpQ8Y8SAK/AijmMUrN2D5ghJgFO6fu22BaZxuX2YuSTIPAKYGvAur5sZCTUJgNXz//O5/bdtp/BAB+5NvupwN7Otq1a5cVdwTrD4mz7HKWYLRXjCydss4gNRN4Dkgn14i4hahHjvp2/Z0i2tlm199rPn0w/HM9P0p1kBVG6JBfzWLwdR1siJ19GNbBryPsYbZ4izsNEwUQROMCteDuc3Z/CtvbxPYObRj01dvGkYlowJpzBP4YDgZMcW8zn4zK4sB7ySzBYFSMVZOLVECkGJc2Ebrqs6PvH8HZ8y9dpo/+0Rfp5NntOYf02rt3L62vrxMzjzIBVim+V6XpD3U/tfhfBgSMFaVTVPix72lj/lqGwVjhPvT/Q5T3IR+AKRnC2HttAYCtsAKGuvvLmAZDRd9Ut3erDIW2IEWZyFT3e5kp4BRANeQ3MBXX14ISQykB7Xgfe39DxfdUd3/Mz2GoyL4SYIaoGPu1HX4s/sfGwJX+3mXfq6yDzc1NOnXq1FVd314VAMD9R26kH3znnbRr9+7QyQ8FBhHo8bHDx+FQiJFBaBiVc+Mu3hTJ2hkT8rxxxgO30b+THVzbAlMgrBu7im1Hl+CA3fcCufNsB2h1MjeKJWiB0b151iV314fOCjf8bY3zE3CfT1iISuzKYBFv0WiSQ4KBkaXhNfEgbsZQNdIvUO+BPlkKjVz1wKBvFrF4Nisac8xZ7q1gY2MEFBpwgqx5NhqrmxvFKD/LPtfuqEYsNV3yVLvKxGJdkpBaUa8ZmNupF4S7YHMwaTPUmwRl7cTE9Nzp8/QLv/vIFc+t9d1r9JN/413B+IkB+KF6+Mum95eGRUJWmAs4xnt8IFnhh8/fDpniLAq8NO5SDERL9nNKvVcZAUaJafTXEOgmaioJQIU6xKtUqEvT6Hice2U8KUuGa+Y2FvJFTu3rTVLzPNgog4yGyCK49K2ruR2Blt7NOCNbiQNDRgJrhiqN2rgSjXu6R+Yh0yE6/ys7CaUACXTVNlZB099D6gcDO0ggVULz3hHoaDd5i5NE478aqWjSrsb7IUZKkhmdyQgFUEjos189Rr+2Tbv/CAAQM+3flWg2m7lJorKXGGNAcx237qqPHiZssZboF+CgGO67QtmeVQZ/CoynQ1sCi9QlN/+0Q2IdhzNYy1sjV05c9sT6nnF/Ra8C9KcgTB8hX7utY96kACQ0DrW9svHoqC+Us5i/B3YxFXgsJlHq7aMyuxz2MSaqa5YzH7kBv0RcNkXglxLTQWQBoLc9vn5dQWiMI8W1BtctnfsvvbRJF3OmX/zk49seAMBLKfhra2u0trZGXdfRbDYjZqbZbDZa+LV06CsxDWwZAWVOpwAQtB3YZd3xoe7q0PsYy6cfo8NP/fuQvABZAVNd+SlQY6tGiEPpAqtEFE6BAGPnivl8Xs6EdYy0z2fsajvnU0X+1dL/r/L9Y79jyvhvK5KEsajBsXE4FOfXslCWfW4dZ9jhn+r4rzKnxkCXsXm+ublpv+/y5csmOVBjwW/G9aoAAIiIPvT2u+mhe2+xLlxroJeAem/FSiLTzKrZl1DMXFdaaAIkLeiLTdvsHWUbdLAhSqCYc1O81E0XDswxGiwFKYAmFhSjnmi4h+7G7ozuxRonNwYyM66aY69FJxpoaUcBnc0XJwRb1F3UZcZumi/eEpIO1Bl5YbBDzJF1EyVuODl00aW+h6lNMSYG4KKTQH8PEdY2bpxREA+iWvwjayEFjSs7Y4D9sNWpptO6LVEOgZpldDLvs4Ahn2vytTPW56JXZiZ68tgZ+lcff/RlTfCf/lvvwye9EEOIMYup8YhoFzHzDNDDreVpQzEGLAGdRQrA6aFTF56kbAFMTpDIurHUD2aIn0wlRjJxKPizUYjZ7rXGyhnIg2MUJDUEGeEppWpGprT/FFywmdXFGaQjlGmWumBAakCjgQsemYZ66XmfzRtCIEnBYsJyTCSxpI5aLCigODePFGl9FUM0GQEzQtMZUmI3zBOXOvSm26ZgZohyFxImCDawZ6407Hnug6Gid6WZus4BJaP2C8hUBPX/CloBe6npGpTNWxYMXnVcfeS3/79t2/03AOC999sCuLGWaNeuNdtDMXFBgBqXIfp0SNOrjBcDx1kN/qIED/0c9Dkr84e5LYiSrQcpMaXU2TrRA4AQvGeqPMXXdDBwTclTfwCkR28JXbdt36UydnOmAFaZH1Ad2Ewuc1CzTWTf9X0tullNdjmAZrHYANO/hgEw7ysTS/cODvZ9luahRsUOGqJmO0fQgjh4sbRFms5NDpGatMCYeOnCZbqQy4H0egMAloEDs9mMdu/ebYBASskYOENMgGWU5LFCKaVkwIMW/wgIIJ16qMs79D5a07829aD1FRgrZJcV26sCBlO6/60CAGPMgTFQYopp0AIAel/OnDlj1OypqMixAn/Pnj20b9++hTG1Soe/LbJbivwq5nJTxfdU8Y/sBNx/h97PmFxgChhASQyaZuPvaCUsLXtlih3Smvu1AAD+t0oHf6huabv5zGymgRcvXgzeAt/q61UDALz7tUfoe990uzn7p0bzhgV9Mho1BVMizHmm0swlMDkmgggq1o1VPIYo0IAZo9BqEVsPuZhfbsU4Y9Sba+2MlhwGidP+Z507i2vMj7nPMy8YtyF9GLW/xoQgj1fTg/Osc2AAu6AZItcImoV91Wxjd9cN/RgygcuhB/PqUSPphw9PHfCue6RIqoESblTtYZVoIOvYfCFS0fcTxB6RG051qaPNfm4d7FIocjCxc98FjgaHIqYBVRO3xLHgReq6gig9xCUyFvuN66AeVOe5D89DROgzTz5Pv/bnT7ysufX3PvBmuuvm/bAwIXUf6Nqm70WoBRcJpcSLd2WBO5ubzZqbn6XYk/KuoBQTuVnyeagu/ugw7z4JfphvcslcfiFk+mR8piTQdRSQbIg/RzuK8yLziIkoddG/oHgLuOcB1wJVhAOIyRzP+hh7ZwBGzVrsqp5509BfMRJNW0wlTk2yRXOIBDmTO/hLMIP0+xZjyWRgYxaTRulG7B3/XBkUFkdYu/2ZKLB4pGGNKN2YYRxhRGdKka2ArAmCNBYFgRN6FsAcfOzrL9DHPvXlbV+Q3LSxh95x72F6w20HiagwAdbW1gIo4gQNgbmQQoxm32fXyFcgFNltITUH1hWLksuZiNGks+g7UINvu2xyUKDt1hMz5b6CeKRrBUpqGCjwHFIL9PvKNHGWQDHLTb4mCMUIS9jPc92f1HzUlQ7FI2Deq+4eTVUF6NJiXX89wKofjs45BRVQoIh7NM4vfIY6r/S9IljrwLsE7wR/j2wgOOmeNVKcnr9wiS72mT7/zEn6wjMn6MRO8b8l1sCePXto7969W2IADBXwWOQjIwCjA9EwcAhcWJU2P0SxX+bKP0WPX9V8LzfStKH3u8yIcFlxNsQ0GJNrtEW9UsGZmU6ePHlVurR79uyhAwcOOChX5/kqHfRlZoDLTPfabvtQbODUaw8xTzAicIgdMCYtGGMPrBK32MolhjwtWo2/xvcp7V//GwK7hubLMiDvpZdeopdeeolE5Krq97cVANAlpv/yg2+lQ+t7wmE9drPJ9Kl9liCHxUgy1FqHCVx3PnRBJsJuewrFuuqipYlM82IjRU0tVjgaqYMddHJXXU5MM+sgZzfzYY4Z3U2OuB1SAEwgoto99MOTHn67xGYyqF0+FnxpQNAgi12/pl3zDDnH2nXtczZNvyBYEKQb7g6dKNnhHumNOTjSq5mSBNd5Fu+Ggrw5+BjopOt7N0Q0TwXQpppXAdxnPdi5D0Ps+tv7U9O6wAbwwhHpyAkKngSxheFZh9xlWZCv/OqffYU+++SxlzW3fuBdr6V33XdkQaoQGS5gmpZlwScjsCoIDpZYNCpgVgECpOlbIU9K7c1esOLGQZ7aUMAlDj4DWlC7LKEpsDmmHGiahh5usWBII8Y7paEtZjDGBMakwOjxAzbbeOSka0yKXXyNp9PNsZrdOchVOn9poUDzDx/nSo3sq0aWvaC0CX02QNLBtJgEwJENocukSgx6EUpSJQ0LcRlq+omaUYxNjKZhVqQk988g4eBL0sJEyLpa2OxBWpUQuOTGLMHkPES/+Edfoi/95Yt0vVwbe9bozXfeTA/de5j27+pobdda2DdYASjChApPXFGNu2r4/VCHnvwOlOVw+EN/i6Khz8HkqcwTTN+ITtc+XnX+MVDkkR2gPiM4bqLsjsHbBNIvKiiQcy5GhSJmlun3J+rypVkHFehN9Xu1+Cf0vqk3A71imMHTxuR1BVBw3yIJ4ASCuALxF5x4IcllyItHGyLqh6NMKVkACymYMr904TJ9/MvfoM9/7SS9dHm+U9m/jCJv9+7dC93eK70QBEipgHz4b0Od1mWd9TaDfQg4GNPrt1/HAgqZBUM/X5o4/SQoMdahxw7xlCHg2Ocfe/9jgIN2/c+fP39VO7e7du2im2++2X4Pmi0u6/4P0ebbgn4MXBr6uaGvT3kVtOALFvVDBn9DnfwhgACZBWNsgimgo/3eVtc/n5ekMf1/jKa8oqKamS5dukSXL1+m8+fPv6zXum4AACKid913C/17b7mDZrNZ6PqWbk+G3HvIZV+gnTS+xayRfWWjnHVpQZOVs3exvTPv5jdhENV4P3Rsty69Fodq5CZ+oNZiP9B7wwEFCnqgk8f3gIUSh0xi3OSZqaFckzlrJ4xWg86MHtRFD1PgEJyBMs/VDEnvGVgrW4c2sRuXt94L2uVI4DKPVF8ckRY3lhiK50gvdXd7Nl05gXeAU+G8o4gdQ6N41wOmHjg9brG+Bz3q6qFIqaek3Vi2w1+CuMdg5haOyxEt8o5YdN3+lx//Aj117PTLmlfvf/1R+r533Oua3bbobuaDbaiQwBGKSIkpBiVZIUpv0JzPjOAEs6klmn6KUE8ezTmv87VLwNYAF3iGQz6jjCCAW25khqBeLFDd4wJp7n12AMefChuzxoE6jwP0OcPApnGKbYKM7QTrQZc091xNIRN0rr1g6KtzN1LtDSwCvX8Gd34df4kdBDUQRBzE1Lna1cJL0zISxDCicSXVOa5gjeWNGzMihWcl4K+yYMIKcaa2ySP4ywzgRyxeF5kUKiup5pbsGvNHv36SPvbH27/7P1goMNPb7n4N3XvLDfTAkRtotjYz0FEku5yCKLJgJAcmToqUuqhHF5f/BPlJ6OhViVzyaEljPYG8KoPhpgKSOtayda+TMWGM3t8lqiSa+r0q12KT3qmUjpr9lymyDqTZ93IWM6ntgneOgN9QduqQGgLW36Rr7LzPwegXGQNle8o1NQTWwBCrKW7mB8Z++nscVKiymsooUvZUtmeC6Up1roDPQM5CTx07TQ8/dYK+9OwL4Pmyc12NQm/fvn20vr4+qb1vi5oh9gCyAVQOgGaBqj1vu6xtQTtUQEdGZg7FWFt4L4vTG/r+obPHEB1/FUBgiskw9b1bkShoYXrixAm6dOnSN401srGxQRsbG4PvZ4wNsKoPwBTDZOpnhor89ncOjeGx9IIWGBoDIMY+09B9GYofRNaGgk9a+LfmfkPylinQpJ0vly9fpsuXL9PZs2eviXXoVQUArHWJfvx730KHNvaG4h4LFzvoWXearIBSZD5hljRFLTZqwqMbshcuqsVVvR/BQTTjGwGasdOawWVXIgUcN10CU2GmxYgw/Z4MSQgJsgb94ODRS4jiY+9WTcpS041cdCn34kw/dwa38XDgI+/8u54buoZAJzcjxloE6iLQ56hTJPBWyND98Fg/CQCAFaXgD2HgAGY1m/FfPeayVDZC9mILFnukXmF3MkQ3ioNLmtNsxlTQze6gu8/cRi0Ob7Tmbk9CP/WxT8UxdwXX2+85TD/0nteFc3tiBh8FDtp7dcL3QhtMqLKbFXo0XC0wBYy6RLOoMU2gaHTdUbo8kV482gEsHOztKqDSZzL6rwJHygYqsZXVcDFxU6hEirHG9Sm9ts+ZZvWArGOlSx3MyTY9AWlmPl+TdVDJTPTwPillWLv2ErquXkQh0IWeIMissahAMPxTNpI0hV+Cea0+CmpeaR0/KLL0va91Dijo94S1DYw0GYCCjsGIjKMWmiRq8mPHwCPmwoErgEaeQoBO5yHdBHY3/Psv/tEXr6vu/9h1z+ED9Na7XkMP3noD7dq1Boce9pQScqdvi6pD5/7GiFHlV2SxdFLp9hK06VQ9byz2tu4zSTXtElkzahAaioQ6qVKNZxXhgAgxUfWVAF8WivG5mvyDkX7KHmHQ6fQ1rtY8JOoeoHNZo3WV5i8NCy4bg1D9XTJEWRKcazTqtrcdNUsTVWzSIgJQg2ne+5lCCyiVxem+OKuU8JDtAiConrV0sj36tRP0maeO05NXGD+7c61e7K2vry8Ue6vQ84eKEKT/KxCA/gBjHdQxx/624F9FKjCkkUdGQdsRben+U53+qYK/TSsYe59Dv2tM79/+3Pnz5+ns2bPfVGM2vfbu3UuHDh0afO/Luv/LnP9XLfynEgNSY3TcplGMgRCr+Bi0TIKx99B+/6Dxr0ig92vh30b8rQKQjGn8L168SBcvXqQLFy5cU+vPqwoAICL6K2+4jT7wxjuo61LQfIbFRAEAMMiRQAn0Yls/3Kxq/XoBl+LQQS5bN2ajW44waX5xogTmfkb5ra/fu8qA5n2mtRnQ0IXi4Qo24gyFsh+EvZg1Sia56WFuFq8hgzO8D0qpNEO8xsGcSCPIBEzxcBKpWQZZZ9IM7cA/QcLzApMNiQVA0+gu/gpmppSDB0NukWKgD1HTBUxAq1eUJZP4Z0sdAEPFtI1QM12rmbBRaDcZJB+m/xQ01kPfiAhMaBGXoADG+6IMEYuHYqZjpy/QP//tz77sOXXkxnX6B3/97XavEiXK5GMOZSxqdEVcwBKUSqiMpKsFODJxcM4QtdTT8lw2++ysnOyGiPpnHxds5piuHdMOdoy/xPeDZ1sFsLjq1LVY7qy73G487jwffBioTbioY4vjWoPPNiSQGBDkbIBETJk8iouYqVPfCNDxplQKq17HPIB2xTMi104/mY8CI1AZh3QovqWRCNhdx5xzpqKpJqmMDKlAjNAMQCO8nz5exDLgQyynlM+DFhIKrtlaSQqyVH+F2oENtHUAqLiEl9gAACAASURBVBIn6jV20rTfHIDj0v1/fKfigOvooQ1685030VtuO0R796yZJIVx/6l7XwbzTTTVRWAqJO6Yo34dt+Smk9kAqFSmK+zbCGIrQKBMAN0XiJjWZl1Zu0y+UONyZ2ysNgpRhmRyA1FgW5leHPc6MiZBts/XZ6l+PQ5kE8jyjA0AaTwkMcmo/FwOKR+a9pINbIEGgeTAS3Agj8zoL2eMNsT3VD61gLExV9mRfiZkp3XMlLpEn3jsG/Tw08fp5Lkdff+3GgjYt28f7d+/f2kne1lhi+kA6j+gf0ZmwNjvCck1EwV/yx4YKvhbzf8Q63DIWX0sW30KDBgCIsbu05ikYUi6oNfp06fp3Llz39JxMZvN6MCBA7Rv375RDXwLACwz8hvrro/FAA79zvZ7W2Bp6j3hGG3fIxb7Yz4EyyQtWBvouMRu/1Ck39j4HwMA9Lp06RJduHCBLl68NtfLVx0AcMO+XfT3vvNBumH/Xtuguia7mEJXbdyAgWFTHKLem7N+1S52oEnBuMAOMsrRRK1s9rGjipm9+DuxaCfT8LnWXQuH1Bj0cUi94nBoNrNCavWQqP/jWIAyA7AiwQCxci2qxhmJDk5TFsoViQCaZP3cIZKvJgMwmIuZEVKlJqruXjXJORTwi8izwMHMD/veTfLOSHJ3cCboXDZuyXCgar0XspQiJ06VQP6wg1NWTwiioEnHAmRW8+z1gK0HaoIDpC+E5YeePHb6ZSUA6HXTxh76r77/IR+HOeZhZ0EdN9kzRBBDIFpNO08O9uSYSw2pHM32ax0tsY6XG+BVwa116vVgdHlzXhz3wX9BI8AwqxtZPgtzSA/ApEaZ1ekfaK/GOOGGWUTeJVPWSGri9XSMYDcbtcP6B2kKLKXpoxxIwO/CssxBPkECppxMC54EIs1GFaXw4bN68aYE4spQUOkQvEbfF0PRxK6LtlQBWcyINyBINQj6iHNkH+Bc6QAI66CDifdakzfcVDCTS2lSSGjRZ7nT/R+/blzfTQ8cPUTvf+0R2rd3LSCqrc5cWVulg+1jRuUv837uRnsw75S6rgw7k6SB5t+BWzZWgIB+nivwliBVIxwQVV5ARcpmDCKQdhFzBetzPVew+RRwBdWYuTLcYsQvxv4liJ8soEcmyeopQJXmX9I4ci8xgYc8maQHI9F5n8nZhELYKshBroiiJLLIQ1tjLBY3xgKjr0KXmObzbPvjxx/7Bn3pL1/ccfV/FVz79++nAwcOjHYlxzTqbeGGsoCu6xb+G+oUD52hh/TvQ0V6W4Srpn/odaYK9imd/1hxPtSZXUUOsGq84fHjx19RAzcdE0PFeFsQL+v+T5nqjQEA7dgbouOXVCQZNKwcAhpa5ooyOIZkAkMsAXz9Vr6Cpn6t1h+lAMs6/WP/fvHiRTp79qxFPF6r16sOACAi+vYHbqPvfvD2glYCOt9XcxxSjX2m0KH1et8P03owyXBAVpM4N6hK0O2jkHGtlNk1MxJTt/7aecJ8ctCpEhSoBhzA4dyzsN3EyCjYKH8A2mL7pIzWXDvdQ5nXFvUm6lXgWdpcadVYiJrf0IImHczXyAsQkpgA0Nuzqd2j+pn0Z/q+rx1PdWLPgeLO3NDslfHBaWEDUYaBm5+xF06QQY+FjpDrrLGLip37DNTjslHmUNwh8FQ6QwkOoE4vzyK01iWgbUc6t37AbMaKHn2WRejTTzz3shMAiIh2zTr6qb/5vlC0h8hEis+wZamgHh27ufMs1t3zjYBCd6vE52XwAsghLYPAkd4172x0YZTroHyCAWxB5DdBgaiRZm48KG7kWBlGIphE4ZFf2jksm6kzWtDwpmUO6Rjw5+vFv0UBYqZ9c08RyJAm4o/NEXxxE7bYLvbiHUsIaop5pDQTUZBa+Q+W1+olAlWtJCKAO4Qgp7NLktG4Pd+cQCJDAGoQRX8GBvDSwA0ofkyfLRHcRJXXo18/cd1q/7d0yNy7i954+yG6/dAGPXj0IDn2UkBfgbGZcwEAtCjtugSJAWymeggOFzmXisWoynXUf8WZPrYXVTCAwZOgyHuQicVBTpU4JhSo10YiDu9fI3N7kEApMGlRokQBtA5sLgMxxVIucpUieRqOy2ZQxmagSt3/7EwgEv1uCLw1apMCaTAiXOJiwfgym9EqAavO72WXXEIx39yk33vsWXrk6RM7xn6vwmvfvn20e/fuheSAZQyAtrhDAAANAzE5YKqYnjLY20qHf6xzP1WMjbn7b8UgcOr7pt6jiHxLKf/LrlYSMOTIP/XnMYBn6Gur/PzQhUwA/R3tvw2xA4ZeZwhoWAZGDGn8hwr/sQJ/jDmiX79w4QKdO3fumi/8X9UAwA37dtGPfceDdMOBvSGLnBHdRnO+nK3TzA310x6sbcDxU5t2hcjohOHwDM67SbtaHGN5MEyOmYNGWmMEURecOGpiNS8tWecUuwzZ9P/SuHcnZsqUaycdHJZRs020EImGB29u7mXpniArge3gTgTxUDUBgIBNkGpVk0FjTBSd8bWLj9IATykSkBZk0JaLvw6TBTm1aQBSjaE8BqzSuY1KXEUULCFnvDWPU+BI89/7BiTQ2LgcUFKGuCgGmmylcmcJxo4JutcqH2gTAD72x1+iR54+flXm1E983zvolhv2BVd1A8kgizumEvgioaCsCGzCGAuAEZxtsQnUX4bOPElvRXqfe9PymvN+hV5IjSK7JhIS5xx4QHQp1azwGCm6mfsKCPimJNRqyZCSzoF2LkyD3iOJS6HcZ7F8copZHu6QDvc4ES2Agkyx6xjnrT8jHTRST/j4fdmYRT6eO3QO5xbEKvPCwT+qhoVk0gS9Wb16L4DXgEuz+jCJYpymBLZGBMPEtdc2fqJuO1Xw0SUe7kOg6SUBgABg5WOf/BJ98dmd7v9WrjfecRPdf+QgPXjrgQKWZ7Hx73KZ7BIockNBBLCLN0VfnmkFBIIzNMH3wtzCeF1qCnoO3yuNHMdTWTICReYD4iuHrv0aQYn7EZqd4jrX6vsNWKsSFVH/FN/WaZ7FWFKBqZOrvAI8eNCHRZsNNkcgyiNVyn5f4weVYYZAJ1iIGhCaukSPPnOCHnv2ND2+Y+x3TVy7d++m9fV12rNnzyQlf8q0TDv+CgSoLwACA1MMg6kie5npX2uutgwQWMWccOpnV4kFHAMVUALwSlD+l12z2Yz2799P6+vro8X1qgX8EFV/qthfZgw45B/RehIMSQGmft8USNB+Duz0I80fXf+XxWyOXefPn6dz5869qh39tw0AQFS8AL7nzXdad3548pK5z3lkFujkOJpV9Eq5zRJpv8x2yFFqIiIBQYMPzucMm7GmFHSJDK1nIO/rISKTUGcdeOiUEFnsmP6bO4hzKBLs7xQzgk0+ULurxR8hmf5S3b0xhi4cFKR1pRcDFhgmsQsLKBjcYXSUFpmpAh+ZChXSXMPrqJv3vdGw9VCG2ktmIhYv2HHUous0RkY5iojdxegl4XRvBSh44bXMeJAYulLYYWKjhaaWOgUykyzecXK/BlnweRAAFTpO9L/8m0/TibMvXZX59A8/9E46fGBfMPjCIs3kGmBih6wKXDjL8yl+Chm6+25cVRzis3WekApPAWzwiex042RdeGfNEBPN55m6TlkDar6J3iDeoUtUdOEe9UchXSNLNJkzYzPCjlrs5IcuJUnoQIbYOzPKrOPDKPhgxjnQ+VezT02tNKaTSDCYJMlRuc+Lr4UApbqIK9WZOAShBUZAlzhsDhkcypHVZPcAmA2a+KEsC0EmiUkQhKRSogsQKEE2FdeS6vGAzC7JC53iIfdhvZ48dpo++oeP0s51ZdddrzlAD917mO67aT/t3t15hCpo1JXJM8+9yVncvFFgHKZgcukmgAhKu59KBzKBbMksLvPo679xRXx1THSc3KwPAQWOSThZPC1AhEOBj/4FtraAYa3+vcRkSvUxqHtv/bMmafR9kTDN+0yicYNZ74tH7/YQi0okJnXq+55S9aoxLwYAADTKED2JGMHFuqY+c+IsffxLz9LXTpzdGdjXKCPg4MGDo7T5oUKuLXRbScBQasBYMdR2+4e69EMsAOzMthGBY6Z8bYE39rmWpQCsAmTgv2ns3nPPPfeq7vJubGzQjTfeGJ7pskJ2rNAfAg/GCu8x9/sxNsJQ1N8Ue2GKUTDGANGaaXNzk0SENjc3F5z9lwFCY+/h0qVLdObMmW3T8b9mAICjhzboP/y219LGxt7QlVVEGzXMDO6/fY4UZtQm+3ch5di77KFTAK+thSZShhWlN7M569xzKF5Uo4eRWMza2Wyi/UJ3pC3Km64xvg5BV1dyYC5QYzjoBZECFgxacFowBFR6sxYG2snG6CISLOJy0CgrEGPGXbnV5WOBIBCdZ4RgOyRq8wYBApJoOGUHKKAQo7SezeXcowJLByV5EdLkjaKZYZc6p+rXzn4HtH41biNwX/dxp10ejz7EckuggE6c6H/8139KZ1+6Orqzf/ihhwoDgKgZi95FQ43+Iqpei3dyvazqWLPETrN3dcky7zO6uytFPS8uwr0UbS4W1u7VEenAYTNgiONj0AibEVaydUL9PFzqgpIbsojPee3ABSqyQPwlORU4NX4E5gkCjCKXo7i0AiP7tGiaV1mLjkVc69ybRIIPSJzbFUiDYrmr69umapNBy0xt8kNDqSPwh2BC919y00iQ4SgopqWIa5HR6b/CNyFaqqHzSQbvkTgWOfh2xN+B8/ZX/+TL9PBTx2nnennXwfU99MDRg/Te+47Q3t2de+CISsP6IgVgQng47GGFEp8rEKYSq2Ryna6CpLonpiq/U3+bMubrupxiF9+TbVzOUtZqXa/qHqLJLeoVA8kVuqfpHO2zQPStQ/kWLar0flbNKRk7TIvvnPvyu8UN/nKmEGVrTYvcF4NMHdPaZMglPcXTZfQgm3x/UylGSsHb5bnTF+ixr5+ix597kV7YMfa79g/szLR//34zC0SPpLbAm+p2ohRAGQGtP8AUy2DMuK+VDIwV7G0u+1aL9rEu/9jfV2Ez9H1PZ86coXPnzm3ZhPGVuPbs2UM33XSTFcqrFtVThX/79WV+AKswAtpivi3sh4wAh0wIh4AHIgru/tj9H2KeDAEAQ59LHf2vVXO/ax4AICL6rgdvpw+8+U5Seqp1hMAoT0A3H7pk0MFtO8JiFAECnTnSDCMIkIVi7BFBtF89OCBdj0GEiCZdBGaAAgd1zFtncsMjj7zyeiOD07c0hUZuOp7hPkCElnbqWm1tZD04HREBgsA0UM0jMc37Hky7kLLMpqskK8ioOSA6xVoLQ+1Goy6ydEPwAFQNGvu4CRo9WDPk1ejQzNQ8Zs9/Li34AGjHKsPBTuUYaERm9G54bjHazMetUuG7JpVBD60JDqI/9bFPvuwIQL3+iw++nW6/eX8AxmTAAZ4gzq/r6qGSGQzkyn3cnAuYKgKYg4kAFfSJHeUKcNQOvZmNEcg5KMFzd28MohgPiIwELQTQAVb9OxJDocEMnXoFt5L7BgS/DHUm5zA2TEdbGT3B/U6NuACY8o2FIN/e77etT+qxgdGUGMmG7BVl6FApho1ynFo9J3Yt3Rwv2TjNVRPdQSwnh/VKICq1NzQ9Rp22XUf9vCwO2GIcoDIc9HlgjKS+FjcgioFHaKDYbGQ+vsrXfuqX/3iH5nwVr12zRPcfOUivO3IDPXDbDaW4NcoKBaBPgdoUWGYOpGokXvFQqeO668z4UrLAwdYZfrkaTiXYfxmoW6kyXmwM1gFa1jG2ddoXkwIstMyTEtlJxjwRM3vlhbOHgrrO7HGJX869mRdKkMIIzee9Ffm5MppyLofgeT/3PYtTSCtRYBxlXAyml199/jQ9/PRJenzH+HJbXmtra7SxsUH79u0b7K6vcrVsgLW1tRAfOFRstYVUGw849G8tg2CVyL2xTu2yAn9VBgB+Tenhp06dovPnz19T46DrOjpy5Ej4+xhlfqx4X0Xnv2qMIAJM5qUyQfsPcrDm61MRf8qMwv+miv+pudHei7Nnz9LZs9cHS+pVDQAcPbRB/9F776e9+/bWzY0WjLv0QLDoyt0sXJUaqAVK2WAzuIZziC7puhSK9FhgEnSvoYA2oy6Ggw81xREH5kLfS4gS43bgkzRFoIMh8fOSOahbdw3oyMpCQMf5qFZ2SQBT8BqCmDyPahKJ0gSiSNHPFRDJILPAeDjMu8dTvnd3wbE854VBikWmu8FX+jhDTjowA3JW0ynvNgpkWXPzHojZD4Bg8KfFkebRZ2GPzIMZZYsO0Os9Z5qMNo0PXw+Ux05foJ/7zYev2lz6+9/zVrr3lhvB9Z3Ik+JksGMt2LFuPDVaJD+ldkOO0hHLpobiNkt2sIfIvAAwXivIfZiDhrg1KQpUtPqMZ10XNpaYzJCseyjQsdbPU5hBKcb5dezyDnE3cH2d1DHlXqoJF0E2uevVS3ET2T8KVniX0teFIIUQibroysBAM70c2E6L85M5ml3GtaeN7SO7DzbzsoKbMU7QwDI0RKwIRSK/91Jfz59XGzkq4Dnh91HHbnFwT1ZkIpMIOTW//ukn6M+feG6nWvgmXfccPkD3Hr6Bvu3emyvVPQeIDiM/dd/sc7a4XN3PGfbRVIt0ldXNupntd0XX72uzGvOizwiaALbrqvvhMKH0RYFG2yMrCJ1BNlb2O2e+qUeA+QfUc8W8lxAVHBH2sublxgiT68BWcI3JE0MckU+wLlWvEZAzcvU2+dRXnqdHnnlhJ8bvOrn27Nlj/gBjlPqxYgeLrzYhQD0CMK5trHM+9G9T398WZlMGg2NF+5Q/wBhYMfSaahB37Ngx2tzcvDaLuMoK0ZQAlAS0z30ZtX+q8F9FIoCv1cHZq2UnoH/B0O8ZYrPYeb7+N5/PFwp//f+tXiklunDhAp05c2bb6fyvWQCAqLAAvvtNd4RO5dCCgDpy/HQWnUdu9oMMAtTEhw4yRcMjkqJpNUAAu9WMOfBsBwBmDmZzbaeUoKuaOGaztwhYbijzgVKeJUSpBSMwKJosl10PXuSLaCalIRdQgqzz70CLLbqEdNvY2UFdu9EbwTcBHbxzdTHO5rAs1plURoV2Zy19oaGRZzNwYpMHIHNCzda0UDBKsXhMGIVn4tpUv2f+WbHgtREJnW+NrbT4PAWCjKLJAQTBiDotAGddor984Rz97G9+5qrNox9+7xvoXa894uBZ09VV40I0r4wbvxsqal61P/3KxiE2CYB2xPxZg5s80ULiwOJBIHYULE4Min2b5gp6ZUig0K5fl8LPY2xnC/yhAVlhjWTLF0+mrW0OKY3cyDTSYH6HnfGUEHBgAMzEYwYJ5UdErWTJWQp6gDP8b2gJLP4bWUD1X9+fOosTAXNBwRFaiAJFz5QYSYagHACz5KaMuUqDVH7AbRQpMEEIi0H494QGlromcJO4QM4o+ulf+RNL+di5vondyC7R6287SN/zxjto98zXCWWtpKqxL/KxmG2vRp3GWAM5n0pr1M2eUzIw1VI62Pdzjark6sPjLJ42WcdgA0vGcckQBUadgufOXBGXFpmG3wFOm3fVMBMHtRhLoMoLDOzO4HWUqZ874FZ+pniepEQg0aqggAg9eeIsPfr1F+mJY2d23Pyv0wv9AcaK9CH3dwQB2oQA/W+oyBty+icA+6do/brfYgE/5QUw9LvH/AFaGcCUgeB8Pqdz585tG1f3FgQYY3EMdeSnaP5T0Xjt19pO/lixvxDhCuMwNM+gQDfj8OrsrwBAG/e3CmCCv3O76/yvaQDg6MF1+jvvfz1trHsUStbcYfgEnDgcgrlhBEhDL9U/2EG4ivK7MFDb4t+18HrY1aJSu19dwkENqGcthmezFOKE3FTPQQQFDFIacO4OqBXE2+UiaUjs8YhYjHj0G4V7gDIBwogtTr5AK3uCZECbA51kkSbuDvJgcw6fez7PJrfQiCV36xej3Gsh0AMLQCSbYWIHXgk5S3AbLRrizjqg6vjsOmV28zeBVAEYIJgiUe6Da71Nv92lhe6qa7UpACgI/CRONM/9Qu40CdGzL56nn//tq8cA+PBDr6X3vf624cVwgFcvA93hHrpgPY7hLAvyC9NnQUFLkHowdDiw9AYoU7Fg1m9y6rkX/kZZTylISDJJNQVLkUoGMYjKSnCPAd/A+j6D87hXmeiDkRr02o0RKQB4wXAR0BB37R5at6K5kgGa6oUhFOh2CAq20X3q2eAHt/isPQGAw/qh75ECO8i1y2jG588zOHKAuSWHrq1FM6IUxP7ABoikkFqSg2QpBXZA+edf+/Rf0J//xU73/1t5JWa68+b9dM9rDtBDdx2CZB5ghdjcSO54T84EwLVXi3BPsVGKK8p7wFxKpCQNkAMKyLYLY5587BQAyqNjE8xtXe+8uPC4W5IiXyiHTjDjVCCZhOY6Vuvn1thAMy0EiotHAKLhphS2UAXCu+R+F1/8xin67NdeoGdO7pj67VzRH6DttI8Vgm1R2PoCoEngFLsAC+0hav6QFnvq36fAizEAYOznhxIJcs507tw5OnXq1LYaA+gLoHKOsQJ4quAfAwTGfm7o39oov5aVkJqo8zFmAo4VLPQ3NzcnHf7H2B/690uXLl0XOv9rGgAgIvr+d9xD737traHgtfg9bjtr0VgOqd1q3iVCNO+l0nlj/rbmlJtBHxU3fZFC+caufhDnA2UZUS8/FBA1NYTTWuBEop1SLSpblDUl5xZj0UXmOB8BkAydbwFXce+xxK6axichxR87fKjjRSqxOo3nLKb5zDVWMRYcApTQYlSGngStnl/NmFLy7mtvhnyNUVwAdzgUMgQgiss/OQAUeAg1mjPVw1fOdijzyCiiGVKVwVhKKdx9lvA82g1XCxzzCKj38NFnTtAvffKLV20Ofeid99G3P3gHmNSRF5+JQza9jw8HnyikHpR7b1TW+vfExQsCDQHnmrMNxXIGYz8t0rkxRMwG8hDtmnW0Oe9NhuGUc3/WRg0jpllii9+a1YKgABjVewGL27qAZPJou1wZOQpOsdJxlVWQkh3m1RTTKMTGLPE57RnoUcuGbIWW1YMdyFIc6PpCMOeSm/1BwZMlGnUamJAj+ifmJ5IIhEDBMBUNI9FsMTHRvLKn3Ad0oGOv8ZuWtpCon/cmIWjfr8piZuDXoq9oTJmms6pAVAaD0p/65U/uaP9fYeD+gdsP0duOHiJOZH4hWXoDqXVOcFKKfwpAmNSx4/Y7XCQ9BEw2MIlM1UhQqmmeG3ZiTKCD1bOql+0xG1jX7lQMKmGymHxLASgLQ0UWjcp8YJ6SZPs86BVEAGgT5Gyg5KV8v5QUACJ6+sQ5+urxM/TYs6eumkHszrW9riF/gJVBvMoE0M4//j/qy8c67QHQH0kCWLXgHyr2h753K1/TAvLMmTPbVue9trZGhw8fDn8fK/AXfYqWAwCregaM6f7bYn9MToAAgVL+hyL+2q7/Mi+MlNJ1pfO/5gGA+4/cSH/nOx+0QykWo6FTyZhJnEPWt3YoEDjoNa8ei1po3enhRPPJUxtT5eeC4GKvB1J3CPf840zRVI2Ig/kYY+dPlPboBQqajyFd25oMTBYTZEZ34rTqLEKLQop4iC7dOSKiVHWbQk1jJpjGBedtOAB5feZa9xCnRARGemCOCDnG8z6HqDcv/lOAMKx46AUKcV/E+pxp1nUG3mhOuo6PWR0rPeSLWdFG7mavJn9ZUPoBMAo3HST2aKteafAQYZa6RLnPC8kVn33qefrYJ7901ebQtz9wB33fO+8LPhotcj/rXG6hxoZYOGqn2SjdBLRZ8gLcIsDUuI7cA0GN5grbxk0R1WARC08GDXrSYteYIALPwYGdDnwZivN9oc96l9tjytT7YF4LTk7F3LB4A2D3oqW6xwQSafMnCaMORyJsKgOEwquSxZqSFe9sUWVlbrIBbNEUB2oQopBdHiVIAr+3zIV5zl5w43pAXGLOAGTxLooYmylLrgyh5sAFYxoIPUFuo4Br3zf+K9LcS1tD6jMUpq5bBISJiH7vkafoDx99ZqcSeBVcsy7R/UdupLtv2qA3Hb3BjXgNJEwapmHxn8GbBSJcu2oQqGaxXZMtrR4ciTtj6LECeWD0p4MzIeBP1OwN1TgWQm6kSgZns0S5l2r+V5IPsrFixHxv0LBY2Tpk6QHsLLkMBp+QiKOsxBNnXqKvn7pADz91ckfbv3NdUTe4LdCnXNWVCaAF/5gvAFL5hyj+Q6kAyzr+Q0X8FFCw6t+JyIrHkydPbvuub9d1dOutt9r9R/Cm1ddP6f+nNP5jYAD+e5sK0NL/p0wAdfxoh1/j/fTv+uchEGLM/+LChQt09uzZ60rnf80DAEREf/v9b6A33nFTKF1VCoB0az+Qc9AYCw134bVY0eJzVjvySnkN1FuRaDCIrwVd6BkAD6b/hRteTJDE9OgMEWyxgwYF9cLE8gO1m4cNu2ba94KMoNXaopdAllzuq0knGhongC8CtHkDZ7gc0LNIYA2IxGJdmoQG1PJqQWCdzEqh1JuDZm4EdH79eQ5Z1TAeYJwwYUc7gRkiGe3Yu1Bci1hEvWX0mRD4LAgJdIEXC0qUlah/w59+5Vn6tT/7ylWbP++87wj9rfc/YAWt3ecs0J3T2hMMH5Em7z2vesCtDAlyjbsBIOTUfO3OKbuD4EAtQgteAy2w58kTrrv1+8fBoKuNkVMNLxrn4TxRDS+yaRhy7Q0Ys7Hr/cjE5J15ffeQPU7B7Z9DdCEHiUvyeWPzPVFiMfvA6KhOC2Bou+Dg88B5E6I5GYCWdjOAuFM0PLSCvHp7UKO/t/kdmC5xzKPPAcEYVNNB7dBmY0i1sZU5jFGCSMBETP/b7z1CTx0/vbO7v8qu/Xt30RuPHqLbb9xL996yPwAAGFMrjBC1gDeLpwEojK2AgFGYga2l0jVOxRsghdQIB+Hd6JWA1Veo94XxIrYPKvMFzE9qrKCDuzExpXby+2yytj43FGxgYuKflAAAIABJREFUEoq4VO7Lz52mx77xIj3+3M5Y3rmuvBDc2NigjY2N0QJ8qHBqfQFab4CpdIAcol3zoF/AUFTgMmBgqMgfM/8LYDwUi8ePH6fLl68f5syBAwfMF0Cf4VCRPmUAeCVRgFPf17r8T/1Zdf6q+1e9/1jxPwRu6X8vvvgiXbhwYWdRuBYBgLfddTP9zfc9EKLS/KAvoYjFAloPp7m6+s5CnI4ELXNbEOaKPnU1I969wj1KzrpZLCTCZhBoOe/YQcduHORwC2jX+2oIlLRA0hKAUziII9tAFlz9/eCE71FN1NDIDinqGaiKBKZtSfWHtUhsKcJB4x3eQbOpEAXQIGiQiYxe3OccnL3iJuNUfO2opNQFgwS8H0XvnZo8dTRf86xxpClTcy8NoURHfyjIQgICeDiY4SAutNDpZqVSN4vYv/3C0/RvH3n6qs2f1x89RD/2gbfC5wIABejVeh+061zGR9SlKziWAARBIz0S1f4TGDLG3+fgTASV9Hd2LVJsnTNpzQI8f14pMFWmkSAikuuzmHUd/P5IxdfPVNIIYmfQgCWQ+xD7Z0pgUEhMC0Z+2nlHUAWZOYWynA3QwENOhuQGo7onkDYZyCghgpKD/l4CcwXjQANICvNaUzOYIB2E0Mm5Glt2KRRrrY7fDNTAl0Cqh5mbmvn62CkDApAV7f5HWw2J3hpM9NyLF+gjV9E7Y+f65ly3H9qgB48epLfecSOtzToSceZQBlBau+NUi/vCJioguu7Tid24te97i7lM3AFwxhDPGdNcGICnxAj+F4d+AYZRMUCN6TiFLZU97UacdSZEASE0M1sAGZM2MzjRU8fP0F88f4oeeeZFurjZ7wyUneuqXOvr62YSOCQLGKPZozFgaw7YFodtAYY57W3hvmr3f+jfVkkAQL3/fD6n8+fP0+nTp6/Lzu/evXvp0KFD9jwRwFmVzj8EEEx971Cx33oCjL2H9tm1cX9j/hZDY0aZD8eOHbuugJ9tBwAkZvqZv/1XgikeFlE5twtX3dTZi+ail3VqnRWJleqHZhXa5dSfsQi4phtlNHwmM9/TrlrHJetcDwkOXojRXs1AkCDrHOLi0LQPKecMpkOJYzY9RoXp1WfXmCdwojdtd84hG1nA9MtZEpjXziGmTIEUNzWE1w6FidPC1W/AdJdQYFjxlIV67VhCVW4TvmZE6TMzkIEoZEEjAJE4NQVwjC5pxxMyEbzwQo08sEPEO1SCHgHQecqE3SIZFGT8yp88Tp++ihFmtx3aoJ/40LtCIdsa9smADIZk0UQTs+kjS0AzsSlIWZQNEF52YLEOiRl2cC7jZdZ13hXmFFgxPl6SG2dWMCCi0Zq24SCiwFxBTwicZwjWtSCj0vy1qCjRhjF/vJXh4JpGRCRBMhFjR1XvbJ4NIo10gIIUJwMwhe/dio2BuEc0+kupTdkoDJUOgIe+dkClSkWQCaVsHYx242DAqWybCJy1bv4OErpBaJAgtD4Vdc1/4rlT9C//4PM7O/s1cqlE4J6bNuitd99UZVYuu1NzPmbnGmlMoCZ8ZJDZELD09MCpIJf6Ztg8IGmiAUGmkoj6ebYIWKLCJuhzb+wDnfw6z+d9NrmMF/o+hhV0o6B5LYfZTz95nD771Ek6sUPx37m+BYXgUBE1evZumABd19Ha2poVd+jQvrCnN4yD1h9gFRBgFQPAIQBANePbWe+/6oVyEAQBrqTLvwwQGNL9t38f8gCw2guKf6X+o+5/pcK2Ag4K/GzFB2MHAHiVXt/9xjvoA2++CyKrXF+szrpMaIY10CXSAV2R/ZIpXQ4TJcMXje1S6OAZQ8AODIUGbRnxkAqgNKjWXV8LLKEYVGwxgnAAbjuTXgDwIM0WEwuoUrS1pu+qBt0ozhIP1+bInTDakEP3nrl0Z3ImmnUMzuBOpR5CcD1PvsYaEZlWsgA1GaLwMqQp1EhCEog4U1M2SDtXSj8no+wTxkrJotFIlp5YoLsMrxP01SJE3NXFyaUNnklao+Zq9xaL694ioyorIKEmuty/vjIr2JgD5Z79qz/4PH352Reu2ty5af9e+kc/8J7B2R/0WIZtFFDIGS0SC73sWl29Z8HgimMHGgt/15X7bOjBCT+DaV4sKoHNY/OTabP3JAXdZOY1Kx6lJV1iMAxcNDjkRhpgUYhNSgdRjlGdAsAVx41Q56o6fFu3kLyDmQUc8eEzlBSLaGLIxIFCLy2Y0GzMCgpWEhMYqlGIywy0nKYYxxQDlEspJErgk9F6WSgw2FksXJkHHimo7xOM4rIbbc7rc7eRougKAobkQM2n/+J5+tdXUTqzc33rLpUI3HXTPrrvlhttZDEzAE0uB7B9See4Jr8oq0eCkACMPX3mlH2lyr1yLvF81UuEJBsg5yat4ueBug9ZZCwwbYTq2SLFpA/tvqaU6EvPnqKvPn+aPvfMyR3Dyp3rWwO4zWZ0yy23uMHySEE11MnFRAD8b8qBfwwIGCrYV9X6L/jpDHy/do5PnTpF58+f33nwVLrhR44csfuHIM5WGQFjYwafkXuzZPMhGIoibP0BWs0//tf+nqni//Tp03Tu3LmdB79dAIDX3XaI/pPvemPzsEtBakZtHA/tqGF1waoWrQRoPFkHIGPXIHvx6rnC5IdvaQc+LEZ4MIcbjns918NxBs2wUnYx3tAP1VY5BXqAdyNr0YEadSKI5VOfMTj8Q8541Prm0J3WTG/r8legZZ4FNPUQTVb/bPeQvAMTuvwL6QlMc3UKp9hl7wBtbru1OUdjRARweqSLBcq4PyyhGB1lhQl6C5BqRcEAh7CIdADBNjbTaHN1quZgQIleCVosf+S3HqZvvHD1UOvds45+5j/4Du/Q12I6oZQFDssCcVhKtzWCCOjMQxwc9Oiwq4zUdAOZsAUcKIOqrS8/vznP5uSvmv4EuW94sFig2OtzSUyoIUZQjQEQaAvqDvTnYowhnyjZJDaJMJUgxumhUWJMFtF7n+v4bL1D4tq1+Pc2YtJNRIGpBMwGA2M03QK8S3DNzOBqrqAeplWEQ0DTBTXXf+KB7g0mHPgY0SKprCP1vkTLlgDWYMEvgaFC9NGPf56++vypnZ39Gr+OHtqgNx09SPe+ZoMO7d9r8yxV0b4Im0kgJaqmfYWyrxKAEu8rDkDXAZvMgLayWzr9vgymnc5aasFCXSO5IoLq8VPmuVCXVHrgc05E6IVzl0hI6DNfPUaff+aFHYr/zvWKFYL79++njY2NBSbAWEQgggBoCKh/HivG8T8sBpf5AEyBAENAAv7b5uYmiQidOHHiuo54GyuONSqSiAwEWBYNuKz4XwYQoAQAQYe2MaeglLI31P1fqf9jfhVYD6SU6Pjx43Tp0qWdB76dAIBZl+if/Mj77TCMEXutoZd+utSYvm32Eijhiu5HTbN2eEvHWrt22qWOHTKntuvPoGN9Yk8F0O4WdsT1+/A83xriLRzuoRvbMXbfOB6QFzqcHklmh3bV2oLQWKBA0oLLtNTsHgiF3l8PTQgUQEWINOgExVYO6LCAcZ/T+JXiGYzJRAJ7AuUHSdMEoOhEoyVOsVCz91rBAqhHw8LVxk0504PNtE8Blq52/vW94djU3+PxbhTuqcsziP6H/+eP6cyFq7uA/bc/8B46fMM+N3CEeaQzQjfr4sQuBpLhs/RYy9ZwBQo7GFfMTPNqLImAT0qxG+9DWBaSAAio97OOg7afpDH6ZJxNFIw7dT54590NMmNKiINRCtoxR9NCp6ODqV7zXHXd0DGeIJKsZZIg6GjgWC4JICnxQHyYA1bWcYeIPL2/fcakBAZArTH3xHXTfBs4rJc9gBktspkgIlXZO2VONvFneNMpxksuvpd6L8TX6WKkKg11u4znf/x/fyKsLTvXtX+tdYnuvnk/Hdq/h+47fIDWd6/RrQfXKaXkUZTkHgEi3sW3/ZyLmaYzk3wup5QKowwX/zrp8d/MoV/E9pq+z2ZyqvR+jRL9yxfP0fGzF+nMhcv0tZNn6avHzuw8zJ3rVXOtr6/TjTfeWM9geSEObqjIQk8AlAO0hd8U1b8t+leRAqzCENBseCKi5557jubz+c5DHrn2799PBw4csM586wswNBaWAQBDMX4K+LTGgDi+ZrOZAVFtxx9d/9vfNTQ2iei6M3q8bgAAIqIf/+Db6Pab9tuh0RytybvWrjUp5nna8eptQwcHbe3kYgc8uYYbtfd6APYGvTMFtPCzjPgRSp8WjlkkOGgrsBCK4Xrg6IVKTJlSkKGDqwXowm+RxuW71bs3enl0MBbLQZaFvHrMPPbOKnRFQJfbV61lVy3atRPvxmGxk6fmbarxzfC89L72fY5UY2BwYDFFZt4k8Axbw5pGs6QLYIoLFQPlVBoDOTWXQ+AGKcs+w8Sc9kVK7Fxu0Hbswv/Mr1x9AOC/+fC76fAN68HbAZ8bmqmhH4UyW1qGRTTRkuDfgHIWW2hEKqWbNenOOwLorEWeNID3vshqkIpfvDswhtHACl0DDPjBDkiKMoA6CQ2UqONTdetIw9dunkZ76pyWAZAkoXcEQxKGgWvcdN4rVQ7uvQJHqFlmWpzLJIvhnghWYacf0XI1O5xpFxTkDkRuUBnQlAoyKOCp3gr9wCaN4J/ltVskqSMIyEhq5VK6TncwvxEkUgDmuVMX6Gd/49M7u/p1cO2aJbrvlhvpxn276N5bbqCN3Wt068ENS31hZN8AayAxL+znSuFHxpuCjAxzMfh/iCfmdCnRN144T8+fOk+nX7pEz5w8R8++eJ5eurxTgOxcr+7rSnwBMBVAO8gKCGCXto0JbNkAQ2yDKTBgigkwn89pc3OTzp07R6dP76RmrHLt27ePDh06ZGeB3bt3DwI/q8T+LQMLxiII8fvQ8A89AJaNyR29/3UEAPzwt72O3nHvLXbAVRMu/TRY7KJ79gL1lUph3bEfIrvEtUtZdMXm9N6xOVfrYRaj+9AtPdCfRaJEgLxrjNUDFl4COUKdFZTsB2NZLNzQ4Cslrof2+F5Q/IuFybwXi24r8X9qXEjBsDAWig5U2BGdKbTPF7LTxXXbQ5tAoDdXnThhNBynoBFX+pgyK5iZspqTQfxa6e64xh+9GVo3cc+3rR3wgD6rkaR3LM1Y0atAMz9zzwP3WJAB079oeOaF40/+nx8fBZGu9PqvP/xuuvXgeuySAzMiFFxQoGHXGDu+fhguX1KjOL0vAQ3m4kkx73tIuCiFX26ot+YHIA5G5fqazFzGLAm4cHtePTrNMsTnGQINKx4CAfo9SE0navw1SBaLbo7mYYv/LpYiot+R1QIfwL9iZuaAIlVvCduMa+xeApaPzpsM8ZGdjmtgDYW5piwmpBjRYtSjySSqTGFefRZKukLjhj4Q2dZ2bwjW3QIECnUdyJskB+aTf8Y4VzwedJE18LmnjtEvfeKxnV39OgYF7j9ykO64aYNu2r+X9u/dRbfduF73+mwAgOKBfS5jbNZ1ZZ6YcWidEVlCTKaQkPRCz546T2dfukzHz16kJ4+d3in2d65r+prNZnTkyBFv3EwYrSHNWjvHCAh0XUd93Svw+1uGARb8bWrAKgAA/lmL/x2zv61fa2trdPjwYTvX7Nq1K5j1pZQWAIFVin/8+zJQQJ/9GADQgkTt7+i6jk6dOrWj978eAIC/+qY76QNvvsu6Pk0tUwuP6MouHCMBPduenVLuKVO+eGUJ3eCwoGFcYBbrFGoHkbihqWgBulAAOo3YvM/hvaWUopu6FdENItpofRcXT0Mb1Dgfju4egUdgoocOyO6QHrvcHi/ov8tlBhRkGjFBgew5hUhEo4Or3rsuQIoChsI10n+RRo3sgIxdIYl6Z71fXdcFxFoHSwKgR0EdzI13yQSbphqfh2rQA+hD1TzKkgsYQAim50+dp//51/70qs+df/Chd9GdNx8AincEIQhgtQzGeegOr11iA3gsirHKXvo86O4a/BYIIyFx4/c0CtWbJwSflCmgxWDOwYgwmaaQrbgn+v/Ze/fo3a6qSnCufb7fzU1yk5uQByQREh4JQSCSBEJAMGBjpNCWskULfJQ9uiwGdg2rx+hiVFXXKLulSqtKuyyrq7qbUsvH8FFtFZYoWCpPUVBe8paHiBAQkpCQd0hI7u/s1X/svdaaa3/fDSh5Z68x0Jt7f7/v+845e5/vzLnmmjMb+vG+sxGdNJvviplu/LVIjsijuE1b0+zcn89lnE8nydxnTygVINYq703QeXYfCvC8Mbv8I5Em2o3N7OctRk9Qkw+GkQVKe5RN/FpayUpJFzk20dbEXicrVrrOtSJ5Mkg+G/65x9QDZAohxRca6cc+G6WraX7vfZ/CH3z4M/NbfVYmBc44GY865RBOPeE4nHToGJx+4nGJ+LN7v32/1T52swD43A234tYvHcHnb7oN1958Oz597c248bY5WzrrwVXLsuCMM84IBd9djARwN9e8APb29pwEONps/1ci/f9y8/7jfx85cgT7+/u47rrr5rz/V3HtjQASEb+WX677v2tNHE05YOtiXFOW1mDE05cz/ePPYK855/0fQgTA4898GP7H5z4pPQAGLgx3MqGHX1VsuZIXzpwnrwBzod8spef+GsApvcuPFEG4nYFKYJzzs7c8A5Ac6htgaZLbZYmZ4VGavemfwwGCMmmRu6puvAaa/fUH/vb7ZnTGkuwGxovnqvODNrbi32IJhclL6xK28YWQWm+WzCZi9AJgd3OajxZB6+4zWHHiwoBGQRFOh8g3IFNDFAmFgxEj5s7vTufdsX0pxcGoPRiyWsCIm6VIMlBMYxUiyQAOPc9eCFiPRoufvf4W/LvfvvulzC97/kV4zMNPpo4+O8CDzBvVjSM51m34SvZIQ02d5sizD6CunihgoydG9lStPiqS5fEavgt0Dd2JfjATFOJXaieH3A9kxz4KAB8GiAJgsyykGkh3lxibgWLpBmPY+TOyxb7Z/agiMsVthtmIRKS4vLiXqX3ZgbwxOmC3SMPwJhmclREEVZEegSriKiAzo8xd+1BOrbV6pz6c+8N4kw0K6+gPYLGLZPzESRKJBUD2N2G1QCGfFb++CMLGXvNn3/hBfGoaAM76MnVwb9nxGISdj0LTqG/WQ6nOOuss//MIwEYgfrR4wBG08e8eDcj/VUgAe8684447UGudM993U5144ok48cQTATRVyN7e3lHB99EIgbsaHbBnZv53m/sf4/6YgNrV/bfXu/7663H77bfPi/dQIQA2S8Er/tbXb5m1FZvz7x3eZcj1RQcNKuoztqsCS4lEgJjxV48GXKnjWFiKDySJMo16O5jnCC2eJU6xaAamyEWbwa+Dre6AHMCNTdyyhMoe53kEgTvWduFlmDUec+FHsyQ7D3YOTM5vncNVgQJNMYPs5J/iybq5n/T5/uYZUNEzDJOBSET+KUpZUOuKiP8TJyrgigELkMpy7MgnjxnuRn4IqgCLebxLvjomjR67lTZnmkzhkBUfaf2ljvb2CIJdmE9efSN++vXvu9v3zvc/9wI86VGn+bsufQa8EWYlRiSkbEX/gdbbqDxB52bYTDJJ+/rvl1KamysEIrWff/MDCPM4M+JjMGhAUtOXTXXiKjPLmWgK91nZMvFj0O6EB42qBHlUXJIuyMc2EjiFzCYT4YAw82vkSb9fkOeIhhFHHHsnQmxZGrFR+9q1z82ReQASmSYeZZajTYts3ydB69KUA7EX6BtjiBsE4NdjTCgAchKHjW6UEn4OpswqlNZgxJtIeuP8UIl2Dv/xL79lGgDOmjVr1l8XEIjgzDPP9Hsrk7e7iuX/FhNofx6fS4/230cD/kf7bwP/qorPf/7z0+zvbqwTTjgBhw8fdnO+AwcO7AT7X44I2PXfIylgXX+b8zf3/13qk3EtLMsyRz4eigQAAPzPz78QX/OwEwJIUbcoZo+jUz1K1NsDq3W6yNG+d6BNvl41pM1GIJgEVgegrEKu1g7+KBqMuvzBXrBEOqsLQjquW+qFcCcniS91YS21wIErz5iTYV0CqC5NVpIX55i+0fytHMUt1JQVdo43S3Q1mcBohM7inUYDyGP8Ejv5Q9Lpy+7tO2T6BlpZEcEybhGBSripV3K0F47I0xylaBlU/jMkm7bjYyMq3nE+ItJ/Nrrhbb3+6aevxS+95UN3+775rmc+AZecd2YCeAXFO+trpUhMMq4TCcn52t38lYgc34c0NmIGknENArTbbH7r/MeoDV9vM4xbSttvTlSQgVzbByZlFz9/oyFdJmgiqnApS/aj6P/m+xRxTZYiiUyrO2b9bcMwiRHd/5aYEUGCOXqU0wnML4OhOBOAaycox7EbtvsQI2RQ0k2ewXUeicg+BhxJ6efQ/SCqZ6zLDuM+MGHC0YhENPB4U9zXOsEApHtQZL/z8VY/HlXg09fehFe+7n3zG33WrFmzvoricYAvJ9u3TiyDf1YEcGRzGgfEXasEjvZv+/v7uPPOO3HLLbfg5ptnqsY9UQcOHMBpp53WcULBwYMHj0oAfLmEgKP9u4F8m/XfFfe3K/bP1tu8/g9hAuBFzzgfT33sIxwJjp1W1eqd3PZvkTftBlQW42NZ9V0Gv1mWLi/usYKU1V0kyIP2evHaRjZ4JB0D/KFxlR7+CbznOLEuOFZNM+SEe/31XCZrkWH02u5Abw/TBJh5ERg4S94INkPd5dbxokjzy6yCHk3AbLO78zJFIdrr2Iw+8x8Rl9iVAEC61jYrjiTxbkfK4KHQ5/SZb84elZCAN6O5pvrYLMXHI7bBkiSzRoCNAuM6po62NIPJ2t0kjRxIJ7Ufwx9/7LP4jXf82d2+b77tkvPwnCednWIYZWsuPzrgMZIRKQBjD5bn0O262SLlUZuq1X0uqhtyEXDu+4DXdOwjuDHn0teDveYiQWDEeq1bWbOqiPVi6zeWj4+3MChnr4gAxhQ5iuJ/n30xYp0I0NMo2pqw+EEnW7CdGGAn2OjEWmsyEqzknO/nPiYGPBrUXnc140siPvk+w7/LXgjuCSBMNQ6RpNCt0ZcyKGEsqs2IUxH4uauqKaGATTHXtZuyWYrAjnuLnfP3X3EN/tMffnh+o8+aNWvWV1kHDx7EKaeckgD7LgKASYMxHtDA2q66q27/0d7jzjvvxJEjR6bs+14igQ4dOoQTTmiN1mOOOQbLsqRnqq+k83+0tAfu+nP83651MM7933bbbbjhhhvmRXqoEgDPu+BsPO+Cc7ZYRAbO7K4N6kyrZkMzQz0GZdk4Swng5FnUyJ/eltkHQpexM13J5Rt5fplBfUjvMzBk12thN/Ad0Vm5I8fvYFLsmkcGyMW9NbcDHNSqCSyMM878wK/ddTG6hQTumOEF5X+bs2wHKy65ZoPG8cuCIujCHKw4QcPn0lQTy2C6x/GAMafPWagE3gfnd86WDwBH54EALAMlIaLE8+EJ8CmAN33wU3jd+z51t++by554Nv77p527pZqRwdOieVCwo72RXpExn4ThpDpBJ9ik0D5gszqNOXo3rNN8s1+Wgro2gmdd2cW/rUUjEnw0oBNITUlQEsFj60IHkoX3Chtb7hoRgJFqpIRIRBdtL/t7GdQyjTAs2Le0DglzvpwOMpBbAI0Dkd+Grb0+BiASCgPrppvnhJNNNJY0KhyYmNyldGK7g3HkJR2nYouQMIKljuNUUKw1iE2+GY1f/nZv3a/5+JsCBPitd/85/uijn53f6LNmzZp1NxRHBN5VMgDnsI8qgKMRAHcF+neRA3fccQduvvlm3HrrrVPyfy+vgVNOOQWqigMHDrjHw9EA/139N19PdvlnEuBo8/6hGBRcddVVX1Fc5awHKQHw+LNOwf/0jRcE4KSHRwZhdW0PpQc2iz9oOwDr/xXmVeJz6MVvaCH9Ll0irTy/LxlAlf4AvaaH5faGTDy40z0wyK3pgXxHbrdInutNEJ9GBmqS0vazpFkqz2kGLNMuvWVpHdtliNwScr33+Vw/H+T2rRhAQxAuSwdta1XXjm96huzKr4dMriiBlUTIlDiHVbPreOv0CkX0aTJeRBoPaRPp7Tsr5rKZTOBrPwIiiECGSDmMpEIndgy4RiJFdF9f//5P4g0fuPsJgKc+7gz8rWc9MSk2jB8rgxzcR022ohzhBo9I/gZh/KfIoL7Wis2y+C+xh6OtM6gm74tlKR3M1hyHKGbQGEoPIx44zpCVANzFL6Wkz1qGa2M3CU/a6OMMpj4x5UExn4E6eD9IfAbtG7GIJPf+pgIgMzseGUD2EYgHohw9yg9KSms9kZWuXrH7Rpu5V6W12f9P8Tl93sN9NKRnnRcfdaJ7FpGP438n+b97dYCk/aM5aYxnqLZ7mjJZhEyq8Xr9iVe/A9fefNv8Rp81a9asu6kOHz6MQ4cO+ff4GN88KiPHEQCLadsl5d4VBz0SAeu64ktf+tKc974Pa7PZ4IQTTsBxxx2HZVlw8ODBndf+y5EB3kygjj//Gdg9FsKpE9PzYRIA2CwFP/rd39APYBfLpMkJHr1zJJAcHYjoYMZCizPjoLlL2KsigXjOffeHWevcs4RYJEVrZZf4ZMJOgEuRYuC15khCfn2V8ejTzznQMLMx67pJ7n5W1a5SaJ9lrTUIgDre8KMjyYRDgDSNme9dPgc7Iuis48+z+vbFMzKIDTCXuNYO9AlIkAydlRjWCXWZuJNCMYOtnZ1ZKJKOb0wLdZVL9xGIak74hcmT4f1XqJMFvBkhgp9/0/vx0c9ed7fvm/O/5hT8wDddOEQkBho30Jt9EODEFBMr8Zmpu1+DtGL1RhjQheS/Mngns8kwDUSsd1V3rm+gPmbGpYPWMhr7qWKzWfwzrqOZkTvhS48ujPXAyhE+XvfkIOCaxgMoTq+ik2cln+siksYLbF8sQ96umxZ6pGhb6+HroelGJg742cG/jToJkZy8c/keZ+NLTFSCPThM0UNXnZNRPIVkmPm3o/TRBFLV8MMgewmEaIJc/ynCEynNRHHVDbfi3/72u+e3+axrELT2AAAgAElEQVRZs2bdzXXSSSfh0KFDDsjvKhpuTAaw/7bu7S6Qf7Q/m+T/C1/4wox5ux8UGwQee+yxPhLAIH0X6OdratJ/6/7b/0bvB14Ptn6uu+66OfoxCYBWP/SCi/HIU0/ckr/b42nVSl3EoSvlGe3qndxVgYVk3ezvLTtm5tkZvDW2uvu5RbsRccDEQgI5/S8KP/wz5gG8DeYdYyYbVI9KgjR5bcxge1d2lNcbKWLeCEuXB2sl8Erzu8kcUHe+r51UrTmOrJAcPKLOMnhoLvGIUYlkTJaTC5jssG71shSsq6YoMoLXTh4sJKs2KbmIidw7YJXsDB/d0h7Z5tLrHR4OBGq3u+v2iXLaQu0//8rffS8+dc3dH2d25sNOwD944dOd8NlfNXX/lbrLQmts3QF6Pf7PJds1XRdIEC2E4TuR1H6ogUfXzke+PZtwDikXHKfIMX7mGSEShBabzLkSBjvm1PgLh8wg+b0leUdgi2zI2fYZnNtatr3jhAWRBkwQhhohH4+tlP1amyoJ8RrmY2LdflYy6cDK8+hRGdJSPBqV7k82arNfKzal+J5QGofhSEAm1RIBKXn8wnwUzFOB1TApW7grGTxBQUJhVAT45OdvxCt/773z23zWrFmz7ubinHj/Hr6LtJXRC4D9AO7K+X90+b/llltw0003Tbn3/ajGkQBOCdilCODrO4J/7vzzz45rZFkW3HTTTbj11lvnBZgEQKsXPeN8XHLumRl8kkv8CLraAiQZO+AGYuEUrz6nH+Z0sg24WS7M70FGWmsNYy8Gn4RFoeNc7SB1NZCYNpO9D0XscR526eSHd8xo9tbAVSMpyuCbMHYI1UkDXyhDXjfPrY/yYLVM+U6CmHTacsndTV0pXgz5vLKJmQiwKaXPTdedpmUe26j5HEfX1gPn+mcq+dqSqSMDI+nETlMZKBEXO6JNOhGw6eMVBrI0izKSxNrWi4Gkf/vad+Gz1939Dqennngc/tG3PyOtNQa2pvxQ+pDc8bbUgtoTGzzzwkHnmm8mRLyV3mkvJa572aGs4HMS/8ZEAhsLalKn8HtVjdGG/bUm2Xghrwv7nN6hJ7f/1OEQk++H2eZ4Ay08l+/kiZn/SU8n0EQUsOKEyQ8nGKjbDSL/7H34/X2UZLgnCJFwbOLJ9xu+f/F7NAVPSdSJqaGYkOP7J8dzjj4BiqbgYqBvng6co7J1r6XrxH4CCsW7//xKvOqPPza/zWfNmjXrHqi9vT2cfvrpDuTuKqMdaLJxJgBGFQCTCfw6d955p8/7T8n//bN2jQQcjQBg8M/yf3P8r0M08C4y6Ytf/CJuvPHGeeInARB1ybln4DsuPT9leWeH+oyw+UEY2C0/jZ/cNvPiB25+vQAeYQgg/gO2qDnGKs/pGtDVPlvNM+fYEclnqQSeX38UwwwHEZTvjiGqjoFskfAPQDcTWzsBIkkWnue8uavPA/Is34kvjHi/xPzS+UigQCgyZpjZNnLGJeqoKGVxAofBLHdYg6AI5YU53kMixhGJuEHEzZFN+Vbmus2IJ3CNdM6RQBjS9W+fRfCK//xW3Hzb3S95O/6YPbziuy/Li5dIEidzSnan5/2Vb9KBGuuO2UDr6vJYi83UMwHXJPgyyN+DPNosLdaPQSOP7uhOd3gjwkqPBt2WLTrJoGQmqayKkLRObAU1c3qlrnmc0qp5dALUuWfSbe37sWwlmAxeFQIU9zfI97TR7HMcbbJxHvNBUBUkYU1KHAizzJDbI41flJJjFFUlmWrG2h4cgk0NQqasMsQlZtUEGy0iGTQyWWRRqK983XvxF1dPV+BZs2bNuqdqTAbY5QRvNSoATAXAQHFUEnzpS1/CkSNH5pz3A6SOP/54nHTSSRARHDx4EJvNZjDRzsbfNkKyriuOHDmyU9nBa8qeu6688sq7VJzMeggSAOed+TC89Jsu9AdHA+cGCVet/oAYC5LM3xzUDlCezPEAjshT74RZF29viSgri5szs8HCs/5DfJ3Plg9d8DHfHoPsmd27y9B1LgSATEpeBgCy9jix5OrvBEDB/rr2uLB4Xft83O217q1BOpZRr6Sa4E7q2mXLoIf5tZu5pWMHWse25Blru1kYMLTXsptGRbj1m4QfToAI1h4hxwAivoyUxhSGzj+QiIcgMPol6mQDkyCqEfdmJpIGDl3K7G7r8VoG/P7RL705G9/djfXSyy/EuWeekoCrXauqis0i/jm9+T0AxEImbvl8boO08Zzt19ql7Vmtot0QkDvSNi+/9rGBiHTEMEsfUZNKZoIsH7frbd4NPjZgTLN14sFxdaGWif3IJGN+AKp+bvKegGRDyUqKC1Yw+HkjFF+KJDKykRI1qX9434OIiBLynHbOfBxqMOwfxjRSDCBJgNwbAIJFYrRqVAmxoaX2EabFEzp6RKuKJ4wA254IpWQ/Dxvr2nKIBvBjv/7H9whhNmvWrFmzomwOHMBWbNvYAR4TAUYCwL7v1nXF7bffjptvvnlmuz/A6sCBAzjttNMaHtrb21ID2HO7/X8jAEwBcLTOv4H/6fg/CYCdtVkK/tX3PTfN1C8U78dzpxxJVcjQykGAMNCMGEFQlB2PCYyzs9YFY1dvZzd7947n/sWd8DV1WVfv2A1JAQ6uw2yPpfeQ/LP2UD06bCswECIhEjan9iItmqudT3gMG/sGVOr8V5rNZ/bORiAMGPFxr3X112iz2yDjPt3yOaiegNABEMiXoOaxinbzKT4ioR6php6nvgRx0X/RneCLeEZ9qD+QOqSswmATQYtjg/C5zdfZQB8Q534kfT5/wxfxr3/rHffYvnne152Dy5/y2K1OcCWVgyInTmDLbyH+Uilazubw+WGgeT2ESka1dvCoYbZIC9pIqjAq3B4B8OunNMpQJLn2exygvTxL+8e4OiA554dpJ6tS2JOAZffZm8LWe1XFhiKQqrJJqPTEDWn+CgpIIbA9GmT2PzDpNcZx7lQnqSWVaB5pGJRSnPiQxwHs2Ap16/MIQCnhl8D3XVMLoPMPZui4kklhSxRp6SE9ICCiMQunK7b7kx0Xx1Redf2t+KnXvmt+k8+aNWvWvVAnnnii58OP4wBMAHAsoHWHx9G6O+64A3fccQeuv/76afD2AK1lWXDo0CGccMIJKKW4GoDXh/3PgD/L//m5ztYNgGn+OAmAu64fesHF+JpTTvTuWno+NqDVO5mlz+B6txgxDpBMrJLhF2DxW/m/B+kqxri4DMitg1dVqRNGs9WDUdloEodtvJLnjukqrjsMt9a1usM8kGfS+djts66q2Cylkwntybyg9Mi2HA1XvLupW5GFquIAcOlzvzbPb+Cb54RZ3ZDAo4HMIlj3VwdxTBDEeaVx6aPMNzNhYYaNRiisKXItO8CXIQ1BqH3fyJC+BjnWzM+JOHmz1ugQu/t5Xy9XXX/LPQpozj3jZLzs+RenWDodz7nIltM/g1vu+IuUFN1mALwU6ceJDrxtD9TUWTaXeyOB2Jk/2GBT1zR1iEiAYWVyaodjvXXwbWSkdHZNh3XgHXXb6109ZEqNUAqwvwA8dpLXWHFzyD52o0hjBSDSTQZVjOFzTzFB+H2Md27Bjig+ulZrT6JQkCIAAdjZ/R/IRBQbeBrRpt3534wMF1JYsSxfd53fDv6XRWgPBjnCDwKxrdpn3K/rlsmiETYf+vQ1+KW3fGh+k8+aNWvWvQEaRHDmmWf6n5kEiO/ssjMRgJ8Rb7/9dtx222248cYbp+T/QUIMHTx40JUAe3t7W2MA+/v7KQFgLFsj0/F/EgBftr7j0sfj6eed6aA8ZoE1PRi7sZb9XKUIK2F388h3T4AouaNZVy0AND+fS5LE0hy0dYt3dBPX3jlbfC4W/Rj6A3KNjjtoblwIoLEJoM1Hcyc6GRCSmdZ+JwfGDj7TDE5WkLzZPz8RC2tdO7AoOOLKgTiPDKgDxFiU4NBRxvYMEZAjzFi/Xrru2M3IBpOy5C7fQe6yLD2uj8wgPfZvJApKclYvRbbomOiodvPGBFKjA1okkwysaPjc9bfgJ3/znlMAHDq4h//jxc8eFCtjNKXsBJdNug22u0jrw3+2H/NmKTTfn9leHisZI2DaiEfxfWmAjxU2pqhYSgmVSrEudEWkO0hyq2cJP6d7CDnWe3qAxmsKd/79mjJo5ahP+Jz/qmEAWPta8zQECQJkNAMcOyq85IUMBlzlQOMRwkagW3d6CcUGEX/8s0a82Rr3RAIiRcwss5J3BCuwhBQ50GaayPva9pmRYaW0+1zcF9UVJVvGhPTnt33kL/Hqd/7Z/CafNWvWrHupLBmAn6/suYq/Xw34mxJARHDLLbfg1ltvxW233YYjR47Mk/kgq2OOOQbHHXccDh8+jGOOOSalO7D532gCaWvnlltumaMgkwD48nXJuWfgRc98Qno4ZJDROn72oLw9X5si2QgsNDDRHmSNJLCMdA4dTN3g/i+1dil1B0o8b28P0AqSx9cGVjeLYH8NN/5SaB6WzOnMrK4Q6E/u3zLODIPc10HvbSkHSKZfzam8ErChBIC+Wva1YsOyYHL6Nplzw2SDNFjCXE6VHNA5mpCNYQixJQM/u96kn3eJfSkxtw0d3PdzFGRx18Uc99j+PnLfWd1h68BIlphVjtw7VQJDGhGBQHSQwSkKBKqbo/lH79F987ef82RccM7p0RWWHA0X6xnur5HJG+nu8BETGTdxpIjHdg4i4m0pA6FDIwQGwPe7X8NSAqBbfOBSSpgs0lx4KBGwpVIBqS3qENk3uPWRemYkRWLtMellxwR63/g9cZVE87uI2NAiSEkHzoAPBIGP9NAx2Psm3D8O8qfIxMwe2B+t888+HEr7lMcr2AywXWOkhIvwiagDGdaVF3Qt+PPbFsTQ4TeiwNQ9ZrrIHgO1Av/hde/BJ66aBoCzZs2adW/WwYMHceyxxx51jtu+R00JcMcdd+C2227DnXfeOU/eQwFciuDAgQM4dOgQ9vb2vOs/gn8Mz1w33DC/zycB8BXUeWc+DC+9/EIC/UjxZvFAGQSBS3VFQ+KrIeE34C/DA78SyONR3TLEaRkgaDOrMfNt750l5PG5w318e/6fgT+ALQM+aH5oBgKgogMQIz8szm2/NpAlEOyvKxTSDOCqJuBqD+icDy4U+Rez8c0YTCm5ADDju+pd1TA8s5lwNpBrRMCq7SbhIxveJZVkMhc+DOHUboTKmG9fpLjpiLmx2/sKze5zjKSQE/xatcmXHbiUDLI0HPTDvKyvrzTrT7PtCLWJdbn/4xvej4997rp7mDg7E9/1rCc0UzjaL+ZlwOoA3kTZjFJjDIa792asqUjEDhMBjSCLmE3V6l16GzkxMOw+CWDX/oh1rLWidGPLRFpZh79ydGa/PmkkRDvobj+7LLLtyl+oU+2qF/5MQSiCgPPG/Sbg9w12tI91q8lLJH8xMljOvgbse2FrfzRYctNOyUMdyfCSSAkD9LZnoQpNiRFCoB3DeMPwmfu4VSMZiieXKJFeRo7ZukhjCbrtrVCGiMh/+Itv2iJRZs2aNWvWrFmzZj1ICYDNUvAvv/e5Kc8+PRjTw3Gb0a6tF9UfMM3FH71jHbOx4Ty+CMtgCbp2MLDyHAu9b7iSw+WzHMM35p8ykGz/oGm+luX/W/P2ZAToD/iqAxAYFBIEzmqf+Y8ZfdkRd0gGX0k6LQRyCNCqOmjiz2BpBO7ErpnE2NVNdmKgs4fSxwzCv0CdfNhsFp/ZVo1OYcdZ/tpLj5azaD8jINgszigOHmNYiMhgEmeU+qsM54mAYB4xgBMlAPBjr3obbrqHHc0fcdLxePnfvDSbOKbZcUVhgsmOgMilZWmpEaDZ/ZXInTSzrbp1mzGAaQTPyAaPIx9hVqnYW6Svoe4urzRiIplgcSWM4igjGZVy6UM9owhfCf4cPErQAPwA6odZfFMPrVVpzUi6Z4XJ5QCigWwIWNXNDiXNwexwNUzRmlklw79vCicz6LRzEveWMPCL+14jAlSDFFEb4wl3xKZ44uMFfDwn/AjsHFHyBseO9v/Tw1MS0fCpa27A//3f/mR+i8+aNWvWrFmzZj1UCAAA+Ht/42Kc8/DDWwZyAT7IrIwMvaKbrFuy0gC3EQVmr2Wz5myepmQE5x3w1k5N8mo746OpmklpzQvA4s7KAIw5Kis/7GM4Zt2lCO4zx+2Y2QhwIZO07fg2kmDTZ5cOFIEYnTAnee6uxjnpn6dqdnQnczSO96vmXVBrmtXmufI4QGyREbtmm9n4j00YeRt4lKAAVdvfL4WiE5Fz45m0GN/DAbYwGdElzQjzRSN/rrz+VvzUa955r+ybH3rBU/E1p54YUXSaiQBFm9suyGaIoDl91QC4bg4oBEE7MPeZbg1yjNdqBt/YMqHLc+DmIYC4Nkr7Q6PjbzPsNnvP1yh+J/wKfJ13gqOB4bi4Zdj3ZnhXaAQmzBApKrL/eW9jpn7S4hARSRaZGEAC00Vy7CID6tHhkkIDclQmSAnRlUlj0mRytFCle131+U0G8QuREZEAIK6iUO0Em40+kYrJXgeD4aSrAST8F9Le1iDe3vfJq/HL0wBw1qxZs2bNmjXroUUAfOczn4CnP/6sAOfYJXnNstsEArDt3m+vYTPqLLEPA7RtCX+cUE0z1CFXly0Z69IR87qyc3Y8jHPagM06+yP9lrmZ5sd4Gi3gbqIdv9BIA3c4q9Yk7U3Ra4gZ4lAzxDmuqt6tY6BvcXhMMHgXGLrlJq7D/L6/VtWtmTOPXfToPkkzzwzSMMipbTTBjRNLuPZ7d3MwVCwE1vL5DBgVXetMTI2dau5Gv/Pjn8Or/vhj98q++b7Lnoyve/TpwI4bgO2D7Lyeu9IMtDkSz8gkIzraGq6uDDHVhaUBgAgTd4vvWXEjuWavY6MCggyMm0JDfIykgX4bCRmIGf9zO2JXviQDSnGyUCSD8e05+oHoA6i7HUobkCGoJ2zQuIIpc6rW4ZpkIsvYhaotZi+LACTF+ilFVCpFm4I8O9LYERmFxmhOv7ciz/7bMVdl09KmIGGSjONHK9q1LyNhJzGSs9YhSQA6JK0IfvOdH8NbP/KX81t81qxZs2bNmjXroUQAXHLumfjOZz4hq2GRO5lFikcEJoDaz0DpplagLG2Pz+K5d3qD7Jqt9PCK9MAbLuoBQJqsvcuMRVKMIc9Yr1XJaRzu7M8P4sJGeQYobVa4vxZHqgE9775qMjcb5+KTnFnE0w1ilCJL/5MPAXkT2OvtdyNC6QCPAXPVcNe3+WNQFrnuiPaLc6HDZ2/ggQ3+di30ABY9W9xeo4SvQTNHKwRQYz2Nfg52/otIcsl3d/hk+hcQshLR8TOvex8+cfW9Y4Dy9PPOxHd9/dfuNO+pmmMyQQA/k2phkhjRe0E8hQIkxgAcXJL7v0pkvXNtRUNKjNY0QiGUK0AeN/E9A7hXRCOgpJMENL4jcc0LeURsJWO4WkXJ8E7IqyML8jMRSR4k2FaOVFrPsuOcmz8Fu+jvSiJR6vjLMFcUPg85bSNdW4robEaPJa5rJzWWElJ9JlztXhNjAv3fyfR0K80DMZIxjtpUVYwqJyYw/tV//SNce/Nt81t81qxZs2bNmjXroUQAnH74OPzDb38mPUQHYGYJeFU2udI0g51nd5G7vD1WLOT+6Xkehj/4IZyVBAYsrNxkqz80cwZ3GRT9LH22zjcGQAKNmW2RAFsySm0xRtfZ4zTyeAGBJpP12mdduqFdMwzr0V2KZHqnSQpOOerKMueaTOMKAcn2dzW78FeO6OtArs9DC703igRApGQDl3uTJBoD0eNO9AA5j8eMMgNE3j0yEEL8z/trxaaUAK4QN1RTik8TAFff+EX85G+9817bNw8/6Ti8/IXPCNXCMEqhzOwg4hXHOMk4t0SSOe/SADeb//nsPMLwz0kqyaaQ61qxLMX3E4+VAL3TXIQ667KV+sCSdJBhoZEC+/trI4uESb48w88+DabeybL99m6VzAnTPUKz/B6dXKoDAVAGmftItDiIJ/KpFE4T0eRRkdcpI27ZIsPIMcR9MfjfV/YpGAiHEdyP0n0mEDhVQLfIJo5T7WkiqyZmxU1SAfzjX3pzGtGYNWvWrFmzZs2a9RAgAADg5S+8FKefdDy2E+wRXWI3vGt/v1kC1NVBIj6a3HGGPbvI28Nn2ZLhZ/Bu7IMOHS1O8DJhvWfIjzFkg1yXWIKIwqvhjF+65N6zWXmsgMEL1GPz2DuAU8VNjmwgnYHWpkTsn8XfMQh3Ez/PU49ur4GZQuMB3tH12MT280fWNcma7bzzyVTPoY25YweZkG2jRSAy34FEnpQ+p19EsM+SdAwgj36H55MDOwt1LSNWcrRt+9jnrsfPvfH99+q++aFveRrOPu2woyuRbRm7rS8dSCwgjDK57c2mfUp7SRDXzveTMkhm0ktjrXX/AIVAezKEj7VojNtYYkCtWRFie9hIpRZJ1Nbvfh8ZSMTA4J1h68y65o0IzGtPdfC6kKxAarGe4skWpvwQKZSvSa9FCh1OM3CShQ1Eh9QTA/+FIywZuAMUQyhba5hHi0DH4+BcJfkMMH8E2P4PnxW73yjIxI+jJYl4acos8XGKSn4hIvn8v+Pjn8Or/uhj8xt81qxZs2bNmjXroUgAvOybL8K5Z57SsbamTHd/gK+1xbgND/dphhXbD8UK9OgqTfJaAyIZ/AcgAbZzsblrJ0PXO7pnOc6QcZgDtYQvuWsY3Vt7oK9aU8dUCnweP2TuY0cvG4SZgZu9a8iGkd4z+I4a5ok0u8/AzCTiroJwKUIQAg6hHJyIu7anDqfG73Eemw7eDfY5wpRMsVmWbkY2aiNoHhw57lHcAC4AW+p+8+5CzFF7PCGymaMC+J33fAK//6FP36v75nuf82R83dmnb/lZsLZ8V3RlU7BUH29gzwghtUCt1QFb2lNMrq0xB2+dfFfyaPg7jJyE7xnJSRihVEAC9OOYgJ33tbYxHCM13OSuX9FCKSJOJJi6hPegESX9PrGw14DwGAS560uYRBbyM0h2HhoEEpt5YoexKF/DdP/or++eAbRn11qTBD+bXCJGe4jIQicR4pgklBIduC+LUIxjvm8xMYJhbTixkca5MgGgCvyH33sP/uLqmRc8a9asWbNmzZr1kCQAnn/B2XjexeduSdlHcLydPU1dKOuSmVu+ZoBWPPZPo6tHOdr20L2Qo/pqWfYOZAP81yT9b2B0v+rQPU1PzO11yTV8rKUDYzZVS9FmbMDn885sPtY+2/5a+78HLGngNcCMxe611IQwSgvgHt1/nrcHx55RwoJ3HIGt42Pg1EwDu4GghPxeCBB6R1JDwWGgPUn5BVtkitC55FENuC9ASedvBMYMbkwqblMSMaZB3elOBrzy9957rwOa8886BX/neU/ZuZbs/DLJFLGLQaYE0QEn26wTHzeYCI134qvyvIyNEii9n3pigLnWG9Cv0OytALhTvZWpDFqCQ0VZiq+HquG+3xeOq2RsCTWfh05uVIV0Zk6IMBvvpLZ6SmnEgi9HGzvqcZRH88mIzniA7wD3kiX2lBKgRJT4cZDKJ10DCePDqkMXnmMLkMcGQrmA5MtwtHtti+1cO8iX9PM84sCfoYASVsgU0BJG7PN8+DPX4hfe9IH57T1r1qxZs2bNmvVQJQDOP/Nh+IHLL0qALs/txoNydMazCR4TB4rcEZcOPKvmudpi0lxyK18oJi2cvZGAIj+0++eCxnyrZnCgDG4H4GhdUs5U/3JXvNboKK41pL+b8Ri1S5UR8mUmCtzZHNG1M/AzfvbRhd+7qYjupQFudWWCdZdDDm6kQzi4I0n47U/tNQvF0OX5ast5H03m1FUWkub5DYAUip0b4wRNDTA6qPM246tjEXtX3nDLvTr/b3Xo4B5e8eLLsJrnwg5At4vg4GKliR3gqtZVjzEBI0IchPfOM/srhAKn0rhEe+PSr5XSa0UUX/X9UqE+119oLy7LQkRT5i0qekoFeU0UEY8a5I780veAr+GqOVGEPUA62I69EWuwkkeIpH1PZBmQzDbTuRrjRKsm4tKIKh89Uc2dfzUSM1/30UdBhj9sf64cwaiq3bchzgkTF/m+FyqARMQBWLX2c400ClVE8J/e+mH8ySeumt/es2bNmjVr1qxZD1UCoIjgR150KQ4ed3x3qAb213DVX3vnjQG2d7YQUVmi9FALUqWbW32tERunLEGGy+nZ87saoaA59q1Jz9tDsoEv+6V4ENbhyti8fjasS51DAtfbD96aMs5z/npz3d5fV5fSJwWEKnaJeO29WrdVEgDi8xfmbTRnP3RBUyQjnQtODGCQY3PVguzR4LLh3rFVSHLnDy+I7PhebFzCVQJ5vEFACgs6BWYFYJ4AMpBNrWtcsunf4FT5gSuuuc/yzF/2zRfhMY84aeg28xSApDXAPgfqkv1Osg1mbaYsMVl4ej1bFZXd+8k7Yl0TuE2eGBLnWztBVP0aalJyFClJNcMKDFuDlibAx5xiHiVf31jHTBApoDV5+EcKBMUoaiYfR6+AbEeaySlTLvG+5zt47QScrc3CaqGBzOLI1PGz1FrdYNONOOm9TQ2V5vddGaKkhMgpCjm1wO5NJY2FYEgmiIhCYNMjQ//pr/4BvnRkf357z5o1a9asWbNmPVQJAAC47GvPwrc87Qn04I0UReWAeIwJJMd6A9LcI0xgXxXLsuSOKRv1uVzWHqwlAW3rei5l20AugSLVIfxKttzX4wEb28fhJoJjpF78HvpM+tI71vYQb3J3eyjfLCUALbKE2+XQNlc/ALdd8/EG6DQBGzbrM4CiSfpr3goiGcCY2qAsEsfeiRXtYxoLzeszGhtj0Mx00Dq9VRVrj6wzb4ZliBxUdkJDdFyB4RpxJKEpL/rP/Nyb3o+Pffa6+2TfPO+Cc3D5Ux4TxzMQSYVM3ZicsSjNQgZ7QZoEGDQCjNUR6t4P1QmZiIfTQWoQoBRutBjSfiX/B4sR1KoonawpNIDu/D4AACAASURBVLJh66eUkoBxGpMh88IwrpR8vRFJEbUTa8uCRPYxAdeM7UoQhtA0VgBS+6DHIpaBtIg9LpRUQtJ4CKkjJBnwFYHvVU/08DSSiN1T1TTmUtKIRs2DK5QAsNba7ynIaR8U2RfAfyAwEqWo2Onk2peBKvDGD3wKr3vfJ+c396xZs2bNmjVr1kOdADh83DH43/6HS7G3t0ez2EizpCBnfpPqrz2SbOtBlEAiu/dz158jA+2hNsBtGIplh3LJjuE2965BHnCnXNHc0r0Hv8OoyzrjDLRtXh5QB5vuVF+i86psjKDZhdxAQJLCV90ygyuS27/awbz2Y7fT2zwB0MEH+xHkGESXVdM4Q1NfwOmZkkwe23FyB9f8GAz0GMgqRbqHgKbRAEGezzevASaLWBHg708z7AGCDGiGm3sCmpYO0MHSP/8vb8VNt91xn+yb8844GT9w+YVb3eRRCm7ndSSbRLT7TjBJE6Cd1S9pj6XOsEJthMCu91ohFmmnimECpl/ODr5JKp7k5X6OSwKfoxSd1xyPBNkxS4pH1LTnm78EoGsH50OcnZKpYUkGncipFCKxzohMFPr7ataEo0bfnPn7Wt8M/hXxmTPZwfuY7xsh4a9bozN2TMkrgGIvzKPBzTKH8QhOSjH1j2K350f2ZGj//uO/8XZ8/qYvzm/uWbNmzZo1a9ashzoBAADf8bRz8fVPOhuwDrBJYnWbDLAH5E2X9q4OJkFP5sgxaB3UbsqS3LO501c9Kq+PFAiO6so/Kgf4j3kWnx6MSX7r4IKAdMsXrwFbPXpLY6ZZWz77UmwEQWA4fWsOupoyAG4KF53HLr/f4YdgigfOma8EfJIvAHI0YBHBqor9tXonUzB0FwngyOC7IANpsfbRjY37CrTzwEoCe49lWbrTewdDpYRsm8iCfP3G6L+j7CqN0RKTR195/a34qde+6z7bM4cO7uFHXnxZSPUV2CyS1pYM8ZPNCwFbCRag1AVLmUjE02D8FiC9xty80jovgv11jZEUsTSJTILVPoLC27aQmVzwP4qlLDES42MDdkySQHsp0bl3Uz9TH/ie1wbAKUnCXs8VNjuID6VoUh4ASH4L3PF39YC4AedIWhYpfjx8/3AXfSZYFL4f7NoKusIF6gomDGkVnokw3Lj21xrRgnIUhdVI4CgS+cY+EnZMvJ0++pdfwC+8+YPzW3vWrFmzZs2aNWsSAK3OPu1E/C/fekk6tMqgi1EhZ1H7bwjJ8JF+zx7RGTjww7QRC4ubbNUEQsRN92JefpEALeJdcovHKw5suGPG3TohSTRLpa3zr8NcdMwBiAOCda3dIEy8c9hmsbvUHtzh687+qACKS4kN1K21+gw5d/A1dQA11AcIlYEhgtXnj828rEJ2XOsG0BYH6Qb+DQiBc9YlDPwYyLqxnGfAW/eSzMl4zYj0lAek9RAjHEikS85J1yBISGb/rj+/Er/+9vs2z/yl33whHvPwk/168ojG7k42AcxxxKavE6VZfCYDlACpXTOgdfwthCOBd2gy0vP4SIrli6ZyyPiX4drahzWCyMYDave/CPPJ4tdpWcSBPHtUZEWDDCRIk/ADWRmURwOQzk3EE4bPB4jMgDQVECTWLLtsqoSLftVM2CQ1AWRwGJB0X0zKBMS9ZYzrs2NgY0IndswscRifGEG/nytQLGrM+ySjRauffcP77rNRmVmzZs2aNWvWrEkA3E/rB77xiTj/UY/o2dftAb+6ORUD+shj586Wgf21hmu2gQOWrBZ2A6cH4OS3pRTpZ8BK80xxAHQGVXn4tXXEO7juVy1k/2zOFcCjga7q3dg08mCRXv5n+By3lDbfXUjazqZoEYFI0XlJrh8/v7+u4d7Px6hkXshJAGbqp9Xd+wud83ZsBft1JaM1caM/M4dr57q2OfUikbAuEmMJA7gAwvDM/t0Q1FJKmCyKOHHjINIG4pGBHwPDmFWXBEx/+vXvxSeuum/zzJ/7pEfhBRefu9Ptn03YSgGBViTyzLrjbPZn8+EM/gN2ZlDtPhlao2Pv8ZTFR01GO0oeScHQ+R7jFgGW9MuW0aZFP6bxkX5wbpoHRVXBQsB4pUjKdQ0jyZgzUPf+4FjDzvV1g9JYx5UIqaQa2mH8l30ojGwsW4abpRCRCEq80HYejPzbX2uY90FiXIIuNiekKBMcRlYMqQ66NUtiY00R+Qh/L93pDfCpz9+I/+d33zO/sWfNmjVr1qxZsyYBkOvix5yOFz/7Sdm0jMBiPniW0go9QMfsLXeMDegZ0LGZ7wDW0dUTShmQIqhrB0IeExddzfh86l3OqorFfpdn4XdI0dlHwEYerKNm3UB/TQcVBI5aZEH6e87i5vnqTVmcMDBovZSCVavPgpdCRATFpLF822W/1YgHO05GOOQrQHJxm0EuDmQI4vGvErFjxMR+NzxbRDq4a8APBEKVuqsiAfprUlCwDDp/Rv/l4d+SaSMUV91wK/7NfRD/N9ZjTz+MH3zBU/1zZRf2TGo4sLP0DM6md4IrFCCWEMAxmbZWOC4PmkdzYrTGVDzi8ZCcPgAh331KiGDyJStDckfejnFvkWTWWcrSPQZqkD4akYH2fk5uWDqEZH+JcTyopGQAGTwLSiMeSyOyVlIAeUylBgHCCiD3BuhjAuxxwEuSgfzayTmhcZikUElxHtkzgVVBYeAp24aj7FOSb1o5ccJIVotvpG8mheL33vtJvOED0/xv1qxZs2bNmjVrEgBDHTq4h3/6omd2M0Ay4Nuaic0P555rPzyoJpf4wTTLXt8iAD0fXkiRTCd47Diy47aBnZGwSAZoBBYSMGAjLWVKIB+nExk+O4+tf2OAZK9jDe7cxY3undJTP59LIVM/e10jArQTKks3ekuY2f6TZsyVxiLYcRxkpuadezD40kwOoMmoQZFybdCh1dJl4TYmYUDVu7pCAJVe14kjQk2lFOzvr5Dup8DHVYrgw5+5Fj/3xvff53vm+GP28IoXf0OAf46Wg3ocXIprJKm4KS4MQLdRkFDbWPqFIBQwWrMLX0oBABJBIGQayYaYDnIHvsgd6kveu6rZj8DSBywxoF0zQUFJ+4eTL8yDQwEcWdc0R88GfaPfAc/3298H6OZDyCA6RkqKk5CcbFDS+6h/NnudSMDYDhgUHgXqiifTZ2yI1HOfDZ7nF96y2zJ/Ow/LUoA0EjXcSyuZjvZr4akQdD/4kV97K754x5H5jT1r1qxZs2bNmjUJgO36tosfg2948qMTkM4gI2THZmoHbCcClCLJaM6ArOdk0wN/jkvLOeMx+53jr/Jscu8majYzGzPQyw6Xc7+U1PZjbwCetc4XX12Gy8THujZCI+LcQvodoC4MytwEsJ+rJv3WHJFIx7SuNc2YM2DQUaZsxnCpK8/dds3jCVIoIz7HmlWt2CyLj08s4nIJilMDxcppN0cUul7DbHJ3Yc9O8duEjybSpNXvvOcTePOHrrhf7JmXPOsJeMpjHkHd/byGzVhz0zvj7PK+8iw/jZ0Ij6j0UQ+OxyyluIu+d/ShyQizSeVrcuZXSrlwVQ5CVWMkky26Qh4N5ovh63wRN8k0lcFmswRpQX4BpuJoezLIHFb8sHEfm0wqLK1Ac5IGQj7fPr/F8cVex5BUsXv/mzohjpXvW7qD+DQVjZGHteZxHzcQHcg4Hocow94ZU0pG80jZsef5XBq5t7qhJ/DuT1yF//y2j8xv61mzZs2aNWvWrEkA7K6zTzsRf/9bL0lzqCYzN6f7OriSKxmLleHB1R7gDdiK7DYMLNTdE+yMM+8Pt+ou+9Y/P5q0WnZEDObOfy7urlUy1WJAavPArevWXpw7mMtChICCpMdBKJSmZU7gxQ9T7PXz5zJCRatisywul95fV5dFM9lRaxgpcpeXVRllKcmxUQRQkeRf4OCjCOqq3hk1RiUASBgYAnDA1q6tSbJ3xbR1oIiWrlAG07fx2piq42de/178xdU33C/2zIVnn4aXXPbkrYjJEXDb5dVBDRD7IK5FW0Js4ijewfbuu+fR1/DV6HvhyLoilC4U9bhjLfgKVzPKq1hrm20XEaxr8wJZFvG5+8rIVdHVKGG0aYej/fds/8eNM8wG2XPDzD5NlcIeI6P6pvb1EmMB+c6cRjAEvqfMN4AVQqy8afGbNlI0hJqk14uYyjbOI+5N4PcRDTIoYv2URobMUSU+eySdcELEMBJAP1dKVioVeu//93ffc7/ZJ7NmzZo1a9asWZMAuJ/WS55xHi4675HJzZ5d4Llz7yCng2DuvjvsJQM3gDLtF9mOy2J3rB0AnZ3QGZiTXd1R4rM0PVB7fvjQUbMry0Ze2waEzW1cx9fWzFiYKznn2nunvxjYUcRZyK4K7oZfhlGASmQJzzD3wzKSwWT/azVVApIpYynFvQ5AUY1AeB1YAkCAk+AMlmVJGfQuFS+CRUpKkbAIOE1jGZKj8jqxUkpxozebXbfOOABcdcOt+Mn7wfy/1YHNgh/97svyWoWtkZYN37rqfZ6eFDC8ng0gl+7X4KSXaiJOKl2zMJLr1zV/CB+70NqIgqXLxAvb5DPJ1Nc6JPYUq0UwdO2XDtI5RrKtjeKftapi08dV1p5YYMqSI+vq95i4hwgREty1L7nzbQoDIwAk35hLn3FIaoEdjvz8V+zcn3wtRuNAcBxnfM4WX9gIMSaEmPwBeUWEWQZ/Pkl+Ej5OM96vaO+XIkQ2tfX1wU9fg1988wfmN/WsWbNmzZo1a9YkAO66LnjUafi+517gslh/6CVEXwbTO9nRneKOnYFQA6D2ML3017E5WqUHbfYMsAfgcDOPuWIZgIyQpJ7niC2Cbewu769tbt3d+QnQhkRbvZMtWzaJCp5754d9fjhnIG6/ph0AqJvh0+cjwLK6yqF/5soASZORGbu8pwUr+fwbwWBkBIO4lkRQfak3vBbgLCLf8trZLEtPgggZNZ8LA0uFow7BCpAYwWgydXSyybqbwAeu+Dx++S1/er/aM9/9rCfg6x79iEiZsLjKwk7z4bjPHWKhUZOqIes33KmJIEPaUyb7N++A6B4HEcSO9mY6Z69TSlxn2y9LN9JrqQLi59+a/kLSd1f1dKXAsrQxEh2Qtfafa/u57TXr9BvRZsZ9xUcH4u+Le0iEp8aYolHctJOiRXvcZSWwrtqu0dJfP9I1JGIUySCxDh4V43hOKc2XofbzZNtmIUKEQXwag+jX1giR1QhDyT4mZRhfYMLCSJtklKmK//JHH8Wf/MVV85t61qxZs2bNmjVrEgB3XYcO7uGffMczsLfZxKEakC4SnUBy2xpn+gvFvY2GdixZjaxz+CgBhhNrD+X2e1vRWNjRySegZaMCSQDgHe94kJYUJZYNu3i2WjROiUt6+09Z12+cW9dhPtuAjvc9/f3rEA24ncjQwAncoGycHfYRhWEOOXdpO43SRwqiiwsyWxhj+yz7vGwZO9qZNb+GQtnsoOOrmjvgRkzk0RFNUZNAlkX/3Bs/gI997v6VaX7hOafhxd/wZJ9fFxkiDYeZE0kjLMYG2f4oPYpRt7rHTLKpNmCcrSzUVRb2vmyyaPP5psZITFNfUHYNGUj7tbPIyQ74ZYjbc+WIhKpFduxnJy0kTPmEjsEMQlXRFSDIoaPDmIUpIlZPGtj2m9Da1Bgs0x8JMfG4S3EFFPsxJOqP7jFs6Wfmirw/q6cwgIB8Htvh88P3tpQuMaoHcBRVABQ//Kt/gC8d2Z/f1LNmzZo1a9asWZMA+PL1wosfi2c/+ZwE3O2orfs7SmpliDtLD+BbQKiDnyT7HWaLEaBnIUl6zPlnUy4GlfHeBEBS9nY8yo/dM/6sDaiEPLoMIw6Fs7s7UFiVIww0S5vVIsSQndf5eJ0kochADb+DiAMMMGQqBjaCY5xgkXFKQGSMU6y9i1xK6TP53QTQgJEZupHHQ5EMTFg1EpF2O9aCMLkTJIzPVcdFHC6K4kd//Y9w02133K/2y4HNgn/2ksv8ugoBtwxuyaAuHVb8rEn7dSCmTCGy1gb+lz7CYakaDIYzURDIlccLqmnm+3/btV1kwf66T+SDDMmMAVqNSCgsyfe1G2vI1A5LJzcErbPPYzsigoI2PlBrRe3kRpGcmpHOoZtO1hRJqYPLf1vHTTljZptmggg0koEJDRn2pg7XKsUJbqUYGOiP31lKV0sAySgwGXN2gjURN119o8ojOdIVU1mJxXvojR/8FF73vhn9N2vWrFmzZs2aNQmAr7DOOPl4/K8vvLQfaO5CctZ1uNoHEN6UkuaEaxofMMurHC/YTL7YzCz+hY33OL5Lurs6dx65Oh4YpPBkzqUDaSGDsF81S/lNQlwV6iCvAjVNR0SXkFQSDBRsXtnn7yWgu73nIgX7ZOTGneAj69pAdu/GxueUrU6qz9zTHLf0c40uvfbuZs1dSfucPrtPIwBFisvQU7Rgv15OeBC5YWaSBtI4ycCu3VKyWz0TB6qKT1x9A37m9e+7X+6ZlzzrCbj4sWcAnQQKH4PsW8FEWFrvrN7AdgJHA/9hpjgSJyDiqMVyxsx/kF3VDflsbn3thpG+j4xQUMWyLCmm0FU4QB6xIYmCDKAeSTqvaWSndear/zcTX0sp3lf3NQ5JcvilCFY1F3wkYoqN/UKxQmuO9t+WOmPLyT8nFLRzU9LaBZFqZjZaAVfR2Jpfa/WkAn4v7uwz6cKjVKAUCNvbybC110/8xh/jmptvm9/Ss2bNmjVr1qxZkwD4yuvFzzgPF5/3yJjZ1iwtty4egw7u9rWZ95iJtU4hR/yVIjn+jeSwu3K6/Xc561qHBiWy23qhlriqUkxWNt/y2WIA++aiz5Lb5CHYOt21Kqrnr8f87i6zxNq7tU1C3+TP2j8AS5rN8bydHyRAHA/6fdRAQlJt8Kp10dUNA8NBvAnrXUHRgcTotVCIlAhJdFMFCBm41YoU6cixgbZDOL6snR9xLwTGgTwyXofz4fPqIvi1t30Y7/7E/XOu+aJzchoAk0Js+ld2qAMU2CICCrvqO/m1HZHJezJdQ6ib7rkkX71fTUTP8HnSfunJAw5whz0BG+Fp13QpJY0DOJDt5MXW9A4CmBs4Zlm7kSg8rmNEHMdoApEysJS4b5QdMYBVm7pAuhdBSrxgWb+pZhAjAn5+TDWjkgw2jZikqQAfcTIiAMP4DI8LxZgTpw9oiu8MFVQkrMR9EvjIX34Bv/jmD85v6FmzZs2aNWvWrEkA/NXqyY86Fd/33AsGN316dNehgzbIunnunTtwq5mOkbu7d//pYTzmhzkP28A0RaKBgQHPPIOi+LDlHeAgo4jnh1s7n+PWCKukNq72n7UG62JmYP0v7JjaZzPjvuiY9/iCDrSIuOhHamDPZqx9Pt4f/GPW2aTgy7K0P2vF2sHeIkgdW85Z5/nkAJKFJOdxfGF6VpIbevUIwB4HZwDFTP4kA5xas/O5gbYUvSjIEW39uH/k196K2+88cr/cLwc2C37suy9zwLiqYiMlSI4a8/Xj3HZBH+MYPCfg8+fVJeE6mG/ynllr9c49X8MGrGlvqOQZ9m4CicFV3t6nzc5HgoOqYtU+7tFNA3WIBkwRmX02X6SRa+111D0A7KKPJneld/3tXtDGTPJNuBT2m2DCLAB9WXLeiJFaQAbgW54TJOs38kbS/SKIiO0RpDiy5AfhHXykOFQG/e5BMpopqkKo+1+Ym+wH8rOvey/+/Oob5zf0rFmzZs2aNWvWJAD+anXo4B7+4bc9Fccee5x3+g3chyw1umLW4TJHf3bgN0M9AwM+d67RrWS3bXY5X7ojOZvs2Qs3N+8yyKCz7D8DL3EpcjiONyeCUvpDNQZDOpOuK4EuaJJhRwyfJmALmr0vHa8rzfSXIokEcJUEdc3t9dNn7qqIpRTUtbbfW4qDkLWu8b5DlJlJl/NSzlWSQZqEZwEZ+kkx9/qSRgyKu8P3LmdVVwpUWIdXHPQUydJ1NlpjZccHr7gGv/qHf3q/3jMv/vrzcdFjzvC0A3bet456zrQfPBS6OiUTMEzyBIBkkqwpRlpEpRCQtnl/+xnrQJdOTESWvZFzayJhrINfSgnljAPi9p5Lj5SsPRvTI/cK3SItxo/MDsVTNdhIb4jwAyspYo1VzSSegswClTmIcPbn5V6ScWbxhBJLZdgVDyoU32GqAY/qJGVLiirsx1AR6h32MakqYNFMIh8GMiKNVPm+0JS48smrb8ArX/e++e08a9asWbNmzZo1CYC/Xj3vyY/C5Rc9btstvz/8N28toQd3Am/kRM7gfelmY/trdfDOpl0RIxcPvIIcm2ay6M0SpnQOH9hCwH8eSTbsH9ivZABPlxrbPLLPQJMkvqDnvHM3NzqoPtfvoKv/bjVJdslvP0QL2uKqvcsayQkElDTy5tGTAZZlwf66OnmxuMt69UPeLAsBmXZlWn75AlYYsDmjDM1Ihcn/HR25XLutC8lGkEyckLmcXdf9quk8FBoBMDLnF978AXz0s9fdr/fLY08/jL97+YXDTDd1kocEhLHJ28Y0aJ37KEjpHXrbE9bd1i2ipFbFZhFKA9DkqK9Dpj2TQ60zXdP+5ZQJV6cUbSoCep1KiiD2zOClrdV8PuJ+wqah7ceDwChia7FskSW8WYQMCm0U4MBm8fXDYz4gEiV5WCB36utonmjngB38faRnuJZDSqibGDJxADiRsQwmpJUNBZHHYZTSGtLGVOC//cnH8ZaPfHZ+O8+aNWvWrFmzZk0C4K9Xh487Bv/gWy/GoeOP8wdTz9LuD/lLif9eeufOOvYcITbOzzo4BPxBvw4d9dLB+84H/6AV/IHeYs5ifh1JhmwP0Xle2l5rW50AIIHRGDlQtGa2uDu71iwx5mg+EWB/rd6NtJz7GBUQD79z1UGiT7qBGCsvaOZZFa7SqFWxasUCSZGHSykN4HVlRaXINztf61rJMyAAns33c1dSunpiKaVFEyq8k2xdbiBLpH3G2kEXUR/UXfZpAAdgwP/+/70Vt91x5H69X/aWgh/9nst6N18hBRiaz2ntK6F/dTImJ1f4v+0wEWyS8J4uYWZ+khUpa1UIdf0FgiP7K5alhMt9zZ1uNs6z/Q5txxOfVZJ/hGwZ1FWUsqT9wL+T9y8RjKZGcNd8kIFfEBu+bomkMGJk6UakRUi5QMxk6aqi9nviJoLhZ0EmfWbYSF4e9lmD3wgSlEE7nxteA7V7KyRybRiLSfc5yaom/lysrHrFr70VX7yf75FZs2bNmjVr1qxJANzP628+7bF41hPPSQc8gjs+E9EF2+6Abs12WzddIw+dTdO86ygIaTnaw3jK8AbPGyMZae2KJct+AEwQZIBis9fcoTP5/WiEJoN43QiStceeBZyHA4oUT0hAOYBFfL6KGIlYKRFhWYpHmLHvggEG68YW0hob+AGi+95k/iWM3xTYdNBfqxJoz11O7lCWHhFZyuj+HstkHB0p1EFO/0Zr64Ofvha/8gd/+oDYL9956Xm46HFnpmMZCQCOcjMlRrUxm4EwE3AHXtNsuxEI7tLfu8y1K2TCq6GZ1e2vla5T/DkMA4W64AS0RYd1GSocKRJpBmhdfvMg4H1kEZP8d4a0hef8KTmAATKv3yIWpznO1ouTdvt9j2xK8XGMlWI1LVJTetzFaMrHe3GtEcPoJAmBb3D6B+0HVi/xfSBm/UdvguxJkHw4gK3YP67XvPPP8NaPze7/rFmzZs2aNWvWJAC+ynrSI0/BS571tThwzF7qTnFElsuAq6YHdX8Ilnh4LbJtsAVtpmm1G6exI7q9voHCpVASAChOj0z6Rgf+8QHaZpFLl9GyvDoHDIRrfxLpK8/xAkXymIMBHpEwEzSig1LZaB64532TQR53xe3zLaVgv1Y/nwYizGG9dBM+i5Mzk8M6JB+MS7e5/Nc+etHAYvs9JgxKBi+DztlBYDcS5GhCBmpGyLA6xEiGRWR7lwH46de/H39x9Q0PiP3ymNMP46XffKEfm60pc4s3siv8MzX1h2utSXHhGQ9Dpx0dmFsagBAxF+uy+QDUCiyLJOM5aID/So52Pm7jBhRwJQDA/hTks0HA3LwK3BcAoRg5sq49KUKz2WN/38KqCIlIwL1lcYXK0sd+ipR03wkvAySiwu8HQgoUvvEkbxJJ4Dt5gBrhSGMxspUh2MgEHu8ZjRrHeMtI8Ig40HR/RTZ9jLcSUg8A/+RX3oI799f5zTxr1qxZs2bNmjUJgK+uDh3cw9/9756Ms047OcuZBUNcVfszdxJ55jWIAAz52TQnXyTFW1XKK7fXZ7AONo7rs/JrnzPeNs1iB/8IaF9XjYgu5Jlmu9Clf+ikG0jHYCaFMZvN/y7d6b0qeQBoOKaVpfTMeDNULA6MjdwwyX3tEYQGuKsrFCx9IBQKPm7gPxvn1U3iJACHkR21TzgsJrsmkM+ghGXfIAWFAdKVutVxbuHHxT4BI4C1v7/6xi/ip177rgfMftlbCv7F917Wr2feL5bAkDrqGnCRO/08PmIJCcoOd8jnKiIGYx0xabCuK/Y2C9aeRtH+XF0qX7txZLHUiZqTOrLfhUnkO2lBHf4RMCsiWcK8MyorF7pqYVmKE04e7yfiHheNJGuLaVMWHxWpVWlMIN67SBhs1qpuflnZgJM/K0KNopbCIUFWcQpCKUPSyagGoKi/ddU0vuDXVO0awyM9jeQbxxyQqLasBBABXvuuj+OtH53d/1mzZs2aNWvWrEkA3E319Mc9At/2tHOxt7eXQAn/uWoz5TOp7WgSaGB86X9nkthV24yykJu/DBFi0e1SytUGxQqyDF0G6S3lgfen9Vqzq751Gpk4CBfwHuvWO9TCKgLErHoac+DMcwlpcIA9DcLAPlcH6rVquMBHLmAY+y3FQQ8DGFCWOhMnBn4GXzLPgHdgbtGKnShYyDUtdyslxQAysGGA49esKwGSKSAQfg3cmR27nhX40Geuwa/+4YcfUPvlRZeei6ede5ZH/AFN4QICmU6gJFNHJNAR2QAAIABJREFUOAAXSnww8Fyrpiz5dp1szr3H8609xg/qfhcrkWaNbFGMLW7pQL6GoyY2myUM/sCdbd1eA/bZJNZ6oehHG3Ew74kGjMdOt/hYBIA+SoCuYIHvmc3SiIb9quR7wGaKcPVMyP/N80PSuYCq2Xm410YlUtH2EGit2v2r0Nx+4z5oDIdGCIyoWJYYd3AQn9I5iBTor2GXLvkYIJOvs/s/a9asWbNmzZo1CYC7tY49sMEPftPX4YxTTyLACYrB2mFUZoqAGp3/RhTApd4WA+bSfWTHbZZKO3Q1cGkkwta8bQCKWlt3PB74FYzBOUbLosRsnt6O0zt0CEl9dD1Jnj1Er7GJYCQJBLtQAYpVE5fqJ9lx/8zSncZ9zjliDihiMUAmR4OZIWOToLc5cO5iigB1rSiUDpDAfL8+cXzRmbR8ePY4aCoBTeuhSGkdTg0DM5Z+W5qByHbX82ff8H584gEi/7eyNIDkLN/XWO3XrEioSkZTN2UDu74G3GW/krFcV9wYyD2yvyajPiO7LPmhkVzYivK0CEAD+bYWa0f0TtrpCtt9MGKgryMm2bRqJ37YHLRL7Iv9bvbGEFePFN83oOQPS8LIHgERKchkBEcwSslpBJz0gTQSgESGtFPNPwhX2TQvEUkRhEYUiCSqLI6BZhOcWKDxKP/Ztfq9tQ5GjHwvtJf7zXd+HG+b3f9Zs2bNmjVr1qxJANzddcnjHo4XXnIu9vYOJGMye5hd3JgvA2t38kYol6vmjhoTBiYv3u8O/SHLDTIhuu6ZdAjHenGywciHgMwh5VWSWxsK8PczGTU7EZqregc0hVzJ4XPRQURoBzqgf7djLi57RyIcvDNoBmFdbWDu6nC3fbiZYPIwQLxPKeIO7ynaT7Znih2cs0Ea4KqAtQKbIUZunGteemdWKc0hxgP4GtnIAXCkKzhypGT7rJ+7/hb8X7/97gfcXtlbCv7Zi5+9tbYrGWBaWYccHTib2aLtpcY3abji03nkaMiWQ08z/daB7l1973a7oqCEv0YlHwJBSocAbK7fRjxiTn+bYAPW/RVSSlvHaPGYnOhgPgdGjJUuzef3LyluoL3nUijVAuLrUxNjZPciigfl2D7bykOHvwxxl05wGjlF55yVRfa7plziMYJGpBXv9guRP+wDYZ4b+7UOCSlBWrAaipVVCsWP/NrbcPud+/MbedasWbNmzZo1axIAd28de2CDl33TBXj4w06CjfpypznNIpMjvSIyw2uf9XWAQ/ni1jgz0MMxX6tqMtRyUz8CT6C/Y2Bvn0oEEI24MPYeaJ3s6rPK7RhATuuts8/v246nto6sgbdBjWAIX2FGeoZr2nHEyIQGKOmvv5Tiru3Q1lE1P4DUl+TUhA6QAgCZGWIAc4MzpasBCo1e2HGxudkIBu3vMH4W7+ZnkBppD+Jmj0YYOXFQSj9HPOMOvOsTV+G/vv1jD8j98l2XnoeLzz0rxfq58WFfK5Uc+nWIf+yhgL5m26gMaLbcvDYI3PKeMhKrZDM8VnKY7wIrEDizfikLFMCR/f2WUNDVHSz/B5qSZ7MsDoLDQLMnTawcC5rNQtv9o606B949LUBr3yMFEJQ2WuTO/m0UZikU6acUuic2T58NRy0CUCmmlKP+2DzT9p2dO6GUBHbwjxGJrGwxQjDtq+QREPdFH7tYipMLthn8XqKZyHzD+z+JN3zw0/PbeNasWbNmzZo1axIA90w97bEPx7dfen7PlBdy16cHYQcjtcXIpfgy2RofsAdze1i2R+nSpb5KBmTWHfc55w4ss4u5RQr2sQMiD1h9AIRkvXLn3X6vz6ibaZ69fuHOfo2Djy4gAYj033BQA0Fz3C9Dz1tA6oHaj1F6FzW6kUvvsB7pcn4+PybH3q+rA/GlNDl5i/wTHNhrBnAeR7g14hAz4WWH+7+4S3v73Euffx5j77I0XBJpUWt1lYPQCAioW/4fH4Dyf6vHnn4YP3D5hWRu2FQOrJqxjHoQidKax3WI/8tEj4PRPrJiqpeIlTRCqZFvlX6H176RX/v7a5LSJM2GZPLHTASXYvuzJnrI3P9L9wWoxOi0RAt1VYn9vgnmjfyzMZssUBEijsJI0n9O0RUQSL4KQt19M8P02Xw0r5LN0l7HFEZmwsnvzuMZdu6BPqM/knBGppCawzw1+JjinrM9ElBrSJx8j3JyCgQ/8eq34wu33D6/jWfNmjVr1qxZsyYBcM/U4eMO4KXPfTJOO+XEJG/OsWZmAIb+UBsnzKCAgUAz6BPqNrOuPxvNMWiPcYPNUrC/rg40q4ZJmYFYB5YI4GpXkDPnOblACbyDABgnEdSqKVqv9hPRIu0QYwE2q+3y/+a2v/KcvPkKSEnmgJJzzUgFoeS2z13LMPljQzUmONaeHAAH8IUAopKCof330rutDtapc1psRhkm/e/HWGSr25x8I/p/a9WtXaVQfO76W/Dvf+e9D9i9srcU/Nj3XJb8IWz9ZsM6oWg+pTEX82xYfVZfVZv5XMlmcqvPjQODz6SbSoLezzrmdq6XUrqZZv+E/Xf314qllL5W+PWSP6X7QTTDwZUSMEgO79MrkmI6ayV1gJS0FEDqERspCAk8j8+QCaiBcwXU0xYkaIFh5Ca6+nFRVDMg58g97sg3IlAGn5KsijE/Bzfo7NcsG5Oin6t4Db8v9WNataYXf9OHrsAbPnDF/CaeNWvWrFmzZs2aBMA9W88+/yx8y1PPxWazNJMt6mEbllvMwIvyueOBOIA8PzILsqwY1BE3AJ3HCziNACS1VjcJdCykmYUoyYTQYrkqNmXxv7df4QdxHycYloDHdtH4gBuGoTugC0mVzRixA2ugdwurRf+VBNgUNZz0++w0gwMnRkpxObHFnoHUF3ZQVZs5mpjYv//bGNMHJel6j2Szz83xfqZM2HQpv2Ww8/VmACyB9FN8mp9LAG/4wBV40wcf2ADnOy89Dxc97sw0oj7Ou8fa0pT4wEkP5qNg19bItbWqj+PYmnXfgH5uzdTSpPKcAMHEhK3ZRiYJgJVGB2IUpJD0nYm0UkJpAN3eL5X8DRSK0k087SAXkQ7YaSRlEQgKjfqQYqeURGDY+xUah2CiJO4pAe45QSDdiyQfd+zxGF1wSmEgDQQxSpCSUTpx48QhLPbUCM3sDRFKGSZvgh/98Ve/A9fN7v+sWbNmzZo1a9YkAO7pOuOk4/G3n/0EnHz4UHKSN9dtuNQWKR7OwSxJ+oUAupsG0kO5dZFXivtaqRPd3OP7A3SzR6fs7tz1426lPaDbZ9ivNc0LG5BY+98DNf6tg6xlace7X2uLevOH85xgoFoj5NtA4KAccGfz/m/NA0Cwv/L5UzfQGwGBoRUG2QUCKb1jKtINyDIxYeRBKQVrXbEpi0erNRV2yYu+d5t9TIDs042YCfd2dNCpyf2fARoTMuzbICL4yde8E9fcdNsDeq+cc9qJ+MHnXxSDLUq0l4/ClKSCsC55VXPwp7g46zrXbG7JRBzIyM69F/oLVwLsIvkWpl19sr+a07+CLRlKn2GJFIcgxtYKLEu87uoqAU1GlWFQ2SIeTRHiShBSASz9/bSfI9uzSzM98Dn51KGHosiSCEZP2rCYQ4jHefJeb2MzdQc5EzcqJhO448+Gfpw4UChGMKUFaJBgnOJREb4Hdv/cdZxz9n/WrFmzZs2aNWsSAPdqPev8s/CtT31cMpcLQBjO3Kmr3/9t8ZztAMqczW2AxrvZoAdp1ZwowMBKzaV8NEXLF81m8U3Gb1J3i6LTFINHYwjDcbpbfu/st8/ZALcRH2tdu5N45Lub6dlaO5Fg7dpuQMiz1UspDnbEjAANiEg4ivN5g0SSgTuqk9Q++TCYaV/3HPBucJEOMmOu3zqWCcADAWJTbCBcst1AY0mERZjVRbybv1wBrrzuVvy73/mTB8Ve+XvPvwiPOu3ESL4YgKSRW+xlYQSZmfm1jneYboKINRsXqd0kEBKjGA0Qh8lcAHfxhVz6wl5t/3QyoFbFZrN499peK8B9JGGUUrB24sCurSA74y+lS+A58UCCJFIacbE9aWTdSmkDKs2joCUNlJ03Zs7Ky2qdUXYfv+UkZj/fvF4jLjEnXPh9on8uGb4ZcmQhIu6y5J/hqNEgJ+P9xnvY7P7PmjVr1qxZs2ZNAuBerUecdDy+/1lPwMknn+CmbfHAG/JbJad9/u8CdqTPxlhrDeM5NoprHbTIFjcgxbnyEbnVndOt29g/RCGPdU4tsId9A7dVawPj5hhOhIY7sBOgyGSB/V1NEvq1NuPApc//K0xK3KTR0meWTS1gTv4mnRYR1DWbxjlIgeXGdxM16W77nWBQ5PlzI1XybHiW4huayaMAYcQ2Xq+ljwUodZrFFQ3Fz8tqEXA0f62kGa/a5psf6PJ/qxddei4uesyZYCzIBphmtDimBZQ+g68k+WclDTRiFmsH6GJjJh5VV51kshQL238rkWvaSZqR9DL/AJbSKxEJpZSWWw9gWRY3xxQ22xRAa3Wiw2L47H5gZnkN8JZO/om/nh0fOuhnSA8bY6E15AZ6EqaAGGJLhUgR9g5QDOMAqpCFxokUfi583GH4JuDXqwrv/HM8qu1F2wemCFiE1QbI5E6/D77u/Z/EG2f3f9asWbNmzZo1axIA93Y9+/yz8K2XnJfN4Ogh1+TzpQDrqnne2TqXHe2MKgHugMEfvBGmfSStjYfpAFHLEnn2a20O3NZprA7sNSIMm3UhOXp30MBmewSMlLqE9rFrbXP61ik1MsAIBJFwZLcoM3O7ZzBsc86mUigi0N6pVZLS27EvC0vINRExBqisi78s0TGtVQfAUjogC8KBndaXrgrgDqURFbXruVnqzqMAhc0Mh9i10RNCIPjJ17wL19z0xQfFPjnn1BPx0sufkq6LXwM6Tz4Cg0jVsOsaRpVELtGGSf4BsNcorrSxdayciBEYNxQ0NB5gSQJQoCwtRcKuj3fwewqBrd39de3d7KZ+8dl8itCM94muv5EAAdi7UqITR7GW2i9s+ppXaX+2c2vA340midSqpK5Z1/DAyGuxqxM00in8DFubHxQXiEym2XvayIPHYCJm933shsY8/DPXUPnwueZ75v/5m++c3f9Zs2bNmjVr1qxJANz79YiTjsPfueyJOOHE47EVFD8G1fe/9JNGLuImsY0AQPU5eI9Ps4dg64Yjxgi0u4Jbp/DIWh0s75Lubnf/Imdt+4LGLLN3tskNnf0BDAhVm9dHjBGgP7yrcuRhX0Qd8MMBoCawbJ9ZNST51kV3QNVBCcv1G3ATIl+EYvcsLSEIGAc83G2WpkwQigYM1UZcF3ZnN3wnfO57HFxPQoN0UFfJId/g1Mc/dz1+/s0ffFDtlb//govxNaecgP0akZBbMX/9TLo8384N+Ww4YIeirjXMGBFxgA0QK6UPhBt/dPRLpDC4lL12Ysck+fRZwP4daoMjSQ3An1k72aSqzbzTRhNsjdTu5UEK/jYmQBabnjJQXHFia9yVKY0vc8IqPmeYA/KYhEg2PrQ9ZSRd8fUf72d7gcdu1oot5//xGyGSNeKvK70HExQpbSTdd+JzqCpeP7v/s2bNmjVr1qxZkwC4L+tvPOUcPOeCR8dDr0jPmqdZe4rlC8AqSQ7rwJy6Yc38qs/8q6TUADdB6+Bo7eZdy1Kwv0ZcVilC3Tp1/wHrSltEl3XUDbiwskD8PaP7b8eyv9bW2YeQJ0Ach4GuQkC7CLBPBIABaaVoMeuIstO5cDagKpENMfOvNHPgP4r4cyklZY/bcXM3clkWl2iTTX/3C2jnrjmbt39de466xZZbE9cAlRM5FP3HcncmOADgde//FP7gw3/5oNonl19wNi570tkxx97HUVjineAfu+hb9JzkPZNm0Pv5219r33ehyNmvFYuARmRiDaxufqluAtj2kvqfeURDzKmuX0Off9dsEGmjAN0TNEYPOhnU+TY3wlNtSN5GF6zxLd07QCGeINAUMXASYG9ZYt/AIvPiBh0SfCPaQnZg3XlB3EtGssVIBZiSYogctK8D7QqiIiNh0hMObL5fgyQzVZJdByYGRl8VgeDHX/12fGF2/2fNmjVr1qxZsyYBcF/V2aediO95xnk4fPhQ74r3brx36JEBvJpZVu56JTBo4Ia6yaEw4Oi/HCvXHqJ5Rr893De5fXTd2iwyHCjX0CZ38E+dfI0ObWSfh4O3OZubw3i08UICXXt84VorNt1tv/aZ6wBf6oQGUHwuvBmgxTIzZ3Tpv1e1kQuykJSewAUEzYhQFn+PiGKj8ysheTajxaWUFJNoqExMIm4qiEUwWq1VmpXmyMZGpNQsbUY2xvs3r333A979f6xHn9bHAGhERqH5+CU697tMG0d/DSOsOD+ggXB1DwEjk6pWN+wEIv4SCGl8EAjhQ1EI6IP8L/wzlS5bdwKNkwngoLgRQ4q6Nv6gAClNoI3DtD0sYiM8cDJQCrCUBaGIEV+j2u81RjZ5tx5mQFjSXdvIxYWUFW0viXf1WX1k59Ul+qDUkz4m0dQO4ualTBgaoeFJIVDUKpQa0K+5ZkKCj3Otit//0BV4/QeumN+8s2bNmjVr1qxZkwC4b+v5TzkH3/jkR3vMHD98AyyT3e5gMsABGnlQh9w+N62jDG378z6BHQMzFhUW4wVIZoT2mqVkCXaxKK6e380O3NxdNNBSOY6wy/7ZG0ApE93mp/mA3CW/z9eHXFi6HLpFsomnArDLfp+LRsi7Hfx4YgL8fdrYRCxbninnUQLrbi4lVBALpTHwHDoGJ3U3UDRneAczMqQ5dMPCbpLIc+cfv/LBJ/8HgL2l4J+/5NkJQDL54vvBu+KglIychGFgf3umnsitPrISHXZ4OkatjbhqoLXtSna+LwP5VRGdc4vg5GKfDKBiXbuXhps+NpKqdvUIR2wWARYjPmwvdePOzdI6+UDbz2UpXRGwbBkTlk4gsGye94sKsDE/AiB5ldi9YUNmmegKiNH13+5XhcgKEOGl/nnLTiUB2KhQmxHj3lJS+kBaG4h730+8+h2z+z9r1qxZs2bNmjUJgPu+zj71BHzv1z8eJ554AkW6aXKO11o9z3tXqZMHDRAZUApQRN1pAkgeKZj+Hg6MOV5rf63eURN60G/y+tyRDWATDt7+ytbxHHTaIoL9/ZVi/moyZkMNMoGj+Kz7W2l22szKTHps8/QwEKXhcM5GhqrZZMyk1qbIEAmDvtTJ1Org38CJEDlgwMec5VkVYPGAWvt4wKb4ealEULTO6pAUgDyb/aq3fwzv/eTnH5T75JsueBSe88RzICXHAOrgID/4YTY3exEil5i4inNoozYGTqvp30WTR4e6z0R0qsPEU2Od1OqgmokG7aH3If9XN72z2X5VwarxupU8IMBdd0hTA3Q1gflSFBGIKlBiDMAUMtZt1w6Mi7RxlNr3yd5S+hhSnucXAKtWUgpI2j/2s54kMhAJ470njS+hqSykE3drzWQOkzZj2gYnDxRSe5jSqSrw+x+6Am94kKRizJr1gCRx9/bw8Ic/HKeeeipOPfVUPPKRj8QZZ5yBU045BYcPH8app57aGwM1ma4eOXLE/46rxaYi3WM2m00yGg4fHSEysN23jxw5svvBVLIfyrIs2Gw2TpLa/77whS8AAK699lp85jOfwTXXXIMrr7wSV111Fa64Yt5rZs2aNWsSAF9BPf8p5+A5TzpnB6iXNJcOoLvJs5Q2YvL4cV1t0L9XdpPnXl10Nu2hmU3I9mt1+a2NKBhwiddmcNzNy7q8fV0VRTgWzSTCtRMCNZmhaUde7BLelAXZ/yCBXyIsWoxhdwOX4jLsAnEDRCkhwbYTqf24pZshurt8n/mGNhBWyN0/IvoCgNp5SgZqBFpU1RUCbKYGNOl2y4SvMTcN9A6wpOM3lQCD3n/xG2/Hzbfd8aAlyl72zRdFtnzfB6HG4NGWGDNhcGvG/EFxadpvLpxx4zvxCD34fLn2LrtsGc8ZWQMiAgIkU7e/r8N1Xb1bvWoz5ASkRwy211qNOLD1rto6+937wlI6VlUsiBEV6eumBQEINov0B9rie17Q1pubWHblj5NfCCIrjD/p1i3SYjnBYw4RE+iqAoRygYkaNlAMc9LYLyLYiv+zc23qhLWbLXKiQBsvqE4Y/OvffNfs/s+adR/Wz//8z+Pxj388jj32WJx88skJlEcqUfX/2b3yzjvv7PdJ3al6ZLAPcARrTaB9JAC4kTCSBUwAbDYb7O3tYVkW/zd7Df7ut7r22mvxmte8Bj/8wz88L/qsWbNmTQLgrutRp56A73/2+Tj++OMzCUAAkhUB7H4thD+UQQj9LAMj/jd+qHfmnL9Q2YVb8+x1rQSgkdTo3iXlyx3z/vEz2mXsPMdr4Mk+c1MCxBc4z1+DyAwzK7PPstjscALo4h+gFAqW7zJtFZNft89S+nyEgcfWfS5D7GIg8BgxQFIEDM2LrfEOJyaGZIfaO64BirLLuxDx8MFPX4tf/cOPPKj3yQ9e/hQ86rTDQVQBKerS1ilnwYvEnP3WHaivw4LiJpBGLqy1OtBv5EJ1soYjJdvfVVK+tE6+vX6hZI6qQRit65pMCO880pMHfEsJ9mn0xdIwKiuDKPVCASzktC99XRaayy8lRlqWZXEyzPYDE4EdZjv4t3tJGTr7LW6xx3R23w32BkAH9UW27xNxjQy8F1SYQib2jUn7mQTQ9qbt/KrmaEaKxHzHxz+HV7/rz+eXzKxZ9zEBcOGFF+Lkk09OzyBfLQEwvpb997quCbR/JQSA/fuoADhw4MBXTACUUvArv/IrePnLXz4v+oOk7Dofd9xxvib29vawt7eHzWaDZVl8nYyk1Lg+rSqPtQLNPHogxHb9HgDcfPPNuPnmm3HrrbceVckya9YkAB5A9e2XnIunn3fW1iyzPTT73C+Z0BWJziXHd9nDr8vik1N5jsizB/4tVr39q8d2FcE2eQDu7iE5/jOYqrU5dW+WBdDaFQKVogE7QKut4ykWkdbHCNa1yaRdFk3y5AwOes55Edj9tPpYQOmASrr0uX2Z76+rqxYMaFXNkX4W2VZKi1oDortfZBuAmE7bpcrumZBXvT1Q8DGMkWt2DOELwMqLnk4Awave/md4zyevflDvkcsveBSe+6SzUaG+Jgu5xQuZU4qB6a7SsC9cI7YskYHnzPla1j4GsBR4zJ1F5lVTqmzdxdSz6Nn0zjaKxXPa2i/SjQP73r1jVdxZKxYpTbVg7+cPC9xBz6MJBt4XQtVLX08bIgGWBQ7UzR/DOv6lz+0nQ8JOgJThvmF+FLXfa4L4Yu+EIDyi67/7G2CM0AxPgDAnrDtGAzQRPuL3DPudf/87/z97bx5s11Fej67ufc6dJ83WbGu2LMlgY4MsYxtw/PvhF/MCJlWBhBAGk1QowqMgAZI4uEKAV4UZUiR5MZTB2EDMYDux7JhK+IEDeB6x5EmWLQvNV7qT7nzv2d3vj+6v++s++5x77iDpytpdBb6694y7e+/da33rW+txHOwZzG8w+cjHKRw/+MEPcMkll4TnLULJfRYBMDo6Gvx7IgKAfscJAP53bzKqnPppIgKgvr7eAbRqBAD9e/v27bjuuuvyST9NRmtrK5qamtDY2OjmP0kS93N9fX3F58atKbUSANX+XY0AiP89NDSEgYEB9PX1YWhoKCcE8pETAKfjWHtWB957yTo0NTdCsQqiYM79hHASAiEsM54q5jwSjUBlam+gtKl2hXtX7cyQUVNmOUmnEUXPwUfnBWCHA96omg/YrHQdKg2UKvlsc2HMCen1Uu1jwKiimDrJsqnIi2A1mc+TOCkyUEgMkDLu5dJdSFOlUShIL8vXGmlJISlIX20nQoYAvYv289Vb7s0gmCpAWKNEZwpISoJImREnMgQ3EEYyuCQC934eBP6/dz2Cvteo/J/Givmt+MjvnO8uIIFbPbWpmNZ3A/5Z2wt5SggRNL9AqdQRL1S59oZ+XFKqWVyed7zn8ZWpDbgnXwhOwjnTPecF4FtflALGUiAVRo1ABo8imvfgsql9xKTnPXxLiYQGaWUEgATGqM8kAtgNDpe7mgPljxHzK+Dkk7axg/RxeCwi36DouM0IAG9S4jF9ks0J9wkwCgT/HDovYpJM2eNLn4MIlSdfOYQfPfhifnOpcbS0tGDt2rXo6OjA8uXLUSwWsXnzZsydOxfNzc1obGz0c2D/l6YpSqVSUNFSSmF0dNSpXAgYFYtFlxLDN7JZPd6lUinYYEspmVmlDkAXVeFiGffQ0BAOHjyI3t5edHZ24ujRozh8+DD27duHAwcO5BN+Esf27duxefPmTPDEQTmtBVpPIyMjmQSAUqoiwNJao1Qqud79GOBnEQD0c5IkQUuAlBKNjY3BusoiAPjPOQEwO0dDQwOamprQ1NSEuro6NDY2oqGhIRPMV/p5thEA8WMHBgbQ39/vFALcKyMf+cgJgFk6ionEn/+v12HxvFa3CfZxW2G1GWxjLSOpLN8ECytdzjLk4hXPeFZsWp6TLZMfAMmuufKA525zA0ADqBWoKgrmqE5AVykFaAWlNUol5UzMlIKLQSRQR88lbkQLoOCIAd9wUGB/I/JESvN+SeK0xiYNwcmajfEYNwSUQvL0RGOYCDhHd6W9W3kZ8GFGgvQi3nXdA3+foQ7XekCxgPS44LV51YMRRDt+exT/9uvnz4jz5Lort+DsBW1RD743BKRNGie8TDyfV8Xw1glqg0lT4+wfHGcyBUyVWwjKZs6XLLjxfhjeTd/cdLnxoInqU6R0oWQL1ic/VgLGrWxB874a+wP5WChNnytE10RQcW8QFfXlS6WRCKCuKI1sUcqg1598AMy1hNasJwu9EoAZhLJ+/sSSCLx/P+zj968Lnk6iPfno13u8cfJz5whA+3qJLH8/APj/fvokftvVn99cahivf/3r8U//9E8QQmDx4sVlG2MOwDggK5VKGBsbC+4zaZpCKYVSqeSAOwf7MQH2+RyCAAAgAElEQVRAEu+sjW8MEgmoceBFUlwCZ/Hr88+utUZvby9uuOEGbN++PZ/4U0gA0HxwIE7An8ijsbExlEqlYA758K1ZOgD7pVIpUADwdRWrAjhYo+fQ6wkh0NTUFKxBIgkqKQFyAuDUjiRJ0NbWhpaWFhSLRafg4ATmZED/6UQAxJ+rt7cXvb29OH78OEZHR/PFkY+cAJitY+1ZHXjvtvVoamo0/cckg9W++k/sNyDKLjBkBkhyXwIuVC2FyxjPJhQ8KFJRKoCP+CPTPR/jF0YNkoFeynr+vaEf9edRb7JJFzA3fgtYlAH5JSd/t/3FVE2FK1R66THTQjundPt5pCUsqAeaR4QlhYRVEL0ZGkhOTR4AVPEVoux9Uhb/5hUYohyUsOMrhXQVZZfEAGscqLSPHXSSaFYVjWTrQgB3PPQinniNuv/H423nLcNbt5zjwGCWesKDA8HM5jxJpllUJrWocBmqYNGXmkCpFN4TAIBSaWBoqVIdpE5omyAgdBhTSKoZwRIuSAEwprk6xptK2vb/KPIALuaQHP6hfb8+RQdyQE6fo0ECdcWEyV29aYLM2FAkiXRtAS7FMkokoeuPbwHw650TNYK1WQTXDarEWYKNXoViMXnsIJEVJde+hLJ41B17j+IHZwgpNlMEwD//8z9jyZIlqKurywTQ1QiANE0Df4uTRQAIIVBXV1cTAcDvlZ/85Cdx11135RN/CgmAeL5pXdFaouplqVRya4QTTVnFjaw1xtdQ1uP57zmxJIRwBoAELDmJQK/B16QQIicATuIoFApob29HW1sb6uvrUVdX58jLLHPIM40AoLWcpin6+vrw6quv5m0C+cgJgNk4SAVw1pzWcKPM+vrDrHoVVP04uE2tLFkKYSL84ouH8H3PQmimIvDgXykCxsoaefkoO9uyD0CjkAhXvSNVurL9zrzi6ozW2AaSnjde0hYIWzk2ACl8bJ9TBHDjQ4TfJwYVwlYe64Ww7QI2ArBgN4okG7ceA+zyDfKIT4SwiQLWcIwTIqTMIMAO5iLMItvADBvZTLrWgdRWT0WWp4HwahBHPMC3hqRK4wt3PIThsdIZcY6smNeK62wbAL+QiAiEQnsJOfWF8wfzeD7u5SgojYKIA3LVD+IXNVSqkCQJUpVaJYxdn9YBUMOb7gFehaCDFhszf1IA4yVgxEUDWoJKiiCdQLM2oLiZ3pMOYNV6k4KR8u8qgMbExE3S+pMyQYzYjerHt/KYpAxPpLlwBLeJ9q1CSgunUEitYkLwBACr2gGPCHRqCkZ8aAv4SDHkrneaqZjKPUkA4KvbH8+d/ydJANx1112BkRXfPFcjAKhPOyYAxsfHnUEWgbKpEABaaxfxFvdtEwFQLBYD4FapxYB+/9nPfhY//OEP84k/SePee+/NVADQnPC1xVuflFJufcRzyR/LW1DI80Up5UA7r9jzx8Xgnf5dLBbdv2MzwZgA4IArJwBOEoAQAm1tbVizZo079/n14lQTANU+91TA/XQJABq9vb04ePAg+vtzZVw+cgJg1o3Vi9rxvjdvQENDo9v4UitAfKMxUFUzU8Aw41zyvHSXJS5sWwEHu8gw2OERczqK4DO9ymQ5SPF9vK/f3cSZ3J+i/wj8KFv9Hx/XrlqZci8BWJLB9f2GS4ZqviTdB88I5/p9W0Wsl0AhkcHNPrWKhVh2LSRcr7ORRtuNpTOP81VTno7gXftFoLBw7sOWCDAqAOWM2Agcufg4e9yljVlz3xGshUJr7PztMdz+wAtn1Dnyp1duwcqF7WWgL+uG6SIdYZQl4O0yMqwoQ2uUSL4fVZzp9d061mCGnW5ZmxQAy8glzgfD+xLQ5+Emg9ACYyWN8YDoYWsnitWjmEwXl2djCbQFzKZdwHwGHW0IClKgMRGQiXCqE+cjYo9mwqS03H9AUJ+9UoAlFwxRkTgzT/K9oBRSc8y8Ckdr31pB80BGhI6A5JIZ+xkVN+m0kZ1lcQJ2fp/ddyyv/k9yvPGNb8ysiHMwlgXCSqWS69OOCYCxsTHXn09/J2l3JQIgC1gppZx/AL0WP9/r6+sDAiDe9NLn5e+ZEwCnngAQ0f2RA7fYZ4KvDyIF+HUtrrjSWuFkEa/Y8/fn65GbwHEzOP63iYBgTgCc2NHc3IzVq1ejubm5DICfCAJgOoB/poD/ZF+3EgEAAP39/c4bJR/5yAmAWTQKicSfX3U+zprb6oB9IsMeezqEHBS6PbDVFjvpsd00U3xeUFmBzzZ34JW1F7joPtebbDf1thJKREJJpW6T7iLslHIVe80qm54EMD+Pj6UYJzWBBSwGlNv3AYIIQ6q0O4AG7+wOYaqmBD4AYdzUzTdCSx05/ytHBJAanNotSLlg4tX8RsEcVyuntiplwVzT6TOSk7qGFzJTRCFPXCBjujjtwbcIKO8TEDudM+O7nzyyC0+eIfJ/GlduWoorNp9jjP9QLv/na0zblAR6nHagQDuXe4oJFIzMgmSGepakIeApbMa88xlgkYTU/y+lBIQ36lQsXYBaDOhzKa0xXjItADqSstOJE3sehL352p3bpKih1Am3vu1mtygEGosGzNNmWGmFRCaeNBSG/CIDPmdiyFUGFDNIsX8UJ0ibcEts8AhB51fgyEUdxJHyTYxgsn+aOzrPpHA5A4GRIl0Kv35PXv2f7Ni6dSvuuOOOin/nQIqDrzRNHQEQbzzHx8dRKBQcAOfV+0r/5ht3LvGmqm6SJIG5ILl0c5k2f20uJecjJwBODQGQBVhobsP2IB2oADjpw30CYqBH4J+TS1nGfVngnwN//nOWqiQowkT+BHfffXdOAJyAUVdXhwULFmDFihUVAfl0CIDpAPyZIAKqgf/ypKnqr5+VssHH4OAgjhw5gq6urrJIwnzkIycATuF4w6qF+N/nr0BDQ6OREcNE2LlceXiHczqargrNTMLJ1IsDB8WzzxiYIIMzc8MTrm/fXHi028xzU0ICG2HUoLP78qgWcD2+rnc+TZGmKcZTgXH3SWxftssTNKqFwOaf93THPfn27+RankKb3mxppPxNRSPN1kpBJjIycfPqAaNO0JAJxQUycziq+ArpIxClaQ/gZINm8WyUxJAwJlaz40avHVRBEBk18j5nR35ofOGOh88Y+T+NFfNa8eErt0CGzJe/UQYXF81c/n1bCr+xkmcFrMxcghE09nzwfQOatcB4Eowq+gLKJkTYFoBYHaKUibN0rR4GKI+XNEa0xsGeQfQMjOLlI70YKymkSmFw1PfstTXWYW5LA5bMaUZTXRFN9QXMa20w5njKmkja+AsteMa2+QxFARQToFBIUJDS+F1oZYkr5pStNVLtWxikjb80jxUuIcPF9QkE/fvub3RmBWaAAppIGptq4SP8tGuh8SkK8Aooqx6gv/HzEgB2vtqJH5xhipiTQQBkbbAJgKVpirGxMQe+YrIgUIRF4J/6vXklmAAfd/3nbQS8okUVWmo1iEmkrM8NAJ/5zGdyAuAkjnvuuQfnn39+mYw+XhvxOuF9/3F7QJYxIK23LDDHwX+8lgjw0+Pob1mKkjiGMH6/u+++Gx/+8IfzSZ+hkSQJ5s+fj7PPPtsRfBMB+DjecbJAf6aJgOnI/afyWSYiAIig7e/vz30B8pETALNtvOuNa3HRmiVB1ByBaGqUDdlEBOZmYGZ9UoRGZE7yDE8WZJmokbu5628GGdJpV4FjJUFwN/asCzLlqRuZtHH+H1dACt/HKyBM77+NC0zZ9/MvLgJHcsVM3gI5NnuuIwC4RwCTFBIB4Jzf7QsY2bOPCtTOWM1/KOpblkIiTZV9bXpvySTPIpgDno/GWzrcZxQizLeHb/UAgMdfPoQ7H3npjDw//uSyc7F68dyyDVlw86O+dG4PL4DEzomOEyrsASYVDJEFUghLpNlWF+3JAlo3tLbJA4C3APCiuauUKo0jfcPoGhhB5/ER7O8exP7ugYCcqHW0N9Vh+bxWLJnTgqa6ApoailjQ0mBJKL/mpBAoaqBYBIrWNI1vNgR4KxHYZtkcqwIBLN6Mw4wuBbsO0PomEkAxxT55iWjt25Wcf4Pt/+Geh8ZzQDsyzEUiMt8TOk++dvdjOJpX/6dEANx5550Tblx5tYj7AJDpXxaQiwF4LMnm1V0iBGIDLe7QTi0B9HjyLSAigJMOXLHAx2c+8xncfvvt+cSfpHHnnXfiTW96U9m6yqrcZwHsWGESEwD8+k+Ppf9yhQH9O4764/L+iQiAaqAzJwBmFjS3tbVh7dq1gTdJrQRArSD5ZH+nqf5usp+7kgFhTJj19/dj//79GBwczBddPnICYDaMi1YvxDUXrEZSKAQbcSHK+/SdxBY8W94DewKpvFrprwnZjt0UNear/PARgE5loPx7klkYcyZ3cmSWLOCivNIU4yWFkgKUBdyOqFDWZ4CAuDVzM5J5cNQcuvpS7B95CVgALwQgNdBcT4Z6ptVCupaDFBK+195U5anXGZCyAK1SZ0hGPcvGeF24+LmC9RTwF13v7s8r1GCSaDoJTEeCl0PzFodEkplbSNLc/H+ewctHzsw+rks3LMEVG5aioaE+ILfIWFII05seAxJH4sCbUtJcO0KJO01rjWKSAMJEBRIp5s81/54k16f1AOGJnEO9gxgZT9HdP4JXj/Wjs28IR/tHTtjxaW+qx8K2Rpy9sA3rF891pFRRazTUSYjEmABy/wTF1hx9bkM8KpSUiTIk8ozOHW/26a9LkslxzMbZNKxQ4p/nY3Sm+ZtXwfghmbdHybVRWBNAS9ztOAP9MGaSAKjkARBvKmPjNQ7+qXofV235hpT35HOQxqPX+HvFII6btVHWewzu/D1TZW6cP/3pT+cEwMkkbP/kT/ClL32pbE1VSnvggJ+vGz6vpBLhay2LbIrXTkw+FNgei/+PmwRWIgCyAOitt96KT37yk/mkT2M0NTVh2bJl6OjoKItznGkJ/8kiAk4F+K91HD9+HIcOHcp9AfKREwCzZVz7xjV4w5olDoDTUFEMEoFepTVPDGQxcghDsgUDkjbKjvfpOqm0kzUzQMP6kUkO7GL+bN+/r1rrAGxxwy6dKqSpwlgJKEE7p3LA+xLYzoPwD6zKqIN4PrhkgsQajpWoii+AohBoKAp3WBIpba+zDqrrDsAI7/4uk8TFwWlNBmgicPSn71goJB68kDRasox2xrb4eWEtHUz6THFuHAwRMXCoZxD/9NOnzthzY/m8FvzeRWvQ0Vg01QGKxWPxk2BKF5Kqk+Gj7z9Xtr1FBUoZzXLvXa88Azc+JYDeV+No/wjG0xKOHh/B8eFx9A+PoXtwFEf6hk5pm0ZLQxHnLGzH6kUdWDu/BcU6iUKShP55QphISrZKnQKFKvy0CdaULKB9OwyLENTMnJGIBdMixE7lgHq0UYCpKt/8CMGuRz6mk0c70it9dftjee//FMeb3vQm/Md//EfFv8fxe7EDe3huZMu36X5FFfpYwh3LrMN7nAdtWT3ZWY7uHCzG7/VXf/VXOQFwEkddXR1efPFFl8WeRfJwAjBrfVT7d7zmOGmUFfmnlAqAf2z0x6v/8ecjRUml/vJt27bhxRdfzCd9iuukvb0dc+bMceA/noNaHfqnMk4GGVAJ4E/G/K/W7zCZ7zMwMOBIgNwXIB85AXCKxxtWL8T//YY1EDKBtJLiUqoCSbEs608PJb+plc46YzTWWx6A+2BrjkA67VzP4RUA2oJhnzFOkX7csM/8nGoPXynVQCkFaIWxcY3UOpBTFbUgvFJAad7ja974WP8IeodGMTxWwsi4Ql1BorGu4BZWS30RDXUFzG9rslF9GgUh0FhghIEQDnQrK9tOrPme8QHwcWhCSBPjJmDjBGlj4EGmi0F0Pc3enJAAkIlHizaogQmg7+2nY0xVV8WM3yQEHnv5MO569KUz+vx418WrsXRuKzoaiyjWFZ0Zn8wwkuN+DUr7FhatPLikCSRlgK9k++pzZ98AxsYVeoZGMTAyhkM9gxhLFTr7hk8L8LlkTgtWLWzDZevPQlJIguuIckkB0rXkuPhPaAgL4p0C326kjTKm/BJCKhjf3lJ+faLjLqQnHZzLP+CSB4hwJCLBtWbYKMydvz2aV/+nc695wxtwzz33VAXe8SaTgy8CReTQLoRAqVQKNqFZCgAO0rOAfNzvH/e2xooATtZxABhviP/yL/8S//Zv/5ZP/EkcX/rSl/CBD3ygDPxnxfBljdgDgA/e5pFlSBmTRbSe4jXGCYB4ncVKhCyQdffdd+MDH/hAPtlTGHPnzkVHRwcKhUIA/mshALLA84kC8zPxutXA/mRVAfH5EX/OyZIAw8PD2Lt3b2brVD7ykRMAJ2lQIsCiOa1lB48AKIHkCKcEB1lRjKA19iKHe2cayPrnnQG69s7bDjgp7erYlHnOzdZ06h9LzuecmCAigSqv4+MlpKlAScNU69l3EBboK61wrH8E/SNjONA9iIM9Ay4qrRawc1ZHExa2NWFOcx1WL2xxPcYyMcZ9qVbGPI3bGAgfMWhAvnTkA/U0u3YDKZCmmrVcmE1EIZGukiwYwAFMJnwiRZnrtWvZYNVnajfgLugAcPPPd+CVI2e2XOui1YvwxjVnmV7B+iRQAgCATKRTcZDagjZ4qUrZjdKQWVJIHOkdhILG0eMjGB4bx6GeIfSPjGFwdByHewdrXnuzfbQ0FHH2gjacu7gD5y6f6wwwhV1vyp8BRJVAgBlnup5/HaYksHOIdUF4g012yQlalbhhk03TIOKSvEGMh4J/XSIppBB59X+a4/Wvfz3uu+++zCp8vPmMI9u45H98fDxQBmTFtWVt4vm1kIB+LNnmnyUGaPznSn3jOQFwaseaNWtw//33B7ntldbYRIRTFhlQyR+AwD43luQEQEwmxWoBfm3KipTk7/Pnf/7nubJkCqO+vh5Lly7NBP98PVQCs1nrZaaB/WRfc6Ie/MmQAJNVB1S6zk6GBDh8+DCGhobyxZmPnAA4VWPb+sX4X+ef7eRqVAEmGTMZ1AkhUFLK9+eyPlqObRPb00sbZ74h9xV+7TblLvrPVfbBep0ZcNXKxafxiC5on2Xv+uMdEC6hNAaMA1ACONY/jM6+IRzpHULn8WEc7p1ZU5Jlc1uwbG4zFnc0ob25HivmtYabBosGnULAOqkXZMLcybWNSBNlCgAyAjQRcEwVwAzUgp50hDFtwU1DeoUAN5LTAH577Di+9bNnzvhzY8X8VrzjwlXuuLQ3FFBXX+euLGYTYar8wvozSCnQ2TuEkkpxpG8YvYMjOD48hq7+EfQMGGXJmTaWzGnBkjlNWL2wDRuXzXMSe1i3fWfY50gCWq8mKcGQXeFmJQb0nGxJrC+Ahn9dT7YJS1jCRnbGBoEo8xLYufco/i2v/k97fPe738XVV1894aY1dm6n6xbltXPZP/2OwFO8OXW+EayCT7393Kk9fhwHcPS5YrM3Glk+AOeeey76+vryST/J4zvf+Q5+93d/tyK44aqiLDInq88/a47jBIqYbMjq8c8ik/haz5JFx6Bq4cKFuaP6FMa8efMwb948zJkzpyy3Pl4jWW0+tQD1yf5+pomEyVb2Z4oEqEQIVHpPrbUjAQ4cOIDR0dF8geYjJwBOxWhrrMMH3nIeFra3ePfr8Cx3Mn1RwdDPGWbZPluwHHopidkGpNSu1x0sVtDI18MEAtNawAzPoANzLzIC9E7fvpZIaoA0TTE+pvHMgR4889tjONR7cl1IO5rq0dZUh/ktDVg+rwWtDUXUFyUWdzRDCJKRCkiZOPM3J4mW7OajjUGhZJFxSSKJJzHfmfLSoxuYJ2ji/HdvqMaTAIQQePjF/dj+5J785ACw9qyO4KpSdMoKUXYODI6Oo3tgBL2D+Q2t0mhtrMPGJXOwfEEbNi+fFxBTSgtrrmjJKwXfGgC6xjCZP5GHdi2nym60iRbQUawfQu8AHntZZvZkiVAA+Pq9T+TO/zMwrr32Wvzrv/5rJiiLgTYHYRzgx/32RAxwwoAeI6V0rv8xcZRVkY3/GwOFSo7y8cb3nnvuyV3aT9F497vfjZtuumlCYJNFClWq+sc/07qKici4zz8G+5V+rgae+O++8IUv4Mtf/nI+yZMFA0Jg7dq1FcF/FgFQqT2pUsV7JkmB6Tx+MmqAqRIA8TWvFjVATK4CRglw7NgxHDlyJF+k+cgJgFM1tq1fjN/ZvBJ1dXWuss4jtUpuE+Ud6nl0n5PLWmYdzvvcbsy1AfPcwY+eL10eutn4kwSXev61j/2GcGSESRBwN2XX++8VAK909uE3r3bhuYPds05WXVeQWNTehLbGOiyb24L5bY1oayhiQWsjHUyzEY4y1n1CgIRMBAMycBVo10pgfQ8ky6gnaTUnFqhfnfLoR0ZG8e37n8P+7oH8xMjHCR1SCKxf3IFzFnXg4tULnRszKYRcW5D0kZbOIyDYjATyALeuCcpL+zvfaACf++lUSCzpxMWFCjzz207c/kBuuDUTo1gs4uWXX0Zzc3PVjWe8SedV2SxHdu4PEKdyxJv6OKKtEtDnFX+Sd9Nj475//voAcN111+Huu+/OJ/wUje9973tOaVIrWKqU6c7XEycI+ONik78sEqlMtVRF5l/pdxdeeCF2796dT/AkR0tLC84777yK4D8+73nLUKU1UQn41gLYJwP+p6IQmCoJMFkCID4XKhEB8Vrnr9Hf34/nnnvulEQm5iMnAPIBowL4kyvOw8KOFhfl5yvp2sZ1CWd4B+0d7RO7oUpJVgeeNa/d8yQHnEKUmQqSMb5Kw8g/DV/FU6mCTUE308u8BGi2n3ylE4/vOXrSq/0zBYiWzW1BW1MdFrY1oaEuwfzWRjTVFVCQAvMsQeD6DF1vs+lHd4oA2uDaqqdgKQR0dhRkglSpgPAZHx/Hjv3duOvRfJORj5O/9pfMaca6xR1YtbADKxe2wcUn2pYXgbCnn+N45wFiEwM0IwA4oUmPjTcqjmSw5wddl/7xP5/Me/9ncFx//fX4xCc+kbkZzKqmxhvtOAUg3nTGLQGVMtqzTNg8gY0yo7asin+WWdxvfvMbXHXVVflEn8LxsY99DDfccMOEgIb8IGIww9cO/RxX62MglPXfWGGQRThwQiurvYSTGh/96EfzyZ3CWL9+PebNm1dxDWRV+mP/pBjQViMAplv1P5EmgNWq/lMhALKu0VmmrNXe57nnnsPx48fzhZqPnAA4VePSDUvwO5tXolgshFV3QU72wQ4aaaohWYaclEbm7x7CcugFd+pmzebKxm85l3tnOqidg74jIwRMz7zD+oYUONA9gIPdA3jlSB9ePNz7mjFRyxpzWxrQ2liHloYiVs5vw9yWBjQUEyyf32rz5wEJINUKWptUB26OxqudgGkrEBAQEhgfG0f34Cge2X0Yj72cS7LycWpHS30R65fMwapFHZjX2ohl81pZ5GcI/AHe8029vUZVpJT2xqNuo+99SISE8yqJqz2PvHQI9zz5Sj4ZMzhWrVqFhx56yBhqViEBKhEA8c+0uazkBRBvpqv1YVd7TFbVN4sIuOGGG/Av//Iv+USf4jX28MMPl62xLHAVz3WlamXWvMfPrwSwJqoGZ63TeFx99dX49a9/nU/uFIDwm970pgkfU+0aMBHAnWorwEwA/az1OhkSYKYIgFqu1ZWe09nZiVdeye+z+cgJgFM22hrr8OG3bMKctibIKLVPQbtmZzLc46ZxAtyFW9sYLVjDQASqgURISBs3CCDI3xYCNhpMO/BPPerUBw8ALx7qxtG+YTx/oAv7uwfP+LmTQqCjuR5L57agvphgYVsTzupoQmN9EWd1NLuEQx+t5mdPSoHR0TH0DI1Ca+AHD7yI7oGR/ITIx+wiBBqK2LB0Ls5Z2IG5LQ1YNrfFb9TsYxRM0oKLx4wl4OQ7kuFlIoJzA+jqH8Ztv3oOXf35uTDT4xvf+Abe9773Vd1UZm1sY3M/btwWAyneFlAN7FdLJSD1QAwOq23mV61alVezZsG48cYb8aEPfagq6OKO/VlmkdXATlzZzyII4t9XA4fVctF/9atflRkb5qO20dHRgfPOO68qgM5aB9WuPbUQASca/GcRWRMB9olIgOkQAFlkSTUilo/BwUHs2LEjX6z5yAmAUzku3bAEV25eaVy0mbW/dhF1Fvwrb8ZnIpVUsK2mipvZQJGI3/SjU8wdN6BLU+VaAKgSZ1z/DSFwuHcQh3oHsafzOF7t7EPf8Fg+WTWOukKCBW2NVW8kJaaa6OzLY1nyMftHa2MdXnf2Qixqb8KCtkYsm9vqnUfs9UNpQAhd5hugI/ZSRIaOx/qH8NKhHvznU6/mB/oEjGuvvRY333xzTSZUWYAqqy83dnGPiQH+elmVPt4WwJ8fKxGqOYJ/+9vfxqc+9al8gmfB2Lp1K+69996agAz/N+1p4paPrDVQCTBlkQNxFGU8qsmkP/7xj+OWW27JJ3UKY+PGjZgzZ05NoLaS6meqBMBMGQDW+rypkgCTVQHU+ry4Vava53/22WfR39+fL9h85ATAqRptjXX44FvOw/y2ZtNPCwSyf20b8KW7APgqPWCUArTZTqRwkVvOiMt6CiREJAQOvL5RVwjgxYPd6B0cxc59XdjTmccp5SMf+ag85rU04Lzl87B4TgsWtDfhrPYm50PiriuB678nA4SE8zvpHhiGUgo/eODFvPp/Asctt9yCd77znVUBdWzYV6k6l7Uxj1UC1Tbj3J06C6Tx165mJHbxxRdj165d+eTOknHvvfdi69atVQEMkTy1RKvFa4WDxhjA88fwv1UzA6z0Gc4++2z09vbmEzrJUSwWcdFFF9UEZvl5PdE1oBYCYKaq/ifSBHCqKoCJCABOnsQqgEo+F/v27cOBAwfyRZuPnAA4leOqLSuwYek8zG9rdLJ9yZy5jSGfBD+HTSU/TAUwvxNWhsuduI3s3/XgWgmvAfwj2LmvC4d6BzA0WsonIx/5yMeUxsr5rdi8YgGWzm3B8vmtLEXA+96KT2IAACAASURBVAhwMjNVGj0Dw0iVwstH+vLq/wkeH/zgB/G1r31twg3nRD3W1TbOcQW22mY2q8efkwh88xp/JsDItK+55pp8YmfR+MQnPoHrr7++ZkBTSWXCEyGyQFClHuesv03kMRCP7373u/j4xz+eT+YUxqJFi7BmzZqa5j/rvJ5JAmCm1QAzTQJM5hpbCwEQH5csNRYf/f39ePbZZ/NFm4+cADiVY35rI95zyTpIKTGvtdEz3JplaEsBrTQUNArWfC68qPkWAMf8OUNBI/t/6WCPqfDvP4ZDPYMYGh3PD34+8pGPGR8NxcR4YVTZ2IyXUncd6xsaxcBIfj060ZvzZ555Bo2NjZkb4qze3KyNaBZYywJjWZGAtRAG9G/yFKi0Ef6zP/sz3H777fnEzqLR2NiIffv2VQUxUkqkLua4fB1mOfkTERRXiispAKoZtU0EArdu3YoXXnghn8wpjE2bNqG9vb2mx8YxjjNFAJxI4F/NWG8iIF8NxM8UAcCPE1cAVBpPP/00RkZy1V0+cgLglI6rtqzA+sVzIBOJ+a1NTp6fSBfAZ+L6qIJGMd3C9PmntrqfSOl6cA90D+C5/V3Ye/Q4OvuGMJgD/nzkIx/5OGPHP/zDP+BjH/tY1U3xRMC/ljz1rM1ypVi2ePPOIwIr9YXv3LkTl112WT6hs3DcfvvtuPLKKycESJVAepz2AMD6HunMx2QBy1rk4FnvvWPHjnxdTYP8ueCCCyYGClHlfyKTz5kgAGbaAHAiwD9ZE8DpEgBZn7cWL4C9e/fi0KFD+eLNR04AnMoxv7UR79m2ztzAhHT583TeupYAAIkQULAxW9ZQK1XWuK9nEM/v78Lh3kH0Do3mBzYf+chHPvIBALj00kuxffv2mjaaE1VR4wptvJnn/duVIt34hpUk3xP1ZwPATTfdhM9+9rP5hM7C8dOf/hRveMMbagbgceWfkwNxQsBE6yIrBYArWypFS9J44YUXcMkll+STOIWxcuVKLFu2bNIEwESge7oEwGQJgVquP9MlASYL6KfSNsAVAJW+S29vb652yUdOAMyG8fbXrcSaRR0AgCSRmNfaZNoAbLxfqhSkvXBKIXCod8BW+btxJAf8+cjHtEYhMVLERAi0NNYBWqO1sQ6J9JuV+kKCloY6AEaN09ZYDxuaiaaGIgpCOoM77aM72KbCuuOLeLPhNxxDYyWMp8pH6Gnv9GFagVgCiBA2AlRjeGwcg6MlDI2WoLRG39Ao+ofHMDKe5pObDzduvfVWvOMd76hpAzyR1Drrd3EVPwZmWRtxLu2eiHgATPRfT09PPpmzcNx3332ZBACf8yyjv/jvfB3xtVjpsbUQWhM9Z/fu3RNm2Ocj+zhv27ZtUo+fCQKg0uOmAvyn+/1r+f1U2wCmQwBM1Abw2GOPZbZb5SMfOQFwEkd9IUF9MQl+l1RxQO4ZzHt38pGPiYYUAnNa6rGgrQlzmuvR1liHtsZ6tDUW0dZU74DKnOYGuzGBBdXKJ3Myt02KsANM7r1mbvd0CTQAnVzwAC20+7OGhhASifDtPUIApVS5hA8hjJmnZJtfigpNU1W2iTKbaOFIA04oHD1uYiZTrVEqKZQ0MDw6jrGSwvB4Cf3DYxgaM8RBSSn0DY3mbvyv4fHBD34QX/nKVzI3xnEcV7X+/omy2GPQVQnQZYGzapvo7du34/3vf38+kbN03H///Tj33HMz57BSAkA1MMPNACslWHClSfz61YiqLEC4dOlSjI/n7ZKTGe3t7di8efMJJwBiImAyBMCJAv8TreOJSIBaQP1UWgBiEqDS99+zZw+OHDmSL+J85ARAPk7coAorYKqszQ3FYPFMe9UFwePxiwqH5FKtMTAyjlKq8kl5LQH81kZ0NDegvakeHU11aG2qQ30hwaL2JmuIKSCFRqq0A/FKhRtGAuMeQGtIl6zBNpr2canyj6G1SKkdqVKQEi6JQwgYI0/n1QFn1Gk2xx7wwyZ10PsWpHQ/m89pvoOP8Yxki2T+SUQGfQC3cdDQSkNICa2VfS33BdB5fBgQQO/gKLoGRtA9MIK+oTH0DI7g6PHhfNGdxqOtrQ179+6tunmsBPyrbTbjtoFKMW18A1sJCFYCfADwqU99Ct/5znfyiZyl45e//CXWrVs3qedkqQCyWgL4mskiEuK2E95GkEU4ZY0tW7bg8OHD+UROYmzcuBFz586dEQKgEnCfKgEwk8C/lmtirSB+MiqAyUQGZn3mam0AXV1deOmll/JFnI+cAMhHBrhqrsf8tka0NdZBAOhobnCgpbGYoK5oDHrqCgU02J+1BuqLCQq2aqk0sLCt0YIbA4ToRaTQrtWhfOPpb/qSDBGVNlJojUBmShsIA6wUqPrKL55SmFYKpRSODYxAaY3RksLQyDiGRsfRMziKgVHzc/fACI4Pj0EpjfGcLDila7CjuR4L2hoxt7kBrY11aG+qQ3tTvQP4FIjpgDAI5BvwLuzflNZIU+38M7Rtr6E1RWDdXNC0u6hxBUB4H9WWWjL/T6SSWav++YmLviM3a+Fehz6X1uYzK23aC4Sg9Ru2CJAKQWvzmQVjuug4SPe9hVUyCHdugNoT6LcBiSbA8vtc+gjxaUIKdPYNYayk0DUwjMGRcRzuG8Lx4TEc7B7EaCmXEs72sXr1ajz66KM1bdKz5NJZ7uyVKrMxqK+kGuCvGycDxK/91a9+FV/60pfyiZyFo7W1tWJPcVbkWzXDyRjIZ/2+GplUiViYiNy69NJLc0A0mY3/DMn/JzITnUkCYLL9/SfTBLAW74DJEhbV2gCGh4fxm9/8Jl/I+cgJgDMN2Lc21qG5voi2Ji+Lbm0ooq6QANA4q6MlABVU/SSpcilNnWSZqo5KcfadgDqcXNrdmIWvwgLa5YPT47UFJAJ2oyk9IKIkBH5Nk9K8t7DZ45pDIwv+la3qQhufBfd53O9os+pNqSCAI71DGB4dx8h4ilQpDI6m6OwzvgtKmxiz7oERWxHOx3TG/NZGLJ7ThLVnzUFTfRHrFncENzS6qSmYBAwTc6kdYKbCuBACChp2Cu0a0A7ke38NquprK6Gnta5cnKbkYIivLKFdX7+GvwIK+/wAxAMejBOqF/784ECbCC23lnV0Uxf8whsqAdhLu7UckALcXNSeMwbsS/+3yKyAPocNJ4lk28q0NEiJw31DGBwZw7H+YXQeH0b3wAgO9+YJJLNpbNu2Df/+7/8+4QY9S87PQVulVoFqG+KJPAFq8Q34zne+g09/+tP5RM7CsWrVKvzyl7+ccB3E8xvL/Cutv2ptKJWAVJaaoBoQ/NCHPoT77rsvn8waR0dHBzZt2jRlAqDadaMS0J8qAXAi2gAmowaYqgpgJgiAam0ATzzxRN72ko+cAHjNTIYAFnc0Y3FHM+a0NCARAq2NRbQ31aGYJFjQ3gjpepnpBqwD5BD2hXog4QASDKuYOAMnqmYqC6ANeDcGhhRTKBxooC5p80QdrB5/wZNWaq0gBblE281DUPv00uYAGjGZNxkp0vdMksTJtRUZq1lAJgXb9PKNawi7/PMtgXG4dxDDYyUcPT6Mzr5h9A0bYiCXTWev0XMWtmPJnGYsbG9Ce1M9muoKtqLv8adwZXfqb/eA2D1GCEfimPlQDhh7LGs3ixqBnJ7WsmZqEUlAxAJf4WT8IpDfWysA93rKKlUMOaYcWaWU+UTSvQbcOeIANq+0s00SkVZSSPcdqboPeOWCv+lbksyCe8kUBhqm/cBvvAUUeQrw1xH+fA4ZDvBuGnMGaONp4B+i3Rmi7Xvs7xrA3mPHsefocRzqGcTASL7ZOFXj937v9/DNb35zUhvW+H5QaTNdybG9kglbDOwqeQjw8fOf/xzvec978omchWPr1q348Y9/XBMwiUFNDNSzVCVZa69S8kRMUHGSoRoY/PjHP46f/OQn+WTWODZv3oz29vZJEwC1Av/JAv2T0QowVRKgFuBfi49ALZ8lJj5yAiAfOQHwGhz1hQTnLGxHR3M9ls5tRkdjHZbPb3NVSEIVDggzcOMrfB4sk9zeVNPDiiL9jgATtActJLVTWkErH73jLkbCKwe8Qzqc0zmvflLVVUppiQavGKAeaekk/d78RzrJsnm1klKmDYEBQAMCbcUTXKhtjofp22agR1gCICAopAU/CCrOhIzooUSsdPYNYSxN0TNgWgyO9A6hb3gUB7oHMHoGuLTXFxKsPqsDy+e1or2pzlb5mx2pJITvs/eHUbu2DWXXsbBzCjBPCXuwFevFN4oR6Sr3ypJPWmsjw4cI1rYz0bMEkHa9ANqDXeGr6Em0mVSKzbnghoCh9D5VqQPLjoCw5xpvW6DziBQEUorgPOZklzcLZISUVv53Vj3jNtCsnUBYkwKlbJsEk8sS0aaURqoVEptC4K4Bms5bjUQmzEdB+/Pczm0atEYAB3oGcKBnEC8f7sPBnoGcEDiJ47rrrsMXvvCFCYEZ30xm9eTX0g+bZcxWLQowVgBkvfaDDz6Id77znflEzsLx1re+FbfccktNj+XSfg7kq8nDsxQE1XwAskwtKxFTNP76r/8at956az6ZNY4tW7agra1tRsByNaA+kwTAZCX90/1utQD+am0A0/lc8feOvVlyAiAfOQFwGgGpVYvasX7JHDTVJWhvanAVUw2NhCT47OYmyfRLe4kzARIHqHlZjzuPJ766r6GZ/Nc8nFoADDgyYJ0AuBSy4oUrVcoAMpAfgPZ9zVY1oLR24DwRPsc3VSkKSWKAhZX8K+X7oXmVmACkcC0DvgVAWmM1AlfKOambz1eQiZGB2w0wJyhImUCfN7WEgXTQj76H9NJp9nhhq8QCAkf6BtE/PIbugREc6RtCz+DIaa0amNfSgCVzWrBuSQca64zqZGFbkwf59jhrBpapTx/8IkLZ4ETYwPf3S+sPQc8z4N+CbK0hhAGlhjiwpA6kJxKqABmuJhDgygME/fcEkmmt8e+TKo1CYs4TYwYo/POoe8Cef2mq3PcUfGPMKAT3mRAqGjjZJDh7QkdK+0QCUh44woPOWWuMCWgUZII0AGBMmcAmSLNrBf3CnGMmppDIBTr+gCdYUqsaouuFUhr7u/uxv2sALx/pw6HeXCFwIsdHPvIRfP7zn59ws8jPB9o08p7/avntMbhK0xSFQgFpmk4qZjBro/7EE0/gmmuuySdyFo63vOUtFQmAavGOsQIk9vapVhGOgdNEz6v0e04A3HbbbflkngACoBbn+ol+P1uUAJPp/58s8J9JAoAD/koqgJwAyEdOAMwyoD+vtQGL5zRj+dwWNNUX0dFcj4WtjVAOiHp7cQIMwY3RVsODC6cQDvyDy+aSxF8caE9PN2zhY85UZGJGPc307yCrFT7SjPdNO0AnvQLAgSEFCKE9QQEPfEgKroWrq3rJtvTeA0QbJIk04FyFDu8cwPHv5ukGb5Lm1RDKgVJBvgT239QCQVVWY0CIcgIA3psgkbzXXJe5FgNAz8AwtNbY03kczx/oxsFeQxTMtiGFwNrFHVgxvxUbFs/B/NZG8x2EhtbMQT+6CXnFCLWHwCs6LGh1RpHs4mJYbO3mktaoV5kIC3gNwCzIxJJJ2iNqHWFliKA3XmmNAl/T8JVsIm/gyC74NWg/WyKlM/wD+RAItv7ACC9Wzee9+U4dw87tVBmSD4J9Lvj2BAHPGihtiDOlFVuHmikUwnORDAiJNEyVIQno3VOrqkhVikRItzEhUOeMDencjrw7wk24cOoC+v6lVLnvvb97AAd7BrHrUA8O9Q5iaLSU3xRmaNxwww340z/905o3t7Hhn7tnRCZtWVXWrMeQFDuWbmdt/GVGDO7zzz+Pt73tbflEnoYEAF9PscFfFvDna45HCMaV/KyWgolIiEoE09/+7d/mBMAkxvnnn1+VAKjk0TAR8K92XagV4Gf5Bcx0K0Ctkv3Jyv+nq0aY6LjlBEA+cgJgFoGo9Uvm4NwlczC/rRFL57aYi5XyZlwkO1YApPCy44ScwCO3cBf3pbkpma9REyI2VW4DSnk/M785u+qd3aSnzBU/YO+Zazi07SsGu+kidmkHy1L3smOq7AcRZ44IYMZnyOgdJWAvBEqpRpIIG4PGDAbZ63LQozRggwscwIIFTgSuNCdEmGqA5NUKin1387e4VYH3uMOBTO3mWQiUubZqDfz22HG8cLAHrx49jgPdA6d0va5b3IFNy+dj47K57juSyRxcgkNcMRdOTSGZ6z49xcvow2OtmUs+r8JrJsvXWrie+/JNB68qwn1G3lqSqtRWq7kKgKtmzDmSKu0k9uHag/196ClBXhHcENARbJYI8iu5bNcQJBMgBvNSuNO5zKDQrk8RkVzUs+9JFNhzmlprwFQACObInCfeNFEzUsxdVngUHAN8sKScUjpoqXDndoYyQ2mgVBrDC4eO49Hdh3GgZzC/WUxz/OM//iPe/e53V93MxvLqaqaAWUC9muw6BmKVSIZKY9euXXjrW9+aT+QsJQC+/e1vZ4KPLAf/rEpnHCUZ9/THhFO12L8so8q4HSUGRNdffz2+973v5ZM5QwRAFuk/HeBfKxFwsgiAamC9VhPAyUQCTpcAyDqWOQGQj5wAOMmjo7keG5bMwfJ5rThv2Txf2ZRw1TjaHCdCGPDOECzPC4cI3cvpxqiUBQpA0BYg2O6eQBDYzTeIB2O990IY0zCSE8PTCQAz1HPyYf/HMra//EbuHfh9z7QK1AWFRFqSQrn3rysUMG6rkEIDqdZIpAHzBoRakAdAU9XRgkxNkYTIiLESXqbNQThV+KF1JkGhXMKBTzXgGfGkIKjUw+hBkidBFLTLcifC4lDPIPqGRvHMvmM40DWI/pETqw4woH8ONi2fi03L59nv6heAj76zZBSEA9fucNF3go/X46A9nokAaNi/JTIJADbY6zhTS2sEaMAqAvKhvKrInHIBVgk3qgRnOug+p21DYHPr++/tcxVtdnhKgHZqHbBWAK0ZNcbaA3wqATP8A1yyQSJ9hd0DfPLZQNna4+QW9/vkLQY8htBzDtpeWxCQd+4Niayic4ypjhQDdlJKFBKJ8VIaEIvunKJIxijxQCmFUqmEB1/uxP88dyC/cUxzfP/738fll18+4YY1q7rKR0xQSmcGmw28+GtUAnZZ5EPWZvicc85BmuaRk7NtXHHFFfjWt76VCTyqxb/xfQENUhaJ4F4axpolSRKskTRNy67vlaIEKykArr/+enz/+9/PJ3OGCIBKxqC1Av+JCIGpJALMJAkwlSjAmSAAaiEIKnlkxCMnAPKREwAneFDVdMPSuehoqseqRe2ANn30JGP2YJn13NujG1QvNeubjm6SSin3ewL/YNJj16sfga2UmYmxwiKbXgvyYeLVQlO86AfKIOfxfsoDIBOxlm0E5L6D63sWrkIMV03mYMqSJFJ6sCUInHvndJJo0xdTFPun/UfnRoiANy1MlYZMhAODMpBt66BdIuss4FGI1Brg+tct8SMljO8AwNoIGDBlFXEycfSQW2N/9yCe29+Fvcf6Z0wd0NZYh5XzW7Fp+TysXdzhqsmKV3q1Jy4AHTjhGxm4DsGzrV7TzJJCnKszNDQKSeLWiWTVYh+dFx4HMnVUgXlgSNIQECcjPw7uBWIzP0QGgsxwD8yzgLWx6LjdARmbHxH6bQiEZoQQnoTwiQCwfgK0mfbKBICICjAlQvg5+BVaMOKPt8UYFYQOiAjXksCvB+x48fjEclDIWj7AlANBFU4gSYQlKlVwjRMReHjghQP475378xvJDBAAl112WdWNZaVKWewBkEXkcik3f2wtBm/xa1XaqK9evTonAGbhuPzyy8sSJuK55G1uvoVPButPKRWsF04uZYH6idYnXZeyWgViwuDv/u7vcgJgmgRAJYVPLWC/ViJgOsB/JgiAyXoATIcAmKoaoNbvnRMA+cgJgBMwls9rxYr5LVg6twUbl85jOeCmSgl4V3LqY6d4MAcAGMhnp3bgoE6b/ZJWpkcYcBCFeoYDUGAr3+TUTVJeKb1DeWo/KxnYCdZbLKk3ny5WtkoNVvV1igGWPR5niMOCLgPghJN9h3FkHFzRsTPHL43M4wpkPGZYALYR8ASFy3S3VXgVZMDrCoCMZbgj7BU3Rmkq3KTYuQUzYXPkhZVZ0xc01ew4g94QAgYYhZJ4IlM8+POGcdRTfah3ED2DI3hufzf2dB6fVA57S0MRK+e1YPPKBVh7VgfYRw1MILkCxTvoa9a7LsPKfgawBZs7IUJwqVgQgy2mu/dObDqEB70hGAn8BqwXAdix9d4P/jwihsWrYLQjE8i8jjltOB8KAq6u0k0kFp9zsPcnQ0FOWjlzvHB9lflxcDBmiTB6DV7Bj99LxOoFIYLHcuIlbBcIn0ueAUT4+EhGHQB3ZWQrpkWDkQPaTrJkJA79TUVzRxVAImAe2X0YP/3N3vymMs3xve99ryoBkFWJrxTNl+UNkNVGEAM4rgohgKZtNGs1IJETALOfALjpppvK5pADc04AxIRAJQJqpgiArHVOagB6nZwAmNyoxQSwloSHWomAyVT+TxQJMB3wf7IJgFrSD3ICIB85ATATB0EIrFrYhg2LOrBgTjNWzm91G1i6QdFNR0qTFY4KvXGhVD+6CLCmea09kBcMJCZCMMAYASsGQjXCSh+viFbbGAabwKAyHoLDEOD5lAEOAj3ZEUqfEYFx34et7OcWXvrNsuGVBUaCfT9pe/IJOhujNvu5pc90Z/8J2hOohz8hZ3puTsgapZWLRxQMKPq4QR9N54EaVwf4ja9ZLxSx5oGj75mmXnoBb44nnYeAdoTCjn1d2Hu0Dzv2dWXGDrY21mHVwjasWtSBDYtaUSwWWd85U0eURSsJ9h2ES01wa5wlRii2Zop2o1+yahVnWBlXgFHuD8ANFFyLgSWggop35DcRnqcIgCsswaOU18w7AzwizzIMBElJAK3NmnPO9ixaU/t1wkkQN490vFwUop9PpxKINgDkkZHld0APTRVTK7D4P8mUEmXnNQPyWlkeyx3NMMUB4OSa/zll3gJ0bqTsfFes/4DMEr03gVdqxBGRj718JCcAZmDcdtttePOb31zThrta334M8LNM/yq9FgcEXLbNzQHjKjEfa9asyQmAWTi2bduGm2++uQyAxDL/E0EAVCIFqhEA3DeAnpcTAJMbtXoATARkJwLktcb6nUz5/2SB/0wQALWSAfzcm+h75wRAPnICYBpjw5I5OGdhG9Ys6kBDkqCpsZi5AVK2P53LY7NO3PgGRv3EYJBScKAPBgwhWYWZYyaRKTEO+o4d4PV9wvQQKf3f6W+2Jd8agcnQ1I/FjPGYN4RCBtdfTCkAJL3mFcsA98FLsJ0/APv85GFgFegopeb7JMZcwUnKNUIDMi5T9yRGKEV2JANjT3zllUgJU3GWAqzHWYN7JMSZ8dTXn8TO827GhQNRfA4SaYkMutCr0N6eg7qewVH89OlX8dLh3mBtnL2gDddceA6ggeY6iSQpGK8FBlAF6xcR7DNyc0ciAAitk5eBc3yP5PglFjdHxyGRIuC46CArSy4VEok0JSNM7s8QejVwsoGk/uBriUsOnHGmnR930wyd+WPiK2in0SGRQ99fa4009b4e2WSEJ8S0JckEIgYECFI3eFsAGEHiI/7C9hlaT854kRkIciJHZJAddM4K9phqeyh+DUktoZIqZc4HiIj4COXe0hICCOTkcATAfU/nBMB0x6233lpGAMT3oTj2LzbwimX6We7scRsAPa9UKlVMCojJgUr3yA0bNuQEwCwcW7duxTe+8Q20tLSUAZCZJgBiMDRVAoB/BiEE/uZv/gY//OEP88msccxUDGAtZEA1QDvZdIBTBf6nQwBMRgmQEwD5yAmAkzQuWr0IW9edhQaRoLGpGGzcOZAV8AC5YKP3eGycv+F5sz2Z+OoIInmzv3GS3Nj0tVNlO75cKKYW8BcX8FAARGlpDpSGRIaVpQtGWgTGdh6Ah3FniCr8YWXRgCafr07q7MRKExSr2EprImbcy9nxc+7q2lQxhWBzIS0gNCCSXM2DVARSCDBwx2Xr2jZN8Pni35kDKk6G8Ag4SnegOXKbYN5LLngVFM5tXbk0Aecvj0QIZ/jIM+MRmcDd/tCLeOlQBgFwwTloKkrU1xWDeeE+EaRIkEniPCik5B4Kgs25ZC0Z2kchCt/SwuX6nJiSQiDVKugZ9zdADxqTxGTJp6yFws2/iCUswhM9Nj2AHuv8BNh5KIRmiRp+LhPpe+XpO6ep/z0nOWJzS57oQWRaHOWntCcshDDkHqkkSPGgKhyTNFUuRSOrAhsSGMyjA8IRD66SHxB1wh0fEZFmLu0jY1+iGeHljURV6PbvpsRvUgqJj20kQ0EpBR5+6TDue/rV/E47zfHd7343kwDgUvwsk7RKIH+qBABV/qWUDsyTsVupVCp7TT42btyYEwCzlAC48cYbUV9fj6ampgx10uwkAOi1RkdH8bnPfQ533XVXPpkniACo1RCwEmifiACYLBlwIsD/ZFsBpkIKTIUAyLqeDg4OYseOHflCzkdOAEyHALhi/VI0NhatA72vCnoJcNh3RoDHxI/RBt9UWIUQztk+sTfI1PYX06abzLPgerJ9BTVVVE3WwaRIkV3F00EPr88ARyTvjcG8u5gyrb9gJmdUdXQ961ElkQzwBISTG2c5kccLTdhyqaLeBiDoMwczevO6Ad4O4D6MbZsQzmiOS/Ed6SI9wPZVe+UAq4KCxTYBgKI14C7CCNILXSQaAUg6lKn2Em/KkxeaRRayKrxVoBtQ7rLaVRARR9/7zkd349n9XcHxXLmgDX/wxtUoFgth7zx89B1JyEtpCYKOKRFQtGbs8UikDK4IPHaRjmMQAafDyrMmY8CIwSJTQWrD0PDVbq50iF873lR68E3HWjkFR2CSp32fP1/zqTVsFOyzxGSNU0hEN23lSEAi0KJMakYe+LVCKgXzi4SpFFyPKzQKQrrFlVrS4WzzQQAAIABJREFUwLvqa2aIGVVX7fcVWgRqG7fhUDogbPyxYGQczStCo0SagyRI+AhvFWURcNorbDjJ9tBLh/CfT+3J77TTHLfccktFBUAWAVAJ5PPn1koAAN7bgQgA3qftVCAZbu45AXD6EAAAUCwW0dzcPGkCYNeuXRgbG8O+ffswNjaGwcFBdHV14ZlnnsHRo0fR39+PDRs2oK2tDevWrcPq1atRX18PIQTa2tqwfv36KREAo6OjGBgYwI033pgTAJMkAFpbW2sGydXSICYCs1nzdqoIgMmC/2qtANMlALKuyfH/Ko2jR4/i5ZdfzhdyPnICYMo3vjVn4XfOX+nAP1X9TaVQe+M9Jg82myAfmefk0gQ+bYxZHNnFo7I4WKBKPQdEYI7gIooY8xVOBCkBBEKycpl1lqyAv6YiQzhmkGeN1ZIAqLH8tNjcjL0ngSuTS+6j0qhXWwqiLxB4AFBqgtNdEBC1gN2b/XnpuOAVZzsPvirPqp7MvR2umu/r5by/WwhRVu0PKhwU6QivvqDPTTGOviLvlQbkH+H75xWTnidmk82q8zRnP3m4nABYvbAN79m2vkxSTh/KmxIakCxlAie5D8zqtHXiZ/J0eyzhkgss2BTCrVOuXODKCsFcASXzu/DGcRoQGlIkgZ+Cb1UR4bzBt6v4q5X2Kg1mYmlIAbi2AY3sNR8wLCKOjOSqF09c+fM5XM9BOACbs4SRT+R1kNBapQ0VKSiEKPPfUBqQYEoYraGiS7Zg57YOUjFEUKWXCK9jYRSjJ3bSVDmjU1L3kBcKeXjQHLufGWlGqhg6jyQEHtp1CPfmBMC0x80334wrrrgic+NcTQFQaRNajRyYCgFQzTAsJwBm9zjrrLPwx3/8x+7fSZKgvr4+kwQAgMOHD+Po0aM4cuQIuru70dXVhYMHD07rMyxcuBBNTU0499xz0d7ejoULF2LOnDkVgSUAlEoljI6OAgAee+wx/PKXv8wncxJzvnr16mkTANWIgFoIgImA/ok2AZxOK8BUCICJjiH/XxYBRmPPnj3o7OzMF3I+cgJgquPyc5fiio3Lwig/+Lg4wSrLgcM8vCu/8M34vgodYWTKDHcVNV6ZZ+7eAIJ+fFeNlPEGzZMHUkqUSqnbuDtAoGKplZc1BxcckCFamHkuuIyeGwPyzR5C2bqIesHpmHHZOa/KE1nAK5/0mkp7BEbVaR6TmFjTvFQBiQCr9CqHhPi39c7/PK2BxRPS+zJCJ3bKDkGh/zt9P+cwT3n30YkGVoF1hIptZwgk8Uz+LwRwxyPlBMDaszrwB5esDdpA+FqkWAYphXlVZo7HP5ywpm5U4XcGcMq3NvD2E2oPCNsrPFCW1gGewL9KSY0hrdKBWg28MkMGCRg6AKDmvY1SgzwEtFamR5+513vawLaQOJPFYMVDCB97aGT9Pp0hViAgMv8L2kmYaoFi+Hi7jD/GZC4Y9tLTMeJkA2ISy5IzYP4RvPWCzjmnxlA6coGHnVt/ToCft9p/H3ouEQikDtHKt6dwbxApQjKTkhXctdF+h4d3H8J9T72a32mnOb7+9a/j7W9/OwqFQmbv/2wnALTW2LhxY9VNbT7ykY+TM5qbm/H6179+UuC51gz7+L8TgfcT7f4/HYBfCzFyIggAHoGZNXbu3InBwcF8IecjJwCmTgAsw1vOWxZU22OzL151JnRAvciSYgAZ2ufxdySlNw7aYBXusFrIM+11pDSgPxpQFG7k+UWFG7xxB3EHJsnlW8Su5vbz8igCBrqDfna2VJT2ieZBbzFfXBrOC4FUE/y4OuAJTpbQJpKbBibecI3fjKzLXWKPDZEcgdGVlVCTqRsBMgLsKlXQrPWcHPnNd/T9067arXWg/qAqe2i+FZ5hro1BqbACyxCqj2bz0W7UV/6TR17Czn3lBMB7LlkXRsC5qLckSChwJIUQzrxR2zWl2TGXTs5gzwNOAEUAU0QeAF7Vom2EpQGuMhEw/nCm/z+oYAtzFinb+iBcnz2gdGrJFB2497u+CEfIKV+dBwPGNFdkoEfnsfTeFUQSBUqUIPLPD8mOARkF0noR0d/SVPloSO49IbyngLS9/KSmiKvn9AWdf0SFz0LPIRINgrfOhJ4SggE82DYlzf4N13YgAsLQRZwqzZQPXgXjLklKl53jj+4+jP/MCYAZIQAuvvhizJ07F4VC4bQiAJRS6OvrwyWXXOI2tldddZV7bGNjY2Z6AP+5t7fXqQcOHz6MoaEhdHd3o7+/P18cdlDVvq6uDi0tLRVBFp9TwMiJ83Hmjc2bN6O9vb0iGI3Pxck62c9mAmAmwP9MEwB0LZ1I/p/3/+cjJwBmiAC44rylvvofKNtNf3vgMA8NQZVuAtFsc857aDkA1yp2Y4aToPM3lmwT5XLKmXw3NOhC2LvvgKNXMABGZu4AZ5lWPJQCKy2QJBFgEghAgBQC46nZxBWkqfaairwnBrRWwUZUAKE5nORVWATvAw1DRlhgD4S99Ub5EG9cSbEh3dcjYkEzXwKiLLT1IJDMRE65AHsdqBe42VlIEGnn5SAFEIjXWSYjJ1o40uR56gZwKkjIYF5pLf3ooV2ZBMB7L1nnJPaAj0x05JLwqov4BiuEfy+vIKCKOks6UD6LUitdZmhJw6QHKNZmAU8OIExg8LJ3pqSAIYscaWPj/TRD6NyU05s8+lYSrX1cJ28v0Oz8UtqA5cSRSH59QsCSbp5Icud3xnEkfi1oXxBMAcJj9YT55Er56jkn8oys3pt0ciJSRUkSREDQua60ZpV6OOKA1i61OJG/iE0xhYAOjA0TmTgTP82+l3CtUebYZKZeZNxJhBB45KXDuPepV/I7bZXR2Ng44WNuuukmrFmzBgDKSIBaCYAXXngBfX196O7uRk9PD44dO4bDhw9j7969OHjwIBYtWoRFixZh9erVSJIELS0tWLduHdra2pAkCdavXz9pAoDAf5qmePOb3+wIgB//+MdYunQpFi1ahLq6urLNcpzzHnsL0O+PHz+OAwcOYHx8HMePH0dvby86Ozvx9NNP49ixY9i7dy/27NmDsbGx0xbUF4tFLFq0CGvXrsWKFSuwadMmLFiwAAsWLHCAX0qJDRs2BKZhWT3FcevI4cOH8eUvfxk/+tGPTutz6KKLLsLatWvd+VQsFjPBFx2bzs5O7Nq1C4ODgyiVSti798xLKjn77LOxbNmymgGziL1vTiABcKJJgEqV/KmSBbXGAFZ6X7qOcmKu0ujs7MQrr+T31HzkBMC0CYC3blrmnLUFeB+9dmCO98AFN1DmbC+E6e+WEkFlmyppLmsbYV8/v6BqwSLXHPAO+5BNpVZHgFYHgMABHivLlUIi1axnF1H8Hsm1dXncmSM+KFtdaSbZDvPQefxfwl3tQT3U2pvN6bBCqawpmpeEC+/OTzb19u9Km9f38mdPAPDKPN84xpsfZ5BIBA/5BhCAY6QPOIEB7xVhji0nIcAq78xUToowGk4pRwwwrgBae+CYSOvaD4UfP5StAPjDS9ebY5GIsrNYaSNvd3NlwbRka5nmWwrByAAPeqWtkCtmDlYoJM7jwJ8nvsVBSrNQRSKtisA2s2vvLiiYukPbtQI6f5znhDdoFBEQhpWhu752+/3IkNL8KYzcA+uN534cgcsui7L078d6JpiXhvsO3DBUA0J6NUpMCoZJGMZnwxk/UnsMUxA5NYIK4/WA8DMAoWqBk2mxlwi3A+FtENDcgDNs9YEVBwlGbJKKQrOLiog+lwZwy/3PYU9n3xl7g5VSYuXKlVi7di22bdsGAJg/fz7mzp2LJUuWQEqJ9evXBxtcLv/k16yxsTEcOnQId955J5qampAkSfB4fo969tln0dnZie7ubhw9ehRdXV3TjoxasWIFFi1aBMD0bG/ZsqWq6Z/WGiMjI+7zff3rX3d/+8lPfoILLrjAAbUYZNRKAGS5k2dt2Hft2oU0TdHT04Oenh50dnbiiSeewJEjR/Doo49iYGDglKyPlpYWB+5XrlyJzZs3Y8GCBWhvb0drayvOPffcTGCVpeiIr2cTEQD0789//vP45je/eVqfZ5/73Odw1VVXYf78+YH6ga8TbowZV7RfeOEFDA8PQ2uNXbt2Yffu3Th06BCeeuop7N69+4RI0E/1aGlpwete97qq5y8nTUgxxM/FyfT+10IAVAP+JyoFYLrgfzIEQKWfYwKgWjvV/v37sX///hy95iMnAKYzrti4DFect8xVsKi6niqNJBFOBq2t/F1ABoCOO2c7g7Ao2o4ArHIya9aLDQSycpcJDjhHdZLDU5oASXE1kyvwuDm6mNDrSfsAAq9h1KH9vgSoRXn0HwEJF/3GAKJgoCRVkVcAvFO+lyprKznWZT3RfBUKIZCS+7sFh1KEcYuCZaYTeCInfiIRUqpI80q+EAGxo3mFWytAiyDaz72fJVOoEuqAKik1XIuGQCKZ9wEDk9ChmkApG32odODLx/0RlNb4ycPlCoB1i+fgD9+8IWwfge9nz5arGfCZyASprbBLBipT22MOd8M3c5/a1gVq5wAjN6SNZ6RoMJK4OyNF5o1A/f2p9skYXHVDiQncnNGsD0MGcAKFnmszIy0BIMIYTRESAQTYg/QA6UEuzbVmbQZZuebmz8JV1OGIO+mAdNACwDoXeAwnHZmSUsbTAmELgsyotAQtHwhjPEkZo5hfhTOCVLpsHWgeISi894MQXhYiWVoHfxzY8XQkArt+EQH2xbsewfBY6Yy4n7S0tODSSy/FihUrcOGFF2LFihW4+OKLq26Us/5biQAgEuCaa67Bzp07T+tjdf/99ztFQ1Z03EwTANUcuYUQ2LlzJ55++mk88MAD+PWvf419+/bN+HdOkgRbtmzB+eefj61bt+Lyyy93hEr8+ScCVtMlAPjrf+1rX8NXvvKV03o9ffGLX8S1115b1vpQKwFQ6Wc6lk899RSOHDmCZ555Bnv27MFTTz2Fzs5O9PWd3uTm+eefXzUNIIucq5YGMF0PgEqAfyJZ/EyD/6m2AkyFDMgy/6v2XZ9//nkcP348R6/5yAmAaREA5y3D2zatCEAIl6WrINZNZ1buBOIscuEcu32vrgoVBG4PTdFp3rRMsOpyLPEPTQURyJxNBrpgGfbCyfKDFoboGCjmwl+eRe8C1QLQwckO+hzeuIy1EzMQFAcHcKVBSVEUHXcYF97kTQtLGPi4RQ+IhJVwm+oreQ0kicl6J9baHAfljeaYooGM5NyNxhIWNAfcVyAAwPBrxfeuK2/GyPT13iBNMjd16xCvELSbxCkPP3roxTICYNWCNvzx5RuDOfNpEpwRMJX/IKqNmTEK1r7A0ylC4kKx8yGMASQVhZPd69AY0LQGGHAuLVBPHTHFVSzGzNH19kM5Twphgan3YTB9/1z+7yIWEZrcBaoYNvy5q+GVCX49K6VRSKQllUjq79Mx6DMXEmmr9OExIqJQs2jRsps+M+lQCo50JADo1iBCTw4i3Lyvgj/XnPIIHASYeSqwGEZOBKapijK7tbsmQXO1kQ7ISzr7SmnYM07Xzaf2dOKuR3e/ZoH+ypUrHdBvaWnBxo0bJwT70yUAAOBd73oXHnnkkdP6GD744INYsWJF2bE4VQRADPh27tyJZ599Fr/61a/wP//zP1MiBDjgv+yyy/Cud72r6ro4WQRA/NqvBQLgW9/6Fq6++uqq8z4dAiCOyqTHPf744+jq6sL+/fvx6KOPYvfu3XjyySdPm+M22TaArHNxpgmAaq83o+BnBiIBp0sAZB2jiQiAJ554AqXSmUGq5yMnAE4cAbBxGd66aUUI/FlfdHiCe/DGHfw5cEJwMMMbNXc7L9k+YKV9X7nWOqhex1nqtJHnvcX8GpFIUzV3N6m4ui68pD4wPhMI+pt55jcZD7pqv61W85YJH38mgt77WGYtmVs5J1h4z7vSyhMtXI1gyQ2ewe5d2CXDuqHsXTpCICQplDLmdNTvb+ZBQ6U2rYAdM61VYNBHPggl+7oGD8lw0wWeoa4ippdd+F2+u000sEaF1EJCa8p4ABwLb9wL2vCBK84LXNwl67Mn4M0JG8l6txMpXS86Vf4JDHO3d62BYiJQUpzYYGoXGxnJzQDBKsNm3cA54ZvnyiA3zxnYgScUcvG/NvNoASmX3JPaQdkIQMFaURI7/+485AdfZPQ12uMlnSrDEH80l5pFP3JvEIp3dNGhXAfDyLeClDZitMImiKtcWBuSU1kwI1DB2mIAuNeVLG4xSaQzsuTnZmDkyC52XF3gAD5TA3mCiq1f+CQPRL4W2x9/BY+9fPi0v08sWbIE73//+3HhhRdi4cKF2LRpUxlQC5RTJ5gA+MhHPoJ77733NUUA+PuEDFruThUBED9ux44deOCBB3D//ffjvvvuy/xOUkqsW7cOGzduxNVXX43f//3fr3kNnCwCICuF4bVAAGzfvh0XXHDBSScAsuboySefxDPPPIP/+q//woMPPjirq7UTtQHE5yY/lhNdy2oF8bOJAJgK+J8qAeBNo8NjVk3t0NvbixdffDFHrvnICYDpjjevX4wrt5wduPGXRXkBbNMfAiBeqSP5rAMLHja7fnPJ3O1pv08yfC/b9jLl4AII3p8LfwGhyjNvW2CEBqJNBTft4n3MWrHPRM7pNhlAOkk7U0NIVhmMIgEpxo1Lr5ERrebeh91UU6VRSMKseeoR5wuWAC0BUM3y4F1SA8tm1zws3foFULVTMeM5sAQHj1p1UDXl4MmAdfbdGCjVNkcd8A/gGfKcXOKGiYhuNl+861GMRDJqKQT+9l0XoZgUjHcCycmtvN4oJ+Ci4LyyIPRWEIxs4YO7/2v6DjaKz//ekDJSCNsjbn8P3+qiGVgWwh53cpO371mQCZRKoQAn5RfBpteTJWREKJhhn5DwoNvK7BUnzBCqUgQLr3cKElvdp4jDYpJECpBydUFs1kfRjk63wIiv+KpL859IyRQc2qlJAJ8Y4AkCOKNALveXvMWIxRa6zxJxHzH4d2ey8DGPqVMtsUhPFYFcEfoacBJBa41v/p8d2N91+rm0J0mCbdu24Y1vfCOuvPJKJ+OPN6KnigD4zGc+g9tuu+01RwBwcFGJBOBKgRgMxwA66zFTJQBo7N+/Hx/96Edx//33B7+nHvSGhgacc845zp/hRBEAWd+Fg/tKa+m1qgCYTQRATFbdd999uP/++/Gzn/0ML7/88qw7dtXaAOL1Fp+TldZwrQTARKRAJYPAkwX+JwP8J0MAZB0fXvmvdB06cuQI9uzZkyPXfOQEwHTHinmt+OBbN/k8bg0HpjSTF8c52L6C5iXr3ryMjDyAQuKj1RRzy6LnEcClaShImQEOCdCTTN6bjHmTMAI42lXE6bWl5HFuAQwNgAscEPL91JxIcFVpVgk0n89nlAuwSjKBg3jDrDS08NV3KUNAEVQ5ke1wr4Xvj/cKCv8Y7/zPQIkQQUSj/zNV+UkWrwK3+ZSZ3FF/vrJRdyIwKwwTB+g1iAxJlTLkUNS+kcio6stJGgBP7unEnY+8lLl+//eWlbjk3CXsBmkN9QCr0BAO+TpADwSJClKaVgnqT6c+/zjmTkO5oj29rlv7FuQmZAIYeEmIKCoxlNy7m6EF9soqbMgcMIzA0+7YadrYwitrBPPVoCi+RHpXfulaE8J2FsmJDqau4WCWEweSRQvS5ylYB31SnBCA1+BrHAxQ+9jIkBDwTv5SSJRs0oEzv5QsfpErlSgV035QIp8EyuNCvQeGDKNDmWkofU5KDyhROgLbSLv1rnnHkPnbnqN9+M4vnj1t7gVSSrz97W/Htddei2uvvbamTeh0CYBKG2UCbZWkoN/85jfx93//92ckAVAJZMXArJKJ1nQJAAB497vfjf/+7/8Onv/rX/+6KvifSQIg6/NmAfss8J81vvrVr+LGG288rdfTz372M2zYsKEqGIsr2NWqtrEB3nQIAD6nDzzwAB577DH8/Oc/x2OPPYbh4eFTfuxWrVqFJUuWTIoAyCLeTgQBMNHzZxv4r4UA4JX/WPqfleLCn7tjxw4MDg7myDUfOQEwE+PDbzkPKxa0MSAMJ3M1cnLmIm9RrZRewuw2zbaSp3UIRhRFezGw7S4QUfWQNs9J7LLKN/ssRs+DChEAT9rEB5tKC3qV/V6hm3d55d/ItNlmgkBcDI4siOIKBONHEEbjBa/jHOgRKAN0sCx5xJo16BMmGlCw2DVHSMCYCmr2dkLy2DURvJmU1EdNH0L7nnMB1yrAW559vjuizaafRU7K8Jg9eh8ZR+8xZQYyKsU/evBF7Pjtscy1O7+1Ef/P/3UBuKpcMlf6YJMY3Ey0SwkoN82DI3y4YSOpI4SLnTOVd/r+iSTPBll+QWG9/gKhssD5XfCbJDuert+eyeFNdV8Fq4u8JoQWYXSjXStSSNcqQSSaOUe0j7Tj5wEQtN1IgSjaUgTzSu0xLjqPkTzeYyEk98K+e98OJARsaocIzp9UecJICDqaCOI9JUKCSbG2IlrPRIQp5jURknpg1wxPOGjFAL818aS4UoiQ4Hhs92Fsf2J2RxXNnz8f559/Pt75znfive99bxlwmy4BwEmeWhUAtfTO3nHHHfiLv/iL054AWLlyZUUyphIZkAXQ42Mfu5RPlMM9WQLgfe97H+6+++7g+Y8//nhV8F8NAGXFKMbrKmudVXttDv6rkUlEKN1www2n9Xr6xS9+gXXr1mWSQllkUhaQDVqjMowpZ4IA4OPAgQO47bbbcNNNN6Gnp+eUHbuOjg7X1jTRupUyLIJlEXFZ17DZQgDMBPivlRioVvWPj48rBmR8T1qr/f39eP755zPbePKRj5wAmML4nc3Lcfl5K6Lsd18ZjGO0JJP+EwSmE7TEXNWl3ZxzJ3iS1SYZsmBfAaeqqSUVtHE9d2QDfLWWV6Ddpp/16Prcch1E/CltDM4U7ymENy8sSAEthHOJ52Z3HCg5MGhfz8cc+v5wMjvUDuQBXmavHcRRvFIMuGPAzdnMaxsgV0rtd1AK2gIf6nk2rQDmZ5K/B4YH8IkG3LXe5K8K11Ougn5tVi2GNsZwrJ0BFgTzSDRuyKit0RugnAGh5j3sPB8e/th+aQIX9T/YuhYbVyz0Euwonz615nRu8yLJk0IG0XGhHwDKPCSoh72k/Hwr7UGfyZoPTQidqkAKR4w5wkZ5zwtjaud71d0RVyR7N1VwXpFOlQ7WOLOTKEvF8ICYxRoG5JIO2m+8hB6sdQcsJo/19mvWTgGvHDFvp506JRP4UWVKIGihIWBPxBW/htDrKybHj5MKgRC4S8GULIwA8N4bnrjQ5R6g1veDyWgjU0/6rBSoIQVw88934pUjs9chezKS7WoEQLyRizf6E+VlZ/VqnwkEwEMPPVSRAIhBGicEpgrya/39VAmArq6uquC/FgA0kYqklvWkWWQrJwOqqQBO9/XU1NSEl156qSog4+soJgD4v6u1WAQEcIU1MhkCQAiB/fv34w//8A/x9NNPnzoQIISLKJ3oWlXp9yJShk10DZsMATBT4H86hMBU/lbN7C+LnIuVJnwMDg6iq6sLhw+f/p46+cgJgFkzVsxvxYfftiU0nWMggSpsxm2bKvwq2JgH1dvIbEyyfHFeOQ8mgEmznQxZI6p4mKqghETgH26rmxz8gfV3c2ax7CLLgL3byrOc9nLZvw7BI5M4e18CAzoSlmnu+q9ZKwIpI7gEmkCZf55wrQ8+GpGRAZRLS8cYNlqQPS9JhHkvySrtcOlxHliCyfwJ4PDqMABhj2tZTBv1TisNpRUKiZWDK4oVhK+yEkPjTAbpeLF0AAvenn61E3c88lLV9btlxXz8/tb1DByW92LT+vG57yI4BhxEa9veoKwpJZSPXXSpE3bNOrNFwZ3yRZDaoAOvCb/aTCsIM7MUBCK1M4LkOfM+IpDfPIVVHvhoTPdd7FqU/PE69I9whpBCWLWIbxWAXaN0XqqgVcCrf3irRBD9Z48TJ95MvKUhgITwRprUSuGVP9kGS57o86oO709gvnXiFBIIlAHU5gJHWsJ7GLCek3CDwtIL7LmXKh2QezwGlF/zvnDnw7M6/u9zn/sc3vGOd9Qk2Z6IAKhWwcmqKFZ6jyxJaNb4xS9+gT/6oz86re+7Dz/8cCYBEG+EayEAagXvlVQDM0EA9Pb2Tvida5X1TwSMalEBcEkxJwCyxh133IGPfexjp+1aam1txQsvvDAhAWAIYzkhATCZKnEWaVMLAcBf721vexsef/zxU3oMN2zYgHnz5k2KAIiPX7zXPB0JgJkwAYx/n3Udr+TJERObBP6Hh4dx/PhxHDt2LEet+cgJgJkcH7lyC5bPaw3AfxDbZQ9Syi5wfPPtnbbLjb8c8NJsVx1sPDwIT8ksUMYGK76X2sitEUiTqT3BVW6FByRBn3UGA62t54GpxsL1jEspyza1ieS9wSoiDzxpgqCf2kufefUQgFUNKHe8yYCMGyW6uDpr3KeYGgKCVfK1RiITUBXXgUhLakghAtmz92/QDglLBpS8IkQ70CNhEhxcdT1VQRXWA+CQZuFxdIAHS5pFPcbpExrALfc/i1eOVN9YJlLg+nddbL67CCX9KTQS169P7R++9cNJw62eX7IkBx8ZKQJOi0gZsw6loxqk9CQWIL06gikIEpnY46mYYkH5tWIS/hwrwA3mOLmRBvGXPraPt8G48xNAKVXG1M+uNcEq6554My0RdEZyZQA/VjwJ4P9n783j7SrqbPFVtc/NTMwNY8IkJgGhFRSZgkoLLS2iYCOT0jIoiNGID/AJggPQyq9ptRtpnz8jgo2trxGhRZBBkEHaEUQRUMAwK0IYAhkgGHJ31ftj17dqVZ3a+5xzc5PcG0592ib33HPP2ad27X1qre/6rqUIjFgbFAp839A+oSIQBMYGFU+rKCLw7Ft0JB0hkedb0d+7hv9qCYmxlZBs0irALU024hY8uUUqprDO5bxZQOkoHlG1bazjdAGlgNsffBKX33ZlVsA6AAAgAElEQVT/qL7nn3322fjwhz/clWS7DtDXSYabNrGpnLtus8xVoRx4zkXKjaXRSQGQqgCaTNtWdwPfaxVwpAmA1QFGTQRAupbWVwJg9uzZ+J//+Z/aOZH7c2r+x+c4ZxiZI5s6tQB0Igtyv99///3x85//fJ3O4eDgoI8xrSOcUrJDyDleVxx5XXcPHS0EwEiA/07EQN11l4J/Xh+83p5//nnvE/HYY4/hpZde6qPW/ugTACM5qjaArQMYSsA3Z6UbyjNTCBLpAAKCk1iGo29nThHLxgWdRhV+HUTwHnyTor0yO2On/vB2iuLdYhMwxP28ShGpoJx83HpjPyErLCysTeIOOU7QqREMtzDY4IIvXgE8I1E1PV2gFG0nc+2JFqncWlYoqGAm6M4Vt0woFQOXWHoNOl7lyYkC1RwFDJU4zBP4samvAznYy1qSOMlKLFGB4aA6qF730WeW4cIbf9/V+q3MADdP+SWfBlBaA2u1r5ZHJojiqth2NwiZ794RHrI+dLQJ8EkCzvtB1BDQihIAAilkTTBIMMbGPg+uql8aSyoGQ1dbUB3YOFwilsB7JF8ZG4opJps/+ko4qnYRiekTwM7mgkIeSdKHUoniBqRYACghIL5eWoXyRIFWwJDr69cRacWbTfL+UHH7QZpeYhPlkSUFi+IYUKeY8NVBhFYExEuATAJB9xBa5Zzu4Y79il8/gNseGN1SxfPPPx+HH354V4At3aTVVWzT5+V6t+tM23rJgr7nnnuw7777junv3JtvvhnbbbddIwGQuv+nEu7RRAA09XDXyXq7BfO9/E267ngd1ZFK6wMBcMstt9T+vhsCIPUBSB/rZZ3lgH6TumA0EABFUWDbbbfF9OnTa+9p7GfSiYyrux+uzjpfkykAIwn+03t5jiBmhU5ujSil+uC/P/oEwNoYr9xoA3xw353i3lwwwA6S76jX1hljFUWI5xM1AGF5eKd5DwBV9gSwc700GohpmaUoOjZR89GDKuEZlI1Bs7c3Z+O5cOpL9xypPvpEAxN8AUQWLVVKeFPEUBkNsuFg4FaoEHXG8xcqlfGoepKFFIjjyqSHu9ABxFTV5xAF6HvKXd68AHPrDBQLkt4rBLVDMIOzbv5ChdyU1fkriuB7oEg6rVSo/IdYtlDJtQAKeS9yUOeqsSJA99N7H8P1dz3a1frdeqOpOO6tr/VmjjFBgwgUxusSBKjjFok0zFLWSMGKB2f6F4ClrlQBYqJoK9VE9VxJbXAGiYBPRrC2quoXYrRnDFg0J/NsPKB3ZoNuDWtSjLDSQkA2qwdMGzBT5FOAzJcyeWtAVCYxiSbXsCmNb3nwG5YgQvGtLyCyQlI3hLFo6aIyAExTJehewT4hKlG2RCkGlLShVVAUsJeCr/wjRCHKtS1tFZxbDATlR8nrltbc//nR7/DkktHtVHzBBRe05bQ3bTi7qfSnz2H5Z/p4XT8o57XXVQzvuecevPWtbx2z37dFUeDPf/5zdg5z4D8nyV8fCIDhAP1eFQBp9T/391dddRWOP/74Mbue5s6di8suu6xx/tMWgFSmX0cANPX0d1pLqVneaCYAAGDTTTfF9OnTMX369DYAn7tH8dzm0inqSKk6goXBb651dbSkANSRv92aeOaUFCkJsGLFCg/+//SnP2FoaAj90R99AmANjQ/+3Wux5UZTE4lrLGWv4r5SkzCvAwh95So2M6vk/RSjpqOuew/OJX7PG9MhSLcZwEVyXos2wCLgKvgT+HyDKNaw6o0HNDSGXA+ycBwVSAu9wtZWx1y4amoqKU489uh4K/glDuKVpD+u5keA1AZDOQ/AZF4oLk76xbnyWL1ndaxQPF/xMRVao3SvpbTIqAUOs7GXiaq1imLpuPXAt1kgNmfTlLXuXdttNe8CmrldhAmZi27+Ax58cknX6/fIN22LbbfYOJAi/KUsRISLqFNRi0kAiJai7QJREygBlqPLuuSIP+lhr4B9EXrhRTGAQJqUpQlye7DfRlzNF08GWWqyftjAj4k6RZ8r3UxYUcJIO03SomIogSP9kpZj07oinIZKEwwPnYymIj2CYsekXiAQYG3ijaFXEdFa8BsH468zIQ84tpS9BCLQyeqIpHItn5MJHyRrxRhD8k7a7BExqVVQOgn598Ci5/Ctn4z++L9eCYBOxEC66ctVzboBbGlvaJ0PwJZbbrnG+mLX9HjDG96AH/7wh7W/r4trq0sBGA0EQKcWgJEC+t20leQUAGnEJI8777wT+++//5jdu82fPx+nn356RwIgJZWaznentTbc9ZcjAUYLATBt2jRMnz4d48ePx7Rp07KERroG5XsiN9IkiiYyNSVFuQU114LQNJ8jca13eiz9bHX39yb/l9x3CIAI/D/66KPOnLo/+qNPAKyxse9rt8JeO2xJcnzqF0fcmxuitMImT7tM7dJWbulsqmUsuX2reJMPRwiAnPulQszRZQKGvbQd7aZI3KvtK/xU0tUUvRbi86zvj7ckyzawaCnt+qhDJdEmKQNp7zP3a3O/fxEBNpHwJ/OBUBH1kXFaeXClXeUx8jdA+H8qrTwHFzqXUV8RHQJKC+dB4E6QM+ELx66Q9G6zjByI2jwMpQJEMl+60MSdXiTXZWmSTUo1t48+vRTfuPHuntbv67beGAfvsS1Jz9vN6pSmGEs5ZkfqiAEh3w0sKuVHyUkRsMFLgEAx+zNUOfLVcyUBgKvZ1fkzofXA96BXbREFAknhkxiUKFRUDPAdgcDECxMBTEiVFGPX9mEjrwObeFsYb47Jd042xazWhfWxoL7LAUHlwkRPNUcVEcItK1YBLUeYBPPQOGWgNE6Rw+uQUha8J4j7hOHaRJRuYoyFLoKCwKeT0LqBYoKG2mwQxxbKtX3rA0/gyl8/8LIhAOo2xynp0okAyMW2MYBLN6RHH300brzxxjH5XfvlL38Zhx12WEfAxv+uq9iuKQKg6fHRRAA0EUrpWmryAdhzzz3xyCOPjMn1tGDBAhxwwAGN55cr8N2up7S63W3/f6+gdLQQAOPGjcMWW2wBABg/fjwGBwfb1lc3YJ4fZ8KpTgFQRyjUrdW6RIXc73PV+tRUNPeaTSkPdZGcdRGx6e+b0hSWL1/upf598N8ffQJgLY1XbTwVx751p6SfnKqSDm0K0CgS2btUy5UDnCFiT/vNd9tNTyr4Or5ZFGQqZtk3gIvuTirt3f59/F0c08VO3nwzVgSKNIEtqZCzRB7kgl6S2RpYAZEoJXRiqOhvluxSp1TST07zgpAvn5rBhRsx/HtErugC1VS7k3no6w6EicjSQ0KA8Y7t/iLhcwG0kTgea9IVFWLpeK1YSCxj4b0kyANAATfd/Sfc/Ic/97R+C61wxiFzq3YUcrsHtUV4Rj1Nocj1NBPxFfe8q0TZIOA5qD0EmAeTTGcgCYuh0vh1JdeSqGKkcj0UOeKH96gqzjYiFMImg5sWgs9C9aeud1/FRk/eENAiitIsVJx64F83Ir90tBGoNhUmNtwDE3QqIq5ESaOoHSWQjbGnhSWwHQiEEIVYeMWBgZGWBjcvJa2zNmIzOo8U1SmEpKrUFoHAsJ5gk8eEsBQi6IIb7upJuTIWCYDUHFVl76+qZwOsXLW27m+vueaaMSvbvuqqq7Dzzjt3BGwycr3/6zsBMFxyIEcC1OWy8/j0pz+Nb37zm2NuLQ0MDDQSF2xWl0uW6EZRkgN5dVXv4ay/0UIAAMDMmTMxYcKELAnQiQDIKaO4ip/72yY5fBPZ2klC3zTnubaONg+dmt/nPkvdMde1fNT9zfLly7Fq1SoAwMMPPzxmFV790ScAxt4XSaFxxqF7RmBN8yzB9SZbUNXMJJtyHfpyFSAF3ggUKoWhsnRy+/Be3NOuKKNeetx546lcjjo8yLU+Ko9vLqUx3vWdo/aimx3FnVWgJBz/kAcYlYHcUBl6gENkGrVC0Jdj6avBabwiPHCQtoAQFaja+rVh4TLncz3OJjZEs1LNLgEbgCXI6E+q0xYGWhVetaGV1EwBwBA4q85uSSDTkz9U4Ze+bCSqh9LYAFCdXDwY2wUQxp/5K9fegaeWruh5Db/jda/EnttvgSFjfYVYzOxCrKWiFApEChE2IdS0Br1MHSH6L/YO9IuAzO50O0A1QhQFbwmlgrrC/9tKFCAS34yQWiFEgDyPTfm8xJ/c7Vu+AgSKo0x7DxE53nvywz2H0wfgDUFBffgGnAkagKGN7riKYic5hY/NPg1dG9zKwfcR74HgiI1Qxbf+WtOsOqHPZumki28DE3fsp8BO/9KqBDpeuU6feO4FfPW6O8bE/f4b3zgfhx3WnQlgU7Wr7rE6wiB9nDeEDPg7tQAAwFZbbdX4+9E4miLbcs7/vBlvMh4bbmvAcEDboYceiuuvv36NEwB166YbY0n+mddI3Xr56U9/2tEUczSOY489FmeddVbH85cSAMNNlWjyBVgfCIBWq4UNNtjAA38mAZoc7XP/5TXYpAjgtZlW/+v8BnL3jKaITFaApC146Wvl3o+fxwpc/kzBS8q2pSN0UoQsW7YMq1atwrPPPotly5aNuft6f/QJgDE/Dt1jDl7/qs0it3DtgLU46XPfuqXIOqnk+17qpE/f3/Ro4x9t7qMteni21tpJ4mMpNCsI4tMZy8mrDbqh3n9u2w8kA2ejcxWekwSiyi+Bl9TBP/ok3ghPPo9qe5J2BnpcGQ1HGHr6QUANsFHvvgDR4IBfETACApVSVf+5VjBlkD4rUhUIsSBy7vYqf0DLrERwfoGQJaIVzQ1C7JsYyvmqu6uQS6VdKeD+J57Df94yvB7qrTeaig/uu2Nb3KGoIDT5STDxIKRVULsEwoBz5l0BvpKpFxqha4BbBOA/l6hJxPlf1CaeoHETbnzVn0gh1zoQ+uxV5DcgALntHPnPCwKy4fhsYrhYGo4CjMmP1FRRcXuI0j4OMTXBUxJ5COuBOUcqcmtRlKIAG5FkkWEntc4oX8WKYyVVtEpt3J6CqoWJVQiyBrUSX45qwlpFZUQYSCnX4uRIP1AUIt/mfvvIU/j+rfePiXv9gq99Fe894n0jAtqa4v3qKkJ1z03l2nV9tABwzDHHjLk2gLe//e34xje+Uft7AWop6E83+qmp2nArs8MBbdtvvz0ef/zx6LHPfe5z+NjHPjaiBEBT4kQTAON5SlUkTcBim222wcqVK8fUelqwYAHe8Y53NK4nXld1CpI6MqCTMqCbxICxRAAwETB16lRMmzbNkwC9EACpKorXclmWSWoW2siBumsj1z5Ql+pQR0jkyJ86U8McKdDpGud7U9PfyVw8//zzGBoawuLFi7F06dI+EOuPPgGwLsasTV6BY/Z5LV2goIob2sCzslS9dTJ8qcalrt1Vv6/Lqy809ZbDgxOR0xpbVTm9LDlYBUbmeP5LjmT/oBuXJyiSG6kAfQEDshAGWgWGypLeDTU3QO63ZhVA9UBpDJTWwSOBbOlVCIsnPwUQuRImX54VwKiGhfHA30YVy+pBA1C+fQBODLCk/1r5qj3dxF30nxwrVz6lUi0roSS1hCLg7CvNrk1Dedd2S+slAFIGhDf9/k+46fd/GvYafv/fbo/ZMzdKHOiD6aNy4L0sjV8HDrWL2DwByarNqFElJBenLBRaQbkYQImTrLwTSC3j2lWi+eDbkO+3t/79xUVfRR4Y1dNFmaKhvLGfTdaTrHchOmJlinVA2vhWG1bOhBYUbu1R0fVgOS1EKyh3Xo17biHXKOI0BiD21vCRf+SZIQof7ZM4cpsKS2sebeSPtJ2IMagYjqpEdcMpAZGxIMWjSrykISIAAK789YO49f4nxsS9/rwv/guOOX5ezwRAkwFgN9LsJqIgrdQyCZDbQF5zzTX40Ic+NOYAW6d+7Zz5X11kWx0I6CaqrJvfpeOuu+7CXnvt1fb4Pvvsg+9///s9zUU35mCd1lon4imtvja95yGHHIJf/OIXY2YtFUXR0bcgNZTMqUlya6xbcihVYAyHgBqNBEBKBGy00UaYMGECJk2aNGwCQEZZltG8sc9Jk5IqB9J5zlMCjBWzTSC+SQ2SIwJywJ4/c7cEgDEGy5cvR1mWeOqpp/D888/3QVh/9AmAdTUGCo0zDtvTAwDeTGsVqm1FEcA1p5OztxhLpDlP2wNLa9uAQCXDVZF8Gw50FnQ83gjN2Ai/am+u53qvwZJ/l7/uJM0CIrRSZLhmHMGgXAyfxpA4xyuWejOxEXwBFOKoMemjUPRc8UyITAGBJDkgE1dnA9ECp1wgMZmXdUcmfg5IimdClTkvN2iwgyDNk/HnNlTuHQBzvgACm0yiAClNlSUvLyhRh9XfI6oSA+3kgoXFv1/z22HJ/2W8efvN8fc7bdOmygCctwSCgaUAUqW0W1chblEnigBxf9cq7UM3UTSeX/hKvCzSKCBDMn0TriCOkdShXUQSCoxtJ73Cl7TEb4bDqDgNjockgGUlfSDMReWdQCCZ2gQUAeiKaJDYQhfp6NQocN4gogzwPgWgfntRnbgPW0h7iw1+HOFe0n7/sZSHyeCdCR5Z1qX39KjezxMlWkWqBdYfxZsw9ihQvtVHR2aLYX7//erfYNEoj/+TceRhB+H/fOOixgpTJ0DfacPKG72cdDWVw6Yb4rq+WR5bb731mJKLXnXVVXj961/fNQFQF5+WA2D8u24ey23wO42zzz4bX/ziF9seHz9+PJ588skRIwCacsS7URPw+kqTJerGV7/6VZx99tljZi3tt99+kZokZwxXFEUW6HUbA1jXgpFKx3PrqNPrAMDdd9+NN73pTaN+rpuIgNUlAHIxlXWqqRzwThVBdW0AvaY65BJImtZASjo1kQ5S+e+D//7oEwCjaBy6xxzsPGtGG/gXp3HpXTcWFRFgqIoohmaQCppUv93vVOwqr7ifGqFnl3Pth0qLVqEpjo7c5bkHPalYWuoHjiS/kREaPDFgHeArlAAwnbjZW1/llrptoYHQ3h5UBUrH8mZfxVfh0yqSQwtQZEkxPACyUP7mrv1yrbgM66L3gMIlNAyZ0oPriqghEEv+Csrl2KlCg0MZvcmhQ5yhHSQALG7zCMqLQBqx4aOsAWPLao5YdUEEBADc+5fF+M7/3LNa6/cVk8bjfx+wi5feJ0EQSGztfO235eMdDeDWiMRCegLFVkBXp1GCcAoIrdrUI5XE3rQTWdzjDuPBZTjP8GC4pCo2O9AzAaCU9QaCGipU0B0JJl4B3kfASfhjFQatcfY3QIic1F4BA28K6NUoOn5ude+QGFAbOfCnMv5VQyaQHd6sMY6lzLkmx8RCaGMJn1fSD8Jxi8rBkrmpHA+EOHTtT6uM9YRXSI+wESmhFLDw8efwzZvuGjP3+R23n4P/+eWva0FoL07/nSpWuWpQkylWLgmgbrz3ve/Fz372szEx51OmTMHChQtrwWuT838dQGvaxHfr3N7pdzze8Y531FZrr7rqqp7AXF0rSW6tNa2b3PNSwJQaTOZe4/bbb8e73vWuMXMNf+1rX4vUJGmrg4B/AYdFUWRd4HMtJZ2Ae13VuZe1JGvmfe9735iZcyYCxo8fj8mTJ/dMAPBjnQiA3P2xbo3X3Sc6/Z7bEXIEUU4dIH4FuXPeiQD461//ihdffBHWWjz++OP461//2gde/dEnAEbDmLXJK/D+qA2gXT7kiQDYqCKWmn0FECteAhZDxmJcoWGhMGQMBgoVVfDSGDffLuAAZlmaqP/WtxdQLnc4XgHpvp4IZSk3nPS7Xr7sXoONxVKLglAhBVoOZAeZqiVzlIx8ys0N3zh9hBvFInqZsopbAIK0C4FYoBg5LfF6imv77v87RCQmbK1CzAy1M6pzsm2ft84bMqm+Bpm8N2+0Bj7VLk1GiDZvVZtCSZVhHpf9aiHuePip1V7DB+86C2+YM7Ot1zyoKID2rvEEaJI5HP+uOj/Ol0E+f5IuIBX1oTIGoVWR3Qapu/SUR0aQoGhBRZGOIYYvJDyECMpCIQLZNjLeiGMpWYnDLRhikqm1A+Y2GCFKRCXHDQJxCoCXxbN3QCQPDc79SoVWFJbsyzFIf77xm5jQLhR+VkGGj+D94fv8RYXiYkrhYjWZtGS1TKrAiFsoMt8YdK/61cLHccWv7x9T9/prrrkGc+fObQSEuainXuMBm5QBOXCXboibCIAf/vCH+MhHPjIm5nv//ffHBRdc0AiIGZzVybWbQFgTEMtJe3shAO655x7sueeetb//p3/6p0YfgG7WS6/gnwFJrvqcaytpGq9//et7VjKsq3HjjTdiu+22a97gZowkc/37nVpH6qr8de/XLQlwyCGH4IYbbhhz++SUCJg0adKYJABy7QTpeU59AfjYeyUABPyvXLkSzzzzTB/890efABhNY/L4AZz27t2rC5nkrfGFryMHbqnMR3J1BrYuO73q7U9M+rhPm0zupDJeVWWrG5MRs7ZUOk79xxUo0756yD3pbT29FrFcXhIBsjKqYC2m0vfOSK5EHs8Pp67zIu2OAJtI0DUDz+o9Wo7B52MSwChz42+6llzh6b1C6oDyjuzQqu0qYGPANGOec+KFkJHPx1nxYgInUYfeNA4ErABvzvf5y36JF18aWu01vPXGU3H8vq+L38fayOhPgGWhdQCtCLF80EBZAgMtHcvZybBRARiyBkppaKUqp333GkNDFUkjqghFCQnaqSmsKC4QfASEp1FaZ2IGhVCzft0oZYl4UwnwDkvXWuud97lSb+jaoG0CKQ5C+0mcRBFe3JML1Ul2kYZx9J9WcY89EN9HOPYwiukjs8MqlYAAkHLxkSZO2ZCWG+OTKhKtP2KVUbgfKa+YkNeCjakivpBFqQEAF9xw55iI/+Px2c9+FieffHIjQMupLtKf66IAA8Fpov/mqmW5fOmyLDtWbR944AHss88+Y2K+FyxYgAMPPLBnwMYb6yaZb7cqgV5y3Xlcf/31OOyww2p/v/fee+Pyyy9vBPp1ueF166rTa9VFqeUAVaoCyH3m0047Dd/61rdG/Vraeeed8YMf/KCrdZRz/+9FBj4cAqDTYzK22morLFu2bMzul1utFqZMmYJNNtkE48aN80RAnwBoJwCefvppLF++HMuWLcPQ0BD6oz/6BMAoHIfvuR123HrjSDrtq5SQ/mFOBIhlyam5nlQrGawrxCyzkAiF1l7GrhDLhaMIvKT/1gNLcpbniDC0HTOiv9UKUfa5Fbm7DokDymfAw+eQc8XYuii9qoppoYsQHxcnHsA9P8jL2YQsAowI/ejhOLUHgb6/HsrHAnLcmwW8rL+lNVXpBXzrKFte4hitrSrdIlvXqlJsWFO1figCkBwFWBErwUNAZ6Nr0Ab27njoSVz2q4Ujtobf/5a/wZyZGxLJoKL3azvfBHKrwr8mGXogvrhajwQaDpUlCvlSlNQBI/3jLPM3VPUWP4XwctI6Yd3vpYddvCiMQYjg47YXdvvPqDWUf70q4rI6t9oTE2kSQPiiZ9PP+BzawFtVslMVP8eYWIUhn7kkwopTMHw13sIZKcYtHLyI5DpRUQU/NusL0YRou9+0XPvLUGk8qJf7hahpwj0lUfPInAFYtOQFnHf1b8bcfX7u3Lm49tprG5/TSw92bkPaRB7kwFrau52aAebAxRFHHDFqTcR4U/zYY4913pAkWe05wF4H6vnnXDpALjYvNW9rOrdnnnkmzjvvvNrfjxs3rrF63kQm5X7XaR11WoM8L2nEZN3rXXHFFWNCUXLuuefi4IMP7rjmupF01xn61fWA1xn9dUskybj22mtxxBFHrBd75qIoMDAwgIGBAUycOBETJ07EhAkTPEkg/365EQDPPfccXnzxRTz99NNYtWpVH1z1R58AGO1j1iavwAfeulNUQVQUDQbK1hZg72X7dLOKeoIz7L/1wL2S+stzFakJ2qrPtt39O+rzJsQQqupxBr2AkzLJGo8BWJDgWxVAfJwVbn1UYskqCHIzT+Xm3ldBO5DlJPHiYaB1KkVPXeYrUsGEVMaqzaE0lTFbMufsuh9SAzhCDT5HXintKvpOfSGpDg4ES99XJO122v+Qw6691N/7JXhJdnBxV8nm9ZJf3Ie7Hn16xNbw326/OfbbeXa7skIlgBgBQHOLh1YapQPZAqoVnd/SGrSKwgFU/rJF5OzPMX0miucL6hjrDqAypJS2DLj2F0rKUDpEFrqefVPS3IIUGgTWGbBrVfkECJaKpPM2EF7VWg+pHj6GEspf955coTUrhJGs64JM/YwNEnsG+7BiQgifHKAUIqVPfG3EKqKwLm1EokW3CPoMAey0V0tjwkdRJce2Ex/u/X/70CL89wiSV2tz/OhHP8Iee+zRCKY6PdZrlFUq/efH0vi2HIBLx9VXXz3qQdt+++2HCy+8sCNwSiv/aW92k0N37rFuY9q6AXBN/f8yvv3tbzemHORIoNx7s3FkJ7DTSZ2SIwCaWlN22mknLF68eFSvpyuvvBKve93rGs8jEwAp2K8737k0CV6TvcZNNq2nE088ERdddNHLA2gohVarBa01Jk2ahAkTJkBrjYGBARRF4Q0bx48fP+YJgKVLl/r/9UF/f/QJgDE2Jo8fwKcOmesr9v5LmcyvpEIWVfOVGACakDHvAGxZmsiVXLwBtQqO6taKc3n1YlK9847sDjwWAsRUEqUWVffZ7R1RlnrABTZSGfgeZ/qCMy6yLSfx14paIihiz7vykzxZaSEaEPUn+6x5IHLflyqzdvxFoZWLgLO+usyEAhBi3kpjQqQdLDSBNpaUWydfD5LuIA2Qz1Poyh2+tME3QYCS+C6IDN1S/3/bl5hFEuEWkLcBcPZ/j4z8X8YrJo3HKf+wOzRf5dzPT5bxUmn2jskWkTRckR+E9gZyIaoObdF7FTGioP1JMl5FEkzyFFFS0fp05ngCzmWefTWeznnss2Ajss0yMeberzTG98+L4Z74C/D6kGsyqHmkQo7IqFDMQYOSgFoUtIrSCgyZc6a+CnxHtjpuFZEAACAASURBVCS9t3TslOzoyREhmAKgr9ZsaSuSQzRCljwdONGEozSDr4Yhk1Lr/R6sT9uIFSRX3v4Abl34+Ji813fTBtANAZAD/ynQSyXb3cS35Xq5c3+z995746GHHhq183zhhRdiv/3265oAyJEB3QKtpv7+XK93SjDkJPKd+v9lzJs3D+ecc05XBEBOXVJHLKXP79T734kAqFvbQKV0YHf90TaOPPLItrSCnDeCEAAM4FjpkaZM1EW+dWoN6EQE1D1n1qxZo55oWdtjYGDAkwVCDsh/5dy1Wi1PGowfP36dEwArVqzAiy++iOXLl2PJkiVdK3X6oz/6BMAoHe9946vx2q03SZhg5Ry9TdiQU0VVK+6htXGFzQbndGNtZKrnT4R1mx4bV68r87CQOe887ihNwJESlN0tG3sjrQJRn7AJUWQZAzipTgqEKwrtCI+qOmtQkRBa6ciBHIiNEGPFgk2WnVTv2yuXQf4NMoRzPcoW0AU8uDS2hDWKSAVDigZL5AXlo0Oczll1UBECWmtv1CbgXsgMUpVHLRzV3Bn3eRWQ4m1SM6RXnoHFHQ89iUt/+ccRX8NH7LktXrvNZsGw0K0HoFJtQIV15Q/ab75VYjKnIkCqiSgJX7YqMqKrAGLpfTIgBoBeHcNmitojXKW0V2AY61oA/Foi2b0jp+RcW9sulreR0Z37WyPtJ66HwK0r/z5M+NmKvPKRf474APlMiE7fUAuJpmtd5k5aGQz7EyTRmhJVqdrIOtrYkjGmIVWLzImhVIrIxDBqObCZyqqNrAJYaSBkCLckCUny5atuHzPxf+nYa6+9cMUVV3RVwapzu+42sq1bk0AGbeIFkJIA6d9ceuml+MQnPjEq5/jtb397o/lfujFPN+HdVFXrwHzuHNYZvjWBtU79/zI233xz/OEPf+hqXlLVRx2Q7yYusOnnnLFkp9d961vfinvvvXfUraVZs2bh5ptv7notCZHUFAmZWy/dKgXS12xqD+Dxs5/9rCulSH90d18WdUGr1fIkQadWjdw116uHw8qVK/HCCy/0T0R/9AmA9WnM2vQVOPbvdoyMslIAFyTyiDbWvGMXkzdfVbZJlrds5pXyAM3a0GddgWJ3k3NRbQywfH88rAfTaaSel7Db0C4g2fYcJagILLu6f95ATJFjO0Ilwsuho6psMGUD2PAvkW4SwBNiQV6mUNoTGZrk1Zp8EQScaJVKz00Uz8gtGpbM3oxV0DolQeBl31wpFqDnXeRNMFpTINKFKzXeoR6x47oCLrjxTjy4aOQN1HbaemO8503bxyCS1qUFvEKAyREGhIod4Z0ppWYTS092yXNlTSkvJadvWH8uXBegV7sEjwsV2lJYlCHXiyhLqpgIX4k3tmxrj2HPAZn/QuvQGw9aa3TeeU1L/7u17b34wUBQRdJ4S+c/3Wx4iX1ahYBTOsi6oihBf93YmFDidhzjCS+EeZBIv2hzQ8fFmyEVlAwqii6kz6LS+5rC/U88i2/edPeYvc9PmjQJf/nLX7p+fk5yKpL9NpVUAvDqSIM60JdLAhAyILcpPfvss0dl5bZT9V8+T52kNleB60YB0Iscu1NrwBlnnNHY/8/jhhtuwBve8IaO75VzTW8iiuoey7UJpGss9+/cmpXx3e9+Fx//+MdH3Vr6zGc+g+OOO67293ErlMoa/+XWUi4KsJPx3+qQACeddNLLRv7fH/3RH30CYEyNqg1gDyfB1w4UU9VPqWgCo7xuF7WVfhF4aS2CaZjW2seDCZAwJgaOit6I88ElU70sKd8biKLz5HEGJkIGpP38hYv0kwr4QFF453ox7ZOMdUOIiA3WWKYdTOYSJYAjO4YcmREqkvA99OE1NSKKQuT/VM2Ufm2Wd1tU0XyhXUB5oFe1CKioCl1oVT2dlBkmAT/eMA0IBIAHoxS7xsaNfA7defSkEhQeeXopvn7979bIGi60wuffuxedj7qoShVHNCJOpAjRgV6wnyV3uKotDRjakQaRfp3iIj1hkIDd9PqCjTe9sq7aKuXJZljrytCSHfy1RBYKKVUor9wQUif8ffAksFbWIDxxVpBxYDwHoSdcwPKQsWjpQEWFCjsRh+xZQe0Mck0WWkV37tiUz1JbkYBQC7kNKauoxl/9lSiH4O4n1b0hAAVpNWAwKyQkVBX/d+WvHxjT9/rPfvazOOmkk3oG/90CtBSspSRBHXhrkm/Xvefee++Nhx9+eNTM7fHHH48zzjij80YkkdumwD/9Lu3VxX11CYBu+v9lXHTRRXjXu97VEwGQIzGaznPu8eF4ATSN97znPfjpT386atbSXnvthQsvvBADAwPN33suLSg1/kuVJXUqgDqiqVsVQE6Gno45c+b05f/90R/90ScARus44s074LVbbVwrDQrV8QBQS2NQONAq8W9aqcohvdARgImku1S11tkvGhs5p/t+Y8SO5VVFMyAmy3F4CLFs8j5saMePp278QGIwGAsdfI82G8mF43MEigdD2mWTS3yaSKQd2LIhgUDeq5IzSxVU1A6ISA6gcqIHqKdfSBXfGlD1gRdSzSfDupDoEHLhgRCZFqIGLQHf2IxN+qxLH/0VEgm87N8GAuGmu/+E6+9ccxv2fV+7Jf72Na/0RIuNlChx5nvSleKTEHyGvIrTLiQ5QVOV3BNCysIp9H17CyiC0WR6zwGS/Yr6RBIm3PFZX5UHKQxSF/8AhIWoUtTTHua/OvOlW+faufMHw0R4xU7U+kHqn+oaces88QIR4z+R/st179c35Q9anl+0AwTjNrQs+xe/CzHGtMSUlJReIVGi8pkix2KKx5S5C54GDPwRzCwRSJwLbrgbDz21ZEzf59/85jfjyiuvbARZdTnsvYAx9gqoe7060iBNBqgDraOpFWDDDTfELbfcgsHBwex8pt9xTYZ/KQEwXFKgm57tdHTb/y/jfe97H77yla90TQB0Wk+9KgKa1h9f0930Km+zzTZ46aWX1vlamj59Oq6++mpsttlmtedM1kQu9i9HMnVSlOT6vXPJEd0kVfDoy//7oz/6o08AjPKxy6xNcdDu20VyZ532EVL938KBf4uk0hYoA8ldL41DRyljTJb+bMZnE8Dv+81Zvu3OZqFDW4BGaDEARFqs/GuE6qyKKsVeKuyqs0ENUNNHmcb6idSbK1wOwEn11fvggYwOEQCRVppM++DnU0GMAcWR3wQzQyf59sBcQKOqSsEi+y9N6Sr/RTCos/BZ8SxH56q+qAkqMiNsAiplgPKJAh5AR/n1cfuHtcA3b7obDy56bo2t4cHJ4/G/37VbbTsHS+89cNYKruPBG8oxMOXAvYq4UZHbf7CxYEVIyL2vyB0dEUQhbg+RL0OlWggxddb3tyMYLzpDRjizSO/VgEDEcGRgCiwEIDOhVeiY6EnbJ1qU2iHXXmXaqXyLhxBN1X7bRsoGeSWZUyaZkPgEROkN7hgK1w7EUZ9t0t/kDqRUILGElDFuLuX6kWMS4iqkDbQbKRlr8en/+mmcODAGx8SJE7tqA0jBeycw1okUSNMA6iTbQCX994qSjHkVj49+9KO4+uqr1/m8fvzjH88qK/h4GUR16snuxQtgJAmA6667DocffnjXn3vcuHF46qmnOj5vuGRSJ4Ip/bmu/78bJcBJJ52ESy+9dJ2vpeOOOw6f+MQnMG7cuLZjrgP8ubWVO99N7QG59+h1faWPnXbaaViwYEF/g90f/dEffQJgtI7ByePxyXfP9RttBoT8swe3Yrwn+fQ2Bl3GILjhSynYmZ5JZZIrdLy5D5GC1XME8Ph8dIq2k8q9ALGq1UB5B31lAxiQg5fIM99ioEK0nQAirbTLDAcZkZGdP2JJszdWc33yXrYs8+XmJlUChC9OIgYsEQsqtAfIPPnkeHJHZk+4EMUXAA5XjuUcVKSI8jLqQP7Q0Ulag3eJt159IWDJ2vj8hbkJMuqHnlyC83/8uzW+jj+wz2sxZ8b0qA+9DXiQSWUApeIUH9YYkPg1uKp06c5xi1QuMm9BBULVY9Kqa44D9BV67dasoeo7ovmGlVYKltNXTy6NgfIqB+3SFpyhoA1xjuEmGKr8opQoSb7vVTCOd+MquSJSiJZIFCPK6gcQ1cDXvChopOWmzbSMNvvat2UEkO+jG8nXQ+IvFckSwrVNSoTkvIaYv+DTECICq/d9aukLOO/q36wX9/rzzjsPRx55ZOPmPY2hykm4myLWmkBb7m/SSm2TmVsaIbfHHnvg6aefXmfzOXv2bFx77bWYOHFidj7TPu0cyGryAei2z78XH4C6ceaZZ3bd/y/j+9//PvbZZ5+egH+3BEA3ayslqoZLAADAzjvv3BWhsabGrrvuigsuuABTp06tJdmqVkodqQD8XsQYn3AjP6fqkTQdoKkFgK839hzodo3tueeeuO+++/ob7P7oj/7oEwCjefzjXjtgx603iQz1ZBMtknalVJDbStUclVt/oRFVfOVVWG4fzkSoWktFLkjplZeNe4f1pH9Uqptl6YAYgomXfDEJqBKAFo6j/bPL+2vXg2wAF0Ho3rs65CD/T0B5qOwqym+HVxaYTMsAkOTwssOCMwgUI0Cp1heuPaD6A+eC7n+0kbKiSlEooaEjcGScoZx3lidgCMC3dcicyXkbMsa3TKQy+pCMYKJISAHGN9z1KG76/Z/W+Brefc4MvGvXOV6pQZg0SOzpbpA6zos0PzKdM8EjABFwrqrx3kTQmfkJ3peKe+q/AKpwx0QW2szvSlm/JsQzehKJAGvYrCEYPloLXYRISfHRkOtASANDRnnS+qJoTUFx+wPAKZI+tjBjbBltYBHabUrDKqP4XsPP9x4Z0hZjOdXDhvdir4T2AI4Qg6VUHE1p28mIij9x5IwJfhiPPbscX732t+vFff5Nb3oTfvjDHzaCVQblPIc5AFWnFMhFuNUBen4vMf/LEQE5wPFf//Vf+NSnPrXO5vPf/u3fGl3zGcQzcEvVDXXArBeA340PQF2bnwDQBx7ozefilFNOwWmnnTasueuVAOhWDZBbWynxlFvL559/Pj73uc+tk3Uk0v9NN9201lxPPov8XgiAysOkiAiAbgmlJoO/ppjJTgTAHXfcgb/7u7/rb6zXBrjJnBdJCZAxMDDQRuJIxGA3r2+txbJly7IRsP3RH30CYIyPXWfPwEG7z4l631UiI5beWl8BBjIb8GAoFlqFHQgiKbCJTPSCzF1+57PKbdyTL8P3YwORbblU42UMlVUFPJVvV+8TqtWgGLX0vWKDwdiLIFYxhJg9Jh6CVVxoI+DyI/sLSAGzMvgJHy5IySlOzcnCoxhGORoPVis1RXDvT1zeFQOwJK0ABPapMq4UUJaGzgP3Ttuogq6Uwr9e+Ws8s/zFNb6GC61w9hF70UUfqwAk7aDaTDkgSAaA0ioyUOgoMSKWfof4RqkUK1QRegIelaqi/aTFoKqgUwwl2v0v2HtAAH/1tqa9H9+1ZVgTroO08s6bPZHRS6qDKF6MtVAWaBVFYpYZGnuMq8Ib7zcQE2Pc2mJsILHEg0MML4O8XkV9/J4b8+s5pILYXMoGxzGK4aNrj/E+DyYkUMjfGmM9EcSJGXIP0AIWSOgjhNpDTy7BN35853pxn99www3x+9//HhMmTGgEZHUKgCZQloL5FLznyALjPUTiJAF+vFPldv78+bjmmmvW+lzOnTsX3/nOd7xcu2lznkq2c0BfKZUlO4Yjy+5VAXDTTTfh4IMP7nkOZs6c2XUcYDfrrQmgp54QdeuR5zElAHKvy3N1wAEH4I477ljra+m4447DySefHClJmqLbcpF/8rycP0C6rlIwmP6cEge9xsZ94QtfwDnnnNPfWK/mkMi/8ePHY9y4cWi1Wmi1WiiKAkVRoNVqtd1/6hQcKWlWd15zJJE8tmLFCrzwwgtYunQpli9f3j9B/dEnANaHMTh5Ak49aHcPUFjAy1JdAX0+nk9TbnYbuqwq6YDkrNsIRBrfz6xRlqbtC03AM2fRKx0bECqqqLJpV/XlH17f/9y20QqEhxAaim6+oJ5tQxLxcHMNJojea0BFafKuktte5Ww5YDTkwIly7QfWVelLkZpDqs4muM170ArX8x9nmAsJUkqPsyd1KuBoE2AlZogyj5pIFJOLXLTWSbqr81BQIoNNSIRP/d+11z99wv47Y8bgFE+oKKr8+4hId245LjK9USjE2fBprn1Z2kCwOGAsvhfVOgUUdMYnIYBgJBV1IdhM6VQouspGt1Ao3PkpTUi9kHNTRD33KrqCJXkjXfcFtfSYMkQ/WmoXCTL5uMu+UsRYT4ppD8IRtcMw0WGMc9pP5fd8Rdhwjcv9hdsiUlIOiBUM1hE7gfCjaiC1Eoi6Z8jdc/heJOokbiH57YNP4nu/uHe9udd/6Utfwgc+8IGuwVkK1lNAVgfgcpL/XIU217+dGgN2yo/fbbfd8Oyzz67Vebzgggvwtre9rXnj0WDUllNV5MgBln93SwD0SgJ85CMfwcUXXzysebjkkkvw93//98MG/00/p+sk9/s60qqTJ0Dd2GqrrboyDhypMWvWLFxyySXeRLKO/OFrIJcAkIJ3mbPcuqtbJ6xWSee0k6Egj7e85S246667+hvrDuB+ypQpGBgY8CC+1WphYGDAz+348ePbfFA6XddrkgBI32Pp0qV44YUX8Nxzz2HlypX9k9offQJgrI6T3rkLNp02OTtzIfJNw1JWvIBMMf9KNy0mkp6FHunklkNvF6LYKhBXgSrxBBBHd90GIMj1neTf2nkGMAAN/f469LHbQBaInwBX/tnR3nC7gft/IT4t9HBr14fNhm9Rzz7Iod5WhmesNBCywZD8G0n0IbdbSBRgdfzB8M/7EHjiINR4+bNYcE97uGh0YvDHMniJiuSqKX9R/GXxcvz7NbevtTX87j22xS6v2iz6ADyXSiXtFu6JqZSUz0+UI59UrSXpQSlAae3Pcwr4VRJFCEoYUAgGlV6lQKBX+titMZGqA5BrglteqvhKxecxSSEwzrQPAEons49iBmneKkCPhLwL1X1NAFrmmaX5ct1za0gEfJKqvhyruPvzOTHGus9GlWaFqBUiBQNi+CceG5peX7dtcBAbWLpr88a7H8X1v3t4vbnP77fffvjWt77VJhNNN5G56L5uSIIUhNUB/rq2gLpUgDpQppTCiy++iL322mutRY6deOKJOOmkkzpmoXdj+pdu2nMtAjnwNpIEwDbbbIMlS4aXcnH44Yf3bPbWi7y/yZOiqT0l5ylRtQ6WtQQMAHz961/H5z//+bWyjrbccktccskl2GSTTToaNzKYyz2WA+t1f89zlP5tbo3mQGXduPnmm3HIIYf0N9QOwE+cOBEDAwOYMGECiqLwcvzx48fXkljpml8bBEBTm0hTO4j8e8WKFXj++eexbNkyLF++vN8u0B99AmAsjeP33QnbbDItGPlFPc2hSi4Al/vFUiWAdZv1qKeYQBGDc2uti6nTkUM6A/vgfh8q3eJ6HiT5AohscCTXVaWvkEqkABkrlUbvh+/fR1PLQen7tQkRWuuN5ARKxvnoqurR9/Fw7cZrATwH6TbHAVZefcF93oS7dJQ+EKvTQ0JB6UqyXiLu+v9F0q2UDQ72idFjqKoGwFv4TUKs4igd8NNaeTk8v8Z9f1mMi26+e62t4bfu+Ersu9M2capB1IpSgWmZG3HP50g6OVcFEUcqE2NZUNVcCsitooj6z33agCWISms4BvpoM98U9YKXQlPrRwVqA/yV2EDtfDqCqsXEANkBdjb9M6R8gVK+/78idYLvBTv0RwQUywZkU+A+BysjuC2I39MI0eDWpBbfCtdOVCkdNJF48WfKkTZhAxNHN8ImvgRl1T7APeueLLDAj+98BDfc/ch6da9fsGBBx026bztK+qmbogJzMv8cgK/7d66FoE6+nRJ2ixcvxn777bfGlQDz5s3D/PnzMW3atFpwy5vnNKc99++muL9u/2a4BMDll1/eURHSNAYGBno2z2uq+KdzmK67unWTi8vrpACoA1RnnnkmLrzwwjW6jnbZZRecd9552GCDDTBp0qTaazA9n6n8X9QAubVR5y/RqZovbZydFCu5uTv22GPxgx/84GWxZy6KApMmTfKVewH7YtY4adKktnsY31e7IQBy9+LRSACkx/X000/7VgH2dumP/ugTAKNwHLzHtthl1oy2SrDP8QZVNS2BKlIJRP3sqKqWldw6xJQJnDLkjC9/Ezbotv0UWhtVJzVHu1GlseTIP7oxrSpLB9pq3K2hUMKiJZFpYE8BG0ATJxhY5gXohksxfdXvDUwp0nrr5yvq3ZY4Ml+6l8crcsS4bHixV6iy64PEu/ARa9abERoyqqv+zxmr+VYDV4WWxAX+IvIEUPh7lbgoiiQ9eBSECDulgZ/8/k+4bi1WT7ffYiMcs/dr442gJy1srL6wFkWhwrkgkkpTqkO7FDe4y2tSwkBV/f9hzSk/J/5LEqEazj4WylZkkwDfKtbR+vNSrYvYnI5vbkprH8eXfuGHNUGGhkAU/acSFQ4Ddi3JEeSYn5ro6USnz/cBmwBua2NTSd+f7zc7KjofhdbezYG9QUq6fotkk1ulBFSqGiYsvFIBsULDE1sq4ilgAVz6i/vw6weeWL/u9QcfjK9//eu1wCwHSJuc/FOgBoRIvxSQ1VVx082wbBpzioC0KmmtRVmWWLx4MY444gg88siaIWzmzZuHY445BjNnzuxqE84EQK7a3wTwmwzaOpEGvRAABx54IH7605+u1rx88YtfxHHHHTcsAqCJDMitl6wxcMN71LWX5EgDXntnnXUWLrroojWyjnbeeWd85StfwcDAAKZPn95IJKVu/3x/b1pTKYBLSYVePCRy11tu7u6888712vxvwoQJ2GSTTXw1f8qUKY3mk2k7ykgSADnSJ9c6lJI+qSlp+nrdGJF2QwAAwMqVK/Hiiy/iz3/+c79FoD/6BMBoHu94wyy88dVbRKBZK1Xlo9uwMRfwGOV2u91ymqctLvm+N54M1zxARSqbRtS/JkC6csHnuDqBLSF+wCbgyCcR2CDh1k4qX5pQIVYEWAxiV31SbHvwJPFqkWwYQWYuEmPlqsMVUIr77wHjWhyCEaJx1d3qs2t/vCFd0KLQldOvscYD2+rYyWyNXe+tqCKMIwxMUHAgRClK3Jxk2Zdl6SXXDJgcvo8i4lIJtZyDy355H25/cNFaW8ODUybg1H/Ywx9De699+MxhA+0pLyirvFGcTfwsGNAGnwVqb9FFRFwJcJYyv6wNjooUc7+oXQE28qQQAkZAbfSlW72RI6dcG0K6IZBrU4fcewBt5IZKlAt10kMfJwh4IqNSnQSlkKJUDaXE8V/FqQOZ3l5REsXXk6LNkwrpAUTcKOYHLZ9RRERd6pQgfxBiTWMTQgvg69fdgYeeXLJe3esHBgZw3333ZSPHUrBR5/CfezzdyKZRZHUKAQZeOYJAXodJhZwyYOXKlVi2bBmOPfZY3HvvyPo2zJs3D0ceeSQGBwcxefLkNmBetynOgfRuKm9NIG118tp5/O53v8Pee++92nOz55574uqrrx42AZCSS7l/d0MepMAo5wVQFyuZvu6SJUtw7rnnjjgJsN9+++Ezn/kMWq0Wpk2bFjn351o/uOLPZEBuTcl10lThZ+KoF/IpBzzT+T/nnHPwpS99ab3bG48fPx6bbbYZNt100+ya5Fal1SUAcuanovIoy7JN0YHku7ROCcJEQk7ZUXfPbyIjOyVKyD19+fLleOKJJ/D888/3gVZ/9AmA0Th2mT0Dh8zdLjLyUyQRL0tTRYvRVprltVVknTijVzeb0sb9tDmyAFCwrrotVclWUaA0JUpncibeAaVz2BfjM65Alu6mKlJh4/ub4f8fy+59rr3cFB1QK0sLreFd/QNIIWVEEokHS9V9Ad3eadwE/wRrnFs+omjAcIg6BjRJ77gudACS1vg2AYkqdO8Y+xFQCwC4pcEqaq8IEX5IyI6gyIi/XILzO8UGIlYJfP3636118HTiO3fFjMHJbV9EUv2FtVTlrz5bMPVjQkW+wExb32RIyBAySzssab2Xg/grKJpIRYRZVbHXUQuAJ61MDGytn+eYaII34gvXknFkk1ZF2JwoSYEI6oXKqFBiPQ3CpWojk00h6QylWLCJogBtzRGKKswbV/6F0Iq8NwCvEuL7AvMkXnVABEC4DuK2BFmHlu9J1l0flo/V+MhBaQ1hQ08xNfzn7/8Cy1asf9WL+fPn48wzz6wFl7m+69zGNifVZil/+nO6aU5fP7dpzgHFnDmgUgpDQ0N49tlncfLJJ+NXv/rViMzV0UcfjeOPPx6TJk2qNWvLVdxSEiCd0zoPgSbg3yT9T0FaJwLg7LPPHjHAdsUVV2CvvfaqBfx14KKuAtoJ8DcZ9dW1oOQIgLr3N8bgqaeewoIFC0aMBDjwwANx6qmnotVqYfr06bUmbBLtl6v41xn/5YBdCgLT53WK+8sBxqZYzp122gmPPfbYegX8N9xwQ2y99db+frM6BAATorm1Lr9P76VCAOSuoxzoTx/v1l+i0/0ivX/VvUf6OmVZ4oUXXsDjjz/eTw/ojz4BMBrHjMEp+Nj+bwh97H5THBuEiSwXYLOuYNTnoA7lh4szvbvxGRu1AoDywKV3WEArJwBG4BSxrJgBa2msN8ML0eqxxNkSM2CtjaIGuTe5AgjBy8DQa/gbIpniwYP5UH3m3HbjW6WpVpxUdVutwvUh05c5xMxOJeVM7RQDiCT61phKeQB4B3khAaRKyoArHEpQSwjoC9XRUGVtFdTXzZVsxKZu/99//xLLXnxpra7jo/72NXjN1htHa8Uk8n85S2z4xpJ2UZgokE+AiuMu4UA/FPlGUBsHm9+JHwWDXi+/dxMr7SsCYIVQMqU8z8LaoEqRNVdo7fvvGSCIJ4dOHDPD+lY+TrDyceC2n5CqUZEDKqRsWBsZK/pNjyNGWkWBsjRBEukgvQAAIABJREFUHaDia96vEcTtN3HVXnkiUS7uSlljnAmgI/IkbcRtVFnVwOoeT4S5c1QpEzS0quZqyPkAaCJu5HN9/rKfr5cEwODgIO68887a/uO0GlmXu56L/+sEyHJgLgfauPLPJm7pZjoFv0NDQ3juuedw2mmn4ZZbblm9+8lRR+FDH/oQWq0WNt1001qgXreZTqutTTLeus14U0V2deIAd999dyxcuHBE1tNpp52GU045pePzWPVTlyzRlCDRCxGQgrKcJ0AT8bBq1So888wzOP/881ebBBDwXxQFpk+f3gjkOc5P/peaQ+aUJ7ne//RazpFV6bUu7536AKSvyeMHP/gBjj322PXi3igEzate9aoIiOcIALkn1REAfG9MK/h1azl3buuu/yZvlNw9qZPhY460q7tX9XrfWb58ORYtWjRsw9H+6I8+AbCGxoYbTMQn3rVbuIBJOs3GZvIFYyI3dBVVrGWDrgkAsaJaqSAH1lR5lp5dlgrnbo5CKLCjupAEOuvmTnFh0nQtOI77tQUwIeSC+xq7mwtphVARyeFAo46r6Jpkz0PGoCBQJXMX5joAOq68WnJx1+S4j8RRvdAaQ2UZuy5C2h0ojUAF9UNpjK+K+n5v9wZ58ofm3c2dgfEVcHlbmYLTv/OTtRYBKOOdu8zGm7bf0gNZsYTQKrRiuJA+8ApRZNAoa6xaZwR0PVBVfkkopYMLv2vDYB8AAf9yXRgbiDIhZbiVRhFJVVpbqWO4X558M1wGgE98MK5VJn0uV8tj50h6nMgticmrDEArfwEhObi9wicrGGrG0YHQYFJMU0tNobRXHWgdTEcjgkKuDRNaDjhpIk3UCBuj2OWf129QFMTpDsFfw0bXmlIKp/7nzWt9Da+tceaZZ+KjH/1oI5iqk+ynVf0mwFb3vE4u7jmZP1fT0o0yv+7Q0BCWLFmCs846C9ddd92w5ufII4/EvHnz0Gq1sNFGG7UZsKWb3bre7G4rqDkSoK7S1o18u+k9brrpJhx88MEjtpa22GIL3H333Y1AvBMJlP67F0VAN8RD7jXTx9O9xksvvYRnnnkG5557Li699NJhzc2hhx6KE088EUVRYHBwsDGGLbeWcmZuKYHQpCZJiYVc1b9TVGCn433jG9844m03a3vI+ZkzZ05cNKL5S9uY5PsjB/o7kaN1965OkvsmiX7uHNeZQeZSR3L36VSV0IkwbmrzWrFiBZ588kksXrx4rcZt9kefAOiPDuPjB+6KTV8xObjlAyQFFvfxUP0tqoywit10pURrgaJQMeueGPKF6mDVWhDk14pAeFzNl425jSrOcRKAB/s2jj1j53VDEnDfby2tAVaR3J0XThxdJVJnqZSXrifcGxki9MkrsAu5goKJ1An8BR7M96q+fA3nSWBtVXUnEzOtFRWjq4kRObRU6QVQGWOjeTXOB4CBEeHa9s/MRo1kaW9sBWBFys5V9EefWor//0e/XetreLfZM/Duudv5k+ABtydwKsBpIZXuOCYymFrC96+HanKYc1CsZbTGtfIETiFJFe7LV/rbg1eEcfMMaIpyZCAsVW//pawYgGta9crL2eW64RUW2g9sBNCtmyAFld08+g2Pu3CjloZqNUcJB1K9L7QOHhrcnuBFFHGfPlw6RZD6B/NNRWqd0LJDSha+pyRJFEJ6aEojkHNZuk2NVmw8GLwTFi15AV++6tfr7f1+xx13xI9+9CMMDAx0Vdmpc1ZPWwLSTW/OyC1HIqTvw6+VtgnIpjvdcDJpUJYlli5dio997GO4/fbe4kjf//7347jjjkOr1cKGG26YBWQ8Ryn4z1X+O4HyOhKg7rFuvQByY/78+bj44otHdD1dfPHFeNvb3tZIAvTaCjAS4L9uLfGaajMFpjX10ksvYfHixTjnnHNw5ZVX9jQnqew/fY8ceGs6z+G7pF0B02TeycRpnddEjhTohlBaH6L/pk6dilmzZmHChAlt6yslAOoIptx9qIkE60S4puesm+u7kzlojhiqa2eqIyTSOenlvqOUwooVK/Diiy/i0UcfxdDQUB949UefABgN43+9c1fMHJwSyYFDxcxG8mPpHW8VRQIyNVUVrQOzKuo1552/lX5mcikPDvbuOGySowa09eUr6i2WanxUlSbAUZAcO+SmB8CgtfIEg6IMcWMr4KzJHC/CTQKQedU5qbJIuQEgsp6z6Re49JYLMaCCiz1EJcB90sq3ZhjnJK8VV5zJgAaALiovAqkQxxnuFfkg1Wju1xYQ7dsDbN0NvjqW3zy4CN/7xdqvCGw2bTJOPGDXiMBKkGZUKUbk0q+ieDtZxyoxsJPoQ1a4IIpzjNtM0vmpsH4lQ5cv2RBJSUSOqvwumGAw1mKojA3xAoAOrQWxM7+LKyRTPjGn5DwBNt9LDTDD5wobyNKYyOlfPm0A8GH+/GdH5Q9gQUqWiKgIs2yZLKDnKSVmpEJohHmTKE9/TwLQ0kSGWTHfNFHEJXuFyIJ58Inn8PUf/269vuefe+65OPLIIxtBaLrpZRBelwyQaxvgv+8E2Dr12Db146ZeAUcdddSwCIB58+Zh4403bnuPFBiJkVtTb3U6p7ljr+vh7wb495oAsM0222Dp0qUjupYOPfRQLFiwoCtio9fq/3DAf12FNeclkWavp+/30ksv4ZRTThkWAXD66adHsv82Y9UGEiBdW7nPw2RTzj2+mx7/pmNI5zL97/z58/Hd7353TN7/Jk+ejGnTpnl3/xwJyfOai7TLrdFuWqOGBWa6NBBlt38+p3XkUx3Ry6+fI3NzpEWa0pF7n5UrV+KFF17oJwT0R58AGC3jQ297PWZtOhiAU1vMXehZNpGpVwVqFVnqe5k8AUlfTbYg4I42kxpPDfDNBhRJSI7u1LbtQYIhIzXNvf6kIPBeALJI2HCAVo44sacGedIGASi0CuVfVw7WgzFydxeQpTNS0DjbvII6WswOiSzQvt9b+8M1poq0E3IgThuwvlIq5mjGhlSAKE+dZd0MEKkjpGp54OMn8sEBP6UUrrvjIfz4zofXyTr++IG7Y+NXTIo5o8TjwcvavI9ElQIg1f4iAo0xCaCVmDraQIq481IBU0RGgdEGwKlXmGSrZPQSpWk9eDeZtScVbxVlQMRS/YLk7HJuvEIDMVr3Mj9P8YU1LB4eCgpWSbUsgHmeX2kdMLY9rYCfE0yu3Pw6BZBS2oN4TUaeUqkvqKoh9wFDBE5QFxjv38AtNjK3fAxiIMrnkQmQhxYtwYLr71iv7/l77703LrnkkloJcbpxzW1qU8lr0yYxt5lsqgzzYC8ABm58PLnWgKOPPrpnQ8DjjjsOp59+erRpTo9N8r7l3ylB0OQyn75OXcUtB7q69QmoGzfccAMOO+ywEV9LAwMDeOihh6KUhG7WVKfqfy/mf52UFqkSIDVpa0q4OO200/C9732vpzk56KCDcM4552TTNdJ1z8Z/qfN/E7mRjpx5XwrmcusnVxVO3yP3u1mzZo04mbSmx4QJEzBt2jRMmTIFG2ywQQT+mwgAVovU+VekRORwCYCc9H+4hn5NZGQnki53n22S+efWd+44RaHVTwjojz4BMArGwXNfjV1mbeY32R6AwEbxXlLJ95FgFlGcH0iGy3nfOZZaSANlCWiSs79CUt2nHmufkR451nPx3cbAVlzQibhIX1eM2TSZ58kLcx+0g4xeal+a2D3eP8sG4B+UBu0tC5C5FfZUqr/eqDBYowkw4sx0iQGUYxGAr7XCUFk61UblRWCNEC8O6JsqYcBEZX2bXDpBdSAg2EeuWSJWHNC79Jf34fZ1lJ8+722vxzabTIs+BSsyDPWI8x3CkpxdqsPGWpTWoKW1/2zGhrYAOCf9EMlXGS8iMZUTfqksDaUExF/uoYUjMt6g/vTKF6DlznVpBXhbKJ8oIL4C8MA3XHNBCaDJ3LLNITrtT3GIX+Yt9egIMZ6IFRGojDMLIrFSI0z2DmF/EPa7MFEfv2qLefRtPYmyIxdTaklpJO0sQQlEm3MAv3lg3ahY1uYYN24cfvOb32DGjBlZUBZ7Ltgs0Grqo07NsnJV0JzcNv13CtbYFJDBf25ze8wxx+CXv/xlT/Nywgkn4OMf/3gtMBXwn3P9zwGuHPnRbaWvGzVAropXNz760Y+usYrtWWedhRNOOKFrAqCX6n+dyqQbcNS0XpuIAH7PT33qUz3P2+GHH47Pfe5zWaAta5dJJPkcrVartp87t7Y6yftz8X91xECutaBu/PM//zPOPffcMXXPmzp1qvf0yIF/BvW5a4rnMqdmylXQ66rldf38vQD2TveP4ZAAdeRP3bVYN39N9zQhdZcuXYpFixb1EwL6o08ArMshBmocQ8fyXEtVtApISYZ9AEae/UQsk+Ye9NhYTnnTLQFA0j/sb7ZJFRQJ8GDCQqqFbZuFyAk+dvoXfwD+Eg5u6szsWt/nL7nnWiLTmHZwCFuq9UKKSPUWNsSM+UqxijF3mCt4F3itqqx55R3/qRpLBowMxliJ4OeBHPsjNQIQtUYIYJP5rcAjfJuBgEnOkZdx/o/vXGf56e/efTvssd3MKBNeZQzvCh37KkRtJe6zsiGcdrJ37mvnv5V/V9XtiqBqFUKAwcvP5RwwuNVRST3EWMYGmzFRIHGVAre1UpXZZGqQSQqGqAfb2uTas34OIh9+AvYin4cNSQFIWgdkPXuFj1PlWEseB4aMQT2pl7TEEHFXzQeZj4I+m9aV6sFaRwp6ykpWfGTI6VsMwC0ZfC6rdf/j3z28zlQsa5UwmzcPZ5xxBlqtVm0lqJMku1vH9lxlLSc/TYkCuTeXZVkL4HLRgCNFAKTvJ8fPEu1Uip37XE0JAN1W9bpVAdSNbbbZBsuWLVsja2n33XfHZZddVpsu0Q0ZkPtvtwaTOalyXQW9jgTIqUtGigDgtSLrOOcvkavI58zcUpBat3a6iW3rRBDk5n/u3Ll48MEHx9T9bpNNNsHUqVOxwQYbYOLEibXrifd+TcC9TuqfO1+dgPZIGuOtCRKg7hrKkbh1EbDp6woJ8PTTT/cTAvqjTwCsq7HL7Bk4dO6r29z1AwiJK2QpQRDfFBw8UqH6XYHrAFgDCFZRJd9X5j1YV2QGRsdBJf8QTWi8UaECvw6DDRUbgrlqIPfTy4GKDL6EuOqHvm9x7BdAJ/36AoI8WVAasMueNQlgljZmBBf40EpBLRTkByCSb5Fei/x/yCH2ljMJFPBfyubYEx7Gvyf3a4PTHJIkAOlxZ0JBEg3Y28HA4vTv3LLO3NN3nT0Dh+z5aj+fEWmkNEpTIkTShTWnFSKTO2srg0dN6owqWlFViQ9CJIhSw1ECRaHhlO1VSwYD3ijNIig5UpImR7zJ8XuQ5Bavceeenf9Lvw50FSHojkFnTA9T47y0ZYdjB0VNYayLyERQtYh4QJM6R/w2uA0BAIZKg4TzCG0+0XFZn55QPT9WA8gG2BMTmc8iCqTqmOk+lfiRRJs/a3HZOlSxrM0xODiIn/zkJ5g5c2ZHsNbJUK2pZaAOpNVVmnRC5DY5uNeBNqUU7rzzTixZsgSPP/44Fi5ciMcffxx//etfsXDhQsyePRsbbbQRdtxxR2y44YaYNm0aZsyYgVarhTlz5tTKtrn6nwNP6WY4NwfdbuK7VQN0QwJcdtll+NCHPrRG19Nll12Gvffee1jgvxPhNJIAKQdgZB3l1tPChQuxYsUKv5b++Mc/4vHHH8eiRYswdepUDA4OYtNNN8Xf/M3fYPr06Zg5cyaUUpg9e3bbsadO7J6UJkIpZ3CZA6Od1lSqJKjr/W9ayzkp+xVXXIHjjjtuzN3vZs+ejQ022ACTJk2qXVesekrnrNO67Pba7jYydV2TAN2QBLn7fN13QO71hAR49tlnsXjx4j4Y648+AbC2x8zpU/Cx/XeJwLKvsOtAAoQ4rYwczYF934vvwEOh2cRLBcm8dm7c1hEEiCP2QCA28ejyD4gxmUjZ/ReiVD2JKFBIjzVOO5A3EkLAOkSs3JdoaeP2gdD/TD3b3J9Nn0MekypyoUPPP0uT4eZNPrPMhfSdM9AyVOUXgCgy6EJX5oPGV2+lpx3ecd3SvKdXiVRTBbhxO4i0RVjEGw9jLZ5c8gLO/eG6c0/fduZ0fHDf14X2BAGCQGgrcb3l4v1gKDYxZ1AnhEkAvcqZ9GmfLS8mi6zMEDM6eW32V5B34rYKlfT+G4oBlPkNUvmgxJAqttbKtxloHUweq3UTG/vRaYxabdoco+lOyh4FonIIQDsoXownKNDWTcItD0z6aW/IGVQoaWRfuOdYT7IE2b+bR7eJ9QaYgD9X1vkMAOFeIMRBUNFUz7/0F/fiNw8uelnc+z/5yU/iwx/+cLZyW1f174YIqHOKrpPE5kiC3Psx8Jfrc2hoqDa3vM7Mqq7KmWbVMxkhr5sDa+nmtkm2Xncsdf3bI5ECsCar/zLe+9734gtf+EJHFUCv1f9Olf+m96kjZlIDQFYBpH3ddRXgnMw7BZG5zyzrJ1WOcEtAXYW/CYjVmVCmP+f8K9Ln1XmDAMA73/lO3HrrrWPqPjd58mRsu+220drstL7SNoo0kaSOIOkG1HeTDDDSJMBwK/6dyIMcAcv36U6tOkICPPzww/10gP7oEwBre2w0dSJO/Ye50cxxBd2Yqupd6GrjL5VHlTiIl06uq7X2JnxSnRSAIDGA8U0vgHkPUGATh/92fwLPXEP5fuDQY8zu+y5fHaGqyy0AEgvGLQgcQ2ioLcJGCgKJLYR36Bf5uXxuqURyHGG82XXxiVBkPAdvVMbKBKXb4+jkvbj9IQK1DmwZY+hzIALFQLuyAhEBFNoLtKo8GmBjosgCeOSp57DgunXnnt4qNM7+x78N6QUIaRbhnIrCw6UyUH+5AFJfsbbWqSXCLMl8cG+8LlxcpgoJEWz0F9z1ZX4r6UfaehC+OanPHzYisKIKvLS0UEyjUuG6ZENATSC+zG0uZT0ROaJ0UL2QIwQRLMG4T9adT8pw4FzRPaStFQhxywub+imKcKxILUWqChOZbyre7NPrMFFXevPLQGpGrRl0jX/tut/ioUXPvSzu/a95zWvwn//5n9h88807bv5y/fs5IFX33Dqw3w1BkDq4y8ZRKYVVq1a1Af+RIADSx4qiiEiAnLy6rupfZ47VabPeRAh0s3EHgP/4j//AJz7xiTW+liZNmoRbb721zVeiWyKg1+p/J+BWd07S9xOPCgH/AkIEqI8EAZAC+zT2j/8nz8tVp+vWctP11CTxl+PKxcjlxq233ooDDjhgzN3nZsyYgVe96lWNJGc311WuxWd1CQC7BhWTvUaF9kISpPe91G8jlwiTxlgyCfDAAw/0WwH6o08ArItx8oG7YdNpk73kV8B2BfY1meCFKqevCAcXvVDRT/ryWbrsDcjIsTuY4CkvlbegDHYyJFTBny9Up2sAhv+yd4BYPoexiAzhPPDQdHOLeskDdpMDkDSAQisPKkJ6Qeizr5LexEuAwBK5jwsYAeJoNXb1r8z/oqPJ+CgoX8G31gjC9eCTVRCVrNx40Gnr2GmIpL3q50ZipijzdfsDT6xz87QT9t8FW240NT6vCD3zAja9JNy4XnHXpiL97qU14W8sovObqmKU1lGFvgK+scGcsUHaIW0ySrmNHp3HAOxV5O8QezuEa1HrYG4YyLbgaxDUHI4Ec5GRSOOBEJghBvDeglIIPf8545jNtHIk8ns2VNSeNOGbtCLSS9UCsbBmw3yySqAowvVaGuuVCcZ7NyRJJOC2B97UAJ/73s+x7MWXT0TRpz/9aXzgAx/o6OLOG+DUUd1fbzV9sTmA3/QzbyS5simJAALWeEPZlFu9OgQAS8OFBBDDNvm5rqJXVyHM9annwFoK+jupAHJj9uzZa21jffjhh+PLX/5ym69EHaE0nP/2AnpyLSWyruR/4i/BFV6tdUQA1L1OLwQAE1gp4Of/yTE0XRN18W+5qMF0rXciBJrW1f77799ztOZoGDvssAMGBwcbwXinz89rYHVJql4JgG6e0yu5uLokQE4FURfRmq7p3HjmmWfGnK9Ef/QJgPVinPjOXTFj+hQkhUgUzvBuqDSw0v8u5lygDHWI3Fr630ti+pIvMBtvvn2/tZMuF5ypnjKvUeRee255AE/tX84sH6765k04DmNj8E2tAt4BnSMNIdVLTekIoa0hBXTcoywVWVFKGItIeVDdLNFmlmboda1F0soQkzKeTHD96yI9Dzfr8NryszjUU5HaeQdowM2duNKH6LsAiG+48xH8+K51a5522Bu3x25zqp5mqUDzOQOCg76XrFMUHlfQVaKM0GRyZxG8AxTNg1TdRU2iSGWiow2djeMCKXuTPSWqZVeB2FahfXuJkfQMRwgpFUwiRbHh/TCYKPMtNbHZoSglBDhXKgHyHiDwrCnpINo8cbsN4uQA7eL+Sud/IGaGkOo8yf79a8mmgVQCkmwhGzFW7ZiQvRkpeIQYEAVSSCaJiUh5z1O/ffM687FYF2PzzTfH97//fbzyla/seiNa99+63v/0uWkEXgrWGfjzd8dLL72EVatWtUmmu9nUrg4BIMBNQKEcX6vVwoQJExor/02mbb1ssIejArj00kvx4Q9/eK2tJVEBbLbZZh3PRdOaajKb7GYOm7wmlFJYuXKlV47k/Cvk3LLiJI2GTMFguqZkD5Sub5ZF83sNDAzUEiV1bTK5CnbaspISSTkFQB0Y5rm75JJLOiY9jMYxceJE7Lzzzh3XTN26lPvLcNtUuiUARkIJMJzYv+G+Vh1xlFb+c0kbdeO2225bo4qI/ugTAP2RGR/eb2dss8k0itiqNugKzmHcGXspJVJ/1VZ5ZrDkZf8ejIa+Z5ZJy99qzdmq8d+xQ3iV4Y4I5KcmhUBsMpYzWwOBAaVDm4B1IEpc7j1YdvF8xlVupYIr4KgymTPO90AHybcAMARDsiqzXbeTKBZR1JpUmEWJoVWsNGAH8+A3wKoG46XOKqJIBMyF1gyp1FbzbCOSxdiYwFC8MaNjPf/6O/DAOpZO77vTNnjb618VRRsqFVfhFakBNBkfKtV+LpQ3mpSkB0TntSh0iMVTMoc2UlNYq3yLiKxtldyiqjVCbQEk668q+wIk2KsgtdKz0NBR8gUTCz4Gz8bnMagSwvlWpAQSfwEmPeTojUtNKIqKzCqNvCRd7yqOZPQqAq0CAEdqEmp9TKildWfcmtMuijNtVYKqDBCHyrjlRSs5VudlAMAqG7X1CFFyyrduetl9ccyfPx8nnHBCbZWMwVEuB5sVASn52gS468BK7nXkfUSinXNJT98jRyoIkE8TXzptYtONa1EUKIoCAwMDw+7pbZIed1u5bRrveMc7cNttt63VtXT44Yfj3HPPbQO0vRJKTXPaKVmhUxVz1apVnkiqc3DvBPg7EQAM9Dsdl5AAvM9JjShFAdMt2ZVeE6nkn5/XKfYPAN7ylrfgvvvuG3P3to033hjbbrtt4/VXl07SJPcfCQJgTZhcjiQJUHdPaiIAmuaqLh1Axr333rvGvUr6o08A9EcyDpn7al855T57ztEGuXt78B85l6eVfuMr6JZ6j9khnN2/WY4bNpoidXc3Fh81qGurK1Fvte/jt74f35L5m7joiymhJpJBwFTpHccVJZ0jiu4LhobKGyFWx6fJzMzCGpob/6UDD4CYqIhXcPVa/rNoAWjax8CxK7sCV/dpA21DK4W1Btq9sZdi0/wEubXxVdlAbiQeANbi85f9HMtWrFvp9A5bboT377NTmE8TXN+lmswu8mETFNZ1ZBjHjvHkQK8L5arj8R2H57F6TyHHXNWezl2UKxwb9JO/RKwcEAUAA3Wp2lsQwWFt5AUgbRzt8Yfx9R6Z70FM9Uy01q1NKDYyTYyAGy1hduVnwC0KiaIIcYtevULPk+QL8TIwFtA+mrR9k22894X1SSE+uUIIBa+kCZGmf3l2Of7tyttedvf/qVOn4rrrrsMrX/nK2g0k32vrTNRSoqCp9z1nPJnbgKebSclR52PIVTFzfc0pEZCr0HYC6TwfAwMDtRXCbgzCuolyG678/3vf+x7mz5+/1tfSxIkTcdtttzWqALohAIYLkJpc8+XfZVnWEgDS6sFAP6dsSc36OmW9N4Erlv/n1n4dqMwB1DqQtjopEhdccAE+/elPj8l723bbbYeNNtqo43moa7tp8qoYjQRAryRAN+e/ac00raO6uM26++pf/vIXPPbYY31A1h99AmBtjnfuMhtv3mFLtJXQbZD8liaYkAn4Y6IgjrCD32AzUEy/qKRyzaZ5FfApo0OJbjJRTrlt66f3v3PV1tJaIiLYLCwAEGlvECBfFAEsadfyYKwCf0e39cELGPJEQ9oCYCPVBBwo80RGZF4X0gyUqBVIgm0SgKcTA0WW5wtxYjjqj9IYxFxOUzY6EjIi2nTIRhqxfP6T3745qryvizF9ygScdvCebQBSqutcSfbgw/kvSKa8JXm9ANdQ1RF/ChWfb6gaGaYig0x3XZBpZeVf4aT4WkUJFpU9Q0pEONJNheQMvtP5VhJSbIjKRYEAmRyXsX5Np877ccuIJR+F+Jov3OPGWrR0Ebvwu2MS4ovN/Xzyh7v25B7g20yizxVfdxITKMQhe5RkDR0Rr32TXrNu3h9a9By+fv0dL8vvgKOOOgqf/OQnseGGG3bczHbTCpADxf4cZpzOu6nqigdASv42Aerc904d0VB3zOnfcI94URRZZUPTYznH/24JgBxgyY11Uf2XMX/+fJx++ukYN27ciBAAddLhbs57nQxf/lfXxpLzY7BtJr6x8Vkuwo/JhLp1LetJjie9PurM53LXTRr3l6v890oAjNXqPwDsuOOO2GCDDboGtzl/hZEkANaU/H9NkgDDIQBSb4BczGb6nsuXL8cf/vCHPiDrjz4BsDbHrrNn4JC5rwbFofsKHXiTHJkyhd5e64C/8l+c1seZCQPg4/4sEsOvmhumQwsh915ivQI95IQ6AAAgAElEQVTYNSnBYCuw483+DCLjPSEldCrXE5JAB8lzXAW3zjsgSOU9YDSh0lRStFhbVZT6qNkgjoEJA3iek5wqI3WHlzg5dlPnqTTWQFkVXRRRWoKqKqyle171eaqqciV1VygN9TXSWnniuedHTeX05AN3x4zByaG33REVxplFKqiqzaOs1iYTQ8YyyCQyxgbCCaTq4BYMyyEKzlAyd47Dz8qrEqI2GgLzQjIJkPZ/rxWd+yRnmoA1q0uGSkd0UQtEFPmZuPDLGhNfDgbnSmlvMBiIjkAOCLng++y9CWZ1cTIpUvmKhEp/oSXSMhhUpgDN9/KrcJY8+UetNOkmxvsZIG6XkevqoSeXYMF1v33Zfg985StfwUEHHRTJtzvJ2xm0SHU+3TDnAEy6WczFa9VtJFPDtrqIvbokgXRd5IB5DrDz8Qnwz0moU+frtG2izvyv2812J8D285//HAcddNA6W0eDg4O45ZZbulIB9EIE1IGluri/9PzyOWACoMkNno0mmwwl69ZvzkAwPe9p5GT6/p1Ij/SzdkMk5SIuc/N71lln4Wtf+9qYvJ9Nnz4d22+/fVdAOeeJsCYJgLq/HS4ZMFLS/25USWuKAAAqH4BOrQL90R99AmAEx8zpU3DiO3eNQE0qfwbgwa7IcK0HjirqtWfTNV8ply9SBvwepARPgSg2UKTDNjh7s8mZpsq57xuWJAEHSsRAj7Pso1g/C1hGQu53nITgHf0jdYP0z/EXurix6yhe0MueUPkB+H9TNZ9XraQvSDtCrMwI1VlT0udUQUbNUWhshKeSzUJ1XCqqVAvZImAv2hRDIuxCxJ5SwL2PPYP/uPGuUbGW5+23M2ZvNugJKb4JiNFhtWY1TBJ9mBovKihYZZ3nBXwqgK9myxriuDmnmLEW/ly03LofGiqdOsX5NtC/2ekfNLdcsdb0O03S9mB+p0K+PVk9GGPbIgq5JSbdRNokbrNqazHe5JOPU9Y4AA/6xRCUjTajqz5JkBDFjpCHrNZgw8u4TSb2wWDVgb9YbNwCIidXpZsxd85vv3/dJ1msy/H2t78d//Iv/4KNN964a+DGvclNRm6dXiMHRhgAFUUR9f/nNpo5sF8H6nIb0BSspe+TVglZCdC04a8jH1LAWmfw1ysB8MEPfhBXXHHFOl1Lp556KubPn48JEyZ0dd6b1k2un74OpDCwzlW8WYacxpXlAHjdsebIm/Rc1oH2tnttYmSZIyxyREZuLplUaFpLOZPNdBhjsMMOO4zZeLatt94aW2yxRVfgOVVM1BEAdeC/2yjAkWhzGQkSoJffrQ4BwN+9qYIrN/74xz/iuedeHjG8/dEnAEbF2GjqRJxy0B5RHnYs1ZdoP4uWVjCAr94hydH2QJv0/1pTDBuoSkr9woXWCYhWXmnAxmWanL8V0puI9ZXYllZeBeDJBmNJam3IyCdUPUtDsYVAVO3mlgYfAxf19AeDQul31mKeOFT6aq8m+Tmgoj7q6AuYAbm1UfqBJhm4IpUDCKQGEiLIywXgRtnpYvSW9nArRHNRmvZ50UrhhrsewY9+OzoiXA7Zc3vs7vwsgn9FTEZJjzhXrT0oRwCXfK6rL7LwuLQLWN8Wo9pBqIJbf8GDgs8DwH317Zs5IXUqQ0cbGxq69S/V99A6YD0JZomkUEDbuRWBDpMDcm0KmSZtC1a5dgKo6DMqHTF6fr1zCwmvX08kgcw83XXbKjSGytL5AugGQKVQ6Gr1c2xpZvvjz3/8POXNPtn88Me/ewg/vvPhl/V3wb/+67/i3e9+dy1wy7nbc19np/92YzzFm3LOTpfINu7LbpL012Wq566zOrLARteqbotw62Rw2GuE1+oSAOu6+i9jcHAQN954Y0cA1mvVvxMJkLZq5Fo5eL0yOOkWKKU+E02V1m48IHiPlV5bKWGVu4bSOMycaSS/fs7oMDfOOOMMnH/++WP2XrbDDjtg+vTpXT237jyOJAHQTRvVaCEBVpcAyJGg6fdEbjz99NP9OMD+6BMAa3ucfOBu2GzaFHIZR1T9V0qRe3ncw2ttkEIL+DC2kjdrkQNr1dYDL6oBAaGF0t69PpjNKdf7HE5sVWXVwezLWpL2B6m/oZz76v2oFcAEAGyTTaGPQkN7BrwiEOHBGVzftQfWoXofqqPixi8O6bEJIhMakT8BmS36fmlryZQt9D5z24EH8Iaz6wORUb2PjQApV125ChtVuxFAnYxLfn4Pfn3/E6NiHe82ZyYO3XP7ADxN7PIef3m1V7NV5ouMoxqlX92TVdYSGdae5CDEiVJBys+tJS1XQSwp+zGSzIvXhbHZDSRHaypa+555lzaHpF3ArzPElTMvZQ2sXvB68MyAgH0drTUA7hoOaQci1WeCSydERljftLZYmUB/z3PpiQXEyR/sHaDIx0GeVxob+TTI3H7vF/fi1/c//rL+HnjNa16DCy+8EFtttVVHoJXKOTsRArImmzaNdT/zBrKTwWDqdN6pFz/X052TeafRg9Lj3U2feN3ve9lkd0OefPCDH8SVV145KtbSqaeeinnz5mHixIkdAUg3BEA3CoBufpZKZLquUpf/nMlfXSRf7rOkMuhcK4E8TzwA0mspfT0htIbjHZGuXV7T6dyuXLkSO+6445h1ZR83bhx22223js/zRHtCAHRbve+lDWBNVv9XhwTodL2sLgHg9yJA1neDxwsvvIDf//73fUDWH30CYO0SALtj02mTnZmXjkBB9AVEIBEqBUzBDwCoqvCMcA1tukK8GivcY6kwy+M551tixFSSo8790hJnWB2a9QkEvjfZhHflKjGb63mpd2KOGDwJXKXV/U6jaicIUX1Olm0skRea4t3a3z/X8yyfn83+FM29ZN4zWZH7IpIWhtB6kD4JXo6NqPodVBKsRBAA9dVrf4OHFo0O2da2M6fjg/u+PhAaSdU9VOtZWhnfMkT2Xv1g/XrmtSjnQrwGhsrSeyWw3wMTD5WKJqRhaEd4AU1fzgS8PSAO6phKBRA77EtbB6/DUIC3GTVIrFqI2hxscN4PKp/KOb80YS4K3kiSiihNNFB0DZUu1QMW0EVIaJDqvyFiUQg0K66J7g9l/n1iggUM5FpEdD5MohbQlEhSaIXv/uwe3P7AEy/774LPfvazeM973oNp06Z13DTmqjp1oLuutzMn385t0NNqfh1ASxMG6jb9dcA/F12YVv5lSAtAnaQ9Bft1j3Xj2N5pE79w4UK8+c1vHjXraHBwENdff30jmdQJHDX9O7d+cjLuFKhLy4r4AKQgpe74BKSnALrOi6IT6JT3lBSA1Nui0+dnlUCd2V8TcGvqxZ4/fz4uv/zyMXsP23jjjbHddtv1BJg7XV9jhQBo+iwj7fjfLQHQiwrgjjvuwMqVK9Ef/dEnANbS+PB+b8CrNpsWyZGlcliaEJeXOr376pqtsrbT0yA911CJ9Jl6/gsnZ69k6GF/r7UKQJ36tLVUJlU74E1j6kJ/PCKHck1992wGyEZ9ok7gTPGcvNknGDjzMu2MzSoXds5PD0COlQ06MYCTzyE9/VHiAmLTODmGakMQN77L+WLwC6JcophEUJKAtfGZVJx2oCKDutESASijVWicc+Te0VwyESCf0Ss6EM6DqFwMbERsee4peo3woHWeDfKYr4hzfKDr1VeJX4bKGGJ6kgXt3ICNnPFtUL2Aj7X6PJZaaeSCYBIPKfFB8v6K3DI+8cGSOqG6lsJ8+Qp+BJTiz5IDX37tE8FWOP8Mm6FFuMUhNQ+NycAkwolIB5OoWIK3APC1H/0GDy7q9x/OmTMHF110EbbccsvGPPdeUwDqqvZRy0sSu8bAhmXaaR57XX91biOeq7DWgbYcME/N23KvUVfFbfIB6HXDnY4TTzwRF1988ahaS5/5zGdw1FFHYerUqcMiAJrAf878rmk+UzDCxmSeJM+Y+eXWbBPIZmKgLmEifW0hknJ+B3XXT52rv7y3JBCkbQGdAOHNN9+Mf/zHfxzT97BXv/rVHeP/eA66bU0arhHgcJUtna6XpvO4OtL/4d6PemkDqPvcjz76KBYtWtQHZf3RJwDW1jh0z+2x25yZbTFz3txMqbaZTSv/Kp15pVB4Mz14oCTAlKuFHMnmwYGYzTEJAOUzzeMbUQBI/kvc9/4KSNCRZN+SpIBVDYE4CIBKgLxNyJEKdBYV+C9LT0yUJgZ1fmps+42UJf4MpDzRoEKvvzdvA0C+ZnF/umHnakRkhU2ZhhhhRQRAVtrKn98Bw09++6Z1HgHI44T9d8GWG08NkXuI+9911nTLRpF+Fpb8FqSKjciMMiIXKI5OO5d8WS+KiIgiqsyHa8oTKhGYN1HvJqNZjoqsyKfQBiMVpLIMhpB8fZC6P5Lvs5lgZe5mYFxyQLxOw1pRBMI4PtFvqK2NzDwFiIeNF9zc2mgdwwa9grUGrULDWuOuq2AKWprq+AxiZUq0mUZOugtPiokB5ue+97NRQ2St6zF//nx84AMfwMyZMxs3njmpfVqlzAG2nIS6Tiadq+Z3E6lX56qevmauVSDNAues9rTqmvscvW7yuzECbKrYXnfddTj66KNH3TqaOXMmLr/8cmy99dY9gZocQOjGRLETaMkBECGWUiKgDjDXkVh10vq6FAz5Xc5Isi5hoO71+FibVACdFArGGMyfP3/UtJEMd+y0006N8X8pWdPr2uyGAOil+r+mTAB7fXx1CYBuyJNOn3nx4sW4//77+1/C/dEnANbWOGDXOXjz9lsCCmhp7QCmjYEjAcVgXiZSXfois4EUsL5qL4BBERgK/fGapNjKV5xD5VQOJAUXih7zNxmEXl/2KEvN8qKoPiEV6Hjl5jbEBAgQHasHwsbVXb2jWlw1FkzjpdnGQLHML1muvrUApGKgir7WqjJktMCqoSArrz6f8R4JYCNCF31XbQ5oDmxc0Qbi/niOO5T5FRXCw08uwVevvX1UreXD3rgDdpm9WZxgQdMrUXPeEI4UFL7Kn6wVHQGClDex4W9YfWGtr/6n7QNMRtRVmjSlObBZAYN/uY40OeRHAMcbSaooVcIiaWUgdsvHVho2UHQqHWMp/UPUFNXaswkI/3/svWu0XUWZNTyr1o65CCEJCZDEcAJBQAw0IKDQCBoVBcRXRby1qLTgFRna9ivqhyiCYvfbfN3YvorarTYqiqiMT8ABiogXRC6CgiIooEhC8AIJgRAhZ1V9P1Y9VbNq11p7n5OQnJPUM4Zyci77slattWvOZz5zcioAg8GUmJLnFzk+G0/yvSI4+RNR5r033JFJyElLqgfr7lOIxhvCveHU8ycWkbU5a4899sDnP/95zJ07N7uRzoGzHBnQ5uDeBdxzRmZdyQJtoCx9rhyBkAKyNmAgj81grQ1UDer8D+oe5zbYgzbar3/96/Hd7353wpJJ73jHOwYasg3b9c+NaAwCKl1AhEmhYSTKqWHfMFFoXeuyS70y6P23XUfDxgGmx/mzn/0szjjjjEl979pmm22w7777Dg2aB0nXu9bpRCIAxkMCjBfsP5EEAABcd911T8hoRKlCAJTK1IFPnR/M0wgUCWiVzhzPu3lwSmRAcKeHlw7rKDatH6BI7n3zdTNPzEZd0VyxAz8im69NPOetXRb6qAcfkiIgr0/1dQFTMEL4z78vNu7zAMmGFIBK60B8KAVxOPCJBr6z25gE5jYCsfO7jcDbaG2gVEhLaOTSKiJqGFzVJhjHaR0MEk1wPKTRhziqTVEnd31dk/dAnAhQaYXrf3cfvn7NxIpOe8Hf7YIX7LtL5qagIv+FnpNI9hsFJjGWiDvzgMquG7k+mhn2WEHilQVkPhcwveojgGQshjeF3iiQnrdyCRt1bbyvgJyrujZuXt8pbpBR6SD2KWBSQ7tufzDbdB4S5EUhUZzRuELSiQ/XCoiIkjEDTuAwFCna/CUTHXBqnub+Axq5iAcG0nQMHnWRlylxjRJV+OeHHsX/ufja8kFAtWzZMpx11llYtGhRaz52zkl/WDCXA3Cpo3kORLVlr7fN8udk+V3z+SkBwAA/df5nQDgMmM0RDcN24trqiiuuwBvf+MYJu45mzpyJyy+/HCMjIxGBMggsDQPAUo+iLjKJ14R0/dMYy5x6pc0tP/WGSMdSBpEAOQJBXmsulaDt+mEvgC4CJPUVSH9v3bp1eMELXoC77757Ut+3RkZGsGjRog0iAAZ5OLQRAYN+b5ifPVEkwDAEwUQhAG655RY8+uij5UO4VCEANkUtmLMt/uklz+zcQPMHY/7DFt7Rv/EEMNBoYgMJNsUgQ2mwWkBnpO/9M8ZIADk5ivPMMUedqX6ncJmNZm8DlsAHQiH2ARRQFXLRY6VE5eXx/YkJTF6kM/+sFGDig0cgZIQgeAJwh9V6QoKTGUz0wRPc4kHu9sY2xmlQcSa9ccoGBpa8Ni6/6a4JF522+/zZOOmI/SPQpxNlA58DjjSU9AU/3y7ngKX5CN35lCjQRCyFuLuYTJMxFbDawMaS+GD8Z/t8J+LoTOPJmCDiSECGAuraqWG8yWNYQ1rFxFzqkK9U8E3oOQA0atgwMdlwo3/uP0SCxhtx7Yw55dyoJCGD13IY0wgPH8ws42tNvo7SL0zo/vvz5w7z9b+9Dxf99DflgyCp0047Dccddxy23377TvDOG7qcmVpXBz7dWOZGBNqM+dIkghRot81ft7nx50BZGxGQvuY2X4H0udo+P9ty5QfVi1/8Yvz85z+f0Ovo9a9/Pd73vvdh9uzZQwGFYYHYWMiTdA3mxgFySpZBpoJtzz2oU59b/8OCxq4UgJQY0T5iuVvqfsYZZ0zq2D+pscT/5QiYYdblhhAAm9MEcFjCcUMM/9oeOyUAut57IQBKFQJgE9b2207D+489NAJJ6c1NUwQdYD3Q99tvFRkEZEy8yJUbIcfcR9nR7LV2XW+W/KdRbt54r6b4HNcpbG7scccbrjNvog/QjDwVkdNamHvX4TVN6VWABdbXdSMpp1VnVZMr34BK3WdSqKPIs/D83v3c9BtW+dEB9yg+BpEQpgA5HqnwAM7KObERQPM3Zzda0BgHmSbK0DoCh5zkZaxCgN4FP/o1fvH7P02otTx32+l478sORu2AZLqGqmiUQnsg7OXkktBAxnmBJGgIq2ZuPKzjpjuegolGfQE0/gGSPsFGe5GqxFo6zy5tw1g/KmKcIWQzrtKoTir3tRBWEs8XVCRhDIb9LNhEksF+GmPIaQPKyWmMlUjN2GizdpL8ikgnzSBIwXf85TnTBJB07YoBp+Zry3I0YXz/sWxO0GcEScSZjTcmn/nuzbhz5YPlgyCppzzlKbjwwgux4447Ytq0aVkQ1ObM3zbHnbql5wBR7uddG3MBOW0gnFME2uax0w0rO7ynG+E26XebiVtKEIx1Y95Wl1xyCd785jdPirX0iU98Ai996Us7jSXbQMGwIGkY+T+fq66ubBuRNczz5/wrcn4E6TpPn3OQD0KOjGobMUmJJ/67NWvW4FnPehYeeuihSX/P2nfffVvn/4dR3wy79saaXPFEEgEbW/q/MQmAYY9ZIQBKFQJgM9b7jj0E22873W/c/dwsxXr5i5YBvqLufirX7+tyJHF1KhABbOzHMXXcoRXQ0at4rjc8dXi9to/IkPEE7hrK172qgoVtpPZwYw3sqq94NILN5XiWWtQITRCZog0Hm+aF46b6Hfd5g+BYBD7+PvKNuvBwgGy0DooImacmfsArKvrIDRt3hPvIHwFfmS7CR7/xE6xeO/GM0046Yj/suXD7CPgGsB7WVrz5slA6VqH4Y68E0GqfjCHdaJ5zl2PaAP7EqI9GMHTfBy76Ei3aOhNRbCUpFaxFn8Mfp214gs39ncRi2sgDIrwJFez+m4dzoyWBHACqSvmIvSrJlPYeGm58RTmSS9I+hPCS55YYRSECwnGxgv7Jw4Dl3o6QVMFHgAkMISzYL4ATHQDgtK/8AOseHy0fApl65Stfife85z1YsGDBUFFPwwA5Bju5rncK3rs6rrm56K7uam5GP/3dNtA/lo1wl6ndMO7Zw2yyjz76aNx0002TYh0deeSR+PjHP44ddthhXKCrrSPfNQffFs2XW6uyLnLGlTmzytwYDP+7y3U/fdw2xUpbkkDbY7aNQXRdG3Vd461vfSsuv/zyLeJ+1WUA2KW+GAvpNMjoc6zy/81hAtgF/J8oAqAr5aIQAKUKAbAZ69SXH4K5M6dHYB/UtZS5WQbvIrmXuWfpOHJ0Xm2b3PCmG63JD4Dk2YnsXGaBxclcJV1M8RNoNmvw8mdLYwGyAEZrg57m7T7F/nkw1MSP1dQx1zp20BcA2cCNQChINBnIOV75FxBLXYXoqCrtgVMa4ydpAQzgxfiv0iqJuIsJEOX+2BLIr31Wu4A1ugkLucHgScUS9/g9h9/73coH8bnv3jwh1/IheyzEy561ZzAxzGTKV2J2adPYP+5Etkk12QUfXpERz+Y33XYb8T2WSBuFnHRd/g3byPyNNc014cwLR928P9yYiXhn0Cn3ZICPswQid33xHWi8BsRLw0bmkbJGxYugdiMAMt4ixzONxDT0Hi2tXzHyY9VDbOQZlEC1UzjwMeO4SkO+AuzJINeREDrszcj3FE88KoV7/vIQzr30+vIB0FFnn302jjnmGMyaNWtMm7vcBi83az+eWKu2qD1+LW2GajnDtRT050iBFGQN6jLnQN2GbtqlLrzwQrzrXe+aVOvonHPOwXHHHTdQBZA7X13z9DkQPgh45+b9c2MbKRjPEVRt57ALlKfqyrYxhNwxaTMgbCM8ckSA1Be+8AWcfvrpW8y9qksBkK6lDQH+4yEANsUYwIa4/m+sef9hqov4KARAqUIAbOJ63t4jeNH+u3kgwfPvIRLQenAjM/vpPHTYkjcbdcmz97nrAitTjwGSCPNNmt3QFc1uMwCJu908k6+8pJuloICKJM6WQZnrftauc8kdRkMdUS+5dl1Q+VuvbFCNQ3rsLuzk17RCLX0tXdRRihSUX+Y8eq0klq6/eyxmbcGEDrGaIpwB/3g+Pz7qGkusXAyI5Vhfe/tyfOtnd0zItbzDzBn43y87ODIulPMlgLN28+VMAjWqCwe8nYmeoqhKKyMU/sSFc1Jp1cza6/w1ETabYRQhWv/oVwTwYresHlCNCgECrK2NYwRVHDspJAF7CQSlDtDviKmgdOybIYkGPIpjkuswihVEUAJZ0+/U3RAk1o/QyH2GmQxZh3VtUFUqzPFDJNo2TvdIVAxMqLDBJodeXP+7+3DRNWX+v6v22WcffPrTn8bChQvR6/UGbpbHYqI1jKt6zjOga/PcRgx0vZ6ctD8F/YPi33L+Aim4HHajPuh1H3zwwbjnnnsm1TpaunQpvvKVrwylAhjP+soBGV5nbeZ6XTGWORKpC2znftb2ugZFSLb5R/D6bAO1uXWZKmIee+wxHH744bjvvvu2KgIgdw2Oda0Na/y5qQmAsZAAm4MAGOSxIQTA2rVrywdvqUIAbKraZYeZeNuRB0RmfNGF7wDDaF37biTP28o8P8vycy7MkM1Un+FXnGUvrvfifs5Z7s38c/M33GWtqOPpzcXA3WunH5CZeMoeT1UGjdxZuQ5v80gsj+fXGoCZovceZPlsSKZ9CoCNouVSs8M4R507xTFWC2oFGwCZkCZw5n4AjLxv5M3igulfAJpsNMhEi1YK511x04Sem37bi/bH4h1mZXPoo3EMhchTQSk25ovn3NtMAXkWndUnCrFJmHgBpB95SkwlyQ+CZ/IBGjNxowTN8zrCwnXyUwO/vg9ciNmmdT4PNrppVpWOovgEuFdV5bwG3DiOW+DNmm6OBh9PY0hBY+NRGlHGyOvkdS/kSy3zuZ4MRDS2wmMIEciHis+NJGa45IDQxQvn7Lwrfo47V64qHwAD6qSTTsLb3vY2zJs3b+gNXnTfpw1l+u+2KMw2MJcDcF3EQG6+Or6Pq4EzsV1JALn33ZY+0NUVHrbOO++8SRvXdvrpp+PEE09sVQG0yfzbwFYbeEml+rl10KYIaANzubXdBrYHgfO29dz1fLyO5J7Mz9Olpsk917ve9S5861vf2qLuU10jADkyZKwd/7bvDwPunyj5/6D7yLBmmcPGRo7nntV1bRUCoFQhACZAnXzUAVg0d2ZkliWb7spJltkJvjY2MlnzzuYi5yXAysZ3Av4ZyKrEgV5T9FnMeisyPEsl8dY/qzjY9yoNa4wbRYjb4jKSUAswgPJd4NRNXKsAzFTivC8fzuIuz+oCYxGZszUS9LBKlYxWANH7ldch/gX+mIg5X+J4DqsiIoAd/yPZdW18dCOrB2LQGi6lvjl195unX/BDPPrY+gm7lo/cb1cs22eXqDteJWBD5tBBMX25mWPOphcQHJE1dLupTeNRQUcwWp8cpSiEEINWJpXE3E42frFXRujyW2tRI0jk/YiKfNjS65OUCuedGZn2hdfAm2h3HTp4rSXyUhHgp2tQyLJmbCGMDLH8nu8Dclz4xi3XTkVEWDzbj/6Nt6h3EkVMVqZNN7bTv/rDMv8/RM2ZMweXXHIJdthhh8gQcBgAVzvSODVhy4GUZp3rVkk3d2yHUQOkwC/tpLaBfa6c/L/td9sSB8a6ae+q/fffHytXrpyU6+ipT30qvvGNbwytAhgExnLrrmsEoA2QDQJsXTGOXR34XFQhA/ccSG8bV+E1PIiIGFRr167FXnvttcXlrecIgDaVzngTAHLfH5YA6Pr3pgL/w4L9QdfTeGsQAVJGAEoVAmAz1LEH74mDnrogdLERosJq6pT7uDMyiOMjH+K6bOT8L7n1Yd6Sfl/AsZPqivRXXofMBbO8OT3JjddA3PGPwJd/LSoBG6oPHITOrwAb5cAYzSTr2FQvIgy0SOiRubHKawoSaiEU+AbJBEdQWNi+41xbG3VabQT26PGUDhF07utY2u+8DJB3S5fHv+O+B/Bf3/vFhF7Lu+04C2858hmepGr+hxBhB8R+FHgGaFMAACAASURBVO69GWujhAqWjnsTPZbZ000HNO4iJI2GRm1rKOiW9RXOvdbBD4Pd+xlIc/pDMw3gQHI07hDAvTyGB1zSoac1qN3B4HCAurZBrUCg3TiCqaebsYlRRyhpMtYzNFJiaZzEv28yuQxkHF3HyVhKv4N6rL5h5b8QhLyG5bUzeWgssOKBNWX+fwy1bNkynH322ViwYMG4NnspWJIM9twsc1dueW4+vCv2LyfDbwPy7JKeSrnbfAK6vAYGJQC0vaa2OvPMM/GpT31qUq+jd7zjHXjf+94XjZOMhwTIOd53EQGDwBdHA+Z+r20UoI0M4nWUWzc5OXqX7D8lDnKE9TC59tZavOxlL5s0BpIbSgAMOubDEk0bEve3sQmALtXUsOB/rETAxiYA5P5fCIBShQCYALXf4h3w2ufsDd5Ve+M/xHnyHqSTBD41MxNwKkBC+fl5sD29B2g1AVLvyJ9+MIKd1/k5Y5KhVyXRZiTn5g6isRZTqso7j8tMNEeyBTAWy4c599zCOqkxg/S4g86S/8i5XLrBkaLBJsddPBHCvwy520tk3agxwb1eQDz6FR28Qand30RSfxtH1mkN7xr/s9+uwMUTdP4/kEEKH3vdcwN5Q4QUKxy4iy/rOr8xD2MDBqkZU/NYDYhviBaJTAx3pLiDL2oO7rp7FU0yTN8/y2k9kLZG4jODpD8F/hyJyIRepVVIqXARkl42L6kZ4vyvVaQUkTXd0xVGjYExwJSe8soCjgBMYwbF8V8MGaHC+E447o7ssLHCIlwHypk4mj6VRUou8piBpZ9d/7v7cNFPy/z/WOoDH/gAXve613VGbeWcy7vk+6mRGmeX13WNqqr6/iZn2NYF9vz9viUObZACIN38ip9MF4joIgCGIQRyteeee076uLanP/3p+PKXv4z58+ePCfB3EUBts/epUqQtujIX/9dGErTNMHd5VgQSUkdrMPd1GzHRtm6YBBjGZ+Lss8+e9CTSeAiAsYDk8aYAjJUAyH29MebtxwP+BxEBXX83VjK4mACWKgTABKsZU3s44zWHRyA/dUU3Njjf82wxEM88WxPkvoz3YxAcG59VWjsw0Uj3a9ddVEBkRucBlGPEtYKXNWuavwfiSLAAEoLhngd2MnIAOGOyAIBrY8mUL+7aityaZ/qNMRBY0tPKGwJacjoXV3alE3d512n20mnXufTO/kqUDNGdNXT6KbEgzLvbaMzC0PuRaDfuMoexAfS9NgD47Hdvxp33T/y56Vf9/V7Yf8lO6Gnl3e61Un4+3dp+Jp2jENPceDZIZBm891uQERDERgDiuN8QKGzcZ1uY9thRz8I2RngerAQjuzQJAohTK7zRpSedws+gmk6/vz551IYiLiPyLQLfIYUDUC4pwP3MNIocuU6MG7nwKRcuDSMn2ZeoxconfPC1r6L4QFYqReeNRpKMqR0JwR4CwGeumBzreCLVokWLcOGFF2LhwoURMB8GpOU68bnIv1zXNAV16deDVAKp7D+Xh57+rGs8oAuod8VcDYqI66p/+Zd/wb//+79vEevolFNOwbvf/W5Mnz59aODQRbJ0SeJTo8kckZQC/DQWUL7OAZd0zXYlA8jvywx/SlhIV7RNzdKlOhgmTWN0dBSHH344/vjHPxYCYIjrbhifho1BAGw08DNE7N8wYP+JIABS8F8IgFKFAJhg9ZYj9sdu82eDY8Ulfi7MLSddOTb4YhfwnDO4A1HNYyonV7a+i0rNWbd5N9500HKMWbThs/T/zQsXkCI56QbSTXSAOUkhSHPMo5u0c94XEC8xfwL+fScTYRRCUgH863JxieybkLs5Kq+sINYfFJvGXX9PsNhkbryRhouhHc+NW5vEECUgH4gz76Wki7zywYfx75dMDtn00xbOwQnP2zeKSawcEPQdenL5l2OpE6+AECkXRiTkd3nEJZ3nrx2JopQic0UkQDTpUnnfDNXnDRDIGjHYk453YCNyc/VueiWYPFKEXuqiH9ZZPAZhraHRHkRklkT2AfTeMuNBum1+n967rNWe8x7g4+SJKIqklHSQcK+IVSxs6hi9LgAfKvP/46o3velNeOc734m5c+cOtXlum/3PAemcyVmc4BKDLnF2TxUB6fPmwKEnuzIqAH49uXGArvfQ5QOwIYZae+yxx6Tv/kstXboU559//tDjJIPIltwsfm4OP0cmsfS/S1nSBvjanrtN8p+uvVTmn673VOo/6Dm7gOXpp5+OL3zhC1vsvWk8BMB4DQE3lADY2CTAeCIAhyUCNjYBkDNlBYBHH30Ut9xyS/mQLVUIgM1Rz99nMV60/25h1jg5qqHrH8BJYxRmAweQOwMKHlg1s8wqckQPueqKZp3jpAApYxuFgHwtXUXtPACEYPDgn6LUIpNCdsKjGAB2yWdn96bBG0CeGPWJAkDAiziliwmgscCUno46nQGsS0xbYxI4ampYGdfWMSGixbCQuvtMwvjcd+qa1taigvLGfyzJtnS8PbhVzSM3jvWJbBrAjb9biQuvuW1SrOUZU6fgI685zJMu3uvA5j/kQspEAJs6UQUoIPK08Bs5FebZRV4vv6OhYJWsmdhUMCyE8Djc0U69GJREAPrrL7N5UYFsEO8OjSYJwhjTF+MniR1evyBkASlVkNhdeD8QR0lZXocpoLeAkm6+I8I42lIIjmhNux/W1kZ+CClhgCTWMB0B4LhD4gKw/K9r8B+XlPn/8dR2222H73znO9hpp50wderUTlDWlrGe6+Szw34XgBsk+89J75WKjT4HeQ/I76QkRA70DYoEG0tXrq22pO4/E0mnnXbaUCqAHGDKmrV2qEe65qW7wFzX91i2n1MepOc4JaWqqmpNG2ByaxB4HWa9XXHFFTjxxBO36HvTkiVLBo6WdB3DYYmA8UT8tXW9B8VaDnMtjNcHYDzRf8OoA9pea5uKRmrVqlW44447UKpUIQA2Q+0ybybefvSBkcs+S4FZQgvqNlaJhDz6MPLxaQlg8ieq33CN57ataTf7EYDfq0IWuXEz7WL21Y+1SCLMs4MO1PPMfPMZrgLRgBBVJsBf/POssbEXQpJqYJK0g7Q8gSC55WQOKJJofxy8usDGWe6IEwzCDTgGSgygUgbcJNFryku+Lf6/6+7AtXesmDTr+c1H7IslO82J1lTURed8eHdcU9WKTiLnOBFBnPeNm1nnXHsxDDTU1TcuOk/GADjzXidxgBxPKSSGdOIlUpNJOR6nEVNB5dZlLckZjjOQEQhD69OvN0sddunC0+iAeCD0BBBBFAoByIPIN7l3SKeewT+bbNa1qH2s8yNoWAql6TpDPK6CJKpRrlNPJJr4WAqRd91v78PXrynz/+OtZcuW4V//9V+x0047tYL/tk1v2ww3399zYDt9/JxLe9u/065r7nnbvp/+bNDmvU2+PWizvKXP/qc1a9YsXHXVVWMylcwRPW3gN3d829QA6ZjKsIAvXeNtXgS5mMLceEvqA5BGAObeI48edK2ht7zlLfjOd76zxZOTe++999gAQ4uBY5fqZEOJgE0ChIa454y1+z/W302P2SD5/x/+8Afcf//95QO2VCEANledcvSB2Hnedh5IpC75Ep1WkWmdkAA8JsDdSQZNioB/2GCpZK6aN/Wx0RfH7PnOvwM0Pbfxr22jRRaw7sELbxSSWekA+OBHE/xr9rL/+PWKqmG0rn0UWdNhb6IHezp2ZtcqqCYEmLOjOQAfT+e7/ZljZ6z1Lv/gjpQfFzDO4V15ciJyc/fn1YbZdjJKk2MgYFnw5icuvQF//OuaSbOWD9ljIV5y0B6odEyC1Mb2+TM0hA4iciTtUPtEAHLjD6kLNEZCHWl/DmwcQcd3LBlBEUPIoOiIO93NeW/+aNQlY8j6SOP0NLntK9gInBvyhYgNNpVXL9S18deXUvH1qbTGqOtQVTrEKQbCyAZzS6UDsZaZ+U7TGCxJ/9MxhTCukXn9NpAekazWER+jtZAdwHlX3IQ7V5b5//HWlClTcPXVV2POnDmdhoApKA5kp+kDQ2156fw3/LO2aD9+/LaNaZujP/+sTXqdgvw22XUKJttmwwdtoD/+8Y9vcd1/qRNOOAEf+tCHOqMlBxEBbWusTf3R5r4/zAhADvBLV7MNHLWRDrzGc6qZHNmRGge2PW96bC644AKceuqpW/x9qdfrYb/99ssqk8ZKAHStsw0hADYFCTAW8D+ICNjYBECb/B8AfvnLX2LdunXlA7ZUIQA2Vx13yJ446KkLG/m4i/iS2V6f8+1aiFVVeQk7d+vbDGkUAywEYy+f861pg0VzyM09w0YfqjXN/DJ4Zwd7Q7FrQHBYDzJ+Bv5pd946EBwc+y1iV3nrSIYwQSBygKAZl7/rOVlpAEcSdyhZ5uTEb4x/t9Y22fJiOCekhbyGyA/AOL+DZLgiMmtUUWpgREx49QRIwu4InXv/umbSzP9L7TBzBt537CHR+fKqEI6p0zqZ9UeUFsAkVNpd938TzcAEdodFG5qIGk4eiOIaSfkhqoIGyJoQr2mbsY4QhUfgxEdtyrk3lMDBPgDxa7MmvymNqDqVdGGjn4VrUfwkcn4hHG1YVcqTEZWL6RMCQJMqx8cHGkkSUH0qmniTHf+XBB5QAD54QZn/39DaZ5998LnPfQ477bRTqyEgA5qu2fnUHC+NO0t/P92It62DdMa6zeQvtznOdVTbgNyg39mQ2f/dd999i+v+S4kKYOHChWMG/DnwP+yxb/tZSgSkpoDp68g597cRDTlTwpQUyplbDvMeutaYMWaLjf3L1fz587FkyZKNRgB0EUDjJQCeSCJgWGn+eOT/4yEAhpX/r127Frfeemv5YC1VCIDNWfst3gGvOXxvZ3wXDOC8AZh0ra11oLY/DpBTBLRWDpgK0OQ5exonoFl8ncy2hRtpiNQLIwAOpOomPrCRYSvUtm66jxHjGATaJgE4Ia4sgJFgPti8HumOchedO/RCgEReBkpFcW+eABGVQ5IEkM4VymsJx4JAGZm7aZXZXCfKgChLPn09/ljYCMjJOb/p7pWTUjb91hfuhyU7zY5k5+yYHwwjQ7RlMAK0kUVEszZ18Jagx5O1zrp0jveDM70Ud3xLRpLRBtCDaSaJDD1XbIZpibySWl8bH/0XRjpigoOBcVXpWAUiAN5tUEdN7e8B6Ya2kfeH0QdDRpdtJl2cSOFJNkn8sAbK8jhOuEjZ/M9fhxR/GAgRQMw00nO+4oGH8YnLbiw3+o1Qp5xyCt785jdj1qxZQ29wU/CTczXntZIaALYBvrYkgFx2erppTaP+cpLyNiXAoPe8ITnaW3L3X0pUAOP1AugiBAaB/a7vpQqTNmCX87dI19ogM8LcyEguJ50fUzwCUh+BtD7zmc/grLPO2mruSVOmTMEzn/nMCUUADLofDnt/6DrPT4QPwHgIAJXZu6cKgNzj//nPf8bdd99dPlRLFQJgc9aMJ/Vw5j8cHgAT/SxI8+El5jxDHWejizTZkMt+syVXzhjN2tBtlc2+OKcDsTSe5dORGRlys8dhdllZ5TuXldZeQi8Z59LBHxUjQ5sa5CG8Rz937SF4ZJTHwEeAl5i18bw1kwApIIqd033OWiTxpoMSCQ484ZK5AqIYQr5a3OMI0SCd8DTd4eKfTa75f6mj9l+Cw5eO9B07T7wk7zONAeR1pXUjZ2eDuThmTzZ1OlIIaKVgiOCBW19eWo8AxNkE03/fjTDUffJQFUwdvcEZEVI2RGGmEmqJ69NarmPtZu9tYsrpIXWcdOCk9vAb2LCk0hQFUVnw2uaYwkDIWZceErw1eESnV1WojekjsbRWGCWSxI9SoE+Qget/ex8u+unt5Ua/EWrXXXfFl770JSxcuBC9Xq9z45rGseVmudPZ6bbHagPhw8zb52IAGYi15cbnZrMZIA6TODDW2pK7/1KzZs3C9773Pey8887j+vt0TQ0CPF2/kwNa3MHsIgvSx0zXRFdUYJu6IPceBqVL8PdHR0ex3377YfXq1VvVfWlkZASLFi0aE0k07JrYEAJgGPJqPCTYhoL/sdyvhiUA0utmkPz/tttuw5o1a1CqVCEANnO9/jl7Y++RHfqis+KZ8DDzL7P2lZMe18ZGYCC9p3jneT9aHLrm3H2Wbn8feBF5NZ11cVdn+bwYsY1ag0opVFpjtDZeil85WX7tvhfH7xHKjmLMYqNCn0rggIsh5kTmv4UEEHAm4wte1u9mvpEkBVSUdoBo0wsCOyY6Xhwhx4SATXX/DIySDxWl2LdA5v9vnFTz/1K77TgLbzlyf/9embSqjY3IHF7rQgLwupD1aI2NpPoeKDuzOz7UKiDVxuyOnPijbrZWEehn4kZi7oJHhqWYTRUZcfK6sjTmYClCsjbh9zwHYbmjHsg2Nhe0qdmkAikWYsKQzSkVeV/I9WZpzYmPgIquHxW9ZibNfFeYVQHOI0P8O3o6XDu1ReOdoIDzLr8Zd658sNzkN1Idc8wxOPPMM/tiAXOAqA3QtHXmU0Cdc/bPAbA2WX/u61z3PwfI2uL+ukDaMBvptjr77LO3+O6/1AknnIAPfOAD2G677YYGPTkwN0yHlMFZ2j1PAfYgL4DUi0KqruuskWXOB2KQB0CbQV3XqKV8/0Mf+hA+//nPb3X3pO222w5Lly4dDjAQ8TeMsmc88X9jWcsbDQgNQQqMZ55/vAoA9srI1Y033ojR0TKWV6oQAJu9nrf3CI46YDc/Jz9qbCQBThT7TSdRxZJcMcSLACj6s+U9sBa5u2m6hlWl/aiBpdl3S1F9Kj3risASAxECEdIdtOifg/cfrK4DWZswP11p5eXwMbDv36hactIXpYMoDTgu0D+/jT8YtCZjPpBU3YSxgtxmhAFjtJER8OVmqgVw1V6uTcoDa2H5/Frgd/evwue++4tJuZYrrfDx1z83ArScZy+kjqdNks5+cOiP59AjwiqZ9+fxED69khIw6lzuFYEQa2ncgD6DbTRqYiOpfpoWwSMH6XUgvpe1bdYjK238WlIhnjOeRUU80gDxptDO08L9nUpIDcSGl+lGQntPjOZ1CiHDXf+2v/ejDULUAJHJZ/AOiJMCyvz/xq3p06fjyiuvxIIFC/CkJz2pFWy1bTBzRmc5Y78c8GGpdG5mv03+n9u0DoqwSu/xbUCsbYRgmM11RFzutttW0xGbNWsWrrjiCuyyyy5D/03OfX9YUJQbEej6elhgl5IBAny0N3k1faQDR07y62ISoe21dQHWK6+8Em984xu3ynuSmAHK/WhYAiAHYHPrbWOZ/m0qD4C2n43F/G8spEGqZEnd/9PfL/P/pQoBMIFql3kz8Y6jD4xmjMPG2/iZct8pJvm0bOpDpnm/gzNIWi2mddwBl695M584jvmOeDyv73wAKnosFSsL+HVw/NpobQIoEjNBG1zyWZStOFQcobvuHc/ZMFDBA0uGmtbExn8MePwscwQsrR9n4NEIIFYGpGMYtbGxLBuxI5rm0QNq3zLBcs3ty3Hxdb+dtOv5VYfuhWcs2SlxyLck3QcUNMnG3Tkg9JjGARpKAkhTKsIHofGd/+Zv4I382CcjjHsgduVnosj9njGu+x8ZFgY1iiwEuS5GXYSkSPwrkVl7k0tF789GhFT4IB8ka1YR0cHshlf6GEu+B6rxHTDsoxD7fCA5T6wG6IuBA3sqxGM2TCYsf+BhnHvpDeUGv5HrOc95Ds4555zOWMCcTDs1PBNw1GbAl5Pe57Lfc6CelQa5EYCxgKxs3O0AoiMXC9dWZ511Fs4999ytag2dcMIJeP/739/qJ9EF9AeZreX+tosAYGk/r682D4C25xYQ32VO2AY4c0kWXcRTWm95y1tw6aWXbrX3pPnz52PXXXcdE6DN3TM2BgGwoYB/2L8byyjAeOT/YyEAUvO/rveyYsUKLF++vHyQlioEwESpU158ABZtPzO4lCO4l0tb2kuIreqbHW6M+IyT5ec3TI03mhihKZ8owEDVYagoFi+AWRf954EAyZ4jiEy57NQh5REHk2wCgqLBkPJA+ePhJfnR7H/yWtF0XHuV9scpugmqJpnAEOnhpYWOnJDu5qhpXOD52MtrFmm5uMYH88EgW/ejD+S6HpIOZHAgAC++uX/q8p9P6ti0vZ6yPf7xefvCIqwRlQBnvwEAnEQeqJTyoxCy/kWV4sFtAgoi4EnQWPwnONrOWhuZAfr4wSjz3vr1rf2IghBzIeZSJ2qA2knpKw0/xuAjBiN1gvLrX8i5CMOrxDshIPsors/SMdAqViREoD5KKLDBd8EaT7zwrKwiNUqQ+sfRpOm2xZhAUnJCwnV3rMBF15b5/yeiTj75ZLz73e8eGOmWmvrljPZSsKS1Rl3XWRDeBqhyZmy550y9CVKCoSu+cBDQH8smnWv33XfHqlVbV0zl7Nmzcdlll2HXXXfNpkq0dea7uo+DzlMbaZOSSyzN74qjzIF4/j15X23JFGnqQG6ND2Mad8EFF+Cf//mft+r70ZQpU3DQQQcNBa7l/sDk4IYQAF1gd0O7/l2jR+P5/ljk/4P+Lh2TaIvOTOvWW2/F2rVry4doqUIATJR6xSF74pm7LwidYqgoYs766X0n06XZaWP6O4bikg+Ss3tZMQIJEMmI3dkUybpE6MkIgI8Z85yE28hZAinJ3LKl1944lserx4vBVROhJu/bS//ReB9oHbq23sAvcZLzcnL/JCoyDWRvBQ8C5eYJ+Bx1NgL0hoTkA5ACRgFf4snA8W+2LyYQPjrRb1wsO+FP/ti0GVOn4KzXHp7M/SMysGQjypyhXXpsLCx6uvIAPFZeqCSCLvSvG1uHQIppFeL5FGIJfzhX1nXvnQkh4ng9TtQIqRWWCLpwDctZD0Z68WuujQ3xiC5FwxNopDqoiaAKayv8Dm+U03lYePIqkANi/id+GHIPsHQeckaYnnRULvbTElHBKh1YfOaKm3Hn/avKzf2JINn22gtf/OIXh4p0S9dFCnhyxEDXBjh9HAb2fI0MyolPfzd9rpQQaDOfSzu1Y5H+n3HGGfjkJz+5Va6ho48+Gv/2b//W5yfRVbkovhxoSkF0Oh7S5rifI51Mcs9P12YuJSAlDNjzIn2uHEE2iOhIj+PNN9+81d+TRkZGBt6Pcp3/3PU/HgKg6zxtDPl/F6ge9vsbgwBIj9Ew14FUkf+XKgTABKz9Fu+Af3jO3rGMNgER0jE0NnTpWCptyOXbGkszwzZ08gUzCxAhhTqs9VJh72iudX+2uANaErFWG5PNubcmznTTOhiShVljS38bTMcaoKccYUCsvTXRzDi7+wuw1FpT3nt68/ZwxfsdcLxg8zWZo5EKo9IatTV+VKF572GsQUgTIRHYXT5I2IPngkbacVa4fcUD+Nz3fjHp1/NbjtgPu82fTRnzDjC6o++Pf2LFxwCUyaaKEgE4xQFo3OplaRvD3hfBQFKi+2pjW+LPVBQ3CBvWgKLrT85v8Mvg2XuL9aPWS+M53EFa+0IehHn8kI7B/w7/R+oHjWYWAYjWrJhWAgGUs+yfTTR53KYhSMI65ru6MTaK+lMuXpTVFP5csoEgJS2cdsHVZf7/Caz3vve9eNOb3oRtttmmcyOac0/nzWEqu07N0QRAcYc1NRJMY9i6Nq5RpGULwG8D/G0KgK733VZ1XWPRokV4/PHHt8r1M336dFx11VUYGRkZOL/dZszH66NrjCTt7g9DCPBaTRUJNvrsjqME+fu52f7c8+Q8MIZJyPjyl7+M9773veVmhG4zwBzhN0glkvvvMIZ/YyUHNgoQGiD731ACID0+XQRJ7ljKv++9916sWLGiLNZShQCYSDXjST2c8ZrDPFj0nTo60s0HFVy32Y0COADus8nZ4V46fASm4DLA4eT1TRyf8hJ1ef5oc5/EiRlLMjwbqxR4/r9v3k/kwRaRtFtIgwiAAd48Teb0vVSfPAHChkJFx8wKsKOZ//iGayN3fzjwKPnono9wr0nAVDjWSSdBBQO5Pvm6RV98XaQOoGNx7R0rcPHP7pj06/ng3Rfg5QfvGWbSubvMfhTNyYrc8YP5Ywy6hWjqVdqrC0DgOUoU0NLhj1UEcn04HByNEYRlnnYiQyShjA6w5L5XabeBBLxWX8gqMkGEl9w37yG3sY7WaHLtNMdRR5F7RgxDVb9xH6d3yHhNNL6itL+2DEUYsvFniFuka4VnDq2FJk8ROZZl/v+Jr9mzZ+Pyyy/vjHTLgedcyks6KpACI2ster1eRALkYvzSx0yBXFf3uEt2nuvyt5kBps/bVqeeeir++7//e6teQ8uWLcO5556L+fPnD/X7beMAbXLs9Jx0AfEcKZCLsuxaK12vMQVGKaDKja4MAo0HHHBAAVSuer0e9t13X0yZMqV17Wits9dnLhWgKwlgGGA/FsC/IeTAeMD/eAiArmORe/3p8Vy9ejXuv//+LT7qtFQhACZlvf45e2PvnedFwNByRrkO/26ubR1399yGXKTouXsakwQWIVZNAH88ixdOs7jlS4SfdFMrrVqyolVkdCfu74AAJhtJrv3NDY15m3T+tY6t3XnuOuq2k8ohcvK3MSD3vgHufbC7fDBMDE/JkvLg0RabrjFBketUSJSjGLLBZjYx7ptbimx6h5kz8N6XHeyBvpAxMcGEiMiRI5p6KohfRURmoZHMe8xtY98AOX/+OU13hJOMBwi4l9clKhaVpA7I41faxRZaQIYFek4pEogAeK+ISks8Yd5BX0FiE5tHCwQCd/JV5P/BxJKsO1nfiFz5LRlgBn0Ce1swESDHx5Dap4/IUTzeEBQP1//uPlz00zL//0TXq171Knz4wx/2kW7Dyt+7JPgsjU7ndNPnaDN3G+a15EBj18x/GyDLEQ6Dnvu73/0uXvOa12z162fKlCm4+uqrseuuu7YCt1ylapCxrLXxAquueMCcgiVnXJkjAdrUK4Pe10c/+tGtdnykrebPn4/FixcPdT5zvgxtJNKGGP6NFdyP5feHBf9t981hVh0qTwAAIABJREFUH3880Yf8HKtWrcL69euxYsUKPPbYY2WhlioEwESrZXuP4EX7L4mAkubuesMBNB9skGgw6XBnWHEBMRY0AuA+9JTEk6mos++700mmfVVpMgZkQzFLoFj530ECUASMxTP3Kuoocmfc/76bzjYUB+hBuWVDwCDlj6LnCDR6pUICvOva+C6yQpgT53x0ayQxIV7xyhEIDDwNEQrax8EZdy5jRQUrASwsTv/qj7Hu8fVbxHp+24v2x647zgofRtEkCUvGw6iIRX/8HQAf6ygAnP9MEWkggNzSc0b+AE6p4Udd3DpjOb1ysRIBDDcnXYB78GzwNIZXhqS3Q59s4V0HVKfzekTUITbvVJ4QUxHh0bcZJuWPXKOV1s5voPE2iPw9kJG7EvnIxn9M3niTUiLXYC0MgM997+ZJbWQ5WWrGjBm48sorMTIykjVzi9YhdTjTGLTc3HZXh3/Qpn6YTXZuXjvX6e8aGcgBiWG6/yeccAK+/e1vlwUE4JnPfCbOO+88LFq0aIOBeBeZk36vLRUidw5zyo+cRwR/PYx7f7oGc0kWbbXffvvh/vvvLwsoIZT22GMPbLvttp33hPR+0nW9Div935gkwKC/2RAfgLESYV3X3DDkgYD/9evX49577y2LtFQhACZiLZ43E+846oAAhJCR3Cc52wJsaun8c7wcASitwkaec+qDPDg4fDcAx304G+MRlMzXS8fT2+RnIgBZksydWGtT93v6fZJxiwQcyrcefXffvxYVFAk846/FmR+p2YyAPBMZAHr5qxAkGlCStECD3ALmWFYeQCs8eWABRyqoZJyjOZfr6xpTdEWkTvM4t/zxz/jS1b/aYtbz0fsvwWFLd268DpA4+SsGkB7lNutCh3EXS74QrEoJ5pSIRjLklqSbkwhjgipGPBqYFKsqHWIIhZigGXnvtK+Df4aicRXlTCob4qmJImSiySdp6OYsj9bNOpO1IctOR4oRFZFcSgGVrmAgvhjNa6mdcqCi32+IC0QRi0wwVSpI/qP7TAboMeAPm3ZAuwjHmjJJ0w3NBy8o8/+bqo477jicccYZmDNnzlCby9T8LAU9bS7+slHnyLQcidBm1DaMZHysudfj6ar98Ic/xMtf/vKycKjOPPNMvOENb8CMGTOGAj2pR0Tu93Ldef4vKzZSEJ6a9/Fjc9RZDrB3KQJyhENKHuWugbTOOOMMfOpTnyoLJ1M77bQT5s6di2233bbTP6FLEdAGeocB6BubCOi654yXFBgLATCWrn/6HAL+V69ejYceegh1XZcFWqoQABO1TjnqACycu23SYYuuagKz4etK6wjEGB+tpsNG3nU/BXyLW75JAGpPVxg1dTS77pMFSM4MAWRiyGb55hZeeeU+TEdr+VB3AMiwgaCNTAll3r9yhn5GAJdiw72gBghjEI1aYEqlwYp9kelzjCB3kkXOjWi+O7npJiBW9Rm1ye8pP0dek0FbqnDgc6yUwjevvR3X3rHlzBPuuN0M/O+XHhw+wKjrz0aXnktSYaRCgGz0QYiGFGLzx8bMkqTxlKggbv8VG/zZ+ANSPohHjUGlFIRDkw56oyYIxI+Y5o2SGiZYUthwDXL3PAUwQDTSYphsAM/dk3knR2kiNhDsuxnTumy8E1zKAORaNf66SKMU+cGac2SIGIEnrIxLGQmKBAuDRrG04sEy/7+p66Mf/Sje8IY3dMq4c6ZqOXDF10Y6Wz/sRjbNd+9y82+Lhsu97i4QMezowRve8AZccsklZdFQ7bPPPvjiF7+IkZGRcQGTLrPH3O93/c1YwFUOnOXc/bvAYi6mchBo3HPPPbF69eqycDI1c+ZMzJ07FzNmzMDMmTNbz1fuftN1zW/smf6NaQq4MUiBYUiNsbzm1atXe/D/4IMPloVZqhAAE71eccieeNZTF0agM8zEhw04K6oF7CgX92cRgLsHLHUwJBPwKp1/b5DmHldLlxAWygYwkN68jHfwt94MkN38kXaIaNF40zyH6BjQi/lbYDrog9rPjMMDJyYAgpoA3mCOVQMK7C4fjwVIZrpFE22YbAOirrN/Q/44k0mcNbFbsbzKSMYYczrWWnzishtx71/XbFHr+eSjDsDI3JkBVCrym7DWG9Pxz1nWLt3l2pnsKYq05FhHMaHj6Dwhp6xVPj2ibxOiVbww2QXdnWyekVdKuS5+6Nprpfrc8cN7NH0qFOVIuZrN2KDiWEl5nSpcn42KAagduSdKABNtCmwYCUIwxVRaeSWGddc2EF8PfZsO+nvjR3RoPdMIgaX7wnW/uw/fvLbM/2/KevGLX4yPfexj2HHHHYcCzwzM2zaVqct/LtItBU5pisAg87ZBXcBhAR8Dt66/veCCC3DyySeXBZNrPpxyCt71rnd5P4lBgKftvA4indL/dq3R3HhH2wgVv5acEmCQpDt9rW3r6OSTT8ZFF11UFkxL9Xo9b0yaIwFScjB3P+hSCz0RQH5jmwAOQ0R2vZa2ZIxhqq5rrFmzBqOjo3jggQeK6V+pQgBMlpI4QOW6bCyflrg4hVh2HuT2sdFdcKBP5L2ySYMl+TSRCU7aG+az424hEwDB5K4tM1xF3UzLoE3FoIVdxHk+sLYBbEleukok5Gwq6OXUvtuv+jqcqcmhj5VzYw3KqmSUwtJYQQBdoi6okpt1cFpvjrO4tYf4xqDMUAq478GH8f9++/otbj2/6u+fhgOWzHdGegjgnUC+VvGx9qBCopxMDBo4EhA0aqJ9+kUcJSjnqDHHs+F3IQZ9vAGNgbFXgZCPgNbKq1JA1yTfFE3anfSGeeG9+ZEEMtmUdALLZnwKdMwoVtHHTsaEUpra4XkzNzbAB80bWOo4mSKoD9j8Mlyf8hicniDHdEsxspxsdcYZZ+DEE0/MqgDaJKwpMMptxFmWzeBfRqcGdegHyf2ZbMhtnLseJ/3dLmAIAEcccQRuvPHGslgytXTpUnz+85/Hbrvt1glmuuaR2wBczg+gravZZQSZkk+5BAtexw2halqJiy4iK7fG6rrGyMgI1q9fXxZMR82dO9cD/5QE6CIAhllzmwrYbwwSoO1nw76uroi/XD3++ON45JFHUNc1/vSnP2Ht2rVlMZYqBMBkqRlP6uHDrz4se6FLp5jCxb0c3zpGQIz3mo5/AC0MOkIXFh6UiCeAB/UqGn6HcrP/2s3he+m9JpLAWNQ2GOmFLqSKjMYcFvJu59LRtC6SkDPHJStek7s/bMhz14pviqF7qp1pnEnevwcwBAqj2EJYTwB4VQLESC10gMUDQGa5JUqxls0Df8gxQLRA1asaY0DSuN9w53248Ce3bXHr+WkL5+Afn79fH/jv/5CEc9IP58/P4SMmsmpjfcwfUUjRGAATRfEce/4uptwogXTUI0LMyeC53c0+GsYRBzrZxMjjaDQdeMPz+onJnrwQS2kWkZ+HVzb0gyMhmkAmmDIm4U0IfbeX7yXhujBE0DVrG0S+NI/Poxemz3U9PN7pX/1hmf/fDCUy7qc85SlZINW2wWyT2zL474ri6wL5XbO7DBbbZq67ZsgZEA7Tbfuf//kfvOtd7yoLpaPe9KY34f3vfz+23377TkCSztWnIDs3z82gvIsMqKqqlZTix+XnzxkIhlEnmwWaOfXIoDr55JPx9a9/vSyUAdXr9TBv3jxMnz69jwRoGw/a2J3+jQX+u5Qpw5AAG0IAsEprkDpq3bp1WLt2Lay1WL58OR5//PGyEEsVAmCy1fGHL8U+Izt4VFQb6+Z3g7SZQbycgFHTdEdFbi5gS0UACX2ReZAPQeRi02IQJjO/o7VBVYXHBhzAEyJCIeq2ysxyVWnqJMpTZGZE5TkFZBsL5QBdMBm0ThJtnWFgkIgLuIeTlHM32PsdGOPd4KUpqkny7EEZSwozZnbW2KhzUOkwPmCMiQwD2bjRn0sofOPa32xR8/9S05/Uw0dec3jSSYkjKrWONwBC9jQAWqGqlI/jg+X4x2YWv6ebPPvahK659xSQGMHI5A+ZDOJkLSE25WuIBzi/Ad0n+a9NE//nyQIkEZ40e8PrJazLkDIg5IVxhJskTcg4hI8NRMQFekICKoz8aEXqFRqnabwA4AksJggb8qxRS4hxoD8e9IyROsDdM5Y/8DD+8ztl/n9z1VlnnYXjjz/eb7xzm9G2fPU2l3YB6Ll5aTGV4i5s29xuLnow3dTmYgVzs+O519lV69atw8EHH4x77rmnLJKOmjVrFi677DLsvPPO2GabbVpJG/7+MCoABtmD/ptWG0CXx09/zgRASli0Of4z4GoDbo899hh23nnnTdZV3hJKgP+MGTP818MSABti5jceg8BxAaAxEgEbomToIgAeeeQR/O1vf4O1Fvfee29RqJQqBMBkreftPYIX7rfEA6W+7rxOnJZJ3u4zx10UWpXK46IZaUXz6pJjTsw4oW2Wy0cfog4SSKdQOSRtbGPgn8qTRXJsHWBoxu6Dz4GA9Zpnw2UT6tUHwaRPZshlThxoPBKsAHotHc7giaBdF58BWDB0s8G5XxIJwl04njl3LAZ3QZtz4DLroeJZdRW6rQICpRN87qU3bHHz/4HQ2ht7j8xDcLWPoau43rOnYvBxUDSaofzoiE1m33tiTKkC5VVboOfIGI7+0xEZpCiWshm5McmHtJAHstHkOEr5W00pFiyVZ+NH/97cLD9bSXhWSNh+/3yG1AZy/cFfP5WmGX733mtjUVUK3tHCIkpJCA7bKh4T8ndz64nB+A4fzlctKhgahzDG4oY7V5b5/81Yu+66K77yla9gl1126ZPV5zba6aaUc9Plb9J/58BWG4hLQTuPEeQIgNzrys1vtxEHuQ12Xdc455xzcPbZZ5cFMkQdc8wx+MAHPoCRkRFMmzYtC2zSbj6vny5SJwX8aac+59Cf6/6nMYJta7Nt7YwllUIUBK973etw5ZVXlgUyTmJp+vTpmDNnDmbOnDkuAmAYguCJSAAYRIKNlQgYD7nQRVw98sgjWLduHR566CGsWrWqM6GjVKlCAEzw2mXeTLz9qAMjwOkPOAEBMTZTDhUJ0LEy95uMDFgCqyLxj6MFk4i2ZKMoUXmKQFuIDjQ0f636AJTSKpgNur+rhNhwZEUKnDjTvHm/zU97lSYAGOfFC3ACS5MRXlfqSO9nqiOpYgDt/uar4o6u9wxAQzIIwaCpM2zhUhg4us7GM+gAsOKBh/Hvl1y/xa7nZ+0+H8ce/LQ++T2vr6rSfkQgqD+IOJLYRgTTxVRuX2kdyBwAVlnUpiEHwlx+mOP35wQitrFxtj3CnH32g9kG40zeABs05JEnNmQ8hTad4frTnsgKJJ7xhn+K77SeHAlpABLJyespvivbcPwopUCOmaYxFRlpafwrFAAT+SqA0gqYfOTkjs9+t8z/b+469dRT8YpXvAK77LJL5yY2B4Jyzvo58JUSAAzk2jb1OUA4rPN3Tj0wqPsvf/PHP/4Rz372s7FmzZqyOIao6dOn48orr8S0adMwMjKCqqo6QU1O+ZE73+m5k7VT1/XQhE9KADQqvqoV0POa7CKamEzIre/zzz8f73nPe8ri2AhEwLx58zB16lTMnDlz3ATAMF+PB/SP5feHAf1jIQG6/jY39gQUp/9ShQDYIuttL9ofu+4428/Jw3Umm3liDZt8oMnstHQXpYtoklg0nk3XbtYeQioo6mozlOfOpO+YcvyZ64CSEV8f4aCVB+0CsAU4Kw/swmyA9q76MrevIvWCITPEsKltgGFdG6+SkNfKi5UNCEnpT94HiEkTiJlQ8z7lvVSVUzP44xWUCR5MSodYq2Q+MZgQXv+7lfj6NbdtsWt5h5kz8M8vfRY559PmUdQSSkUqCgGsnhCiY+lzBBSbVsZ3I+2j8xjs6CbeMiF+ZObdkza6ISNEUVAp7dUlwXSyWUO9KjMbTyRCaj6pFG88aaGhP5WCzQxlrMG6WI7m9QVViWxyrfPfiKI4bUojIno+Rdeq7C38pejvF+7xaIQgRxKW+f/NX3PmzMEll1yCmTNnYv78+a0Aum3zm2aht3kA5OK8ciCqqyOc69zmSIQ0hWBY5/+VK1fiv/7rv3DOOeeUhTGGWrZsGc4880w8+clPxsjIyFCpDG2pAG1RjYO8AHJrkUFQlyw695g59UnOSDIlNNasWYOTTjoJV111VVkYG6G01pg1axa23357TJs2zY+abGwCYGMSAykhNB7gP+h7YyEA6rrGww8/jPXr1xen/1KFANjS6hUHPw3P3H1BckMIXeTwwRr3JyutfafdpZV5sCwAS7qeENk9z8srMSIjsBr9PXXAbej+KyikaWIpwOD3oVQzUw1RMThZcSAimllr4yTQPV0BymK0bl5TpcOogTfZi2Ti8dLkrmmjZCCHdA/Iw3EJOfXBBC6ODFR90YVaKYyKvFqRY7tCNLog51Dk01/98a9xw50rt+j1/NYX7odddpgViCfyQGgAuAbPSnDUonxduy5/Y/YI7xNQeSDfLIGqCmkLYixYKeXSJALAjVICFLy3gBg0hqQI52lhjIvrC27+ze+Sh4UJiR1MaPjrTQewrlUzqiKyfe9bwMQRXW/R7davr0BSCSnR/Dj4JIhXhjGWSBEZwdHufTekRm0tejp0dEMEadiwV5X2x5BJi+UPrMF/bMFKlslUb3rTm/CP//iP2Gmnnbz5Vm4MIGfkl36dAvVhs7kFxLcRAAzqBpkIpjLwQX8PAKtWrcJ9992Ho446qmyQx1hTpkzB1VdfDQDYbrvtvLFkG4CRc52C57ZzH30uJyA9dfBPCSj+uzSJgp8jNwIQGhK6b63n1u9jjz2G//t//y8+9rGPlUWxkavX62HmzJmYO3cupk6diic/+cmbhAAY65hAVyTkIOA+iBgYDwFgrcVDDz2Euq7x17/+tSibShUCYEurfRfPw2sP25sM0tBHBsjGXkBszgk3iuzL5aer+ANVuQ9GYxhs0Ye5jBXIPLCCl/AL4PUdW5qtN8a48QUhLRwIhvYKBw+WjIVVzQyzmJ55w0IEfwKW6PNcd0VtTBmZEH9Cnbi6y+NqlV/QxliSQYcowGbKwPrmqngfWHKyFwm3IpO76Fi643/GhT/BI3/bsh1bj37GEjx378WRl0Vb3JcfTWn9kOYYzMYoUM6tjAEYMgSEkFTJRpITL5qnpcjNJDlAxlKsofg8S74X6E456APPxCCwIoTTB8QvI90UiBJAlnHwxwj+Ff4KJRJPXllFZoWKxn/kmmTCQgg5RbGFos5g3wYFhet+uwIX/fQ35eY9AUpk3Fpr7LzzztEsd9pR7ZJf58BXbkPatkmWrmsX+G/boOfMCdvGB9LHWrduHf7whz/grLPOwmWXXVYWxDhq6dKl+MxnPgMAWLBgAWbPnp0FKjn1Rtt5GwR6UgKhLY6vC0SliQODjP/aqq5r/P73v8erX/1q3H333WVBPIFEwJw5czBr1ixss802eNKTnlQIgBYC4LHHHsOjjz6KNWvW4JFHHsGjjz5aFlCpQgBsaVVphY8fvyx7Y0o7ND67XAVDLpucnEprjI7WHvCG3HHuMLoPYepce8BLICI4lSen34FfVgKknVwGU/BgQ/mOaIMmQqQbP4XMhctD1qZZgooM1qoqxCLqSM2fN1ThWMJUXi6HXFzXG3IhHCMhUORGPVobF/MWZsMZ8ItSQtQDxlj89r4H8d/f/+UWv5533G4G/vmlB1PnOcQnyvfiD8BGss+D8GwiFiIpLYxJ4yDjG1T0935tKDcyEpz3xSDPyjrysmblnfQbLig8X03xejpd354UCKvPE3Pu4rCUgGEiHwvloy75e0JKNc8h6gGn5PHRfc2xaRQ0lhQKfG0GgsSPKwiR5tg8C5EbGj++IddTGidqgWb+f2WZQ5wodfzxx+Otb30rpkyZgsWLF/tZ7hxg4q95NltrHSdWJHL8tIPaJulvIxLGslFP4wK7Ord33nknPvKRj+DSSy8tC2EDap999sGnP/1pAMDixYuzyQDpOWK3/RygSV37h4kKTM9v+jcp+E/XaqpG6QJ38rf33HMPzj777BL7t4lqypQpmD17NrbZZhvMmjULU6ZMKQSAqzVr1mD16tV46KGHvNt/qVKFANiC6w3P3QdLR+bFs7aKwaylOWIEyS9kFl9Hm3sGucGgDFEnz1IkoIDX/iQBFc1MKwH/lhPNw+96M0JEXmbx/Db6/QKsSPWVQi0mZeLK6x6lctJv8RYQ/wGtJDnBRLPnJgFkilzjOf/dH1XqoAZCgT4QTDhufoNBvgGcvS6RgZYSEq75zXJcfN0dW8V6PvnoA7Dz9jPJdDIsBg9ubVCNpDLSsIaDu76JgCx8RJ9lQ0lSaTQjJc3jV6Q2MOQ/wf9mc75mjTSqA/+63GOn8YHePdolT8jvCzj34zsWkeP/qImNAr3ywMaeHH79KfQpB5iAYhLLKxVg/LiA+BWEiM04qcGYfpDH3gQ8HlTm/ydevfrVr8Y73/lOzJgxAyMjI9kNZs6dPUc650BS+u/cXHVOkda2MW8jFVIAyWAwrbvuugtf+MIX8MlPfrIsgI1Qxx57LP7pn/4JWmvstttufcAsXR9dAH6QIiAF+m3rbRBoy/28a/2la/Yvf/kLPvvZzxbviM1IBkyfPh3bbrster0epk2bBq01er0epk+fvlUQAA899BAefPBBH/FXqlQhALaiWrZ0BEcf+NQkpzuebZMPtUpr1KaOu43u/5Wba4aTSztFO93gEHXWFRQaL3MdAa9AQIQzLx3OSmsvqQ6u+Yi6rNpHnMXyfQ/UkP+Q15Fs22Ruxjzz14DJyBUdAMXIA5ExW7AItJ4YsWT+1zxuJSPqBDrFmd5kjKjk3FSUlsAEgygozrv8pq3GNf24g/fEgU9dECnkeVY/3iCyN0DsNh/c84WgamIj3UB9kMRbRCoWmen3XhDu3E2pdN9IiYI8JhyBBIzWFhURUorIAonGS302lEq9I7Q342yk0UK0sXkmG+8FwoPHUfy14UZc6ih6MvydJYKquZZABBURgFEMYFCsWG80qP0IAPg+4Yi55Q+swbmX3lBu2hOwTj31VLzkJS/BnDlzsOOOO2ZBWC7xpQ10dTnvd22ScwkCDO7aNuaD5sj5sZYvX46vfOUrZWb7CSKSpk2bllWT5Mja3LrKeQPkDB1z3fs2UJbzrkgJpbbP5xwJ8PDDD2P58uU44ogjsHbt2nLyJ1iJX8D06dNRVRWmTp3qyYF01GkyEQDr1q3D2rVr8fDDD2P16tWo67qc7FKFANhaa5cdZuKtLzogkuPL5j0AHBUD28hMDb67aqzFqAlEgscR8nMX1aekm65FEkzdFt/tgzfI8w7uEFM248GWcZJ5gfg87w9SC8jrsxSdBnZ9VgHYpe7ofnYaoSMbNhV511XvZA4bO687UKNdpxbkSQBlI6NDHm0AkxMgoIZGIl5VOvJECGBQ4YMX/BCPPrZ+q1jPT1swB298/r6e/JDuctypppl8EDhFUFUIGPVkjbGwiiMXnVGfQd86aLwtVHDQdxeCkAR+rp8/qF1Mn0Xj8C8LzpKMQSlkCYBKBWk/+xSsr2tnWKhjfw7wOIry4w7RpsL9t7YGlZ//j0mVaASHSCcZPVHEI/QrLprvxtGENn5tKn4t1/32Pnzj2tvLTXsC1sKFC72M+SlPeQq22267LAjnzS67r7eZrLWB8a6N8rBd3DaH9q7N9IMPPogVK1bgZS97Gf785z+XE78Ri00Bt91220hNMug8tcn9u8ihtmi4QdX1+20Rlvy9xx57DL///e/x9re/HTfffHM58ZOUHJg6dSqqqkKv1wMAVFXVlwABNF4pm5oAWLduXfS4Dz30EB5++OFi5leqEACl4pI4wCbnXJEaQMeyXueQzpJc/7UOjt4qigtXkRu+ADJPCKRReQgd1Qg4wMLUwXCPJf8C3IIjOZx7v41c0gXM+5hAWV7yfn3XyXVzVQOatFKiwneb1eCeHo0eOJBkIrf1+P15QkIxoGMQaMmNXea0w1y/YZNFG+e+83iCzKDfvuKv+K/v/WKrWcvTn9TDR15zeOQDwE7ybMAnUv7amVEyEVS7OX05B1qOq1uzbBgZbfREwqEAa5uf9by0Q/lIQjlhTA403gMBbFtjkwjKkBRAPf/wc1qbjRFfIL1yqRXw1208MlMRsYTAwVHQZZjr98fUx3HCkyV+nt/yJsUpH5ypZ3MdWBhSXsh17IkBNDLd8y6/GXdtJUqWyVhi6Ka1xuLFi32nrA2Q5YDZsGC/C+jnNta50YFUtt2WFy7fW7VqFZYvX46TTjoJt912WznhT0DNnj3beyrMmjULCxcuHAiAciCqTS0wHlJprCRA2+9Za1HXNf7whz/g/e9/P773ve+VE741ABhaa71ezysJNmTtrV8fN3RGR0fHtT5LlSoEwFZexz5rDxy851Nosw6/SZfZ9rh7KTPH/Tm7KgHFAoTkMTlxIGzKTARiBRBxu1Ka+iFPHLDW+DxyreIOf12baNHEpIRElDW/24A/+Bx2NjzsN9YLqgYG+J5gIPm/cjb9ljrzJjPq0AB8fnU0StCx+iU+LZJYeyKgiVu79vbl+NbP7tiq1vNrD90L+y3ZKTpO8Qx7nCYh64nz7tkHQ0C7H/2QDrxbB6lqRP6eRwRSQgw2mPt5ZYupmzQHC68CSV36Y68IGwF+WXlCMLEPQrhubEwWgTQq7n1UWmO0Np64EOUAK1vCtSFkYPMqhDQIhAhtgti/Q8Vxiez4zz4XTDZ85Os/wZpHHys37AlcL3/5y/Ge97wHU6dOxeLFi9Hr9Vol/sNGUo1lo50D/JYI3rF0gPn7q1evxvLly3H22WcX078nuJYsWYLzzz/fkwBpPGBb1nmu287nMT3/wwK3rq5+20hA2/pasWIFPvnJT3rTw1KlSpUqVQiAzVZ7L5qL1y/7uwRcBnM+AfTiGK5ZfizyTd3El0WRgk7mLyAsAHFFJoHWm5tpMgIUECDdTu0vbG7RAAAgAElEQVS6pXVtglN6EqMmM8aagtG52++BlLKelNBKk9M7f7CHVad0+JA3FAHIYIpHBphIkS6uj3SLpNqgbGKbALzQrRaCQhIAAGcIp5vHqJ3k3B93oSAU8JkrbsKdK7eurum+I/PwmsOXNmaOHhg7UgZBXs7pdymBFDvZhyQHUOyiAFxF689yPKMio7tIP98yx0p/qGjDyiSCqEHkGtV0h7Rorjft4/YCwG9GTsjMMDL8FPVLM94j1zZg/bUkhGCQODr1iqb7gbWgKQN/PPriRdEYVFo3EmSNJTIrs+m2wHV33odv/LTI/ydDnXjiiTjhhBMwdepU7LLLLn3z/CyTHQTsBoH9NtDeNoudA2aD5nUF/J933nn40pe+VE7wJqjnPve5OOuss/pIgGFj+tL1kFMHjHXNda2zYUiAFStW4OKLL8Zpp51WTnCpUqVKFQJg81elFT72umXOTA8R4JANvUjPteoH6QyO2EjNd/0I9EcAN9mYeYd/14UUYC3SbEPxZn5EQJ4TaEzb3KgAG7Vp3YBk7/BuLWobiAIhFxhAg53Rk9Yuy/gZSMkHPRMExlj0qirMljuZNsCZ2HGHWggCJMdH6+Z8yOiEHAetyKQNcWzah772Y/xtK3NNnzalh7Nee1gr+Ad93xiR6Md587KmamMjdQCrYATgGx8HycZ4DSnDIDjq1BMJIIZ9/Z4ElswzI0MIJ1d230nMAJVWHvQ35BKisR15Th4L0M7bgF9X7aK2emJgSISavB+twnFC4qXACgNJBFDKOoICsVGgI1XY6FNRXOBXfvxr/OL3fyo360lS73vf+3DMMcd4JUBVVdFcbFsXdyxgP/1524x3F4AbRACI7B8ADj300CKt3YQlyQBCAixatKhzDYz1vHetq2GNB9tUJCkJsHz5cqxevRovfelL8Ze//KWc3FKlSpUqBMDEqFcdsgeeuceixnmcoEZFgIE7fJzbLKZ73NUX0FTXjbxdVzoyFAzu68EFn6PWvKSaAL/PQReHfAemfTa5M0hjmXHTuRSH/Qb4G2ds1uSwhxVmHNjpy46nx7MIXV/uCFvF7IGK5q0DcFIkP48TBcSbQMiIYHgowMqSIiKcIOVAKTuny7G77d6/4n9+cOtWuZ7/4e/3xL67LYg3asldxBNHzu8BNp1NRrTmBfRK6oKsicjd358XRIifN5s2csG33jTQynUkALxuPAF4tCP4GTTu+5wOQcGdqLQjnZKNL8/sM4nXXGOGEgSC8sUaoKpoFMG9uZ4zDzRR/KcihU5zvWhlI6Af6MDYE6MhsMLPeWzhwxf+uMT/TaJasGABLrroIgDwSgCZex2mixtIT90K4toc/weBwPT320Agg/8jjzyyGGhtjn3Jq16FU045ZSAJMBYCYBiiqC2CMjcK0LaG5PdXrFiB1atX47TTTsMPfvCDclJLlSpVqhAAE6cOWrITjjt0r0iyW5HEmTCnBy62hQyoHDDgHHblNO/KA4gAqnguPhu74zPZRY4AT0pEH85gOTNIjh3M1DTFoMkIQ/NYwTTNdzvFFEo+6FWQ1oeD4VQIHHHoDeCs9zLQ9Bo1eywgdEHZVJCfw/LvsNM/GyjGeWsALD7//Vtw+4oHtsr1vHjeTLz9yAOSDEA27IsBsCFpfaoCkL+2STSeJaDKwN56Gb+D6o7AqVQw0ASPHCh480ClNKxrlyuauxeQ3KwnQz4YNnq9yrXxxUvARm89jLdEABshbtAiTt6Q9cmpE83f2gDgTfN+/DXP8/2wUJaVQqKqad649QoWFQgvsIGgxc/vuh8XXlNM1yZbPfvQQ/Hxf/kXTwIsWbLER7ttKAEwjCqgC9wPIgAY/Jeu7ear6dOn48orr/T/biMBxpIaMajzP2yE2yACAADuvfderF69Gv/5n/+Jr33ta+WElipVqlQhACZWbTNtCj74ykOjDh13lUFSZMOzwZ4kiOecRfKraUTAu5uT/N7Y4MBOn6ywZPbXSKnJyd1QRzH5sJcuPmBR1yyrpvhCIgW01jnsTIx/8+blceT3/cp0x0YkzNzpDAAvzp1XjnCQ+W3LoxMyk92XA29CKkMmr5i9BQQ4fvCrP9rq5P9c73jRfli842x/DkyS2dz3PTKpg/O6CCSMdd8LqQIVgRMG4jEp1cziawUCz6HbrQiUy7oGmWXyuvZeBN5QslkTAtD981sLpbUnwNLrzJABory/qtIRqSbXsLMG8AaYo8agp5UjNqw3ugTI/4Ak/9qNJIiSRiUmoP69uWPL16ZysYtf+uGtRf4/Set//a+X4L3vPXUoEmCsCgC+ztjFf1gzwTYCYNWqVfja176GH/7wh7j99ttx9913lxO5GWv27Nk45JBDcNhhh+HQQw/NkgDjJQCyDYdxEAC5dbR8+XKsWrUK3/rWt3DOOeeUE1mqVKlShQCYmHX8oXti710XeLBKeDxqf1q3sUcicw4gl2TOyZnUzf81gMGZ7o267qtKXPXhAIMiQqI2BppICGNjk7GKnfpBYwUmgDtjLHSlnDFaMDaLjOBkpECHPHnxQGg2pjy/zeA7DkwThYP2Weo0DM5O8Cr8lTEmilhTSnvgx3PmEXgkUkJB4Vd//AvOv/rWrXo9v2DpzjjiGbt58MxrVNaBzaxRJoC8eMAbQapgAkjAnCMYGeBKaoBxnXAfE6kQ+2e4dSFGlEqR1wDCrH4qRW1GCJp1r7XCaG2ckkT5WEHlYXl8Tcv0ix9pkEvaUvYfAvgP6QPiT8Brs1n7skyjaEKXoqDd1yYxC1XR/SYcEzG/PP2rP8K6x9eXG/Qkrbe+9S04/vjXDyQBNoQAaHucsRAAV1xxBX7yk5/g29/+Nn7/+9+XEzcBa9asWTjkkENw9NFH4/jjj5+wBMDy5ctx3XXX4fbbb8cnP/lJrF27tpy8UqVKlSoEwMSsfRfvgNcetjSaEU4/OKtKo67rZkNfiWN4I28GGiM6AUPe+Mx1N/1mziHjBhAIwDb+dyMTwdTt33C8IHzMnsiO/Zy2SxWoa4NRa1C5zHd2+pd57tqGcQdWJkSSfBodUCrMSWtNXgEKlBUfQJX8TCsVuskcMYfgtdAAROPUCgi/Q11Yv3EFYqaFSIAvXHUr7thK5f9+szhjKt537CEeaIrLvJ/tN2G0Qw6oShUrFGnXAHkZFaB14kE2vFLFOgmLVo2/gMzGWwTyjA0FQQaOgZSyXjEQFAZsHBkiKoHYOJCj+lhdwCqcYLIZDDv9OI8Xy7Bnh4qIBwH1dHHCGIsa1q1nFdY6GQDEKRoqTtOIxiiAn991P75+zW/KzXmSV6/Xw9KlS7HXXnth6dKlOPjgg/GMZzxjsxMAV1xxBW644QZcfPHF+O1vf1tO1CSq2bNn4/nPfz6OPfZYHH300ZudALjllltw00034Rvf+AZuv/12/OlPRbVUqlSpUoUAmARVaYWzXvNsKF1F37PUCZQzEdzAbRR9J11KkSizyRegItd6KHjwVBuK67PBkK0BH8b9W/vuJ4MYn3OefJArGzwLlI8utGRUFowLDVycHsfvqeBIXhF5QVZ/fiMQOpo2mKLZRg3Rq1Tf+4pi5ZyJgLHGjTw4WbczSmRfBQGijUFcMFFkd/b7V63Ff1x6fVnQAN74nKXYc9E8fyPhDZ8cP9BaknUhmfZBuQFn0sebTOWvC55dVz4pghMebN/fxQkSjdmen2/2156NDAdl7deu0y/vQcu1QdffqKmD8sEGAs6TCW4dGgf0e2L0Rz9XSvmYSQtA2bDeqioQYbJ20yQFG40bKE9qMMkmr4mTDKQu+NGv8Ys/lI30llg77rgjnv3sZ+Oggw7CM57xDBx00EGbhAC45pprcPXVV+Ob3/xmAf1bIBnw4he/eJMQALfccgtuvvlmXHLJJbjttttw7733lhNRqlSpUoUAmJx1zP674tCnj0Ru/RznJd3CSgfXfQ8kSNpMVvfUqdSoKh3P/gIwVvkOOc8g84nXcLntAdU3UmIVgFHtnlI6rPEMvfVAhM3eNJmTyUiAiuLeGvAvDujBPE5Du2MgjyOmflqpqEurfERibiPBxyJOSDA2xAUqNxfO5oqKOs9yfoDG/f+LV91SFjOAfUfm4bWH7+1JmnRvZ1y3nQ3xPFlljF+vaVKFEEENYaQi0kfr5vpY7xIwQGtSuXUr6hAdpUW4tcCRm84IQ1z4RZ1jXfedIweNj+ajPAAaRYhGeSjCUK5nGYkQ5QLHAgZn/5jw86SEtRQNGEZdGmIsHEvxChmtbfBYoOtDJ6NHxf1/6yIEDjvsMBx44IE44IADcOCBB240AkBA/8UXX4zbb7+9HOytmAwYLwFw66234uc//3kB/KVKlSpVCIAtr0bmzcQ7jzowGIu5D0UBEIJXDNgsLMwqs0w97oo7Uy9dOZCNYGoHUP53AALeuV8pD0QEWEjn31DHnT/MfRdWJPla+b+T5/EJAG5W2iKJW6N4MwH20t307zP8FawzZRP3/+Z9hC49P3fznoznACysjzWUUQMxbUv3I33+DEA0L/6Fq7Ze9/+0tpk2Bacd9/d9ao1cigWDZ0vSfotGll+R4kKULkIG8ZhA7da0cgZ9sLGUvxZ5PoJsXwzMaiPRkLKmLHqVSuTyYQHI9dOMjohhZvAkMOQXIP8NRIiMQIQMgUihwu8RYe3G87bN9QPrwwD8+vY+GY4YtJDxGGeC6QkR48eILBGDN951Py76aQFrW2tVVeVHBfbdd1+88pWvHBMB8KMf/QjXX389vv/97+NHP/pROaBbKRmwbNkyvPCFL8RrX/vaoQmAlStX4le/+hXuueceXH755fj1r39dAH+pUqVKFQJgy643P38f7LZgrv9gZNN7RTPyydh59DN29reIu9ucXR++nwBciwjECHCpyWGQJdE+3s8xDU23ERh1KgUvzVdsPKb8a5UnFC8AD8Rlnt+9Vq0UlIbLho/nl1mGbTzp0Gcz58EV58ILycIKBB4T4GPO8WwMbI0F7l/1CM697IayiKlefuASHLjHzt4ngpUgSjWdelnDQvBIJCR7PQTQ7f4W4dQqModsCLFIa+J/NzKFFHd8IdXc8/UqTdF/zX+9nJ/GWiwpRNIITIWGiJD1a5L4P1a0KKdi0CpOkwQlEojCRxZkGElhVYONiDFZvqKiMP5aMO56JdWMqHaM9e/7gh/fhl/+4c9lAZfyhMDSpUsHzngDQF3XuPXWW8tBK+Vru+2260uJaKtVq1aVA1aqVKlShQDYuuo5ez0FRx7w1AjgSmfOz+8TgBbwWxvTTxIkbupKAb2qwvpaHMoJbCiauwcil/UArDyM9sA3uK8Tm++AnlYKj4/WUVZ7pQFrlX99InlWWnnVgTiQ82yzd2LXYY67LweePQio4y8kRqWbx5A0Az8IwBnzNDMtJm/eYR2Aw6sQdayAtkop3PrHP+N/fvCrsoipRubOxNuP2t+nRyj0bwCZJApRfyHKUrn1VRvTlyggoyta68bLAmw2KFSNW+JaNYaZCvRY1hNb4Zpy2gMVxmik+2/I0C+48QdSo3KvQ/wAjMzwi6pFK2fKGRNNltIpWKEQwHva/RfvCok7ZC+CoOIJBpYhLkNeQ00JGUzQwVp8+Os/KfL/UqVKlSpVqlSpQgCUeqJr1oyp+MArDvFdeZ2AA2+sl4SosQu5gCP2EDDOVM14kBvk7Fpp7zRgLEXquV8SGX+Q5geSwEemeVf+Jg5NFo923cpKywxy6M7yTLNSSN5LI09m4GOd+ZlmpYBfpUGNoLSKDAtZAWG990HsrxCpJMCjCM1vSJwcpyRwJ1sB+NyVv9zq3f9z9c4j98fO82bBuPVZUcKEQjB+lJtNGDVxQB4CpIMRZSSl1xJWSWGNHsyG9e5VLBF5YPw6YtM8IX7YKV8rjVFTO6BtPAnFxn7N2kJEUoTOeuLqL1GIWkFyB1gtICMuwc8iJHbIfSH8O/YNEfWCrP/askcGohEB+b6QCTfddT++XuT/pUqVKlWqVKlShQAotWnq9Yc9DU9fvBMonjsAJd/IC2Z1AlSrSoUccNXfa03NwQRUC1Bhh32JLxP/AAZNo8Y08n3FzuaBgBDA5YG9lzRzxJ/KztcLyK9r6wGgVgG4BT8E1fe+/L8FkDkCQ2tnVOjMz6IoNk+0hKi45ntEPthgBsjg31J3+L4HH8G5l91YFm+mnvf0RThi/93i+WFZ1zwT6ta4dl16HsNoVCjwaygQTIpc7HX0/ZRE8koWt3Sa5IkQidc8lnHz+NanFchoSzOy0ryg0dp6YsgTVCaoX4QYC14VyoP02oS1I8SVHAshIkBRgpH5n6NI4FIuQsRiODaVUo3XAcKIQJTGIfcKRwCwwkcp5eT/xf2/VKlSpUqVKlWqEAClNkn93cg8/MNhS5sToGMZsPaB5M3ZCTP6OpYxIz9rx4BfKR1GBqizqPqc9BW5sIcZfWOsz2KXVVJVjQTau/GjAd2+80otWgFp1gMa506uAOmJSgdWnsMqRHnq1s1tG3HoT4yFNDmsazFNc0ubxxWk8y8gSnrKjTmg8Q7tFv3eC0oBv/rjX3D+1UX+n6vtZkzF//OKQ/z5As3DWyKYGqWJprl840AyvPM/r2ue+VdO+QGmahQ8+LV0nQggF5NAGzn4mwi0C0j2ZJB7XOvjMQNoN9ai515/4ykgowTx65Zov74bLZlcwqLp2qfGf6KiIc6r4jEYIjTCdWyjJ1II8/89STOw4Zo546Jr8Lci/y9VqlSpUqVKlSoEQKlNU5VW+OhrD3OgngCndPFEYs+zvW6GvzbGm4oBiNzwBSRI51HpGLwIwOfTL7L5SoCNMRF4ZkNBmeUXMB6k+W4+WaLOvMM5x52RiJsAk5/rdnPLSgmIQ2TC5+XSQgygiS8UssNa64iJ8L5AP5dxBeNmw40xPuovODFQQoGKj/0Xrrq1yP876nXPfhr2XryTl/trAs6ps7iPpHTrR7rwSokugxQbtHb8bL5SUBYYJTm8cifa+G4/vDLFGgvrzqdWscmm9ySwgNJkJCjkFMJ4gFxxnErgvuOIJXhAz1L/QCY5UiM0+T0JVhuLXhXGUoIqwKUYuHtF3w1c1ns6KmBs9Ovy/duW/xVfvKoYuJUqVapUqVKlShUCoNQmrWP22wWHLl0cSaUZMBnYZt6dor/8971EHW72Po4RYzd+yyCEI/gUO+Q3X4/WxgPouIvqQIQAaB1ADeD+jlQCYaQguJb3dAVjje+OKgCjRoBUiItTRBqExwhL1HduHTIUcgAIqQIMyqwVZ3UVmQN65YCAOff6DcW6efn/qkfwiSL/76y/G5mH14qqJenMpzPsIXoSLp7PhLESb7oHihJU/lYl8vvaWCgNaOgAtpWi8ydz9NZL/K0fYRFSqVnhjVKGyCg3HmNVbJbJIyVeGRP5Rni4nT1G4RJRfa7+KgL1kkhgYOpgLCh+Aukd2yKOs5R7gPxe7UYbKqXwtZ/chhvvur8s2FKlSpUqVapUqUIAlNqUNTJvJk4+6gBYmvmPwUIAqFWlYWoTKwJosx+Bfw8KuOuoY6m1A0UC5GVmudIqmp1nF/bQUQ89c+/Q7r0KbCAMKMItBjcxcJFH1FpTPFr4RT4OohRQkDEF50tgbDT3HxugBaM1Sy9MgGekiLD98n9rLW64ayW+ee0dZdF21DbTpuCDxx3qI/64i621Qu1IIh4TkGMu8Xp8K7JwZoIIagFFpJIskTDi0pxdUbIE5UFICbCkOkg9NBrTySb9wb80URDY2IdCOvPecd+tl0DSBQWEVyQkMZ1MMgkhYWgcoFmbzUxMbIrYH1EZ+WUIuZdcShIH+uELf1Lk/6VKlSpVqlSpUoUAKLU56qTn74Pd5m8fbd5FiswdR5OYq4ncWTb6xgTzOxem50FMVWn/g9pYHxfoZ+Nl/lnDgw15PnYcFwABH5EG78pvETLdAxixZMzW/G0YWyCTN/EgQDBDUxQ76M3PyN1d/s0RgTILLTnvtTEeNFoyXJPHCWaFzWOM1iYyJfRjEwr43Pd+ibvuL9nFg+rYg5bgwN0X9SU/eOCamP4xkOdRAU2jKyKRkTEVv+6oxW1tfDfr9Sq/HsQhX+T/zex98NuwIFNN1Tw6O+cDsQqFgTWrG3xvX6XJHWG9NkkTBkppf+0p5RQPBsGksnnHzWuvjSe90tfB3hY8QhMrZsJN/jfLHyg+FqVKlSpVqlSpSQlYt585o/N3jLUYrWvAAmvWPV4OWiEAJmY9b69FOOIZu/V9XyS9aTc/BRVs+CdCf0M9bA9gHEAIf4foMRQZi4WLSEA8zUX7WMGojd9IpxVJj0Eu/M7ZT3uPARuZ8wWwpN18dwBWjF6CD4CKOvwq8hhoXmfwFQhjAeE90Cw50DdnHpExAFYW+f/QNTJvJt5x5P6ojUj3Q2SexOexD4UfEaGYPWstlMzRw0BB+1QGY+DGRYK/hJI5F8RjG0I+Kf+B4MYMrIkMBWV8RUB8bRr7/eAZoKJrUpMJpXbjNxbWJwQoKFgl16+Krl/FBpdgpUEgD7yZJuKRnmB0GccH+khPR2iIWkfUQBJjCQAXXvMb/PzuIv8vVapUqVKlSk3M2nnuthiZuy2mPanCzBkzsPuiHWChsGDOtqHBBGTGTJt/r330Udz7pwfw/V/9Ebctf7Ac0EIATLzabsZUfODYQ+ITQoCWN/2cS+8j9ziWjIzvFP2fzzwXQGxVlMPegGBnOmgBXTVyfuNANJwxoHRfvSmgCjPzAqhzhm+BGHDghszNZN5f3NW11uE9OMWBJYd2D8IEQCkFK+Zn4qxOnX8/jZCkAIROqo2BWD8TgxvuXIlv/qzI/4ett79wPyycO5OM+eg8IJ7T15FSQPn1VVsDZRsyS0C2dioRpsREFWAQZvSF0BHwL7P8TBjF8vlmbKAhjmpHNvGaNTHJ5Dr3laafIxgb1rYhGiqt/ZhK5d+zrHky/nPyGuuuOa3ddW3hRwmYb+PrA240wRgZl4D3UQAQjSIAwIe/XuT/pUqVKlWqVKmJW0fuN4LddpyFaVOnYeedtm8UxJIU5lXJoYnnVZC0iV+7di2uue0efPvGu8oBLQTAxKw3Hv507LnzPAKrYlIWJNDsWC7Ax1C305sCGkSdeEtA1oNueozwQ1kFKolxsx6MgLq2Pn9dNe7o4kCuFBzYIZM0D1gSYzRh7UjeDDGHQxiDkPdZ18bNeIdjI8oFISNqayIiRVlF3gpChtholtpaB56IYDGUsf6Z7/6iyP/HUMv2WoQX7r8Exo2FaJrZr+gYK9WYQDZEQPAB4IjLSE3ibv6KUh6qKDpSw1iDqlk4UGjWg5jo+fl8SbnwryOQCkbUAa57LiM5Bs3fBHM+S6kAiK4lyySZW/c8biImmmJOKbGfwTQxvL40UUDTqISM3wjo5/GJ1CfBGovfrHgAX/xBcf8vVapUqVKlSk3cetXBT8XOO8zBoh23TxCrirzOUi+nZi/VxDhrpbD20UfxrxdfiwceXlcOaiEAJl793cg8vPrZT/PAs1JhLtnL1B2QsBRfBsBnjTcmfnBdSep0OrAeO+l7bb4HJlAMfIPkebQ26GkVzT0Dja9ATXPSkjkuHdGKZri1A2c8y20jl4Lm8aw1zjBQRZJw8RbwRmgO+Mhct/c3qMML1No68B9gWXPTsFEkoic0iBAQrwIFhZWrHvn/2XvzKMuu8j70t/c+59xbY1d1dXX1oG611BpaA5IlBiEQZpAZjAkJthmMiQceAeJlJ8svfnkheXZC/LDzng2EGDsrvLznODGLBZjYgJgnYUAGJIEkNHRLLam71bNU1TVX3XvO3vv98X3f3vvcFrYBteiW9rdgqbu66tYd9j5nf7/vN+A/Zvr/D1Qbhjt4x89eH5tPf9r1m9eaiykTSAAA19bSC3XexWULxVN18o1wAw2vak3sAfZ3YFDJWx8eI03CkLg9DLAD0iZfMRtBKTEMTAwIQypAlMzE6X4aa+gjeIHUJDCa/2mOGPRwLKfwAWCLyZRyJYhgSfo+pMCEUgofueU+3J7d/3PlypUrV65cZ3H94xdeiWdfupMHn+CzEQ8ZjQ79SmE0M6U9vFdJwlMc9H397ofwkW/cl9/UDACcfWW0wu+98YWhAW03S3HimNJdjI6Uf58O6JPIwPTxxHk8aIf5o0/Ny5yL1GmfuK7LgzvXdhsfbDBiM4NWlCAAGI5Zc6BpZIj8C6CAC0aAIfPdOziv2NTPR6BBCXggTZtPNP1R/w9E6nSqiXbOtT+A1GcAKR3d48t3H8Ln73g4L9IfsH7xhktx5flbTgMAwkQfCeFfNPtAql2JwA1SoEpBJ0CYNjpGCPq2SZ6sY/m60YC1Ljjti2lmCg6IVkDYLYqBJQGPYsSkCqkZwoYRGUEL3FLxdcpE3xgdZC2yr0he44Pkp704kz3oY/RniON8HNmNMATS3frOj34j0/9z5cqVK1euXGdtdQqDP3jzy1tpRnLCIbaoSXzEdDR8ZiNk6U3izyj8yz/9HFZ7dX5zMwBw9tU/uGYXbrhiVwsAkIY9LPCBxgIKaCw3D7wZ2rnp7QY3GK4ltOPHczaPIAJaDRQkGz1ZODr4AviW/4BDBCJi9JsDTosElEkwWP9Pv9MoBWiasqrkdRmj4KyH9T4BL1h77YitEDa/R8s3gXLencivY3ThQPZfSEZQwB9/5js4PLuUF+gPWFftnMYvvOBy1rS3wSgvk/MA9CR+AAlrRQCiIMeAIk8ApYMfhfUxvlIlPhiNcygZJUZgAdiwHyiZgj57aaaFui/rJERmBh+OBGBIdP0+ARQCK0arwMLRScJFACZc3C+FMXDeBbPM0MALwyXEBkaEKrIofHhfnUN4Hwa/tvfILP70y3flhZkrV65cuXLlOnvPj7tm8NZXPJPP8m02p5zTAvvSR2BAgIDQiPAPKKXwyW/tw+e+uz+/uRkAOPtq1/Q43v6Ka8MnoQfMLDzYmVw+sCTyT6vodI6QKS5teXRUh5IoPtVyEkGZb0kAACAASURBVHeeHMy14abK+eBsrhPtvWw40VqTgZluxw/6RF+foHNBs8Pf691gZFr0JpDXLs8hBS6EkeBaZoji7J66oqPlLh89Ejx7EfjkopJ6KsSLxrH5ZfynT92eF+cPUaPdEu94zfUwbCgpTXdaqat+mFirNNFCBad9ubBrpWhSD2rajdGtibfIYLRW3PCr0DdL5F4AxBIGjEsi9wTUkgbc+zSWkAAI+Z2O/fyNYklM0pgH8z0VG3swUCY+A84RI8EYBPNBMfGTfaAZJAvGholhoBqIKUyTEtJEjo98Y292/8+VK1euXLlyndX14mdcgNdcvycOfRIjNOoJdIwYF/PkgbhwkXnKQO/AyVN4z1/dkt/cDACcnfWWG6/C7i2T4e+yuBVU1AXzZDFtDpQCausGJpSI00Ie6avEHOy06SpPw8X4TinfAiBkIk5/lgYjARkQdd3SWAslOoXuFAuoaQIaG77UBNBaH7wMpKkTnY9EEWqZ2gb6s29R+EWDHRe4D0kKgirKc0VgBLSN1778vYP4/J2Z/v/D1s8+azees2dHNGlMLzqP4w0gjax8XuEinnhSqMS8TzNtPlDvvdwYCMQyWrVoYMJCocdoR/ClMZmi50/XggBEAFqMG7lBhV4/JHFEY8tUmhNAJp826AJiJSAXENIFxAcjjbgZfE6yzdKIQijwewD82w9n9/9cuXLlypUr19ldv3LjNbh299bo1ZUkN1GboMNQpnEemgcr3iEMMmV44z15kjnn8MefvhX3H5nNb3AGAM6+uvHyHXjZM3e3nNNlSiq0/sFYwKjmb9OBZRoPKJrCJqaAvpU2oE5DzYA4QXSJngapARkzDQCOEPSxsZcNitAY6WQi74KO2zmatlKjw5tc6fD849coVQDc/Fvnk9cendXl9apgGOJDg+U9Rxxq3TIHSZvT9L32AP7ks5n+/6PU+ZvG8baXX5N4OrRlLCn7IsgBQpwkA1ag2Mo0DUB4MDpETEY/Cc1rJf4uJM6BgE9M/gQAAwMHzokPRXSQlRSOwARQEYmW/Rh2jQAC7HERwAT40IgHdkvCUEnZPoGV42Ti307OCCCIsGoSEC+lwmmlWB4B7Dsyiz+7+e68IHPlypUrV65cZ3X91muej10zG+KZL/HpCkNDZcJAUCSVkVWZ9C0A4B2c87jz4An8j5yElAGAs7Emhjt4x89dHxY90M5Jt8FpPDEMS037MOihFmP/jNZkdqakcYnf4uVxTJt6P0jP5nYt0fT7RGOt4J1j2r8aYBPEvHTNE03rYxMvvxMMFhidTuLJ+dPDozR6IMItghTCkAjIn4AYiMZp7UYKEU1E28AQAE7Mr+B92f3/R663/tRVuJBZLYOSFqP14zbBElvnE2aIAFepGaBizYdj59eQEMFT90Z0/KDpvgqRfj7QwnSiX3GJLl+n5pFBiqAC7T6mU8R9pxLdv9E6NOCSGkDNevQ2APtsuET2I14EaMVUKn7M6E2RJmXIYyig/R7y8/roLfsy/T9Xrly5cuXKddbXv/r5G7B1cqztz4VERsoHfI0Y3039kOMhjA3nO+kBGusAePz+x27BqeX1/CZnAODsq1/6yctw+c6Z09z1pak1nGcuupeU/uzRpgArRU25NjpMSQVUsLxRAkomen1JCfA+NBX0O1z8Pp7Pp7rkKCtQrcxzFcwG0Zpa+rYPfGtaK88DzjMtW+LaYlpBSimnyW0EA9IEg2i8phOWQ1suQBILj4TZjZvvOYTPZff/H7lecvkOvPSaCwMgI+wTncg7UuAqbbZ90mzb1CgQaVIDWtF7AgRILKasb61J3y/fH7T2cFDQbQ8C/vPpwNFAIw6RjSRmmmHfyverKFFJvt8lKQA6uQA31kHzHk8BD9k3BOKpFoylBswUB1MA3vmRW7BeZ/p/rly5cuXKlevsrW5Z4F3/+MWtM11q5ixpYRIFGLjLMuBxDs45WGfZI00Ho3FrHW66fT++dt/h/EZnAODsq584fxqvf8EVrWbHe3K9N+kkPbjr++g8LlNJSDIAu5nz10tj2o10Ii1INfNAlCDIhlPwgWKfrhylFOrGQoHi+oQuncoYjGYKP09ZU/f+8Pit0AIVfAFa+YaJcR81/Tr8RND7wLcYDCpIAtRp2aBpE6qZaaDpJeC9n7wNJxZW8oL8EWtiuIN/9bPP5fUWjfFinF101Y/TctUCvtJG1/lo3udTgCxZmdY7Np8ENEc+WJabRAkJYBI/DBeMAeM6l+9T8C0DPjKhJDDBaPGmiM/dD7ACBCxTzPsXGU9houxAbnZBksIGgyYYErYBNsVAnB8IDtVpSogH7sv0/1y5cuXKlSvXOVC7t0zi1376Wa2zugJCD6QNp0AxszkOaTyzgS2apgmTfydeSvw9Dxw7hf/6pZyIlAGAs7CMVnjXL74wcfJHaH6Czt/H6DtpOnQS/RUaLBeJ+zLdFvGxyAiiAz43Y4j05wgAeFjrWtN8Mc1rrNCok+l+otMWN3OtiBKN1BAuifeTJk4rdZo2XOja4gZK03wb4tcoghDc5CloIDjPI5EjGM6MF2lBjAdsG9Q9MruI93/6O3kxPkH1izfswZU7NyefecJW8Qhaf8cNdQRzaBF60JTcyT7gn9NKURqGF6kLQhSgXNJChGUAiUjvT1GYDCgkrALRkvnIwSfGiW7vP6N1smqjt0Zq+idgV+qrUTe2lXbgB6j7AXxTkQXw+N4J/DPeQ0kUZ0gZiLKDj/7NPtz+YKb/58qVK1euXLnO7rp02xTe8lNXtwZ/sQ8SNqSGMYYZw3LucYAD+k0Da204VHnW/wtD2DmPP/rsd/Do4mp+szMAcPbVa5+7G8+6eAfR0tkNLxh/8YcVJ9dtMzzRA0etMkJDFA3NYoOemqdFmYGOjuWgxlqm+C1Tf4/g1m+TzHOww35qzibe5vo0+rIKGui0EU+d0+XvUSceARAk8of0cQf+k0gS6PXIxFgNMBrggS/fcwifz/T/J6yu2jmNN9ywp/VeS4utUxYIAwFCc2/JPFpusAwQIa4/AgHQAsF0sv4AYo2I+D74PoicJLBKZP367+OrIUAAgsFkmrLhQ25B8nzEy8JaZhKkDAhNfgfw4cZG+02H+D9J14AkJDBoghZAqEIEYAou/O5HM/0/V65cuXLlynX21yXbNuJXX3Jli9YZmY00+S+LAtoYNivXTPunyUfTNHBNQ+d8n6Q6+TgY/NI9B/H1vVkGkAGAs7Au3jKBN994FUednT4F9PAh5ixoikMMGMX0CU3YKInKcKz9j81w6mwu1HliBrSNyjxijJ6LduUxcYDd/8VhHy1dd3QsF222GK+p6B8YnjMBDQpGJ6CFgBWJ8V/q1i/6HgEl5LkK9dsw28GyY7tO9NICrijJWgfwvptuz/T/J7BGuyX+zc9dHy7QacJFC4B5vKtSMiWXCMlU1iFrJg0PDEhvop+33sEkWbKOv9cnRjHex/hAArVcKypQWAsCXXjvW/GUhaGviVGlmPq5YETrotFfQuc3Widgh4IHrVkCADlNgCUEqTeAUNzU97mC33/sFP77V+/JCzBXrly5cuXKdfYDAFsn8csvekYYWMrJiFj/xAA2RYHCFEnsOXFIvaVmv1/XqJsGTQNoeDQMAki/se/oHD78N3vzm50BgLOvjFb43TfcQA21izNN0fxLU6yVpgxytGO/DI8APTe0khYgE0vTiiiLpXkKG7PPSTcdY8vi75ZmyCVJAD4x52uZoSkdDPkkklC+X5zbZRqvEimDGBwKahf+zQNQsXn0YbLbfo5IWAcePokEof9YBgPihFfh6Kkl/FGm/z/h9XPPuRDPvuS8ANIggEMIbv7pZ5P+URztJXoPUCFCUhgy3qsEUPBJA+6jrr61RgmwUkrBWcupAoQ2NNbCObDJjA9ymkHpSjDOHDAAdJJIwX4dAl4EvwEGBbSiSX6MG5TEgQhmSWqH92iZ/3nffrOCJ0Ly3v3FN+/Hdx8+mRdfrly5cuXKleusr4u3TuJNL7gyDvsSL4CiUDDGoCwKmMLQAJMOQHHS7yystej1azS1S85SPgwaPYD3fvo2rPUzOzIDAGdhveqaXXjenh2xOU6i/ggM0IHeElzQWxnhSBpimaATOOASx3N4n0z1FbRJjDWUB3x0MvdirpbIB9oJAPF3SnNlrQtZ7UmfHeQBwmwI7u5gEAKAs46aLb4QBG1/EtuXmgVazm53Ln49gBehx/SnGccpZiAAwFfvfSS7/5+BOn/TON72sp+I5ozJVccwc6TljC9rR6b7YhQ4YIwXsmHDHsFpjbDE8olDrPx7WRgCghL6mETIpLGD3pNfgPw7tEhJ6Isku/EteYuwAATQc84RQOdIq+aYeVMYA8+ggzABHANvQcOGKK1J0zqcczDGsNFNpP7Le/Ouj30z0/9z5cqVK1euXOcQAHBF4geGcD4zWkMb3QIAVJB1cpSzc/DOotfvo9ezsAmD1CWpgh++ZS8eOjmfAYAMAJyFDdP0ON720p+IOmewtj9pNFr6ZjHYg+L89Dh9jLFnkouumOqc0pxVaNrTFRFo+9JgAa0pq+j/AY8iRBImJnvc6OtWd4KoeU4m8N55aKNbJofR9yDRTHtP01KvggSgFTPIzaRIEkQ2gcRrYDA2UZ7ae2+6DScXsjnImai3v/RqnDc11r748GcR4iz583I+uuwPRgWKd4A47Av41U6MoK/Kz3vR6HsP5SMIpTUxABybA9LNxgaAKz7PCG4prZIkiUjRFzmN8y6gE63Xw+veORdAPKL6O2YN6CiIYBNBY3QrWUAAMNnXg5GYUvcdmcUHv3ZfXnS5cuXKlStXrnOiLpqZwBuff1kc7iRAgDEaZWlQmAJFWYTDUjBAdh6AQ6/XR79fo187NMkgJT0d3nd4Dh+/7YEMAGQA4Oyst9z4DOzeMhkno2DjPaNi5n3IF08jxXxw0McAS0Cm4wFVS5sNrVvNsRj/haYbCLplIMoOtFIoksdvZarr2NSI+3rQ7g9EAorxW2NpAluwa79K57meqPtwCM7sHg6ucfDc/LfjAVO3//iaWTHUUqAfnVvBn3z+jrzwzlC97KqdeOEVO0MjKxKSKFuJNHmtFH8+0efCg5t3ps2rQJ0PS4OiKIEoTeGmXSbnwS/CE2ZMTXSc+EssYWNdSMQIMhwVfS0EUbZOBYBOQCrnHZSPrJ10n8oNSonohTejdZYAADH8DLesmGIhQMNgNKBId3xiiPmX396POw48mhddrly5cuXKleucqN0zE3j99XvCCUjyyjyAqtCoqgJVWaIoijBsVFp8yABrHeqmQd3vo24ses3pZ30NhWOnlvHfvpojkjMAcJbWT115Hl5y1QWCcTFVXgezusSKPDQ6YZKauJi3vNGTn5Emw7Oe2iPSi+m/SBqtCACkEWfBnDOJJ5DmX6aq1DTRn7VSzBhIog2dgzEJrTsBGsTfQCan4TmK2VpA/lzQUgfdkDRxSXM06C6f1s33PIIv3HUwL7wzVBPDHfzWq589wFpBMIGM5BMfQCetTZiYiy+F4sm5XL5k+i9mfjZpjFM5gA5AFn+/EXaAo8hMmezzNL/lLJlcJqPPBYJcxfsIVjjvGIzTYc0aRTm2gwCAYcZLY21kAPCvskm0pmxYzciDH2AYyOuS/fPum27H4lo/L7pcuXLlypUr1zkDALzh+j2tpp0VuqiMQlkadDsViqKKyWDsUaZ4ANKvazR1A2sd+rVFnSSoBUYwgD/9yveeVMavVgqX79iE6y/ZTibuRqHQHGeYsl0VsLy8ioXVVfz1fUdx4gw+xwwAnMUN0//2D58TPiUdJqRJ6+OJxq/Z6V4M/yTzXijuMvmkCbvjZklc+SOLgMacbKKmZEqJlm4eoKkoZXBGXEGnzu2OqNJa6+gDwAucTDsA+AFgIWnW5ffCU4KBCqADNXLWufA7vPdw8pqCdttF0zgfX79LGAGWEUMhS7z/c3dk+v8Zrl9/2dXYPDFCEpEEjFKq7QNICRi8ZlzqNeGgtWFzSUBBtzwkwhpNgCh1WqPcjpz0vFbAgIF1Lmj+kVyQ05hMy/tMnP+D0SAkTjCyXMRrI6R5eAGmEsYNr2VhqoR9nUZjJkCACz4bEUiR53Bkbgn/5Yvfy4stV65cuXLlynXO1EUzE3jd9Ze2fJzkPKa1QqcqUBQlirJMkssQjL4lZampyQOg1zgCABRgkuZfQeGWfUfw1/c98qS8rit2TOE1112G4aoI7FJjFKA0SmOiETUQhrCzc4s4tbyM//cr92D1DBkWZgDgLK5fedEVuHjrZKCyIzG9EJqzNCdpdlr4W9C/EH3aJ596pEi7ZNqvQ8SaPEYr3i9EkfnkeYBj++j3iWeAJpvz4FXgvOKowvhzg7N4HSa/qtUEyWOk/gCQxo+/T4AK5zxPgh1ao1zvyR+BX0cqCXh0aQ1/9Jnv5gV3hus5u7fgp6/ZRYYuKl64AcXsFWrGZTJujOGmOolx0YqiHHmdpuZ7wvBox1UKtb/dzB+fX4V1Hr26xvJ6H2s9i+VeH957zK+sw3tgaa2PlV6NJZ6mL6/34T1FGyqlUBYaY0MdAPS1TkHgxFi3wnCnRLcqMD5UoVtqGG0wPdaFH5AA0J5xnDqQ7GHv226GAOImVi0PANmP3jvcfO9hfPnuR/Jiy5UrV65cuXKdMyUMABFOpnGAlVEoSoOqrFCWJXs5qSCBZqElvPNY7/VhmwbrfYfGA1r5wCSQOjK7jA9+7cxGJe+aHscVO6bwnIvOY9NnoDD0gpT20MoACiiLMumDmAGtFOZPLeKL33sYX9t7NAMAT7e6dtc0fva6S3gzeKQ9gfUcY8eaZK/QorloTU7qMtSPGmXPeZoxX02c+2XyLi7lUTudgg/0M9KsK57KkzN6SteOJoAiAUjz2qOruUqi4aKUIW380sYNSrEu24fGzrl0wi9sCZ9kyfug5RZatUqAhNsePImP37Y/L7gzXDumxvCPnn0hNo0NR1+KZK15BmRkul0El/soZ4EiAMAB7FuBAPqoJDLv2KllrPUbPLa0ioMnF7C0VmOl18fSWh/L63VYq09mbRztYnyoAgCcNzWGDcMdbBobwoWbxwN4MRhnmBoQnn7pjswEeI+55TV87Nv7cXh2OS+2XLly5cqVK9c5BQC8ngEAIJE/Q0FpoFORCWBVVRQFnQxCyJfJwTuHfl2j32/Q1A597+EGHk9akD/5zHew2quf8NexeXwIz9o9g0u3bcTY8DAKPqvCk78ZDabozErpBqYVNU2eUNSjLMwv4MO37MU9h2czAPB0qrGhCr/2kisxPNKJR/7g0B/j00ID7qPJncgCAKCxLjES821tv/KhoUpj/uR7yDAv8QOAeAwozC6voW4clPLo1RYr6zXRo+HRry0a5zHcKUMTM1yVqEqDqjDh8bZNjobnxXAETYNbJoeKzdXI8KyxjoGCyCFIo9cc67qFzeAG2ADxokH//oEv3oVHZpfygnsS6uefexG2T45i4+hQoD2lkS9i/Gi0DnIPLZ+jc3CgC6h8do/MLsI74Pj8Mh4+uYCjc0t4bGn9x9Lg/7A1VBXYOjGCC2Y2YHKki4nhDs6bGm15ACi0zRN1iNKkhI/Z5TXAAx/40t3o1TYvtFy5cuXKlSvXOQUAvO76PVFu7MlDCaD/FqVBWRbolCW01nBIkgJ8NH3u92s0TY26tlhvPCykz4k9EgB86a6D+M5Dx5/Q13DB5nG86toLYLTBhpERMrkGG5eL3JnZ1sYoli9rlGURmN3S3wkQMDs7h//yxTtxZO6JHe5kAOAsr1deswtXbN2IsdFO+LhkyhmM8sQDIPEF1EonMX9xxN7SK3sf8DCRAJxcWMXieh8Lqz0srdVQClhY7WFxNdKhhQrt/I++dITCPTpUoSo0tk2OYahTYMvEKKbGuiiNRrcssG3jaGAAiK5fBwo1vQ5jDLMGXMxwF+NEHxHAdPXff2QOf/71vXmhPUl1w56tuOb8zfAANo0PE9uDGRmiaZdkAEmREPaK9w7HF9awtNbHg8fnceixRRx6bPEp+T5NjXaxfWoM2yZHMVwVQCsbAMEM0HuPlV4d2DhfuCvT/3PlypUrV65c5x4A8Nrr97TkwfJnoxSqyqCsCpQFeQAoo1u9jWejNGct+k2Nft9ivXEhSSo+JnU++4+fwl9+8/4n7PlfuWMKL7r8PBhjMDrUheEGvgUCQJP+H0BRaDJB94ApCmbGqiCtjkNX4MNf+S6+vu9IBgCeTvWci2Zw3UVbMGwMRkY6oflHsqAVIv/feUBrJBPC6HzuhS6tFBbX+njoxAIW13o4MreM5fUaK70a8yu9s/J9GB/uoDQaF22ZxIUzG7BxtIud0+PB+FAxABKjQzx7A0Spg5TgFo8truLAY4v4xG0P5YX2JNX502N49TMvDB/U5vFhdvuPUg9h/IsU5JHZJZyYX8FdBx/Fgyfm85uYK1euXLly5cr1FAMAXn/9HgifVxjIAEl7O4UAAAUKY2jo533wKSPfAA9rG9T9Gk1jUVuPvqM+SAaALukH3vOJW58QxuiVO6bwwsvOgzYao90Oe6oplMZAK2Fmq+BtYLSCh0JVaZQFyRp8SKEiOav4oSl4fPLbe/HZ259YqXIGAM7y2jQ2hDfecAm8B4a0xshoN/nw4kRfK8XRYYgW6Ik52IGTi5hdXsfeI3M4sbCK+dXeOf/eVIXB9o1juGjLBHZsGsOFmyfY28CjSanjkgLAzoMKCrNLq3De43uHZnHzvYfzQnuSymiFrZMj7c/RGLQy8PgirQAcZS1/rly5cuXKlStXrqc2ACBeXi7pTgsNGGNQVQWqooApDHt5Adqo4PPlPTXzdd1HU1us9iwaBgnUQBKAg8enb38Q9z7y2I/0vK+7eAues3sGRmsMV50AWhhDBtByni20Ck19WSoURQHDQIYK8evJUBdgYMPjE9/ai899JwMAT7t67XMvwhaOTxtSBsOjndanJgCAlym4Bw7PLeGxxTXcd2QOx04tPy1ywbVSmBzt4oodU633J6QYcK31m3AR2Hf0FJbX67zIcuXKlStXrly5cuU6CwAA8fKWv1fGoNMxKMsK2mjJUwraZznrOzYCtE2NXu3ReEpOc2yarJN46L1HZvGJWx/4oZ/z5edtxI1X7oDRGkNVJ3zd6AhOKKVRKjIt1ArQhWYGg4YxRcv4TxKtgsE5yz0/ddv9+OztDzyh73cGAM6BumhmQ+vvRimYwrQ+RPAHaZ3DsfkVLK728xuXK1euXLly5cqVK1eusx8AeN4eAAhR4Y57m4rTy7pdg8KUKMui5enlVWRFA0C/7mO914drgL5zaCRKmoGClA3wX79wJ06trP/Az/fKHVN48RXnQWuNbtL8F4nPGhQZV2ulUWiNqgLKsiJmgAKUNjzERZAsuxB9HmPOP3Xr/ZkBkCtXrly5cuXKlStXrly5/vYa6SQ584rStB63PLC49uOTB++emcDPX08AgPfMApDnDWCoNChKDa0LdDpljPYGQjS5NM3wDuvrPdSNRd961M4H43J5+aLHv/PACXzxzgM/ePN/+XmA1uh0KsCTkbVOmmsTnr8K7AWh/RcF0f61ZvlCCmAk6U8Chnzq1n0ZAMiVK1euXLly5cqVK1euXN+/tk2O4OeuuwgAsGl0FGMbKHrbsBbdOhsi9Brb4PDsEh46Po/vPHQcx+dXntTnumf7FF797IuDAaCPuAQKrVBqjbLQ6HRKFEVBzbzWwTpKUqQkDaCue+j3HXqNRY+NAPWAEaD8nv/n83dg4e/pjSZu/1prdDudx22sNUiZYD1QaoVuVaDqFKgKijD0LN022sAORJfTa44sBe+BT9+WGQC5cuXKlStXrlxnZWmtcN3VmzC9sYs0vjMe7eL0bWWlj7nZBkdOruHkwmp+857gevVLtgdj5E5XoyxpEqpS3SRiotK375zFAwcW8xuX6ylTP3PNLly4eQOmN4xiYmIDHDveu0CJpwaztg2cdWG/OO9wdG4FB07M497Ds3j40Xn4M9wtPmv3Ftz4jF1ha4oltPy/0hpVZVBVBAAopThaT6j/Krw+7z3qukZdN1jrOzRw9LrgW3HoAgjcceAEPn/Hw3/nc3z51efj4i0TKAuDoiyDDEElngVgAAAKKJVGVSiUZYFup4TWBRrvURgNozUk3dxJUgHr/8NnpIi18clv78Pnv/tgBgBy5cqVK1euXLl+3LVlegjXXrERz7t2GhfsHMdLnjsDAKhrB+89ykIFc96Y7SxxVR733DmLz336FD7wpXux2suGtE9UXbJrDP/t968DAGzaVGB0dAzeezjnYdhATPTCgsnUtcP9Dy9iYamPb905i+/cM4sHDy3jwOHl/IbmOudq09gQfuH5l2Dz+CgmNk7wZJyae+cIAPDOkc7eOThnuZMFvLNoLAKt3nuPex55FA8cP4U7Dp48I2DAK6/djSt3Tj9uo6oBlMagMApFWaDTqaB16gIQ3fMpHtzD2QbrvRp17dD3DpZlAArkGRC2P10M8Be37MOBRxe+7/O7bPtGvPSqnSiLEsqYAEwA1KQznMKPqVAqhW6poYxm6r+GVqT9L9n5H8qjaSzFBsLH91/SALhuyhKAXLly5cqVK1euJ7+0Vnj+Mzfj2VdtwvOuncbEeIUrL54gqqej9GrDItC6YcppQutUIZqWmQGems6vfv4kPnTTIXzurkP5TX4CqtsxuPnPXgzvqfkfGRnlc7WCtS4AAEQZ9tRIKKBp6HMpDAE1dUMTuL0PLuDg0RXcce8c7t2/gLvvn8eJx9byG53rrK5XXXsBrrtoGzZObQxmcgIAeF773jIAYC2st9DKMFBm0YQEZmpSAWqunff4+O37cfePGJ83WD9//R5cODPRakqlBVY8TS8LjaFuRQwAFvNrdsrXStN1WJGDvrMO/X4fde1Re4e+dfyY4gcgaQAEcOw9ModP3f74U/afvGw7rt41jaqsoDRdzGTNNAAAIABJREFU5IXmL0ACRfx5ov0roFMYlCU7/hcllFIotIZSoMfwTPRXPrr+Q8FzKoCku3nncdNt92cGQK5cuXLlypUr15lu9p/7E5swPTWEn3nRdlx6wTguuXADrPVhgi/uzQDQWAejFQqjYJ1HY5lqCg+tNZxzpFcFYJ1n8yoPpRUW5hp89pMn8OnbDuLL3zmW3/wfsf7Fr+zBq1+yHTMz1PzLBDNIMdg4TL4WD8JCDVYhfqsoNIxSqBsHYxQMO3t99545PHhoCd++6zH8zXcfxf0PZ+lArrOnLt46gTfdcDk2Tm0MTbJzLonY8+jXDbynqDnbWP6zhnMW1kqsuId3DtYRSCDUfChg/4l53LLvCB6ZXXpCnvOv3ng1pseGAkDauh4r8gDolhplRUkAxhh6NkpBeSTaHgJkvXewTYP19Ro9SwwAyw01XQg8+x8gRPDddNuD2Hd0LjzOprEunnfpNlyweQJlWfDvUKc1/xEqASpNjX5RKJTGoKwqKGZ/qcThT/6sVQQj6fPRURbAEoCbbs0AQK5cuXLlypUr1xNaW6aH8Mwrp/C8Z27G7p1juOGZm1mDqVAWZNhknecJGB3OCkMaVGc9GksHaa1V0HNioPEsCprq1I1rAwgK6K97HD+xiN//wH341FeP5g/kh6y3vm43fvFVu7B5c4HxDWNwlpt6BXLb9h5K66B/Dg2D9TQNZHMuxf83WsHBo2mIzSFsAa0of1wxhPC9B+Yxd6qHb9/5GEsHlrJ0INePrd70gitw/ZUX8ir33CfHmDwAaGwDbwkUqOt+cNV31qGx1BkTG4Cm05b19UCM5wOAh0/O4wt3HcDc8voP/Xw7hcFvvOpZQROPQM8nxpRRCkZrdLRCt1uiU1XwCuF1Ka3gHMI0nV6nQ7/XR9NYNLVHDwRkODY+VFrBOyeXakABB04u4H9+6wEAwK7pcfyDay9AURTQBUX5ne7k0gYptFLoFgrGaHb7L6CNDtcUAhk1rHUBdNSI1yfwPYTUGp6lBQq/99Gv4cT8E3s9yQBArly5cuXKletpUUYrnL99FFumh/Dsq6Zw/TWbMbOpiysvnaRpDh9AG+vgPFBoBMMoOTXVNU2TOpXhQzLQry1nPlMzSWBA1Ppro2D4MNdYx1r0SGF18HDWY3ZuGW/6F9/CPfsX8of1A9aN18/gnb/+DGr+x8aIVps4fwPR/Exr8mZw3sGwL0O/JhZHWSh4UEOhmeJheYKolUJR0GHeWkBrYng0jYPS1KR4/izv3T+PR46t4Na7ZnHfgwt4+NASDh5dPuNmarme3lUajT9488tgTNFqptPGUqbgzjaw7JrvnIO1jujzjtawA4Gb3juA/gfN7vbCntEMCHx17yO49YFjqK37gZ/zzk3jeN3z9wTn+3anqqChUHISQKdboCrL0IZrrXlSruE8QRPKE9jRq2vUdR+u8Vi3Hg2/TogZILfBMSJQ4bN3PIzSaLxgz3aUidQAAgyCjQdTIEABBgodo6GNQlkaGFOgMIYaeU0gQACFlQeceBH4wGAQmZiANlop7Ds6i//8mdue8HWSAYBcuXLlypUr11Omwd913ihmNg1hZtMQrtqzEdNTHUxNdLBt8zD27N7AUxWi6VvnUZU60jn5RESaWTnmJSAAa8Ub61BVJug25dBclZoPzAQAAMQWkMmyUD2bxsEUKtA9gSgrOHZ0AT/91q/h5Ox6/kD/nnXNZZP4T//mmZicNJiaGk8M/lQ46DpLev/U/Ys8AegDqGum+TNdt2EgpzC0CpqG1kRREMvDOnqsqtRgtm4AFprGoiwo57tuCCQqCw2lFO6+fw6z8z08cmwVyys17r7/FO7dv4Cl5T4ezqyBXD9iVYXBe/7JTwcwUxpbUNvLk3JwDKADvIN1Ft4BjbUEBDQOjk0zG+ug+OLouPF3iFn3Vlzr+f8f+5u9eOjE/A/0nC/dPoVXPWs3XwjRosgLa6erNapCo1MZ6IKaa8XMLBV8AOL2ttzoN/0+erXFWk1+ByJx0MIWAP2MVr7VfIthK3m70JReMfNnkAlgtEZHkUSorHjyr3RgEvHlJpgqygsNf+fXq5W8twQGOA987JZ7ccvewxkAyJUrV65cuXLlBn9m0xCuvmwjNk52sHFDBzu2juDSC8bDgVCab2n6PP/daDqoWedD/rIxnIudavwhX6cTmugyraNDG9H9Xat5N2IoZ11oQkVjqvgUKD9jeLJUloZjq8ioS2uFgwcX8DNv+yrml3IywN9VWzZ18ZH3Ph9DwwqbN49D5nPSFHhE6nNo0p0DFHkzyGejufF3vCZkDRVGB+aH1m0AQIEAAOtoDRADgBghRqsADjiXpkB41LWFh0KnJJSoZgPCBw8tol87LC73cejoKuYXe7jngXnsfXABi8s1Hn5kKX/guf7W6pQG7/5fXhGaSmn0QiPKf5frGEA59A1HAXqm+ztHX+/XDp7p8wFMA0fdITb/Nvna/uOn8PW9h3FifuXv9ZxvuOw8XHfx1gAAOI8gj4IioLRSigCAToGyrLi55ubZM41ewAjZ1wro9fvo9/qoa4c19jQgbwM/0ARHQCCYD2p+bK3IqT9hg5mEGVAohU6hURYGWhuYwsCI4R8Dv4pp/nT594AiloU8aTIXTH47P//f/uDNZyQhJgMAuXLlypUrV64fe3U7BkWhMTPVxcymIUxPdfETl01h81QXE+MdbJ8ZxpV7JunQhDjN8ny4Evd25z1s43naTpMXObZZ0e4rBD1/evgDaFLrfTTyA4hmGht6H4AFw5p/ARe0Im2ptY414zqYb8kUOAUGPOh5UxMYgYG1tR7+4AP34QMfeTAvjL+ltFL42gdvRFkqbNkyxs2CCsBN3bik6fehsUgP8r51AEfwZmh4nZUFAQC2oQSBIAfQGoWh6V/d0NfKwsBohX5tA/VXeCRaAUVBxmW9voVSDBA4WpeDAIVPpAuam4F79y+gri1WVhs8cGARS6s19j44j30PLWJlrUHTOBw8klkET28AoMB73/IKuubwdcoFgzmCBFz4M13LrBfqvyUQAJ68AJoGdU3/1nfU4FtE6r80kTVAEqfE88QDuO3BY/jW/Uex8nc0sK+57hJcsHmc94BK/Ao8oDS01igBVKVGVRp0Ox24sDc0lCaZgA+SBZLnSKO/3uujqS3LABzgPKy1QdIQfAAGGuPoBwI4L54thDoUWkEbDeWBQmlUlUJRFOhUJf08AxmF0SEpJpUcOPYfcM7Ghj997UrhnkOP4s++ctcZWScZAMiVK1euXLlyndmGfnoI05NdbJkewnlbRjA12cHkhg4mxys4Dwx3C1y1Z1JikMmF2nmUpWZTvdi0NUmjLLnPMo3xiKeahhs10XVb59HrO1QVHdqQqE29pwZcKZrKkku2GPv5MBmW31M35BFQlhrKe5qANeQaL42n4ZOl96n2XIevCeuADqt0JBMwwzmPlZUV/J/v34v/8YkDeTF9n/rtf3oFXvWibdi2bRSmMGFKadi7gWj89Lk17GxeMM1fKNBmIJ1B/q1uCLgpi8gOCUwRXpPEJtFoGproC1hQ10Q/1pqnhtxgVGUbAOgwe8AKeMTeEc7JuuFM8SJGFzaWQCz5HmElK0U+Bg8dWoLRCqvrFovLfSwu15g91cOBw0tYXbdYWqmx76EFrKw2aKzLZoVPQQDg3W9+ebhmRjkMIr0+pF14eNbLe+/hPEkBrLUAqHH2zAYg7xICAJwDCkVNf+09nBjyoS0REKj21geO4Rt7D39ff4A33nAZtkwMh2u852ukVopMO5WGASgJoEPO+oXWgFIB2BBKfRvYo6/XdY26rrHWc+h5R+aH3gdgxHtAM2tIogQpii/q/bURgFAHSUVpDDpGkcGrMeiU1PwrrRJEgeUJQHhs73yQgynlYzoAEvYDFD7w+dvxwLH5M7JOMgCQK1euXLly5WY9NOtSW6aHyegOwNhoiZmpLrRW2Lp5OFDdpya6qCrSOpeFxshwgQ1jFbQCrrhkEkCMnWosWFMdiY6ic7TWQyeGe9LcGKMSOicdxGxDVGw+I7H2UwXqvqhHrfOwtq3b7tcRAPB8YDRsImVtBBqaxsZmkB/LO4+iEFO4hAVgFBIiAf+7C47xYHlAbekxSqZ9BxMqpqDHKKgoYTg1t4Rf/3ffxc23nsyLdKBe+4od+I1fvATn7xxBWXXo/RO/BR0/J6XJzJEcwKmJP10ignZMIDfxSjFrg4GnwPrwHtZR4yFrRImwWsmaRaABk0SApoEiAQAUOpVGYzlVoqCGwyOumcbS4xW8lmhNe1SV5uxwz7+fXsB636IwGmVBDZ5lOYPsj7rxqAqZQipY6/HgQTKcXOs5rKxS+Pv8Yo9enwbm5ntYWW1QW4djJ1ZhncfKWoPZU70Azh09uYp+36KxPnhXrPeabHj4YwIA/u9ffVlYm87HBjMYAGrFjS050UWGjAsoat3YwAgQeYBzfO1LIjSbcB0Goo1/ejkUdpXHl+46iO8dfBSNawMBv/TCKzA9Phy+V4BbJdd51thXhYExCp1Oh835yKODfFh8AA5EWy8Qr3MOdb+P9Z5F7T0BEd4GcFbuI0hegw6MIAHmiPOgeU8bcDJBqVCVBYqyhFF8bU+8FygUxgWtv3M+GM44H/0GBuMPT8yv4D2f+NYZWycZAMiVK1euXLnO8QPfhpEK528Zw3VXb8bImEZnyKAogOmNXQwPGVgLDHUNNm7oYGS4QLS3o0PSxbs2hCmjNNJCOyYqfKSqNzY2Qo0D6tq2dPZlobkB1mEy2TAln+jZgGXWoyF8AU3T9n4enOTIYUz+XhiapDseNRVGoWmiU7tMahtLE17nXJAEGK2g+fvFuE9zkybafTHt05oOvKnRVDhARV/A4Awvz88nsVtiAuicvAeANqRrFcf4lqyg0DG+DsDJkwt4w29+E/ty1nyolzx3Br/za1diaspgfGyUDvn8uQWwiAEVrciVu2lsoO4r0GegEJtj8XcQ0Eref2ETuMTngb4XAYhy8MHQUX6vYbYHpQ1QEy8Lpq6jBCAFAHiO2TIUtA7hZyWdomIQKfW4AAgAEO8BIIJilFpAz6UsIlCR7vPa0mSyLPRp+7y2PgAgAlYJC0EbzWCeMCcs7R0D7H1wIeyFtXWLurbo9y1W1urgezA338fyag3rgEfn1jB7qoe7981hdd3iwOHsefCD3w8M3vuWV/C1CGzc5znVwvNkWyWxfqqVae+4MSYZE4FVZBZIk3Si1QM1OwLWfM8oEKf/SO4jinPuJTHFe487DpzEfUdmcfzUCiZHuviVF12ONFwvXlsVvAK0NuhohcpolJVB1enQNToBNuR1CAAbjAFZktU0Nfr9Guu1Q9/56HXAoIdSFAsosaFK6QBSE/hMzb/WpPkvNYERxigMD3VZJobg8yHX/AiCA5YjCEViITp/hQgAyLvwpTv243N3HcoAQK5cuXLlyvV0bO7Hhyts3jCCqdEhbBjuYGykgy2bu9h1wTDO3zWMa54xCW3ooBIaA49ghGa5aZDDfKo3NoUKxkT0Z5m+e5SloQmPJT1yMueG4UN/zc2r1pQf7Tzl3XsnPxON9JxHoMXXTQQDpAETFoA0KprN+eqaDkomaYIeDwAgd30fJu/iYF2VhtyV+d+996TldqLxVvy9kdZNDZ6j51goOAYBInWcfo88R5UcekWioDWBDDIdVkwJp8OpsBukiUMwFiyYaioHaGcdjh5bwivecjNm5/tP+z2x58Jx/H/veg6GhzUmJ0dRMUvFBXNGaQKix0NV6pAEYAyjUkJZ9h6KPyuA1u/jAVECLDScgeYZ+AnrToGn+Ar9xgXPB8dZ6mqgMdJaw2iE9aSSxALZU/JTtO6iAaWAcZEujAAwBZAiyVIvjPwe+llhu9A+17zPfevx0n3eT2Q3ApTInkv3udKKGDriwVDTXjWFhuYmhwAxzpcXQE4DzkWvBNnnDxxYRN04LC7V2H9wEYeOLOPE7BqbIvZx4PBSZhkMVFUY/OGbXxYa6HT9CgCJAJAhMEQAoEmm0zK1p/Vt4b1jeVMDy+vbOg/LbJiUueSTdRz3Ef8+UPym92QWeOzUMn7ysvM4tpOZYcljGE0eAJXWqIwiE8CqJMANkX2jdWQBaL7vKSVrmlhdvd46en2PvhdJg2Mtvo/u/8m+E7BQGAHaaJRKoVIKymh0K5r8R9aRar3XAiA6S+9TAAidS9IKfNxzDAZYa/HvPvJ19GqbAYBcuXLlypXrqVajIyVmNg3hkgs2YNf2UTxjz0aMdCocfrCP+ZMeMxOjGB5RuGjPMLbuqDA6rtAdNjR94ymc1gp1bYMmXfTKQJzSNZYzzEsN70ijXhhNzYCLGchyIKkby40zH2R4RCQaSaMjAAB4VIVGv7bUYBSazaVY98yUY+tiNF7deDZQk6k5wuG/12fqNYMZ/b6FMZobZqLxl9xoxak+Ar1SGinLr5NeBzUtzlHTZi39W1loBkXI5ZqmvfR8+rUjvbjRYSImlNrGepTFgMM2n277NR2i5fnXtQsNU/QIoNcfmA38mALSRMq5HF4bfOBDD+Df//HdT+v90u0YfOlPX4zhIY0tWzeE6C+JA0ubZaUoklFM/YC2G/pgBcp/qYEE5KGGhT53eWxqNBQ34jFarTCaG/XUcFIFTwitpfGK0WBtPwEVTAG1ih4XAiwImCe+BI2VtIroY0GMBx3+XTwwXCoZ8LQfG2sTgAyJp4AK7AIBAIym11s3LvgQENAm+5ymo00yfa0bh7LUpNcWkEYBiveAUiAARyRCWsEwWCf7XEBLjyiFcIGlA9y1dw6Pnerh0JFlPHx4GSdmV/HAw4t47NT60zI1oTQa//Z1z8fIyEh0ooeiSTcb5WkVQVnnHVPXPbQ2oVkPjCVu2KWRb1gaYK2Fcwhgl2MvFJF1EUDVZgAAKrrwJ89DmmG5B4T7Ad2YoLVBpTU6hUZRanQ7XfbiSwAOqPA7vXcotA6yKll7/ZrMAFcbD+ssXGNhQQ05EhYWMQAMGRsqliIoWseV1igLQBuDblURA4YZAmlTLRI15SPV38EnrDAEnwMxitXMHvjsbfvxlXsfOaPrJAMAuXLlypUr1xmqkaECWzYP45JdG7DrvFFctWcKkxsqTE10MTpa4pJdG1AUKpnKEB3+xJEeqq5Gd1ih29U8aSQto1Z0sKEGNk71rfXsMk+HMppIxqbZsE5f/r0oiEIpZnllqWGUgvUe/T41BoExoORgTvRlYQdYZgsURpNm1NPU0CiaJsm0UhzYSRdNEgCKvAv9bzh8iRlfWbSnV4p1+r2+RacyLQd+cU4XVmt0gfcsbYhNWVWo4NpeVYbNmWIklpRzMg2WfGh2wfYeTe1alG1r4zS4X5PzfFXpcNSqaxuafwFoSpYeCGjRWCSpA1EHK8DM0vIq3vm+7+HPP3nwabuffuvNe/CGV+7Etu3j3KSCTbRY489rMUY2IjSu0mCkMX9Cj0/ZIyGVQVIA+IAfjRxVnOpzbGPwoeDJfWPpd5e8fpomft6y3mVNRaaKDn4EIpdx3NSTTEWx2aQL5pg1Mw8EtFjrNS0JQK+ma4RWbRNErcgDoF/LPk99Cuj3Nk1c43VjoQ1dH1JzTbk+yOMK2EFpGDT5pMkpv/8uNj8Ny1wqNt2M5mo+gHdloaPhIURm40/b542N5o4C9JWFwr3759FYj/WeRa9nse+heRw4vBRYBCceW8XxR9eecgDAP33Z1bho55bQVYs5Kq11F6biss5EvmWMjtNpYZYIE8A5WE/XwMY2sI1FYy39rAMaDzTMUnEgSYCThlws8eHD4yHxEbC+bYQHvtY6EAPAFAaVUtSAVwZVVSXsAAS9v/LRDyP19JDoVWsbrPd6WK89+o3Q/8n7wPP3uMDO0SGCUBmNjtIoeY13uxXKsgz7XmgLWpnwnsrzcN61oAG6T/lWwy8ABt2z+vi//vLbWFw7s2yvpwQAsHmqgwt3jmPTZBfTU0NBz5TqSQZ8KQKStbRS47E5MiyZW+hheaVG3TjMLfTQNDGEZXW9ySfZXLlyPW2r2yGaLRnFDQEK2LJpKJjEQQHjoxWmJjrhpkv/jdrCYEasfGj4llb6uPO+Oew/uPiUoXJeftEG3PjczfipF+zE85+1lajiWqYTNMUjN/A45ZWMcDoU0xSkEdMyzZTGxNCrsZ717Zxpb+lQURZ0ALE2RuO5xNFeGoV+bQccy6lZEQovMQRo+u0Sd3Ryv6ffI1FFztoQdyexR1oMy4L+XSjE3AQPHEScjxrOlHat2cBP1o/o+gthBHgPDTn0+9N0lI4n8UI/pnz2qM1OJQqem/6gHefmOz07iDxCjqvyfMWgMHV3rkoTNaAarYmsNI7xQAJYNqBKKbo6+eV147CysoJ/+R/uwie+cuRpdw166+t2402vvgA7zhtGt9sNk3Z4H/eAj3spRDNqhdJEdotooSOAgAAuEV0+NrIQZ/+wRn0rEpJMBaOsQ2QCjv0kqoqAsrp2pBfWEVzQmibaDctLpFEPBmj8Z2HraKNCAy1gUgpaeJDxntY6SIGExaIUeOKuwvqzzocmX8A0AAzmuQCsyf5USddg2Uyx0DoAAqkHhjTyqQxBGk7nIh08vTaWhQk/n+5zuYZppVv7PLzfDKQYzQ2sj8CIgCzi+SBGb/Q4dE36+q3H8IWvH8bHv/AIjj0FwAACAJ6Bsc4QNk9PxkYzmYZ7puDLegV8wkZRNHkPHhgaDWvX6TrmGXyyZHYJYgU0jYO1Hg2is77j3xXu/6y3l0k4PFrGfSngC++htGZJFEmjOlqj2y1QVR3+xmj6GlNUEl+A5HG9RB7WNdbWG/ScgwMlAjTMSnDWQmkNrQ1dC7QGNNH+C63RrQzK0sAUBZTS4T7hARil4UBAFgKwSPdlYfKkn4FKwMCUCfHBr96Fuw49dsbXyTkLAGzZ1MWLnrMZv/yz5+Paq7bxQtaoqjIgKgEhZEOdiOEj0pa8b0W/pCY9YiJUNw73P7wQFpdzHqtrTUB1l9ca9Pq0OWbn1/nf6MM+cmI10C+XGWw49ugaP16uXLlyPfE1OlLiqj0bURYK46MVZqaGoI3C9i3DnP1LV/+piQ5GhgrOIteY3NCBMQqjw2XU/4Gm0xdfsAFGy7QrRpfRDdCEG1nD+edlaRJH7Dhls3zwpUNB1BcCHn/2sfvwV58/ilu++9g5+b6Pj5Z4wyt34p+8fje2b9sAY4poHMRNneMDVmq0lU67Y/QcnZUGAROJi0v1vt7Hw2xZmLbZXNJ4SkMtTbLQ6FPTP8+Npk0MwABwznLUAsshTSaior9MNfe19dycxYZJfAkIpEDwAEi1zTZpcqT5sOw1UBQaTeNaTu+D93N6v31wq5aoNvIAcK33IUzck0Y/arLbh7R0eEA/E6nSKa3cJg7XqcY20JZ1nIb65D0Bu8YT+CPGVPH3No2DKTROHF/A23/ndnzrrtmnzTXtDa/cid940yXYuLHA+PhoyP12rN8nEMiFhl8nWmT5fKWJT/8swztpyhWEJRPzxMvSEFDWt9xoqpAk4NiEIvWPiEADgUDptJt63MhyMRoD02xeMxrB2dyxoWC6XgsG5uL6jlKf1EuAvjfKSlLATcwHSSqkw542WgXtcdsQUwX2Q8PSGmHWiK9GmGYK6KuYBWDi5xXvHeCoT8PTYAJx5L0QnwK558h/BWgUsMY5hOtdURr4xM8jNXgMg1qhmHvPa4aav/X1dfz2u+/AX37hMNZ69pzeLzMbhvH6512KHZsnaVruo6Zf/GFEDgCeeIfrmET6aQWjdLg/CHBq2R+F7js2+JQ0tiEAgJkkjY+ArPgHxIl4BJUcf6YCSgTQk38/GeVpVIVB1wBlVWCo0wkyAcVgmQrAgfgREKgnr9SxEUfTOPR7ffQajz5LGbwHHDvTaqb7S4RnaQwKBqI7VYmyLMN9hzwCVEwRSAGMwAAAPBxjH/JfH0wzg4EmaA3+7l988/vGJT6tAYDzZobwxledj3/0U+eh01HYtm0iMV7QqKqC0CqbIp2M5CpAq/bLTbN/o0tjnMAIlUvHbJZWVJFMAjSbGtFkRAXHVfnecABjzeYDBxbgvULtHE7N93BqoY9H59Zx3/55HDm+grpxOHJ8FfsyUJArV66ksb96z0ZMTXawdXoY22aGKU99vIPJiQoj3RJKAVdeMpk0Dirk3WJgoiMHVsd6Z6GAQyn0+pY0y0bBeTLIMka1ppbxiK1Dk1jXdDPtVIZ/rwrXU6GVSra6IO6NdYAnXenS0iK+8NeP4nPfOI6bbj56znw2r335DvzzX7oUxgBbto5RLFChAWgYYxIqrThxx+xxOqQD3kf9bBmi5Xwrck4My4Qm7Hhy2CS59BoprZCq1yfOfVlEDbJOzOuc8y0PAOt8K3tcDtN0v4yTNp0wPRor2mAdGg7PDQq4UZC1kEY9id69LHQrFtDw5LJhrbCsPdFqG6O+//08SALaU89wP+elKykESPKgoyFaWz4genzPQA28Z/0yfxbcLDlhY5QmmDCqRIMeDaqY8cAO8s65wNyQBiV85gySlAUd1I8cXcBr/9k3cOjY6lP+unfNZZP4k995JjZuLDG+YfRxTrIqTAxdGgPocVqyhHNRIpB6XwjwJcCYkcl8iHNUwaxLJRrldHgUYyN9SL0Q3b94cKTpFEC8TtIejEaQ6YRQzA3Fu8JycoVSg9diWpeUxKHCY6YmleJzQeAjwhoH67e99yi0/tv3uXNomoF9Dk/3DkQ6txybw7ULJF8IwF7ydwK96DphuAlN97lMq+VzlDO+TPnl3B4/29TMUMVzu48MHa0V+n2LummIEeI9VlbXceLEGv7X//BdfPPOcxtge9aFm/GTl+/Azi3TASAO5nqsOffOwSuRs6jgGUAgqg6frRZmiwAJCfhMwH6UAzSNhbVMsefrGwG8Lk7kfYzscxJN6F3CDlOhETdawRQFDBQ6RqHbKWGKgun5KgBDsv9DqsueAAAgAElEQVTEvNVy8ouGasXveQC9/jr6PY+ed/R8vQ9RfSHmzxiK+VMKVaUp5s8YKGYjRJZjGC23pvueNW9WIm9ECoGADcQ9zD/3vk99G4dnl5+U9XHOAQA/88Jt+NdvuxydDjC5cQRlYWAMUUSUNtDGBJoQxZBE7RNlYvqW2zCh6oROGr5YiVbSMFJrA2XPB6ML0Xw0gVLlwyFa9GbW+TA1AaNcQrukCyMdAigXFglyHac1DxxYCOjm3Pw6FpaIRXDgyDJOPraGk3PrOHJ8NTMKcuV6CjT2mzZ2sWXTELZvGcb0xi42buhgbLTEyBA19pdeuCE0EdE8TRyZNRRPjWNsjYezEWmXJkrooGjd2DnKjA+N1nmON9OEYDsPzaZlQkMNB2um4BXcnDTWhUl0Sr80Kk53jSHUv99vOHMdwZF3ZWUF//Ozx/B/vO9758Tnt2PrMD70h89Dt6MwvXkYzmsUhUFV0D2JPht22mZafxUc9tlxn4HjfqDjizO+CwcKpejAWqQNCmvag+EdN6Txk4mNgfM+6IyFiSEHcdL869A0OM68p0M7PWBV6paRmDTrZEQmOnbXmrhL7J4c2iUWSlqWwiBo3wV0l6ZCGh9ilajQ8AuNPqQLOPyd93PxULAJBT/ez5HsiaiB7teWKchsrqbTJAKiwHaqIoIWbJQGdpw2LIUI00ijWBNN77EAMNLgi5FjKl8wCeCWOqYDJNd4xiv+Co+yjPGpWJft3oCbP/RKQAG2acJ+SJZ4a+qmQzOOFlU/Rnz702QdKjFEQ9LUCy1aaNJC45f1ITRzOcOlytNWo877HhJfmchuOlXcUyKBEaDNJJp2MZ30iSfA3wUAyDUi3atirCfryTOVX57z4D6XPemCwSC9r3Vj4z5nFoQ2tKnqxof9LLPmsqD3T+5dLVmUI8pDw/GBg/tc3u/IjKB9bhJmQ8vjRICPxNDThcmyD8ykwtD1am29D3iOvGscmqaPD3380Dlz//l+NTZU4VdeeBkKU2LHzEZe25FN5TgGT1zpi4Jp78bAGMOgJlBozc74pzOhVDCwIwClsZYBAIrctA2ZPtbOo+EmOySsyHVN5AAsy4jXZA1lyIhPG41CG3SNRqdToKqqVidrmFLiB7RlAqTKNUGed13XfPZwWJc4QGYIGBUn/0ZrVIXCULeCNiakd8g1QUOF90buf4FhJNEfPpWntdliOvEW+c7+I/jQN/Y9aevjnAQA3vnPLsfE5HB4w8vCMNKuyaWxKAJtVSe6SrroRy2KOEhGMx/Pxkqx4RdqlhyabaLVkhuCUipMEerGcbQSI6qi4eR4lKYmvScUHdTFSVWOahGZbWdHuoT2JRfNpnF8cNTYf3ARztHvn1/sYX6RGAUPH17Cydl1PDa3jsMZKMiV68c2sd8yPYTtMyOYmuhgarKDifEKQ50SxijsuWgiaIeRHJBo2mn5OhejwYQSqkTT5jw3E9F4Rq4xYtKmBjKfrYuNmNyQxGwJUIkUSodmXwAEymxPKGwqRlW1nbjRyuIVB3UCaGm61us3aBqSTQV3YO/x8S88jN/8vbvOGQDgo//xedi6ZRhK6RCFRw7vBlVlYLThqDHP8WE6MdETp3y0qMSWqe+GPQLkoKtAAEKYUpvEBLDU4T4lEgDRI8t0U2sCGvQA5b0qowdAAJX4UOMHzNWE0itT/5RZIod4aeANH+Bl6o0E8E5jz+SeV5YmeBpo1hgPyvLoXhifvxzCUnM+MUqUplkaHGowojGhNArBC4Ej4xqeQEb/BgbCNAKbIDALEmd0+V4xNxNgIb2fC/1bzij9vgUUOamHfZ6wEYVmTpJUHc4Mf/zf78Pvvv/Op+T1U2uFk7f+QmjuPMjk0bJbnXhQpO9RNFHUUIpo7vLey+cif5e1ZbQK+vrogh+n8XJIp7Wkw2csjBYPMkETWQBdt12QVsmekTWRNts0LEJYh1pR7nm/Tw227GfH7I/BfS50bqHMy+sT3X9jB+MHWRJgiDVk2cNg0NDz77vPhZUgDIX0WpOaLMaUgXh9E8DYeSR0aJ+wJOJzkecfhm/MWBMKeXpNEJaZfB7WIiSmhLMzg4/WOqyt9eCc5WslrbG/+sJB/Oa77jjn99DV52/CT162HZ2qwrZNE+Fe7hLpQ2NrOOtgjGHfB4PSEHgta4PWtTDLVMJOihF/tCc4Ws86SgpoHKUEQCQBLJHin5G1QiCE5cdjdhSzEDTHABqjUUGhO1SgkwAAkYLPcoDkOuCZ0uXTFAL+N9vUWFtr0HMWtXWwbNZnRPNvNMpSodPp8LpTQYojz0sOW0br5EzEj5+kYQhIErwvEhmSAAHv+ug3ML/aywDA96t/eOM2vP+dzwESTSPlu1Lz36lKFGXBTbcJN9zainurbxkCKq35Qgs2OIq0LWtdoh8DR8pYQjpV1CiJXlNMRbSKN4FIGVOxkZcsSMQDeZrdCtZM8X4Lh/iU3hRzk11ysI4THzFUii7CtAEOH19FYx2WVxv0epaMpBqH5bUGs6fWsbRc06HSeRw9sUomiafWYa1nk8QGdeNwcnYd673mjJp2dSqDslDYvGkIM1NddDoGYyMltmwawtaZaPa4cUOFTsegW2lMjFcYGS5DXFO8CSVIcIJ4z84uY//BZbzjPXch1w9fb3/DRXj+tZugoLBpU4WyrMKNXcyKrPMo5KDl6YDUNA69vsXsfI25hR7W1hqcmF3Hes9ida3B7HwPj86tY3mlQWNp3QHA2ro9s+uu1JiZ6mJm0xC6HbopjnFcmwKwbWYYWitsmuxgqFugKg0mN1Skp2cq5cYNXWydHmLdt2tpr4VmNxi5JPs8mIQJ5Y5vEFqlB1gxVKJGSXKW08mhFZ01g44qOZQ1jQ/u8zLNKksdbkx141EaOgDXFmFiAhUnOd1KDN100ICmgIVPPABSejndfEhn3q8b1HUDY8AmQg7GAJ/56lG8/bdvPSfW/86tw/jSn78EZVEEUzgtSK/SKIsCVWVQGBNotymdVSXUfDH1SuPmtIra+BjfR1M4aSQ92mZ00swWRhgdYmimwoRucALa7RShmRU2geFppDTsxrS1xKE5KQ2cc+H5yfOXtaoU0OOGmqLExPSs7VFQFircg6rSJLp+ntp6ehxp6tM95HkyWBg6FIphITlbxwmMDnnuLjAUtIBX3oemRporabhDXrNS4fEUT3jofu6YgehagH3TRCCBfqcKxo8pCJLez+M+iY1b2pDKGUIr4B1/eDv+/K8e4mvjuW9Y3KkMikLhwNdeR4OWvmUaezrho+ZBADCa9tM6D1R8XitaIbjiB4PHFNgcIBOk8gH5HsvAg8RRilaEpBv0XBSDR1op9BvfNiTzbcd7y8PB4Lhv21r+sM8LuqamzJjUryNlDAlzS/4upn9+YCxalcI0RZCVCFMlAHM6sVZTcZ8PxogKC0euI4pjPCmBRKNfC1sBSTxplDMIsIHEz8Fo2l+0z9nlHZIgQu9fjxlLxJbwIf1BWGfxuqN4yo0A9FgxOFTEQOvXDTefPtw/P/2Vo/iNf3/bU+J89tKrduKy7ZMYLjuYGB9hR35qeEn/7uAtMcG00gSsaJq4K5avkRyANoXmCXlqbAcVPU0QziXEBKgbF4wXG75uNhzV5xhcDkkB1sEm7BHFbvzaaFSK7nvdbonSGGIealoTNZ/5VbKjW6kdfP+LRfe0fr9Gr9dgpWkIhAOZKHbLAmVp6J5uNHshMODIACOB5KZ1LkvlW+EeGdIFXBjOKLTvj1+8Yz8+d+eTm+5yzgEAr3vlTrz7X18bFpMckq1T0MZgqFOiLAu6GUDojZ5pkwZGiSbDsWEJIa2i82ssobmiRZSs4E5pAPhwUe/whCCN1ah5KlYFcyeacAklU9B7oeJaZgeUhWplxsqNK96SFNb5BlgyrVIML8QoItVnCboseh2KfAHfLFWiDWvTCwHSiQZDKpXEKDHSWteWbyA6AAqz8z1UZYyv8vCoaxcmiXI5lqZOTJhcopWpSoOxkQIjIwVKbo4uPH+cb5DgA2ukxYrvpzhNB3MsL59vlHiIKQgGFrss/uPH5/HL//u38b37Mzvih63//DvPxNWXTWJ6uotOpwrIsByCReNbFCrQj+WAD3j0as+HJ4OmoYgxQUpTU6c+T9IePrQY8md7PYt+4zG/2Au0ZloLClVlMDFe0mGfKblCxxwZKsI0xntqYKpS4/xtI6iZktxh86e0+n0bDqkiA3LOBy1nP3F7Vskhq1Mq1A3dDEhjKqsw0pFlnxc6goJIqKnyXKSRl5uvuE2LyVLTOH4P0YqnUomGOoCnDDA0Fq3rnuOJMPj9ahqLLtOde0JfLeMkUuivde1aUVoSzVXymLVpLB+wHRpr0e83sNZCK3Jol33+qZuPnDMAwAXnjeDLH3wpCt3O0taKtIsAH1oKg8bR/UcYHcIak2tb8FrgOL46UFtVzKYvaN2IEZf3Dj493rCHA31GEdAJzvQ+NicCGMtBXfZnY31LnxzuSAxSRA2+ajkh24akIkYpNOR+FPZCj+PxCm7ySxPXfno/FxqzrK94J4zPVdzBU/kcIBTnyNDzwnpQnpMT4v27X7u4zwfuEP2EDaD4c/KJd0OfmzLJga+Z2VFx4yVMwfR+Hvc5O6+rGI0oUkUaTCTUDCWyHhUek9sbkhBycoPn92Dfgwvo9S1W1y3mF3t0bVzoYXm1wcnZNTx2qofZUz1Y63DkxCqOnlxF0/gnHDjodgwnhnQBADPTw9g02SEQVQHbZ0ZgtGIPkwobxiqMjhRQSuGSC8ajT4Oihk2uGanhYps5IsaSjs3LWItvaYBDIJlKPCnaPijymct6SUEB+p26PVBRIovSgY1gLULUX7/24bECs4clOB5Jw68H97kOAF6RrGPZi+k+V4pi/rz36FTRY0SYoSkoKEabss+NbgMAgyCIehwNvoAjPjBtRHKBuBYZABAwRLw90vQAaeR7cp4sVHBUF6BaTAo1g8mpbl+umwVfJ2XvlSVLo5iNI9ePeG43sf3zDs5arK3X6Nc1Cu2DDMh5j5u+fBT//HefGgDA1okRvPb6i4iVWHUxNtqFc2Ta55nxILGU8hlTY23IV80UMEajYVaYaOrDvnOem/aY9iJsgED5tyTfaRpP03aINwCDAJB0BjIHpnQBQLGs26j/n703j7Zvq8oD51pr73Pu60BQkVaU/iFBUEFsAAVsGBoVQ6xY1igKjXFgGcWoMVpRjE0SDTaUvdESiU0koDSiNAXSKII8WoNID9Ijgjyad8/Ze61Vf8z5zfmtfe+TZoyU+b33u2Okefy60+y51pzf/Jok+6nIyVxk3s0uqcPZl7JI6kkawdNYfHKkYUpJEsmBaq1yenoqH14VkNilLLu5yMnJ3qn+2VgFAF39M6LlYgz+WMCopw+zI9iIsvaI/mu9y4/9tz/5Hx77d8EDAP/0gZ8q/+nf3N2RUDc4WppM0ySXXrKTaZokpeJIKA+7vPGKhibMrFjnF/msGMzFL3Y0EN1voSarmY7gsDxStFKXPjRGkCW4PCDpoZW9+Zcw7jJjKAAAMIkCqtV7dBbuKmtPPF57SuEuXXIgVCmFjrJarBQaK6AJMCVSCUM1+CoebLiDIvM1mqQ+bIqYPtaluwZ55xceNJOJ0hlgHtbDzAZxPTmoadCrJoGTrGltbHDsG10lGsbVNkQ/8cuvkF/87ddfnOQ/jp+73P6G8guPuIfc9KYnrstiWq/mqSbX7uFZ72ZYxs7Fu7n4toOptwC4DhxXJtAft2HLka2JQoYyDGx672SElHzTjsZi2IQ0vdR21rjwWYPXN03Zt5EABBrMkSbWCsvQuEdsExrSYKZEtFKYwTH9EQY6KWskDV77cakWNxXPNPLeOzmPqydA90Z2kBU0/f/lknVD0mWwIAc11DcoRGdtfcxph+lUt4Y0+TmILZqeXXXV7Uutq5sz1aZbsT+8kACAW10uz/6tBzjNGIZx0kXKVKRLkZP9JPOsYEAj8zsYj0ECUCmjvJ0DAGAbDqqtMy3sE4fx1mKaf2zM2NEe5zqYUGAIsBnu+GfTEN3HQwWDCahzHU9pw17itQN4AgiVSd7gOmYHKzIZ8m1clkUUXJdR98l/T60BKgD4R966PqsW1UZ1IAZbL6uCyGfu89nM+kyDDKBLwQSTDwzxbAEKcZ2H0VyYzCEvOuo2Bi4Md5aUJr1nojWnM/c5tsGqoT5HVpCDui0pyV+9/u+kNzXuOj1VsP6wVHnP+w7yoQ+v8rZ3fkiu/uBRPnxanQl1y5tdJjknufEN93LDK2b5hBvs5QaXq1/J7T7tBn5Oh76eUytk45HQIqu+xdKhGwAg6AVaOwNI1dptU47Nrsg0FT8blaoedYJaAFgpKbyX2I+DJVO9J5daZZKxMCNT5aMKenucmoEFywY0rXbelqzRYcsZDbsyV3SYDc1/a2dBC042wN3pqStk+ufPRMkO29bWhjqP5yRo/HyfpwQDtNj64zkqJZJgUtIowuOxut6f67x3WqjtJge6+T7vFilabImFHS7rpuO8TYNponomZGPThMQpzFOr1HWVw1Hvn2weX0g5+d0nvkW+/2deep3p0z77NjeRz7/DzUS6yKW7nVxyMilw3MSleh6BmgJ4KZOa2OZc3CMAJ+z2+2SfhQaTwS6SLG2h1ur/57iqdfCxWwSfyREq0oew3MxJesqyy1nmKcsluyLzbmdGt8GmyxQ33JxBIMEssV8vds761GcgwNUfOpW1i1yxL3JycuJSguidxEGAUhiMS74EjjM8/t3sm/5OYPdohvtHL329POsVb/r//Zm4IAGAH//Xd3P6vR46OhRP06QRDbvJfPm5CW8DFZFzidkPoBty45RcapbhxisS7sNH23S7IZehWOwwyxTLbYOFX5tcvzVKAsJkI/S4OCCDJhwPmwj+GwCAkDzB2AD5LAXUmzqh+AoJQx1cquF+i4iL7mADAAj+LFVn2Vxb7I0OKHMptMIYDKCxgU4LjIlmp4lrSyW2V5w7i4tKdTZil11Q+dj4CV/Rn171bvmGf/UnF6f5j+Pnm/7JbeQHvv0ukvMcGw8bqJutt2ACBl0xftC0sccFYjlZ14hn0V2bczrjJB4bnXCGFWtkIqrLnm9KCIHzdqe/V1J26hi22j60ESV/cJImwymcNduBaVvn7ALLz2xo9JM/w3xu6DBeLEovHJBddmGUWDUVG01nuM7dA8BQdNR51H0KxLrFxhgbItdzk+7UGRs5qKyq30s4Muzv7LKsi5zaBgYmcjAffPqfvEMe9oMXDgDwnN9+ADWk7OSeZJpn2e1m2e/meD48Tis289vruJsRHWvq8dlWM6FTs8VGUoug7OI512Y5jBunKbueGZrZYLSJ02ZBYfdnM8dWHQNJrVE/U4n4NK5zvF5QIdm1Wc90kdZMKrPxkYB2v5vDBaj7+ut5MHbitsYHuBKa0PE+j4YRsoblzH0uLtnj+xz/XinFnaPPu8+ZtbCtc85iB6gp1BTi3PJa8+i4Ls0Yj0glwJmSBibgWKv4/vg+L06ZDko7fBe2dY7oNbxWsChxdigjIqQfMJcr9JyHuVdys0No72uLTVmHizx6gwGcaufe5zqMxIZ/PA9zROzhSeoRFYe+Ca9pnhIN6eLgKbTGOUUkdLzG+L3Ff3/0fvCBAMvqXFd7CR09gzSop6Co0/NjdY6BJ+eI0tM6Dy8QsE7ZBLEZQKd9V3NWK86EMAZV0AbPDhZUJUedl4LzgdlF4ndIobpwgH4DLLce/gwsg+EoUfSWme7wiGUM8Iv9A8SeNTG/gGVZRYwCf1wW6a15PX74g00e89g3y0/+1n+/zvRpOSV52Jfc1b+Lk3mWS3fFajpMMF1qIUm6MWnmORuz2nwBch7kiWEwnKXDUI9YzIj/0wVEk3VdjCmySq0iS+8ee9rAAOgirVXvrUrKcmL0/91uJlNPAttzloqkAZ/F0vA6CCvX5AqTDn34mg9LSllOTvaSDMUu7v+BvWcy9kMa7jGhGSUkYeIb/rVWYyFl/8xgiPzqt79XfvUZ/zBA0wUJADzy+z7LNmlm5DElo8hlueSSnewsqqESwnxcqjewcQnHBQIqH5wa3SWVtE4piW8bsNUAAIAtOwyd8uAwHM1w3Rgf5QTTitgM8EHPDbFvA8LjKxxVU2xDOw0kDEogonD7wwYu4hu70D26qzMQ9I4ose6a1JK1IZA06sHwWe9s08tJB/5ZZfFGUiURRWprfiFmQq+x8cAlgoEMFzdQOD8UQAWiJhZGN4XcgqeS5Wu/9dnygpe9Ry7+fGw/j//5L5TP/6ybeWwQKP+sgZI0bqZRDzGk01DUwlcDdHU0IhGTNOr7cjEJzxqGQlznDKbpJjV7pnhsno3JkpTuiYEoW1PDdc4RRGioMYyg6czkQSFOXezkop7dIVbsmcXvG2KmzqnzaptVfGY8WKDxk4GDE+ycaQodfyZApFKdI6YMzSyo04UGiPPAzXnOpumToLFT0+gNWu8WnbrI6WGVdVkGR+guIk977tvlWx9xYTEAEjEAGLjczSpNm+dJerftyZSlN/GhN9Eghw2kglPGzCDDJZyZq22psYkIkKubHCbbvdacbQATM+hiw2uCqei6ddzvpkHDCHo+ZFtt4yPQepd1iTrH/zZuTLEhEo+DBFNGh4GIQytFBu+IYnWuW89xGI9nUd8HNNF4FtkU8KO7z4mFI90HUQVjQvfNJnFuPLwxUuTXp/cpDAy7U29xdiBqs7XuTKloNrsP6MUAAJGzzA6mnmMAxJmI+3yaYqMc97lRq6figOC4KNAnbb8rfgaF0Vrz9+F1bHIevc8DwMeZ320obAYOsVFfktEfBUCOnkvdh0AwaNAXeC9HJsyT3zmN+iJ9PZ6G4Y71XfW+BmR1sQQJbPSzDCyGlELSmVKwC1oNsI37FXxWvYuUKam2urdBVhP3oThrjCMv8Zph5Bf3WiRfgMnZOBoxBTspCdIFmieSdNCkPU4z7hIeJMFMElvglJI96hI1CAZL1Lk4dT/AYjMlnPMZUCWnYNwCXB8TRJK9vuRb7HnOziTQFIXsYIyQh8ZxUad66VVqXeX0sDgIdHra5M2vP5XffeJb5NHPePV1qlfbTUW+5f53cYrUPE1y6TRF8ojJZrBdrwAKs1LwT04AAmRdQAD4MZoL4IDWq2DJnmwJg88e33HvVRcUrcrh2GRp8C9rsjYAAiH7mIwFcOmlyvKO4ZtZYYl8WcRN/WC+ZyYHEQeas2/tOyImfLWYfHmIGQ2SAO0LMyULJGeaYtaqdq/3Ftt/vrPQ1z3lqtfJc1751xcBgI8WAPjJ7/ssyyJVlNkjWFKWk5OdzFORXCaly01Ziv1eaJHU7K/5ABDRfRyTkjz65Hi0qB9DkDwrdsb2Es69Sp+DEykMTzI17selek7zWsdYoWWNvytt3JlxWTGVL5NeKdE3WUpEbfG2FBfhQFsjky6mlJUS2wE3B7NGcFlVGxoAgDWsEvnNMHrSpq4ZLdIodyXJlGWgs6L5qeb6CgYASzYArGAj2yWpfKBvNgfI6yXGhtD2Y0W8WUmD4/av/bfXyg/89HXTTfl/1M/drvwEefJ/vr9TFXnzm0ivDgAA+nwe0DNHolj+cLPGcdSjWyxNSxHvIymiNd3tHM9jcrBnnosc4Ko8JftzaHy6D0f4b8hnsLHx2jR67/GoPgXFt1dCSSJ0hpg+Meeo3eMaru9jnUc+72w8X9T5kaitvLUE2NApXsqfdVCIZdTLcpY69KrVP7fskptltci4za+DtuzbQKsjbD6xSQU9Gu+NWRtqbNfkuK5yes1R01l6vJec1APgQmIAKAAwmg/p99llnifZ7WbJGWk1yQcDNrZqcP0vwShxaYZHzzYCgztpN7v7yIyU3RhA0dS7Ltk8WyaiNXei4oKl0snZH8MI6hzbdgz7dWNi6NtyDF69WRNug2oJR/3WEEGGu2CML5vsmdL4Q/F7x4cKus/nWTeIen8Xv5+OS5XdXHyLiUiws/d5RP9NJZ7bUoIhd3pY9e+2CD+AXnxHTSVAOukBfLem5w3YG9m000KUax2UYnOLYX8qxTSw0SAzy6cR8HC0VATWmp/sJwcfUOcAANba/fOB4zwGU/j37HbFjOBoy9+69dfJXxfkPI1MR4PNFyyqxcCSHS0oOgFL1UATBTCqRrZlOMUr4LW9zz26zqSFLh20YTQTIBJ63gBqhoUFxWaK8EAqLg/AoODUekrdWCyFCt9JMylWNvAkmcwhUXIVZIxc5wC/IXkIw+eRgQbZ1bjUiZhX3My1BSNmYIZMWVY7w/k+ZzkA5BPQ559/n8MPI3y0IOeZ3b9D7G7sBF4gSjvJsprZX86RfDUXimBMQ4xpyRHR6JHbfUxBOS5VlrVKTipD+9CHD14jb33zQa56/tXynBe/Sx73wtdd53q2Ky7ZyUPuc6WfJfM0y75kHZStX+iiJn1ay8ki1NX7a5r07MlZk238XheT0EgAjkmSb/SxyMTv1UdGTYCVFVBDimwAQDPWWheR2QCMyy47cdQzx1HskbPB5jF5jUkLpKvpe9xHOkwstQa7SG1V/de6dMm5eCMbDMjk6SPqNRKsM3iQJGcpBaubGd6ti7zz7z4gP/Okf7ge54IDAB78wFvJI//N3Q2dtQe4oNmdpEyT7ObJowCnMzmqmYIsZDhwcBmdHqvHpCjNUi+uyShSnajuMACbCQCA+YkDACVJtuKonv+sWpfe1Rkd2iOnQ3GWbTobwQJ7PTgfT2zSQii6Hu4yuOAz7a0TJW9yc6NwcPUNrG8pg6qtJjLNGzFo7YNyCG23DEOHNoejHjGax+bavWVt7hKtDry6HcpFG2c3OutdUhp1oNq4GSVo4wXBdEh3XzYw6Xb3f4Jr9S7+fOSfH/uuu8s3Pvh27laOzZm6huu2hbfk3Jxh8OVNd3bKf6D5uOjRaNQ6bpQ9voyeb63nDFhIzZKsrjGIH9AYW6PLA13Q/a8AACAASURBVG5cUEKAob0miSg21akmHwxwJuA1sa4UWl3oHkvORn0OPdhS+5DP3qmeZUODZAaEU1GFzbD6ZnMjvnlOxPSZaBiUzYUQ5ye5Ref4TZGxnAaNORsBosnj96TDZZdlWeXD1xwkpy5JdEsIY9SnPPvtFw4AcMvL5RmPuZ9/zsx0aK3LbjfLPM8yTZNtbrPTBLMNJM4cIRCB5RoAgYWMjbZAmm/kQc20hqV4TOAYz8VGnRxl24dsdXFPDTCzos7ZTLAPEXfOboNjfot7l2n+nn5QZWOGGIk8YADAVI+BZ5fS2Os94D63P3cwk1/8OTc7JHDD628N/bnYnZyT+HbV69w8AtYaw/QQMWjeILjPAdaxyWHj9ILehy0+7vMBOJHQhft9LjHUcoxiIs07zk9ssxaj6rPMEINSaKUjQYlN2QLcp7+bnOs9ps0cvWu1DW2nRYGDukGHh2GyD6gEdEqPIR3LAQAo2ABCCooo52psEtRATn2Ig85Zh3hIQoZzrrbh2ee+iIHqTJ95IzAgBvEeQxCYoIgadMmkDKBngL4p2CEbF3+uc27g0XfiPQ3MHGIA+DJmbcPSBABfti0wvq947+FpIMS0kd7PsLcgPykWcdiJfYpnZvZo0LN1roN8pns5AK5tneNORJ0DOMCybcpZmQ04b0VBwGVZRUR9AE6P1XveV7zoA/KiP/2A/Pe3vlce94LXXif7thtcspP/44uu9P5rN8+yn0r4ZBEI10TlACmpN9GUNRpvnmeZShFz33PvEr3DMKFAztOlZNPNd5UIuD+AGQFWAwBab7IeV1mryNI1FaiKuvNfOme59LJLnd2IJyL8n8JnpZPxFye/5YQI2DYYXoKJI0bzb1Y7eC5zLgZu5E0ihfj/3ogpVz12UIaZUz9fbXqvet075bHPf9VFAOCjZwDcSn78X99toNpjMJimnQMAvSM+gmhTFLEFulonJ3p8PUqRg14pon/QRCXbNDTbhuNPcgbqRMOAN8r20BXroHG4J36cyalbnS3TmXxWvmjxwENuOThBg4qaxq8YOdSJaYW23YTeTIxyDaowNyWueSbUjfVnbtbkRReNpg/eiTcanYxkosFZ1koaz25DRLxm/2xzCs0N8jcb+y10j0uCfs/1g/Y+cKl+/Xc8T5531bsvTvYf5c8zH/MlcuXtbhhbzzRmmYPlHvKN7M8bmvTVtuvhsxHPEnTDhTYNrSUH4DBkFdrgRNM3Djlch8KmfyXJuoTfhG4OxZ8fOP2jSYOzMd6DWKMrm8EmiQxUflwMoZkb5Tjd6cibOqfNufsWkAGSiDrKbsU97DXAda40/T7EwmGY29Z5Qu5tawMYUej1gRonpDH3uLKs2m5JBEy69KfL4bDI6eEodV1IAqLPzVOf8w552CMuHADgj3/rfm6ihIYYw9nJXuNpe8+y38+mm46hNlnD0cxJuzvFVjfIKWfbEMY2+mhxi9Okz6NYQyJmKKaU4zCRw//F5nDYJrrJVhcaGHXbj2x696PpZ53y+b4D1RkgdOjUmzOzSg6ac0rdh4QMKjMo4tDfbzwGwnCKdO1U58FOoHQdez9ujDfHZ6r3aHewLon+eoP+2kAzBtWcHt87QfJRD+zJE+Zzyeu8Nei6TSoIR3j2T6DIKTbG/WjqfEc58fEdjZR5vs/H3kLC/KqPUqox5ip5neNZd8dr+1g07q25hAjnsC9HzEBLXfKJLUHyA/cfIWMvaJkzGbn2jcRyyIOXiIOeSvgQCOnV+zlb7FgqQFqR1K+iN2d7mC2BA8RgQOmAn1xWAg1wrU0mi7hcPXmAN/+2ve/iHirw6sgEoKsMNpIo+E6pNSSTiZKRJhvKfTmTwgB2tuULQEawE5CWgUWX3+8OWiTrQbu/X723ujuhh5EiGLfJ9ed4JvQcSy6P662590fx2EaOVYw/DwkO+nb0FGVKFqutBqVg8C3LIq1WEYujxbnwV3/xYfmzZ79fXvnWv5XHveB119ne7SY3uES+7vPu4P89z7OcTGUYCE3UM/Qvk5lvn+yzzPNsLIBYtsTZG94zmTbviOOD2383iUdrleKQq/SqLI3TY9XoQBG5fJdlf7K319Qk9TQwhYYtfEqDBLJ3GcD0kOiFb5T9rbZczcH2oYUL/AH8fSb8Wg4PG5PD4OwS6cYUMGaC/eKjnnKVvOU9V18EAD4WCcAjv+/u3kjyZVFyljJNMs+z5Dx5wxAHZVDqtj+xhUxGDUo20Jt+imJl+N+t1CCUJBR3Fv+uu2M3OWNQ427+1nTgoUFkzDxl12nFEBR7utZoe5ojWibTwxeGMiMAEE7IiuzDvdipVVPEJOLfhquzWJoA6NlO92adaho3HIHMxVZgMDqEv4AxHsBeYHQZW4za1L0UlDxIDQr9d2Q7N5d/8HaN/208Rb/62NfKD/7MRRnAR/Nz9zvfSP7gP99vGELdALNGQ4stPUcTqVtyyAHgbg3NeMrR9HYyj+xOrQ6TyQCNehhvpXDnpsQaAqJ06GB3aNYeRpRkxCfBcR1NNmiY2zofaajRGGNLhsvDtyE21NUWm66dRYMy1RSmYLhg8NqEAEJuklkLzHTebZ3jOxmo0zV0o6Ukbepq8/eeDRnhwQNOuCJpU+fiG++oPVHzpeMi15weFQSkqJyck/zhBcQA+LRbXibP/e0HnLldAVLudkWmMkku6gOgm5N0xmG/u0lml8NRtfQnO908rCtcsfW50oxva4y1s/CGJs7w5N+HnnPNYwiRbIPzHM/mskZMZfhVRP35/2beGCmJR05qTKyB8hiEMjTzzR3JkUGeswya8bN1Li6DwPPUWgAGAETOu88HNlhKnl/OsaJdwqcn2WDDG+GQoinqstag6LNZqda5bYyKbDTcyY0ccYfC1A3/vTX81Sz0TD4cAQA0N8j76Ooc8hxQrqEPx78NTwE3W+wBlHOHuKW/ozdSZlQhz5c+3LH4rMCwGmj95M2A8xSyBbApPEGIPls/i6/lPpdhM98Hun/rMvzZkAGELDKdAwCsdKfxmoXPfAztle6S3jc+GNLdyR5/LzNJVoo8RixdJGUEcwAytiQi+12mFJnsDBVIUJjij9qAFwYG8ZFt0gmoxbMtnjgS8rhkciFx017ca3geFwd+omfF7wtjyjakCaD3BFANj4PELFPEv6U0POfhFdQHsATDWupqPnd6OEgSdZ9vvfnz95Y3nMrTn/Q+BQBe+LrrdA93o8v28g1feCeXEO/3+2FpqptwMCeSrLaJn3KWXUkyT0WKomlSSgnzVDuzc9HIvUY53AEgtgHo0+8v5iCPOF5XOS6LXHOocvmls96jSECjemA9ZciDguHMwPwIlDVnEGEBGx5iVOsGNmVn+QTw1dy8OeiR3rM5o6mHLWsSeevffkAe9Qf/sP3NBQcAfNHnfoo85j99XiDw0s0ApFteZZGcVQIgSR/QRMZboeny79ObXaCbhyU07KFrb66xXUwjj2336rnf4hE2u10ZwAMR5KZuNUnJNGLNdem9ixyWGvE9SRuIkrOUHLnBYR7UXWcNg6a5JEKfkhtHgR6W7aDE70HDgIYiUxICLoqS00CJxEM+GBtSviYPVUzv8lhBY2MIDAzp81ncQClSAlaKF6twlzf2ALYacPpd16ZU507UST6cOv58OoP6f+q9H+9/38Wfa//5ke+8mzz0wbcdKOdszMjDqA+TBAgApdUNEZo/pvAnonB1v9R16I6BBRvpZLcLzAbVaCsNbv2cbX9YbDgzGip+HQPxSiZCrQt5UqQzv5dBQWjrcakuFJkXmmK9WE4tImln7AYdwrP7kTCazv34YnU4lajhiAINQ1EMHUJN9rbOlWqpjBvQlSEPwGeFJpbjo/rmewFFFxtOULpR52BHQOPeapUDAACpfmmjQfz9p79FvuNHXnxB1EJKIn/93K8ZorIgsxBR2UUxB+X9bpZ5msIp28z+kFfOOdc88K9kKhe03j7QooXuqwC7kxm76eamtk7MAxvye/Ak3QyyRGzlNCXK5o7tX0RMyrC9ZAYAXgvOZn5/kOQJNSJsStuN8ePSM/KEAZANh3MAUSo/0jtYqcHBaEvCiTgRSxmeBah7cUo86pw17gA78Hp6j8jDedK87JTE5X2nx9VA9GJ1rukNmCXVdDRcq//eOvf7vPuW96Opcxg96udefDgLoAiO1S002diw2QsC2F9gyEeeD0hQCu19s9egZwRTsptJScA8GZcj9lkKPj8D9Eucf7XGsw0ZFJy1mRI/sKsMxAUA4KZnzh4cGST8d0DbPBMzY5SCtoG9yCaoDIQgDhA6ezEmI9hoU0nuN8Mu/5ym4GyQgd0RPjIA0pmx4HUOYzaYvJI0RHum5BnvzOYJ8FkGZtNUIi2BzXt5gOI6D9ZFDEiTyTgVRNceeyrZI53XtQ5ME2xx0dPjOT896AYZMYvwCGNwEs/bcalyenqU3qu0utjrF9nNSf7mXas86b/+rbzkTe+WJ131hut8H3erT7xCvvpzbuOD8W6/k2I0+O0GvUmcs0lEJkmy3yfZ+dIVcptsZpqRdNRapIaFEWyc4Wqe18ynq+mfNcmAno0WtQdjvY0kBCkdaVPTzEhba7DAmUkdse/NLQCzH876b4PlKCbr0Uc1O/cLLGM35O1NQRDePkX8h7zwtW+Tx//ZP6zJ5AUHANz5djeUJ//Kfc+8aBxkpcwaU2H/B/QnXJ6gIsKlGLpLGPIAOZUUJiXrGg8tdGfRlAU1sTnXtw8URE4A0IGhe15337wHDPyH4+qFlpEJbqh/9RgXZHF2QnUDmd3Ssp1OR+60IqqRPC+6iO9EN/nxvGcZWBBA+sI1mGN/kjVU2fX2iKRineKwgfXojGTZstq4YqtR1ybiW5A+aHxGTaQ+4jog0jA5RHeMiPy3/MAL5MnPfOvFCf/v+Sklyeue9TUyTVmmnCjRIQ1GmSKRRoHtEDTosqHF64YrDQkNW7d5UAHXjb59su0A5AaJjCOhyYW0BYZgaJDY8Gusl5ApMLgxbiuFnNmDUgtKNDNu4j2EzlkBu+RsAU2+GOtchJu8MdYUg8F5dd6I2tuTWB5zduZOJ40qLmlQkNFoxvuw4a1E3Cf0buHJkNy1HRRuvJ5iwAC2W3ozN1nXVa45PUhv2nx28hr4L7//Rvm3F5Ap5y/96OfKl37hzYYt5KDNtjvpZK8uxo1i0rAFdCPFHoNqJDG0oeHR56+71wwGdgzitY0aX4AzbIQGxhtLbHA/IB1iXSuZculQWCxZQO+b7iwP1qHnkoZLhOs8WDIhLxlM2CRiy/AesgHgWwd2d5MnY1nNFo86b717bOHxWIeN8Xl1ng2l97shj87mYoMyAGmm4qcUZxhAhsNxNc8PTQho5BcQ5nJC4ElyF/qo80gX4RQjxKSGuWk9N3JUyKE9Z2yqm58JYF84g5EMgvmZgndJTtk9LnAGTRSPHN9ZfF6QT1YM+CWo7CJJcommHYMeTC/RXrk/EcU+rsTGcEbkZosP5gXAIOndWVfssxA11tXpu/YhplZ8mG5DXCLrg9mUtTnQEeAbkpGwkMF3UjjqlraWYI/BVBH/O9gQfEdmSiUQgTw0az9l7LIuWda1Gi0+OTgCrwwFFKPOwbD0O4w8ALRlDYo3hiBOaLi2+3wbWdrp3kF/hvqonsiQ/T7vvcvJXpNKjuh9C2QLlcdXktB1ORxWWWuVVldjk4bc9ur3r/KE33yPPPmqN8qL3vCu60U/d8sbXy4PusdtnVlxsj+xhV6XTrVXyItGP8ssu6yJMPOsALf0mE14KEdthg9XgJlgDqqcsoV8U5r1PH0485KMvU4M/Wf7oE615HWVxLw4si9W0sZ81Wcf+/1IDOgGjIaUIKRQLGfB6/XXJSMT6Jef/jJ5/TvfdxEA+Fh+bnfrK+Tpj76f03pd55iS9JSkFPUAkDRJKTk0xy1cKHnjy5nxcGuM7O42bBrDVd6GStooJ9Myd9K94zFlo5e0MXRBU4ABhCkxpWTf5Ddq8vSwjAsO+kVcEK6j7BE7yI0gmgb8u2xexNp6BglEZGj6+TJvjej99FB1ot/1Mw9bd00OkDcvIqLhQKt3ONbhgcVFET4Epjlqbbhc1IBRNwRgHmR7Jgptrhmt/92nvEm+69+/WC7+XPvPF3z2J8lv/tS9qWGwBjBncvRu58b8gSXFcX4OOtHwHW7n2XN+PUfVHiSNW+ueR43orUxNNNe5b7CMe4zNRmxUZQAAYHiFZz/bsDbIXtLZOpczAGUiSu5Yi3AyFtutY2PHda6vMSiUHF8pEv4maUNhdfp2DgdvrvOUk0cdciwh3gO20pNlzaPOQW/wSy2HIzWfobK5WAfjrtak1lUOB5MAGN0V39nP/eZr5Kf/n7+6YGriOx96J3n4Q+80NCR+ZvUuk+Uo74wBgFVZ6JUxqBZPRIAz+uqxYco3DD+Gbn4AUR/YfsBE1Z3CwXgiMAzAgmeXdxmYJAAmYGjZJRgCKSc3iMV2v9Z+bp176sxwD3RnfMRzF07l3Cy6QeB8dvs5Uv87SQDG2hfeRMmYosAsNdSPy90kWDUe9el51WfrfLLhEkNwGO2ViOfs4WmD+Dc28UTtRp3HphXsue197r8HMZOazCUrmdcVMk1Lm+FeJFKCROBmvZXupDinN8bAAL1aH6U87IUykYZc6bHJz2HIEHrrtCUmc70UefV+BucAYDC4xsZcM8HZbb9tTInZ2wB3gTNRDAjR7znHUI/BJo3JCwEEJJKVbHyZjAHQDKDC51SrAQKtD7GVW0PA4wp2nPh3sjXDxJ0CFhbA48USlvIApphkEilZc7aBJyRf7GWVOb0pZY8c7d1c0aWfe5+31txnwAGyKQ8+PS53sGWeR0MPjNdtfymDnGdb555cwJ5T0qXWKuu6Sq2rM63wVR6u6fLU33uv/OTvvUze9t4PXm96ulve+HJ50D1va+dEkWma3Wh08FfB+W2JAVNKsisikyXd6Hbc6rKLzmU5eaxoNFcYwjuZeXZnAgxneodZdxteQ8hHsvTWwj+tnzVX3UqO+TlxCXYOPX8XY6S0rv1Pj11/TnkAvnOSgR3WOy9+mxtrJutJ3/7eD8qjnvIPL2+84ACAW9/iMnnu7zyAECZ9GJTKLzLNs1x6MkvKkx0MZoq0BrUD1EI8ANiAYyPiTo6IjaujCZnql8VpI4tR1xFnE6kEibJw82bzkbxpn0q4naord/HhB+YuOjSE5sodhclwQo3WAvVVgzWm2Y0DDh4AO5eDYmwHvDafYWYEHZdra0gm4PTTFtFHA3DQu+eQc3YxDyrblAa+yPAdeXyVvWdsfThtgBkJ+NnGAkIDu/rlW4ha2uQOD3iigw4Xf87+/Mh33k2+4as/3WmK20Y36Fk9/DVSmNmxo7RqUeM5RRPlpi15RFW1GUmym83V2YbPNEhHMuUma90fSJ8cgwD7biglEvKdWuVMTCeys1ejyzfprtXFJhFNHgA0pRRzGkmYhlaipCVPDIhI0t6j4eeNJ2+ktM6rb3lXu3CiAete552YC2J107rIfi5SzdQqkwkpdNoAXsLkr/sGD3S/TJtZpoCiznNKshoQN09J6rrKslZZ1kXqcvRIMjCYfvrXXy2P+o3XXDA1ceVtbyBPf/T9z79oDcgqk+r/Ncc4DzcxBnmPpiQ22emhGsMthupOmlrQtsFQjri7THp1cet4fI+ecCFjOofXk6WtYOB3bT75efA8iKEse/Ur9Rb33NrYo6YP8a64JwrRvlWyk0hvr/8WIgQxFLJvwIGMCYWa10TSO7/PJSR8aN6Uql4Ezv6IsWPpT2y6RyNGjk2DzwnHPebB1NeGVumUqhEGn23zPYERkZMM93k+Y2plMhrKto+892BplMwyPnFDPtznvnFLmT7LSJvom/OJAUgsI2ZnEgg9EdFzTdMYecfffUrd2THMtACVF+d7a/E8bpOWXNIxKfh1hDxLZJDroHcJE0N4FOTh2WYNcToHeIot4Hb4kCFN4bg0i48Ul3106bIsuBMpJYcYJjCqC4anDKkWK5mPxeeq9wkYb8VAAK7ztYbU0/f3uM/J3wH39+hxEAAmZGCre9TEeYR8+djKymCwuyPzXb7P1Ww3O3CNOyXYc/iM0xDDiPtcJQLK/CnGYFvXRa45XUSkGnDZ/D5vq8hv/MZb5Iceff1bAt36k66Qr/rs20gX9QMAAIDvLc6qAMCSJDkBi6hk2Z/shLXy7L3AeeUNw3/r7ugf4HTcM75ORS25IXHIpjgKtQNA6NE7eo11k9fAvLMLmcnmkVWQ9ZmCJxSYkjmNfkduLE29jmxARYCGKOZXvuU98phn/8VFAOBj/bnskkn+8mlfMeS0ulaxqpPlpZfspJQiItnRbgwdc9lkvRLlkSmQMCfy7YodbIjcAgVtJRPAvEHlRWKjtdtBh2QxgVN2nT+GeAwunqW98qU40hy76WG4+cGlq/Er4WwPauZKWcm8pWRTnbTZPuQSqLkewLpNx8UOrXTQVEd9aaWGsBqyDxMoIGqgIrpu0bcIUVBgVzAyDpNAUA45upA1fR4pOOeBDQB3WJgYoUjXtct3/fur5HF/9OaLk/45P6Ukef0fP2jYgjOwC+fdkmLThPzxQYohYSZ2XEJ3rOf/mG2tzZcMbvU7izNqA8tFhuafX5frJd3cM3SaiOHEa8AgG54TQnUeaG7UeTu/zuc8PJucHuAAomU0lyK+EZ3n7K8Rm5fwUwhDI93oJKfy9h7eCmoO1yJ6hs2zSL6DzXKFP8GUyRgnLj6YdpUSaSG6rbbtILmYtybmnA6an1BkoZh+ucrxeJRlVSom1/k8Z/meH3+pPPYpf33B1EVKIm96ztcMwCa+b9DI53mSaZptw1IG+jdLrDJtL9hkDCDlduvNbBU3i0NkXGuDcz8Ds5OdgXXzl46sjRE8jQ2HuFcHfgWmgPBfwZYSr2+tMTjUNma2b+PA2GiMM9D1uY3N5vZna1BWKaKT7/OxzrMng9TW6VwYN0jYXO/svoAJ227W+xymongvAOj4jgJbwr8f8zHaguIYTAQeGkk+4n0eVH0FYtmDBWetA69z8Q3rZHUODwik7TRziweQxEZ4MBAEcMubQgC1sw/ifTB5XNfoozAUh5HWGFHKWn1nh1X4A2WP7guT1eR9EbwG4K3hfkYlqMxcqwEq9M0g3by3giwzpdHIDxGeKY2dNdPYt3WeBoAwjf4acu11DsnC8LmKDFvwoc5LgFc83G/rfHuf49fhfYM/t1SSgqbkprpCgEIxFhDkLhl3SR8XQWpmmqLOJQwo8WcnBvPt/oWUaZ4grWDvgDC71PfePIq21lWOx1VOD0dJ0jxFytkKtcsjf/Y18nOP+8vrZX9360+6Qr76HrcREXX5H/XA2Mb3GLDNL2BOupSZ50l280xu+ZaSQWiYs35NLuyMH+nSajP/ADvnWhued/QUag4plhwSPk7CjCQwFcjANkwCbXm0YaEwWNctHQAsV/cK6OGF0Lz3GpMzxtSUkDuIiDz2+a+Sq173josAwMfz87RH319ud+vLB5ou/v/TVGS326nJTS7DIY7hBQMmEHqgPSVlctnt/mXj4hbHpcQMTUDbTxG10lTPgm2BbDbZromfIl6Pt2vu7J3EG3lcCE6v7d2diFPqg6N4aA85GiWYCnIOVdnzziliaTs8EZvLmys0G2ttMs9lyFOH4QsiFMFywCAHVA1NDH5vyXDV7BQxFU1tJCgwJbEPMYkALZrFb2TLk0VzgdgexAOiCeX3/UfPfbv8i+//s4vT/jk/X/2AW8rP/dDnDkZFsaFobuTEAzwGZGQNRwpGlsV4itDZpo07Oh9VAa6loM1u0kDQFDtAVTnWigABa8BBbYbhFjYWiej3K234Ux7NzupA1c0UTagbWzzHQVMco/08LixvdJQ9kG+O/ERUGcwCU8quzW00GCQasrZNXdQzf9YyDDxg3CSKcNvNxRttuKsPtUtU8BgM0tB4Ima1NY1iuuZ0sXjUNNT5Q7/3BfLsF15YGsxf/OF7ypfe+2ZunrhQvGTrTUpRg9p5ng2kDlAM0gqnIpNmEYMZU2g7RWdCD/uRzm2XA9izW4r+3b3FRpcjJnFX6IARkWy8tWdKNWjvxejc6DC6a3bl3CGD76JhayoyMFa2WZds1LtaxFsiU8Ctj8L2Pg/GXPL7/Lw6R2MIth0MRwN4ST7IbLfL/FxvwZVCsX05aUOdydUcnyU2vkEnjfs8kz9EfMvn3+dMjWaZ1I4MA88DKPFdg3WwswQBmLfmNMbujXe/ge5NhsjgtUZCxEr+K+x3oQCK3vf+2adwww8WolBCU3Yp4Zb668ao8yjF0IjIRsDBOAyrAacNrb1LsoYfwMhC0cpt83lj6Eethhv/+UlErZ9NTwrz3LM1tK1z98KhAYT7JqSNcDmhzrf3OUfspnMMSiMBRkiW168VTDivzvEq+E7c/tl5kEWJ95cM0EOKC802Ekg6e1lIl9aqnB4WOR4XydY/b5m5D3/ES+TJz33L9bbHu/Mtbiz3v8uttK+fZhvWI9Y1SZzn7lVWiuySyMmcZZpnmczoNlvTXU1CqSzrGnjCVivfhWQBmzoBeGweIr3HfBBWfCmMvm2+GmuNo8HNG2VrGTpIZOD2rzQG1f/HsgtMBAD9AiYbsdR5SSBd5Mce/6fy/g8dLgIAH8/P//uY+8sdP/0KRX5t2wxDl1ImOTnZyTxP0rrqwLJHIzXT1QflibXiqmcVb7SmkjfGN9oEHVftaAqZNU1GMQPSuGUCDNq/rlSoozXqiPrrrQ9bdrj5J48h65ZBq1mrc5FBM4ZNIgzGcIiXMiLcyHVF/jRHnG3lAV0oUopQZL4ol7WR4VG3Bosy2ek9gqI22zYUFzI+H7xyZ1aU5LpEdRUuw6YGTAMHC0DvA6JHdGam5ED75hSzCZtOa7olyad/0e9flAGc8/NfH3Ufuc89P8WZHwC/sB3Dd10p9gk0YzSaQv08niF1Qc6yb0QsnQAAIABJREFU+GUsrjGvthUXa9hqbbpt711Wow1OiHw0rSMo9svayYle9W2VTNfY4BIa3uTbzMjWhjndSIEdmzjPKScaJZ7NHcXrzRZVBF8SUHOb0V/h6hx1DkNDce2+eSE5xdeBstr8PFvWNjT3bvRU4jxKhoBqVFn4emCLn5O6fS/GWHJX5bVvlgPdmQsrb2dqXI5BJ+2yLrqFOT0cXVIFV/FpyvLgb3uevOgVf3tB1QZ8ADzdZGME23qWS05m2e9mSbnY9xPyI+hkPRGhd8HyC/fVwGDJiASM4QjMK3ffPkcvXs0lXzbGSjx8h5t7lZT1ORxYbbNRrm1D3Anw8PQI0C9FY0JXSpRZyQiOWTYhW9DzGp4AixlkcmSmDsf6e48mNYAZJW/DARawKR5ntmM54Ga9xhbjOlegJOQFHl1rjeKR0j5Q5/pdSQzD7NS/Kgutd906eh9gg4hmoovL8DjLHd8jBmDQwLd1HsBoMDWWtUkS3c43AuWxTQd1GuahYDMFFVed1iuBgPOcZVmqgXeQX3U311rWNpjM1d6l1QBqF09Q0NeJe5fp+s6Y6MFuaSSD0Ptc3OCZN+c5jT5LIb9KFEkXw/b2juoS6TQYM1ojqSUPkF3lY6Uo1biJGrCC8g+AFHfSNqVI8XCTSTVxyZR7YaRgSqyV2ZskybC/Rz+LAMlEiKVAg3ij1+TGjBRt2Jr2jw5suoFuSBEQ9Yo6x12J5QzMf0MeEhGP8IfAYAlZDe4SJOWstXnSFQDMZNHBbVPn8GlA4gPASQDPp4ejP2+N0mxSSvIV3/hseeXr/+563efd+ZYKAqgUwM4+e8hwhzcCXlLKymwTkZNdlnlWoFuIzdtI858M0Ezwf2khFdLEFQUDBjA867Iji7gkDRt77uGyU/ytP0OEeO++/MwJkpGR6eUDf0rSJGIJw2gweYJcSVlq7wP1P1JaMoH5AWS/8V1/J7/w1Jf8z8FavBABgGc+5v5yh0+/wi+g3Zztw9bm/pKTWUqZ1MDGtCg4hKGfYkMVmFlEAx46rN7DAAVb78XNyYJSCADA4ydAhbKIl/2uDAY52QYmjTVTg63WNfYmJR3wOWILF+pUssUcafbr4ahFCTCAaWnsT+B6xokb/4hNAp03p4hP4YsgZQVOOG4PtOKjRxYm3wJAH4rPA82Uvucm+7n464tYtHgUa+ve1Lh207JlUwLFldzUjwbaTPkM6iYi2myRLAInzbKoIzQisqBxyinJd/zoRRnA9ienJG9+3tf6QIyDbSYzyMmSLppd3DAL80FXYtBBeoYaEBUC8pKh/Hmo89FXI7ZnKVkGdu+O/CtgoJpgUHE5kxUbu/2soBue7d2cXZuYCPhCtrHLcCRM/Fx7OmVPlvDt3No9vrDDXTmPG/reE8kcxOu8d6XVHRcziLOmEE0gILN1bYOGF1vlcMWNuCnUFAaTncUvQmeNrG3Xedt7PSDKzIb4tXYzKdW6yeS+q9nV2YbG5OCra9Rbk9aanB6P8qEPnbqxFQNHX/nNz5a/eM37L6j6uPJ2N5A//NUvHgZ4Z3/YVmG/28luP0nJZcgkr2bElXOyZnn0o4HhHkAWb1z7GLs6AlJp2A5CBoKBY6ZhNSjKbaAxos7dc0USPRvd6c05G9hlBmddJMzlSg79vT2bq0m4cgpgIUC2AL3madzW49cQqbmj+7xwxK+ESZpYU4r7OqUk8xwxhx4NZcyzaUoyedaz+NZ/gS/BlIb6VS+Fsc5h8seJQByZqQ1kiriyKftmFWBA1Lm+CPgP4T6PzShH0ikAsN8VP5u6JJM/IvPe0kBaHxhTbSN5xHDKfQNYCdVSILKBUog8zSU7WMTb18Oxyn4/SQKAX8E8QNxb8zjC47G5TOE8vf7xqBGMeK5QZ6tH34U0Cu7lQlvLAko7gQtuNphHN3D2VoCcIIbnGODxHISpGEwr5cz95cP2tNEdp+T9JgZv5IyD5cBEn2ur81rF2QKTeYfUGsMaUwdS4sSJ5P2Y37MELCWXUgC41mdqsTNgoiScTDGGmfx9aqW+PUWyiPsa0GfOkh30lO7BVdigMlgAewIjJYn+t58DXXqvcjho/CzHTONjfdXr3i9f9tA/vt73elPJ8q1f+o/s7JgcBNDAhu7ALr4vXSokSTnLpSXLfpdl3u0kpYhE1vuqUYPeh2exkQkg/AXcENAO4kQGmLgjmWqfKB6w09lRjNHFXjaQAAjHl8Pkz5gBWjMivZkRcwrPKWeF40z0vzcYNVv13Uvf8C75nT/5n0NecoFKAO4nd7rNDRzNn01z10Vkmia55EQ9AHKO4FhHIW37EBo90IjDZOxoBwU0xtjg7eeitDeKGeqe3Q2dSHMNcyIZAHRnx2P16LHkm8TulxQYCGo+E80LdFjcsEwlefQJm62xBODgl3kajPJikIqEhEBgxyhBd+b2wtEhIbYN3WOiMAghVokLPXKN08BK8C0s6ZfReOowppR+5JR7dm/vg4lN3l6oSb0HGn1HMCartcs0Z2lGY/QUAMpi/sM/fqt88//1gotT/4b+/6gfvOfQfDA9FM/60CxSbN88WbTYggZPLw3Ws3J0ENOSZ9LWoulJKaLxgp7cnTpa0fxOeaAXdmKN+GCw8RYA0IdtkjqtZ5nyuK1NRDXGdn2xCKKB8eCRY0GfhWkYhhJ4AaCJyyaJwWsbmDVJZDfZGbTGGVQ9qzsc4bu9PuiSw3AQrzEASf+cMg/sUecw20LurVPwiIIaZ6K4zGNb5+u6egzgdns5lSz3evDT5F3vOb2g6kN9AB4UbtmDf4rVwLyzpJpsLLUwmGXKf3N7fLHtZh/MuMqUpdswAaskpr3HNjz049BfA+zZEWMDdYzviuOUUOcxiI8RlbgfBt2+Aa+oIZcB2BmhMbgBDvDzOfohhDxIhoEtJDyI81Xq+hi5fGqGc6jzg9/nYb6LbbMPlyUPrvIwUGxkAlgss12HjuKvzTfJRb003IOAUxNySKQqMZGWtQVPlOLwcBcD5OD7HK8zhssWQEoOBhJc57EJxecuduYEY0Ib2N0UjABsmBNxvXGGOljQQ4qH5xmAB4DaeYoYPeTQy+YzE+lO8x4WFimot5BvajJKcp8CsMNyjrPGjbvsNdfaNE1jI3liyn6tnYzFRlo6wI+IveU636QE2LOqevSzdQ4tNBuCos7xfr0eKLccElH2BAjZi/59eA4Qn4koZcgva23De762+5zTMZzNZAsq3MEwAMQiwKMMS9z1LA/b9u2JpIE8EwLcnEp2PwGYTJecqM6DUbvf6Xd7NHnubkq+RNCescpaq3zoQ6fDfY7v8PFPe4t89394ycVmT0Q+8YoT+V+/4I6ScwlfCqp/fFFwwFc5QJapFNlnBVkvOblEmjTpLtsdowATMQjBEJgsD5RZos6oSyFHi++fIo178zppxDbQfyji4/DrmbyqemsWMZCccQDQLZgziZIlVD6ehOWqY5jomQX2X7xZnvHyN14EAD7enyf80n3l7ne+kV/cnKeac5H9fpacNXN5mwk5+4WiBy+2WfoAZOm9BfWJMm3FhvbVLtgk4oZfp4fVzEayUZBDvxZAQ/JtYG1AP21TAIQKaKhEtjgGXDSQtSX3HwDiiX8LLAIc2tDb4jPyGDD7DOpWf2956dDTYBuJQYGHOlwUfEDnHM0F0G5HjWlL6uAAIedgRLQOwx69CDmfGZpBb7RaI5RZfDu2/en2Xjn2EA1SSmO5crSMiMidvuSJcvUHl4s3gf385k99odzv829mDvERP9RE5HDQrOtpSkSXDRYJaFfYiPEGBKZPu7lYfm+4yMYzXEwuUIcYl20TIzR4owGdsFGlxgwGbaAcY8gG0AeKsW+lCEyLbRBFDJEmEZpWNN2y3RL1GFo6ZY0jdip8C0jfmMJsC1rXMMmMlIxGlEsRa5oIkJynTNvi7DRiGILRve4DFtOoS1G5ADaVJcP1eaRdQ0cskpwmly2ze12r9Fal1lWuOT1KTt2Akajzr//OP5UXvuxvL7ga+aUf/Vz5yi+6hW+IOf1CQa4i8zxJLrNLANyN32IAw5Qr1InBvgpjVEg9Vger0tDMMjDmyTU9tueRdINazk6lLyVMcTFYN9+gBw2+UyzntdV5sYcZbDEAVZXYKvyMYUDc6oGv7T6HuVMhTwBP9/B4xTykBKBvWC13ejLG0HEZAYDwFtAhCma8fDfiHBR6H6737vG/sYkcsycYvExp9AFCzJSbWG3u84mYGB5p14Xc0cVlR0HtTuQPkAhICOYPKOa4V7M5qzP7z8EBB+Kb+xit5FovCbR4GAIb/VdGw66cg63EoMzQTuPZz7Exx0AJSj0WFc5gKGGUuKxNZV7OSEln4iH5vA5JTOSFrza4ziX5Gb2tcwCCYKXhMx3YVSIDWOcxsdI9fjb8i6zOs7I5YKqcBoZPHyI9WeaGeoNxJxvzgtG1I8nF4Vid3bGtc9xJoFF38sCJRY+46SQkamxoyn37eXXOvgLzlAfvJiyruhBTqW7vcz0/9nP2dKBWq0VvLvLha450n0c6zw/89MvlN5/4xovNnv3c47Y3kXvd/mZSciEavHbW+vyFUCalbEu6LFNKsp+S7HfmdxOTPi/9pfXmUX85Rz/VOsX80QDfY+/ud6TQkI7NvScBwLQ5jXUe5oDki4Nzt4XHDRIrkiXKuVeTGbekDTuNo+KDqRBMmze++/3yK894+UUA4OP5ueKyWf7yqV/pB2ur0UAc1yalFLns0r2IFD0oJ6XBHS17FZtAP52d9lZds4pLEujm4RgoP+i9QSUWOT1o3BKb/UAPH3qQ2HjjoMUDW1sbjFty4s1DMup6NFjc2OBtQL+P9wHAwPX7myiiSm7MyNSdp7jMsM2EZp/dbmtr1CCFA2+SiG1hE6xsm3f8OwwAMENgJX10SvFncXmpg2/Q0/AEp5TkeIQL++jGySAAzHmbhEEMPieOlWTc7l/96FXyO39w8TIQEbnJJ+7lqid8hcdnHY81mq400vxrV2frwelXRjohJ1hw4+UNHUCzSnm/ttECyAQjWbgUo84BQHGW8kq6/5l0/rNlnB+WPtT5NlrrcFTfjAku3j1Jtvx6mM8WauZX126mAa3e1rnHJ7lr/ljntSVvtuB6vlj8IS4cbMxYFwu3ftCQl0Wp3wpKdKdelixS2dRNGKzLw0AGTwDEqk5F3GugGAi4TTrYIuFr61LXqkkA1ogh7YTlHj/+y6+SX/it11xwdfLwh95Jvvuf33kwBMuWra1aRAMAcpbakux3xSnkznryC9q0zdVkWVMMGQfbKgI8aF38DHcTI2F5SnwPHKPGHhWJgAbdVobEC+AC038BNmzrfDLabbcNCSRgzCTAe8JgxMkF0cB3fx1CG//xPh+NccNrJnn9HY/V7xW/z3fFa9fvBoucnedsdGaTJOXRPJeTClDnGFzaOaakneoc925KSZYafjluOGgDHr4bAKUf6T5XI2MbvMkDAJt4SJniPtd/vxFYBzkR6jx8DYo/G0h5qND1mwHw9h6teB2WBABfkIk8mOYp2QA6avXhAQAG4OBYT95CiODypJXNnQK6Lnu1rLVLLqrfXZ0N0IONSOxEjoHttCRY7E7az9l7JgZ3wYiCJz3H/rFEgwcDpB/wfcbpNFPhOs9DIki2yM7WuvtG4awtNqRgQ76jyOptnTOIspjXFXqqbZ279EM4npJllELeQNHXQQKBIf5Ikgce8LPFfTYAUBt/qjp4zWT/zvDvaJ8Q39Fam7RapbYqy1LlmtOF+va4k7/im58lL/vL911s+OjnX375Z9ozNbIARBhMVMCnJNV1lZzlklJknrOcnOxdP89RsqDva1pR8mFevwtdhmBQ17pqkl1S0B1gByMNDB/v482wM7G5s0QkoP7dxT2bwtw2e8yfOvwrMysTQ4hTLRQUgI9BvIfemNUX98N/+P0XyAeuOV4EAD7Wnwfe9+byiz9yj0FTjux4mABecrKTaSqScvEvlalpJB1yhIZp/vEAMnVITFOXXJ+CGEC/FLGy6zJQ5FkXiCagTFmWYzV6dEQDImKiGHp6XFqYopTxdZ/ZsEiACdAHH0wrB6fclHqwJeyyc7dh0+hCdoCNTyI2BMdCQVoBMz5sClUrndzATb0NwogRpn+th048J2hAMeTDSE6LEGZM06SUre2G//SwOqV1i9431jnSd55TMg+ArWlVHAZP/5N3yDd+7/Mv3gBG///pf3sPdwpmyn8upF0sSskLl+c0AACdEjjYuAV6ZOSfuwGdadXRpKKh8O/aEFds1QEOZN9MhFERtqwn+8kbc2ywnRK/y+4ci0MSjf6gEe3xfiJKtHjMJBrl1YAsbBr3u+JNuYLlyYFBSH3GNAQZYt6AjvPGaVkjy7yal0Ajo7RSxM0QUfd6blEmtCUNhCkSaLZh4AnwQLdL4jFQzaLMRuAxhkZEimKLuKxVcurS6iqnh0VqrT60Anx86nPfLg/7wRddcHXyGbe/oTz11+9/Jiedh4R5niWbrpK3rfCBmMydHzFYvlVOsSmD+SpH6EWuON9v4nW5vf7BVMGwhTzvRokrTgUe7oduQCw2uZDvUJ0T0Mp1rhFsSRrA5RzPLXsAMEAgBKZwnfvAQpsl1Dlo/nzej/d59g2PiOZU49f5Pgfw4ttzori7HG/KDlijzmcbXit9T/rshwxuuy3mVIFu8bg5R5wm/AlgmgjALcz3+P7W4dqN70ryjdl4n8eCAVtl+ITUqmwk9FjdIj0hKYF0RD0LWkSn2t2qhorF2Y14DsA+ULPWTMxD/SAOx3UAajlFhM3eeCOZzSPBGZdJAQD4aARLpblhq0tZUkRYoq86LzGAGU56/tLKAGyw2mlrmIbeM4b8PgBUuD/OM+rDPerR1wQqnl/n50Tgtu69oQ/L9fw6d7nqAoBgNLLUnlEGw+nz7nOOWQaLFe8BSzCtc4k6T/EcaNJTMFBKSsOChv099nPxP5vJNFvBq0RLtSp11TsH6UP82b7mTVfLlz7kmRebvc3P7W76CfKPP/u20nrz+D5E4SlFPsyEc0ky5yI9iZxkZQTsT/YylUJyIEhtIxEDbvoRn5k8RYATiqK3N5Cgd6f9oy/DQzIA0NJEenIPDJxonroBAILoKE75j/9wCVwxanPv8RrxeYCNnejMSln89zzuBa+WF7/+nRcBgI/152cf8TnywPveXOYpkalVUb1vE5nNA0D1/3mgQPYz2uHursV9iP2yRo3irhANxPF52/zUQJ5Vm4b/jl/PmyzlTvTZYADwthNxLWj+GPFFk4/XCsYAuwTD3E+R5zZ8HkGJacIxa53i9ThqA4BA/D40CLpNKjmMxaYyXqKlBD1UhyzLD8f7s2aH6XCcn9nocyyGyLmPAUEBeRNBxBcwm4OAygN6ObuVb3/u+/VPkze/7UPX+0vgMY/8QrnPPW/iWxlslLUpCC0+tkMcK+QNOflmOH2+cyTdqEtUnaCEZINyhdHIVIow6xsZQNADx9pKxDhAnbsbMdW5U7BNZ6gvq1Mu+Vi3yWQLbOrUWsSCOtVTNrR+ip3hTSNv+zCE1do9GxwAV6VBqdbz67z35sBC3HORggD/EDB/wgwreZ3rVjGaM2Y9YSMEBkcpxYbOaNq7G4A1aa1Kq1WW5SjNNLX8Ob769VfLP/6W515wdZKSyOue9dUDVR3PQslJdvtZdtMkXZTqDyMi1kMzdXb8u5P5y4wRj3jO4XPCgyUafQy1MGvFHcGeAbw95YGlecyjuMfNNGVne2zrHAkD2zo/G+8pnifuzxQ8CzaeIpXO+nbufR76Ymbb4H19NPe5UAQc057Pq/PtTydWDwa04T7fRAHnnAZgR2UBaDzVAJSXBxzRlw007ASKJPLGCdfpyKnO5JQ9T8V8BAAwRC8D9qM+R8mjXcFyAniBhCRov7GBxXeqA1ai7yHOoPFzGV3pR1q8uKSB7/NBN99HGQUbHG6jxFiGwZIKjs1j82PWuPdrcQTn75/rHM8MEnCE+jiv1xLD9bbOce+01s88Z/Cy4jrnOlZtO9U5wJdrrXNjF1idIyUBi5NtnTONX4GpOjzT11bnM90PHPEI8BxRjkEPlzNgCRZp5/XtXOe4zwG0taa+M601OR6PZ6IKexf5vaf9tXzPf7yo/8fPpftZ7nPlLeUzbv3JYdRXm3lgNIuPDaf7lJLkktX4z+62Xcqy3yc5ObkkpEJr9T5q248w2JuiYfekD5bGtaapE/gCg3xvz262ZQuc+iUNG3mVCaTQ+jdFgvHakYAEoEFgICrZDUaF7phu0eOJIglxRiLxKeckL3ztO+QJf/7aiwDAx/rze79wb/nsu9zYEOZGlEnVx0/TJJdespN5nt1EC9S3I+XmYggMB2U5E42SRHxTxkNJ5PtGvrGiptka5TCcC3p9NnpuG1BZuPDj4mHdFrS60OOD8sKbQn5dOFgzgQCIgioly/FYB3OcoPvGEJ9t0Om9+ZaDgYWIGoymDBsTvgTLxgWbmxP8erb3CzoXR+MIud3y5+p0UWJWBF0PIEVsmHF5sX+APwMp8oVn0mpXxEMWfcZ+6tf+Uh716Fddry+Cm9/kEnn+4x4omVgWtY3xfNDsQscOR2GmGW+NM+GSjFpooO9K2tD6IR/o7veAAV+f6yy7WTcTqFc03dh08UaWjz9mwpxX57yNQ8RVNMpq1ontrVMVKTcLplSLPaNTkWGLNE+xgeComtgUoukrQ/OT7RnF8+9xjHDcL8n/bTSidcij1o9gLurh0LZ1npLRxsMd3Y3ARP7eOo8s8qAWYzsGJgU8AI5HZQDkottS9uf4un/5p/Lnr7jwfAB+4YfvKV/5xTc/87+3JrLfz7IzDwA/2yUNTAyc3b0rcwLUWAxC0K16BBIZOjKdHmDTihhOmPNRhBwPbvB3iDq3Z7uLyT1kMLxsG88UlhNgQw5QyV8T1XmYFAa92YeuOm5Oq2mjd9PZOuetIN/hsfntA/NFJIC6GDCyv65i0hf2non73DT/ecw1397nAJW9zufsgH5BZJqBd2lgqHUbyOy+ZAZhJX0+2ITY7NuGQI2K7XPMYJHo0K8bPNyBiJyTqHOJTXiAB+lMek7c9dorYGvMz2OYFOoZyUw8Zwf4e05DOkLbLDNwnwN4cENgGogdFJHkCTGgp+OsAlNqylvDZWUs4PMUu1d2tP1fV6aid5fW4D3wwIvtaMR7huSGgTwADQwGBBjMdU5bepL6wM+B5RswmQZ7AN8f/vv8OifZGrEukAAxRCSa1BQGe9DPZ5OuNAK5+sD61EHreKzBGs3JfSbgqQXTQI0ZjfhTTsRoZBQYdfj33+etNam1ivQmy6IMgJJHwOARP/Ny+S9PuCj5FBG5w81uLA+61x0IlNOkLV3cVafkI1pROvfXWZKlApyULLtS5NJL97TUjP6e47mH89oN+OLcUQCyuyRgrXVgQkdnl4bkgZTUh6STry4AX5UeGnNOXcOl2yIHf0/IvnHXBDsBCxb1oOjDQgeMPkzZbmabujzpRa+Xl77xXXJY6rUsEpLc+PKTMyM7y1N9ZqlN3vehj90w+YICAK64bJJXmv5f7KLiWKvei2TzANDtrrgmGRqnTDnK0CHXjTkdNmo4HEKPZjo4yqwFPZj19MvaZL/LRGvXaBKxJqa1bigSzFZUvwZfAPx9GGahQfQNWuUteh8aRmQPlxzxatMUuuucAwUDchUXWVDxGzVeHIZ7JF0+tjowfFE6Yj+zra2elxv0xMkkAvAPAG0Y7soa+9ec9nxcm9Ta5MR0dAB0ohELRkXvPdIPjE4NrTdvirb/LhvpoFiPS5PnvPCd8pDvuX7LAL71f7uDfO+3/CN3HwdQso0JcoCHdIjwc4gBRWtKL/kSwzYGA2+0ovlrPQyX8HxCQ3kwB/39rO7EqPNi22foDYc6t6EqwLvkz+ZMecRsKrS4NhYxZF3mKSLAWheLB2Pdo+pfJSW55lRj9HZwKV702efnnV2vkWCwm8eV7trEtORp0L3BgTriBMc6h8P3WOc41yJZgOscxk2o8+0gBN8CnFtgCABAmApv8LS5RxxrSk3Wpco1pwdprWrTZvrYk51Omz/4M6+QX3/cGy64enn4Q6+U7/6mKwemB6jKu3mSeZollyytZ2vms5tYIVu8Vo67FE+gyTl7452JUpuy2Vz2MImE4zdSKXQD19zfgQ3dJHU3AQTVN+paBn8cPKMsq8JQ2mgoWugM598HcACeBvp7xaMuE+l/QeM/brwHwC4oZTzTsSnXqLDkUhi834MBhqDSr6SrRt3judb7vMtuToNPw56iQlnfDE+gktOQJgIgLIbBAB98qLNzZsvccD24aGztbGemAubkddPFZQZa56ajpmhBUPfR5yxLgB2J4hXVyKtLszi5eSouH2w9OUMAIMU8afxXp201/p6StYFgaQX8WE52k4g0aRbDCvnf2pAEo9/9ARHOSGY6VtlZL4Dvns3ccupkhBxLh6O/pmjSkxDVfsqeHORSRqQrtKgBdrrfz8VlDYniPgHyNAOtJ5aFSvI6X0mSgoQDDBwYzjn9AMAIgNdkXixg5XUJvwcwNvBv66AuvvFXhllxE72PdJ8D/Djav7M3E+2Fkqlk0HLbvTbr5+rPdYc8p1Odq28XeoOTXfE+D3071zmzTcuUrdfso+wQd5A9j8dllZy6rOsih+PqUhHU+YP/z+fKy151/db/3/XTbiK3v+mN5TY3/QRiyNjQ3tSsmaMua2/SKb0rJdDsAdqoIeAVl+5knic38Mag3mnT71Iuj+brZOQXLIBqWciJfdY2LLMtK8/rE/+EiJpCSxp7JQzFYAykOFvxbzWJaFFx2R2Wis3OAEomYOPDHmzLlJL89d9cLW977wdlqU0uO5nl0v0kN7rsRG5+4yv0E8rJI9vhSbAFHHsXec1b3iFv/pv3y6vf/j55/bs+uvjkCwoAeOB9by6/+MP38EOTaWE6QBSZ51kuv3QvpWQ5LH3Qm69Mf6/4AAAgAElEQVR0ITVC7JkqX3JsxHemyYcbKg7jMCBKHnkV2cUxmHosXh2N7Tii52xETDg0w+mVDzxF0sWNzph6CMSJTWsqmT1x1GAzGh02BPj7ckpyWKr9W5Frm8kwz902JWJ1VLMakTfQbMGYZjeFzg5DljdDdjO4qVWJob1M6czfk1IwD7JtbsLVWjz73S9Q34rG5b3WPhgVJpJU1BbsAeg6v+Dr/uh6LQP43Z+9j9zrbp88OA5zTJAOb83ZGmirsoEwxyOowTr8ogkAcITjaIj3oo1OpmBg/Lsn+2LNYXPdsX9/tuXhmnAztLl4I7ysMWAcrNHY1jnHZ8FboNYmx6UPdd47DDuTb9vPrXOKFwVIBeCjFNPkIjs85cH7I59jODj4ckjEX3YZ46wQuRSABruwxyaXt8tAuP1zLOHSiwa52BaHwdhl2ASL+R0gmlS3d0mUkvnha47SewAAPGD91hPfJN/7Ey+94Orli+/1KfJr//HzhBiMvp2eZ2UApKxRtZw73k0XmWiLuLO4OmzdEFHrkWWtSV27M8yYPplo88ebMPYeUMAzueMyp1vgz3riQ0lujsZUXRjRHo5sppsctABgLMTE6dJ9O7xWpu0npwKLaEynPjfBfINcQNMjaLAe6jzuZNWxk7EeDVdsKIjBSGuk2+euzznumWu7z3H2oc53c/F7qhATEYAkqKyQt+3mTDGPWx+ONNznToHvXXpKlPQh1B8osAcGFe5z9xnYbnbtGVxXADjdzV7ZwA7DGsA8PEvVhoJiTTrucwyF8C/ghIAdGQ8rs7Gbj0pIAMR6LHz30MzDeBiba89/X0G1VbAC28F5KrIsVVIe74ZwMo8YQtwjLA3kPiuizCIajCNau/tdqJwK5/NWZoLzXOs8uYcSvqMdgULNpGyZWFceVbipGWaxAfCoDcku4oDt2fs8OUBe6T5nNmYpHI0dS6tGUhcetJxFUrIzvJDww8lVutxJBuhbj9giwQQJA6iJxdM99Dnn+zylJKfWtyuw0uX0oPF/SarUqiaA4V0l8uo3Xi1f+pBnXW97vDve/MZyt0+/qdz6k2+gn0mXgVLvw6tp7qWL0e+bZMlKp0/J9PbGoE6QdSkb4EaXn5BErUvqMRyP7EFNFOA6i8FegQikpyUz+vN6oFQAlk8nSaYKt/rD+5JM55/eSc2lDXD+L3ZvipsBdmFgwHlRDsAD6GZzU5ZcY2GjYIYow5NNAzP85EqwsCTOmtHkXIGM9//d1fKC171N/vClb7ruAQA/94jPkS+/780Hd2+OhimlSCmT7HazHS590Jh5DFcZaRa+jSihhWXNKhrjQuwAHo4dhbRsYwwghTZlJY969ExaF9Yx5RLaK6aS4P0qfTgoKbhsdDOXiUrW/XIrpDXcvif2KYjM28jOZE112uY+MxW4iNPXamuy2xXJIoM7NV6TUyZJhoChnjOSMeB7pjbp+rmhlh56MNdFU2g0LmzXr62hg1zX6gXAUYpb7fXPPuav5Cd+5ZXXW/r/i5/0lWezmG0LEBnuscHGgMimQX3I/t3qBNOZ6J8tpUtkzNnOeaTqezOGQSIHUOUmQC2kO51cZBEDKuak36nO56m4iRIDQ63HtkHfH7a3YWDJzyPX+WTDBJ73bZ1r4xmHM0tnkiEmADGEZEgrZTtH3cZR33tQzreXADaSkBo4nY+YHAAicU4CAHA2wa5Is4bXrvjh31FTsuoeIxUmgOvqZ0iloeclr3yvPOhhz7ngauar7n9L+fkfvqeZnMoQiTrPk+zmWSQVH56yx3bFYLMiwcEotwBrppKc+bXVbUP77GBVSg4qa0rE1sVY3KyV7yREzermdozRWzd1fqREFQwGg0HgJrrv7PM5pnXwEDXWeVD5eWXE97kna9jGFZFrlc1A7a6bCmelj/8NIBqAFNgEYAlts9J5SOM6Z5PdydzuOQEkfAhkU3Nxz/F9jjuw9fFzDLPJdOZz4/s6JBJ98CoZ69yo9sZMqI0AfQNkNYGlO2A7NtvJXdf9zEpC0sVRapEGidb4/jhVBX83ng2WQkBT3jaeSd0uf73/NblFRAIA6F2abf5XWzgkSeSrwj2SbKKEQxLGgMTa4DMgpgEGSyKyzTkFB8sJBpSKp8IQzddYCFHnMtS9J3SYrKsL+RiMq9BBppDISFbgqSEhQxBmH9gZAvf9Qgakg7xh84wNKQ4yKOS8tkvJZ86EyF2XQUIRFPDuEr1OywFO4yglSzPjWR1cm5weDi6b47798x78VPmb9x6uN73dyVzkzrf6ZHnAXT/Nh/atvQnLLuDcH14NXYd8WtynFKyVBFCoi5zss8y7nZmCj30BBuWSNUFKXHffYgtPZuCAGPCMAnyc8ih1AWCAf02Z0fZMU1pLJwAPqQN6Z3QpuUQEpjEa8GZTrP/dDwspBEgs8BPJ3lNtlpiUsksr1DSzEIAn1NNmlwJKzyZZCl5GgT+BnS7P/4s3ymNf8OrrHgDw+J+/t9ztyhsNujdolPQTKTJNk8zz5I+yIt2gm3dDc2IQLCVQ73D37sO2K3SNRbWS1rzCTGlZghq8Opsge0oAKFlOtRQZtvLLgszUTJnP1XO+mcpVSD8c6PFIdeTsaI5eYtM8boLcsTKNxY/3594JabyIU04+YDvFzJz8kRt8XDcme2RS442ZyBnXWW6Yc4LeLhDx2FDichwpqQeKqHNGx5wHmupuoHE2p1bq9nLUvj3vRe+Wr3/4866XAMC/+Ge3l3/38LuREV0aaJnQ/HfSgDXTeakkw8xWJIbprVEXtvys3ctk6ANtMKik3NCi0cDWERGXcF+HpKCTVjET8FVIWoCtNXT2GGzgOTJNYcDlBpsiHgvl7tq0MdEtXdQ5nlHQEmH4CVYT2Ayc1sEgVoCQ59c5A2y4BCfzA4A9TQ7ahdV5aKNRM6B8Jri0V8vPFoA/EcN2JPkEzEGjaSODIMq7n4pIq1UOx1VqXYzaBwlVSEPu8sCnyNUfXC6omvmmf3o7+eGH33X4fsE0OtkrFVIZADm8GyoorSEBwPcBRgm22gBE0Sh4LZaIOisWUxSafRuejILpG2RJA6C7wBi1JNqo9jOeMEGFbsNw220rp0ND9X/HjZDsOcbfo89FMNtQQ6hHHhAhjYPnTzZTTtQ5fHGgGefzaJqy05dFRPa7SZalug5Ur7OQJsTnHnI/BrT5Ps8ldPLn3edrbUblxNmYfKONO7Pk7MNRziEB2gIMYRzah6bY+6Iahm0cXYdkiePSHIBj1/lMpqIzseO6CNX5GMEKjxE24cN9zmwQvs81SaL5fS5uxhfgbCPNbMgJEvlHkPcT/FcmnC8hWfF894QkIhnMB/GZZjMtRMwkJKMA0fqGTlyN2QlGGPxRAIZigy2SXM4wU8+jg7z48Il7dVnakMLQ+8jqPLoHU3JKfyEaexfxlCSvGURFtoiD7L1Lhcmkx/5pHeckFuWXKPmg+X0I9g5YQXEWjcucQj5L+C5Vekd9u4SMZDDQzMEcOe8+n5xhdLbOr+0+X2s1SsIqx2WRw2GNvr0pQ/gLvu7p8q73nF7ne7qTucgdb3Fj+bK73TbOVznnuSEwLsztDOAn41FGdrKdPdl6i3melNXTRZL9xZ08IvB3ILK02nfqQJ6dfpWiAmEm2mnLNxq19sFYWc9KbTiRmAJDPvSfncBRfQbzGUDL/zsRO7IpCwt+CGwA2Fo1xoGe/9jwp5xlLiVev4izDMDUThl3Y/b6UsAx+8Jqa2LZe5eXv/Gd8uvPfNl1CwAoOckbnv1Vg8GW54kW3f5LnqTkIpeczCIpO/UuUGR11w1jJM2DBSU5p2jgMVCC1tid7tTPuHkHANAdlWS9ssYkpUEnyD8wsMtb6C2Fidda1XET5kq6yQy6CWsugXoi5aCYGRBrsGCoB5ZCbeJ0PM6jTlvaPpqJnJ1+yvr6WsOoKKfQd23j+cKUBihbGjKPYd6BjGJc5HiNrvWR0LOFiaFYJGSy5sL+7JydLcAPP2jSs201jqZBCz22HhT/7v9+hfzy77xGrk8/n3mnT5An/sr9zmzsePM+bvbiMOI4SiC5+73SnBaL01JTwDHrGEMv2CjNvk+uKfgJgKIKo7FutYHNaU9qKjQMBuaQjIYVBkSHg3aK+1nduGsf67xCs+xeBW1wSufYqExgG5aV25xp/gEgt1LkaG3NNplB+ZxLHgaKQv4fQ51T3jSaVAAMO3Z3J98Cz4WeM3lqeGaG649BjV4rfBi0zrvA06EPkgW9vG2L4/9ON+lElWVZ5XA4alBPh+Y6zsrv/NEXy+Of9pYLDAC4rfzQd9x1yG2HlOySk51M8yQiRVLOPkBVj+WCljsAgDpEn8lgTqfgQRjiQTq2UOoLvguWgmCI5ObnvDp3IyOSD3DDAdownnfIFhoZxO5mBf5Q5/PEzXt3rbbSwvW7PyxKM93vsmv+x+FHX1f43QQbQGn4eeNjoPcS9Msnu+Iu0mHYZnptirVFnaOmMOR6nZP7tPQxZm5I/ZEwJ2Qzt9hkyrXf5znRe9QeqNAdulaW3anRH9/nqHMRi05LSeaidd0RaUXMrnmGB4JE8gD5r+x2RWMTLeuanfMxCB/MdBj3ubpmJykW/bWsTXaQSHUZAP3wQQoAGIyVTmfE0LCTTKK1RndLbMVZ+ukgMG8epRuFWXun/X6SRIwU91tyYCSRnj5YMMXMXtFndmJC1BaySY5p5Dpn0CRMKIPhhYjVSkufTsNzJi8CYf3xOfd2pEH1M+kW7GvAEhIMOOxb0KW7JOC4hgxve5/jOwIgt676v2s8rgIvhZIlEHfJnz0AgPCZSOaxFTHAuJP2sy4olJVXpbcqx2WR09NFZpcD6ndyr3/yVHnndRgAuPxkls+89SfJve5wC5nn2Wn82Pw34VQmkUykkTa42wcsif8uor1HEgX5dvsiU5mc3dk6jAK7e1c4AIfhmBZCLLFnRi9HRYK9hmQcbNSTm/RlX5biL4MuH3p9AK+1id9FMvgI6Acy2SCOhq7k6FH0rmiDYaEarqr+MWVaXNoiTBIB710kFwUA4D3ggHDGrydLV0iUNsXxqfpa3vDO98rP/sGfX7cAgLtdeSN54i/fd3BTBRV1mpLM0yQZEgBjACxGOSvEAEipRwQMaW2PS3UDq0SXKjYboLnjUO4Ug4Tf51qqut3qdaefYKOJ7Q6j+tOEIohNAZB8oPxsPMh0flyG68bdGVRPIGm6HYotRrg6x/tD5A3eU6X8c9a3ZDJzYo8A/bs0qm9d+xm/AteGmT4MzUNoorMfTIoGiudkoznuZo6IQvXs2SzumgvtGQYmUPB4g6VgQZWUspnONNf9T8RaKPYcPOvP3im/97Q3yROe8dbr9OB/20+9XL72y24p3/a/38U+pzZsiljKkjcxcqB/YiMAiiS2nb1325hrs9+8FsVjMWGShDrXdIHQ6+HwSvk8fajE80r59ACnQO/FdhQNFuiiYBI4WFWSuVrHUNHaKJvBto4jmpReerbOYeoGhsCyVGfyYCCbSSubjAonfUzf8EhMiY17Ikd00BphlrjW5nWecx7i0JAKgM9NiKbqGe1oyqcs3TK/3Z187b4p3Mo3sAHC60M2fDHN+eF4lNPDIr1VSSlMOVHnv/2kN8n3PfLlF1T9/PP/5Xby/Q+7izf2uiUMACAXZQAkchGO1AkZIgC5WUfqBGeJbyVc8xSUVo6iE4msbqFtHYYi/t44ug9GrZlyyLdxYDAHrStnrEeSgerhKUpM+pl7h3XXeYjCNK8dMpzzuy2zeavKfnqL9Jtk93k99z4P92axTPfWk6zmMJ8s4z2c4sMwEJRubDRrje8Dsgds3HFW1c1mvluyQibwDYALPB4c2EtjTW4BB/cbsdiqVmMTCoYBBk5O2+n43FJkWK8wdDNmV9R5xCyCVckyI+3H2sDCm0r2Z2Elk0s8O5nYgPCewOID2+iexFMwmBHAiUAMVuGcZU+AnMwAs0aaC2SUasqsNHGRMMVDdjeeH2bK1DZSjOHEH+/LQK4WQBmYavBvgETlPNkW3lskV+VzI/VcDjow2mLRkWjIiCjlcbhK1Nfh+8DniB6QQQqOnOb7PNm91ai3juexuXlwR98+Z4r7DEbGcR3vc76XWIpRK6RvyeszoimzTzYBNGgKQGtVTg9Hr3M3VGxd7vXgp8o73n3Nda6fu2Q3yR1vfiO595W3kJP9iZxMxRaJbQCHqohMdHejfYGWv/YuU0qWaW/9jv2ZMkGqMclUikcn59RlbdGfx+zDi4I0PMeAVPOZhem1sB83whIM4hxn7BJTAAfky+G1QlGfutGHl5WYxxODjqNBYOtdElhwLpHQs6ZSP6ybfTNJR48pyX0MppyHmiwl+/kLU8BsBxNHhPJ7fMRvP1ve98GP/BxfMADAtz/kjvLtD7njuVo3zVbeSU5ZDZZ2kw/DaDRxSY6Uwk76OaDsbdBFjVmvsXHOWYZM4W1OcESTjOgr0zVw6TbS9/pmhb4g/racvtXGWL39HPTMrXszSsM32qJZnozag6a9dZbEZYO8b2widYsaEobtQ9Q3cUyB5EM3nb2ZwOCD4QxmLwBPUDQoIqYq8sXJDcKwFeANjYDSFI0lx+7oa9SinacYkna74p9n612e/My3yq899tXykldetxxjr7hskgd/+a3kx7/3Hmc0hRGFEg01zK86eWZki5xkR2Gnt7tzqznIsxtxyb5ZHmO8osHiAxeRURgowR5gCUEfnkUdplFnaCpcx0oZsUHzEhpkxjpnrRZvV7hZO+/PcJ0DBU4bimnEfo2bmABM+lAHQ50DbNtQLfn5Pe8HLCSu86loHaDOZTDj4Us8DRsi0MLho8HO56FbTVJblWuuOcpaq9R1ld4b0ZL1/33JK98nD/62C0t+84hvv6t8yz+7vevLkVZRssh+N8s0zar568m3ewCOoeOvVQcT6dGA7yYYKYbxpTvNZx4uu1MJ1YhWmSCd19EEAEQNRiuVXNJmZo+mpe3UaByPSnGcLOKO3dFxZyBm7WjmjzkFDXpb54Pfjpmz4fl1r4Ecrxm60TbQN9PAXonI1+6JFNCac1IJqMyjH47QPX4213zL4NnWOTarm0xCo4GyZGP0APio7vM5u8maggl21rbucYNb1oaIkB9BSAiwReV7d/sew6tljP+ENBELGZhJQq+u93n3PmHcG4bRXxv0282BMTwkrtZ1Gm/y+xzfJ7yfAEYzC2s3a5oQEhfWamZi9gyhMOCNhO8OrwvAwUTJAPjO4Wcgvev2O4dkDcsKbO3WVSNPC0V0likibVNSFg8Pw7tduO2jzhNT5slIEaa2spUtmBmmAESjIaq2GKYh02PPHyRMeVQfPSOZvCoQX1ky+xS0M317sxSS7CbTwdbZmmZu73Puofk+5ftc6E62BaoZ2FVZ1yofvuag38Omb3/gNz5LXvumD1znhv9v+uLPkJyz3PDyywy4U0ZxxXkFR38b9jFvALzHdhnPnbSuQ39WMGCelM3GtPRuS50uyVk0WGTwwc8mg27C10dwAKeeLuuS0+sByk0EqqokQRc/27i8iDEO6YK/XdfSdz+DSs5uCtgkAEpQ/RVQIDDd5a22fM4qr1QGLAspxlQBPnNQd9ozFe/zUsoEQJyVJvjnJl2e/Yo3yRNe+FfXHQDg0T/xefJFn/spvq0LIxlEzhWZp1n2e5UBCDUcE1EiGaXlJgEUvEyOu6mLI9fYQKaBzte9uc0lS0n9/+PuzcMuTao6wRMR73u/zFqggNqAqhqoAoqCh31xYZuWblHaXRDafpxBXNul1VbHDZVu19HpbnewQRqXVkFQZxBpRVtAHVlGpRVE2URlky2zqqjK7973jYj5I87vnF/EvVkFilBJPo9Smfnl99373jhxtt9ilktN5dELa3CkXcVft9mcBFLomwMfH9AWrZo42GZymOiU3H+YIcbgl2HDOGO6jcZbfBKPCSoXP14MEfcYQ4HkRZtNDDOp4EZvbozvtbAtVE+n2Cp3kl8jX+ANaSDU+BRrtpr1j5gQDxInmpdS/D2iqN3TBNigWfVnultdMTuSGA7OwvN/823yY8/9C3nT33zwnE4SmznKv/7Mq+T7v/mhncppNpgtDV30OWx3qzXU4DGz93ImdAfEuLBdgFqwSOPPm8pv9c8nJYcW5yK2MW6x5a/R4lyFJgHzDwQJZBoQuKK4+sNAKXI7Ln3tiiJgNwzEFu4FbvxLDR1Pe8JrJTqCCXR1cd5vYvs4FzuTq1aTU+ydOLo4n1MnvuRUI0cmdXFuGiOxi3Nz1hD3God1midw3zZtVAwE0G+GcSLOd9psYuC6rqusaxsA5JIN5szDvPt+2ovlxpvOHR2A//D195cv/YJ7GN/aqC0xyDQ1odoUk6wleJNkDVWPGGlWSy5Ua7aaOgAIVXTDUrvtcoF+BAa7FL+Rdib4c/CzeXAL6D0KbQwI+L6Hra2IGOLF9GG0uRSpGufawGtMG4Q3OXUrhobggraMx7nmh7kNSxpSBHlE9vI5OyUw55QhyIGiD5tLU8lPbr1n+T/4c4N1YqV8zva7KTkNwPN5NRQhms2z5fPdkrvGSPS1YIgBxXyD0doGXymF0ZX1Gb03ohOxTQLViBv+UnpxP+R11FHI2UA7AIkUQ7Q4x5CjW2poszuZAGYv3paLK8pDBBPIqkoCXrjjoRtiiIdczCVm6fJ5a3ag8VDVNnZWLRdrFMWtVdmCcZoc3cVNxUoaKIhzwJJFAg0FFElRi3Gbq4qlhUBxPrUtHz4j0E1YMBC3byEqpOdfpzkUci8ACnbqGgkx+1zQ9ti209AbpA3BqC5e8nA+92GwaziMQ2AMr/F+OZ83ikO1OO8RRw7538yxQ77xUAMD8KBb4ZyzLOsq2+0iu93Sxfm6FnnSv/1Dec2fv//jpvm/+MKT8uRPvpeEGOQO518gU2y0yawN6VqKI1BQg9AAOGCJkaKkIBJqMCHItshLrSkN7nDBMHgsTdn+zlHAxQY1SZFbubr2EH+fEHwwCEo1aKUxBmq6eXsvZB2oAzw9Y5U25lU1ZGrxxW01nIBTZHC6cq26sXebQKChwOEXQuxVQgXgexbLi6EXa6XmPsagr7eqHlywr8ed3Tfz6gSiz+G1b323POd3/uTcHwBMKchbX/bZnWc71HPXtTRf5c0sMU42iXJ1fr+wGyLA4dywLROp5j06k68xlLcggAI+Ok/KzXpLBvGI6oVQ49VlKwSL9FtLbDcCwa8ctuKFCeCRpfReyygAOgi99G+j50n7/L3QM02xNeFojAtZFnERGk2hst/AA+YNYaY8KFqKuGq5+XmSkJWL4XjRNCUxxEObiHli4Q1WGw64evjxrqm9njiaDKmRqEkFhxBQU8D+Y3SuNpTawe3j4oSVZyWI/MTPvkGe9bw3yftOnXsKsp//uCvkh7/toU1HY9husZc7uJW4nNoGpdgW0lTOp2iieA7jr863K7XbPgCmxRt70D0Q59D6AFdr0sky1KQx6HP/5mjnBP7OUqsNybCdgZiLwUcLPJpDp0CNy75WHzoxDM2UlLOLNAFBEeleYZ2LzhqKGjEMIYpCpGfC5JXKG5IDcb4McR5cBKwpwycTrcIgJMM3PCnPtJRmNxWkg1gD6YBNKttq2gYG03Xpt0MYABjkWnDXtY2MVNUC2C1652hi1Dj/iqe9Wn7z5e88Z2Lq33/d/eUpn391b2+nz2Izz7LZzDJNk1Kxkm2urEEP0olu4hwzXBJn0Jr+4tsLaGdYIaf/B+rA/oYwdPoCjAIAX519uHGGF7LQw1mAkFrvs147hwO8frhyuEWemKd5F/MkfDtPPecfZ862sNKGk0mbYDwP0GWwgfTGReiM1oM6CIwUgP4HBsOrxs+Yz81RBIr83SBGTJ/jI5PPhfJ5sWZztzqlAhQg6BmwUwsPA1EUt/o8dHZ7GHRG4nOPyEbj3mb3pDe0JqEZ1lV1C4Z8jnOAJqPqVh2fPS9M8KLZohWWqsjnLY7awgKCgCxQByRbpQkFapGJRAHXXDqUQTAL20Bbbte0GBXCOS6KxmpMkYZm0mlIjG4PLOQsQgr7hHgxobwBUcJOOVOieov40D70VUQG4lx1CsY4n5SmILXftOYBWm0DfNUEAK2IkWmI81JkL5/nLGYHjc9+UoFF0KqmqXcIqLR0cNHHVr8cbxfJeZF1XfcQPZ//1b8vr/mzj48BwOUXnS+f//B7SIxB7nThhW2bHFrTX4tIliK1FFlV1wz8/RUIIz3rASjrKUoN1bjn0zRZvAX41aPJZ3pJISQ0KDo4GxiSmTaK2D3Jw1uPg2r6YEHtjkute7TDXiC8KrJbm2nLn1rjqUhzDITg0jeAZn+aElHFqHUOwRwpKmlo5KIi7txglyohxQGuH3s0BAHFoub1iGcbMOgCDUAsx0s31PA//5bnvlTO7NZzewBw/2svkl97xqO7CTLzjo82s5w4miWq4AQDapnLiG0VJ6GgfMQGsfStZExuB8OQWAiMBFXTZeG+XNy2DgqSVbcB+ECmORqfGLZ/xXh1SWpx33P40rfD0IolHaW5ME9kW5rel90mSsWLrwQumHooY7DAEzZXxxXjb4pOxDGBDbQxAHQVsLye01c7pdtmzRaJpyPmswulaIZxWRKszuvBZc8wazQYsFvcLcWgiXgtSOgohJlnjGTRQQY3zTcYnvSVNkQ2KQTtQNVAv+cnXivP/MU3nRMJ4v7XXiRf8sSr5QmPv8ah5CJd44YtHAqGUmtnq9mKtGZtkkm4Cb7ASQsks9BLsRNUAqw1mQCWdD7KIQaDHcPPuEowuy6cAwiyGM0gSLd9YwVhF4LprTBtCFC9IeKNdbSNBqwqe4isWYDGttEsVUU8g/MmC8FvS8e/R6HiQwPMz1NkXr50SsmJCy2CDE8xSq7F9A9K6RXZS+0htECBiBVh1RAbJkJYah/nNlSBTVrs9FF6iFogz2197rFtjHMuUsoiu11TZxbonZBuyDYZa+UAACAASURBVH99wVvl6T/25+dM8fUj3/lQ+ezHXuFwcPL83Wxm2cyzpGkWCOgZ71bvYiCgAO2G+CzUsXHWmJ5ViEoy2krydpzjnIsHDADw2Y9xblaaud8ig3+OIcU0RSvW8d1zBioMUM6hMRFvZCA4V4fz3nk8E3w80jkOhJhjoUODTuIVkZMGfh7E4gK8nKFmHXsMaVbdnyb4mTQvNrgo/NOrMPXHvw+a0RjRfIeD+Xz8fMd8Dg48azywZkOgYpZtvEQ8n+Nn4Bc+wzHOIb6HOAdqQcSt7HgjXnI/fOKhOu4izt3TFPaoh6Bv4n5eFNEHpMlqm3znys9T3MvnHAfzHF0UWYv4nPebB2wUWVk8F69RAp1tpxnA6jFZ0+Hft+UB0OU4zvlrE+kVQWsGdR07vAD9wfRFzkP95z0OaNzaEPpMLmbWowZYLJF1JhjZxmrtXstVyhl9Po9EBeXPi+Oc63aQdiPZAJZumOyCpkxDgK4AW4BOKUjJWW4+3sm67CTn1RAUqNu/4mmvlv/+ined883/g+52iTzy3neRFJPc4YILGnVDqShV6TnN6aHILldDBEQ9tJM2mtDOiK3Y6TzpPe4V7RIVbdaD7k0/yuOxGIIEiE6gc6ttsosKBjbaQK1ck/pyIZcmLIjaDFt4OBcJWUNawxuqBImkHSb9YF2ERACVCpCiZVPW7bGlpjjl23qC2k8kgg0EaocoYASU7fID543Yhi5C9AWlSgiJdAqJAWIA+X8897fP/QHAv3vqveXrnnKtXlh+8U6qgnq0mWSz2ehmcuqnQMQbduGyHi7FWwEheHs72BCAaAm7lCYmF4Nv+9D8u8CXIwGQZPkyhfCGb8fcT5ynyFEnuQylxtR6FIhiX2K+bCt5vp6NZ4yCYSUhI2wm1tyE2jDJNVsrtW4SgptCRdPFhdjSqXQNuBCfD1ukKcUGqayKDooewNh2ss0LRAAB14NtIhI2Gg3fhlW3+tMtCUOMGGoatFAqB/xr8b+w3ZlhV6PP/WWvfJc8/8V/Lb/627dN5fJrrrpAnvjpV8g3PPUBeo7qnm98a+Ldlqv3ag0OPQwuSglhyBBcCMgh5txQ9JdOi6lg8NmcZW+YZeKfZBnFSaW3luw5of0mxLltSQcKXPhhUw7LFaOBSA/L5q08CpFMTbyp0x6I84lEAL0AgvNG0hjcj3OeHLNvrtCWf4xzNGqYxGMYhk3eRuHUcAfAtnVViHLbTvuzA+oK8FzcOdgM8aANoqB4/W53FkzUptEomjjT8XYnUrNvhUgJu9Yq1/6LFxkc/bb+6wU/8Wj5hAde3O7W2NM15nmWzTxJiJOiiXzIMiKzIAbpCIAg86Rq7MXFVXeqNmaaAAsoZd5QYVtZxS2cItPh0j6HvdK2xYbmXdONTbF0w7Fx0IA4h61aVpQJ6z1AdBWIMzS2XthV8kAeaHzEGxfitiPv8oYX4n7dkCuKigyWTl9ow3zq4GKgrOGD3I/YHPO555dWM6AZFBpWjM3ah5vPIw0qnLPuDg7zFA3psyFdFo5zoB/QPI13Opo+6DlA7DFEH6q0oZAKsZENKNCWECHmIQSLvTEVCoMhqN+zVSGooImohfNwr3IcIZ9DIO5s+VyUf19r25Sm6AiAKrolDYGQk17nMT2MXz+QYClFmVOPgMuEKESsLrqZnxM2+SKbOVgcC1EbW5z39DlGvTBiY82kCUPoDY9zH4xD7RxOE0UOxzkjhhgJh3vrlvO5Dx5ajGt7VHvkGdN7AkPD9cNj3S0gZEPwptDzXUMB3HTzVpbdTmuFYqgIEZEfftYb5Md/7q/kXP/1oLtdIo+67gq504UXqiYa9SoqlFhUq2ctxXSZYgiy0Z4ppqj3QhAJkXQygGz2PMLnqVD9EiMvLZ0OAOE+OAgWo1D6EiVAWb+4bbHnLtr8D9TUEKrUTLorofbNuOxrREh1Kg7ytFOfSwfLRy8B274QY7sXoqPF4XgE20GABoL0wpyZ9K1QMwYdkqUIoUDVZ9LXk0Lo7EwlAH0QOu2zXIt8x8//D7l5u5y7A4Br736h/O7PP7bjIk4pUBMZ5GjTtiltWzW1B0EPpVerr5YAbDtBCtedrQjtDEIQ2e6KWeBEoaJKVVC9SSebNAEHKuu/C2oX4Tz47VI0OYDj7JxCWPSh4WDrOk72o29vGnx58TUsHMiNbbWGrUH7AWsB3ArFCyyR0sCUAOyx1iZCw1t2o0ukQNxTf65sOwhf6lKripG4ErKLvohBvGCd5N67Dr0GxBkbE7yPTIMNOQBhM5j45L6dgJ4zt41tumDFFZMH6K/+9t/IzzzvjfLHr/vAbSKW7nzJSflXn3GlfNOXP8CaePaJBsTYN4EO54N3Myy+bEszQF6x0WT+dia7rmx8frc9Al/X6BirP9dITgD43PtpsMZZdGhWQ234lFqoaEOhBo4pGjMJXsDsdkUt7VqzAu4yfMCxhYohdAO1pkqcu80cfJcbX7Z2PGpD3ER3KEBxfjDOtVCJKrRUB6QGpsGdzaDy09rku32N+zI7qgHWXy3OQa2KDuWkJnCng9ATm8k2xgzVNo/tTmCnfd9CNm8FgyGpTZjpeCu1ZMltvbg3SPz67/sTecFL/vY2X3zd9bLz5JUv/DS1VapCYGC9oyaZ5yYEuGYfuDYKSVGUWuwE4NCgNCvIYENlDEZ3OPMx2KC2DRZ6UVkhKgE7CnCcrzrYPlucu1sBwTSpQTDXiLIvBjZPLvDH+ZwFLVnIkM83NCii+KbbB1H+/JvafFAbu2oDlmEXKssq5lADizvTkFm8MR0LJrbdQz5nFfit0snm1Dfst5bPWSsAP/uW8jlTAzA0HPP52eIcOhIredkzIgRx3vK5uucU6fRPnFInJNDnVoGz2pKCQsJWhjwExeedTZi43W8htiYYZ2WeFBZeXHQPtZ3bAhJveMjnPCBgu0dHfIS9TTwLUuZSmkJ38EZ9Ur2Y0YqQz66I57R5UspAEdNmWJUfD+Qa0HOIczi14PuMcd6QBcGa4Rj6pQs7CkAjJqU24G9xjnpGOiG+Q3GOgRWGDFgSuagriYbGcCCf++AwaZ0uXZwHs4VD72hoELgX2JLH74RlyTJPaS/OgQYt5h5S5cyZnZSySsnZY16/56v/7H3yuf/mFef+AODul8rnPOzecuJo8k09I27V/jQYT14FVSeREJIO8JM+Q9chYUpKrW1LX43n7w299V+oA7sGlUTGaxPXA3/fOfhitoAQZKvF6xls2qGvysOIprNWO3HvUZegCiOkAvV5vtiS2iNr8BpS6ulCoKDZQge0O1oCuTZBQ2C0LwANIdr3b3c2KKi69KQ6L6lDAAYsoHLFQWMW99F3/MI5PgD4/m98gHzR59zdkm6KgYRI2gM8efJIYpxkmpI9tE5d1fhrDmd2H8rqk9EUqHDijUw7PMeqbA7I5mrWPQ6JxOvKucg0Jyu4M/jrIdi2vdS+id/M3h5j+m582+iCFoBhOrfTDxeE8nD54jWyZ61NhgnCYiI2c7QiHpZAgEiuRWwA0Cx1isFVuDiEFzgKSXDKIHQDXuw8+SYHzSUrNtvWBQdchzlQgc7EKV1z/74x9cezQWEKrhsKikSbOeekEwyXbHPQNNpFRtwkJH6G32EA9Osv/duPqVAgBP6+5xsfolQJF2wJSndBow6vbN4INLui0vEngfpAodoEAXtvVBYnwudUuSAjjt9E9pZoHMzui8R8bAOJjeRgeQU6SYslgicGkbw60qQ1NdG2PaJUIKlocF3ohmGigJYhecBCSgadjhgdNusUodoLStJG1ZTLU98YsE5JIP7Zdim+NRK17tS15DzFziIu0hYnD3GOLT0GZik2waqsRdyUYrdhacPOnhrk4oK9xy7uXPdt75E5MQVZl2ybmN1ukZJXbewq3WEuuvmgz3rJbV5n44ufeI1851ffr7MwYtrLiRNHbWidknHH2WqybTuqwSNtiF284GEaBWg0oI2hORkH0alzfenhvKL5AWdhjHPk3O0ud0gutoXFhqSPc3cQWXNvYwtO/2Z2SgwQAKUMcV5IET84zJydD6zZWpo6dBPM9LukLwhbow5eOnI/Uww5nyPOq943BtmHfg1tQaFxgcECBtQkDdS5LRzSE0KR6UiOph20LpzPGUXAlB4IBbdh23ogzmE9iAGA2ZZiM6uoEqAgoP2AOEct0oTENM6T5881147SZ7SEEOxzh5sS7j8bKoh7v3M+j1TrQMgSm0Dkc9ba4AHAvnOQ6JDIm4pKtmSODBidIwJRdBxF08d5MXHc2CFw3GrSHI2IPsGuUGiyHQ7f8AeohaI2/BCKZCQDx7nHtf8e8dbiHMgDpd+oBe5u8Ti3TTvHeXKgt4lzQpsDwty3ks+BCOnjfEB5qv0iC+m6zS2os1GHKE0IWDox1ShbFfFs9NAq222jmuV1kaCNFjSuaqnyhd/wB/KHf/zec3oA8Ihrr5DPevi9rCk1qok24IYOCiIpVuKYt2cRQxsKZhssBrfP6yhZYjB5GahcicS6Q4iSc6YhV3EOe6gSpWkPBYXnGwoNS52crZb04ZwYOg71eAUKwIbSlV4XLyTcfSKMeia1R9CM6vwmHFhFnQ/8+UBcGhSqQAKBuH9Mb6WRvW1JKTEM9AnQoKPdkUJaBSEAddxsojFkYVTYt/7s75y7A4B7XHWBvPTnHmuXL4pQ3oJJiLLZzDLPzXsSqriifN9AYkTsX8/TLP6g6wDbRRJgr2SG7toAwJR5pePkMRePIfsMIay1F0ULxHsHN9q2aprQIFzDr4O9uKu0QgVe0JjYIXHXKnuNGuCQ7IvufGcPvKb2HWyrg0S3W9xX3OzdaIMo0ryiMZRgkY5RjAUK/5Ff45DYrZhjyB3BwljsB7610FVwQcHYbWp5AICJWgiAIY5ejtJZeDCvD2eOoWs//nN/Ic/65Y+uUODnfeoV8iPf+XA5Opqlish2u/YieEyTKJXUg2FXUrsNHtAxo7/qboFXuBfEzGW0AQPTc0LoimKOc0AFI7k24Aya6rT0wzB/5tK5DJRhKhojb59it0EDvaD/Wr8TgoneeJxbITPEuZ8fMUE7FmrhYtjpP9LBrRHnLMS3LAo7C9XQDFk5yDbhrq7EzrxL3CFRP8N9Oy+OgSb8w9tcaBTwVophp7jFUnKItWkxSNhDIFkolSYCuKyrrOs+Zw33wE/9tzfK//XsN9ymi6/n/dij5OH3v1OnkG0cRQmymSc5OtrINCVDXaXktm9tM8jq5dEGKqX0Yl84UCxWWrUx8OJeukJwjHPcW2iYfXMfOn0YEW9IcZ4ziXDyPcL33/g6XLvDof9oSLObS3Sib7XWg/k8Rh/zeZwXEWnohkqaIGPRU0iHIJmoa/Hid4hz3pKXIV9lEjLtBsoDwgz5nG1o1wNxzvmcxRlzqZ0aPxyIaumfjXQ82WI5f4xzNJCIc3yWDRnSnqOyjDonD4cCI58WQ6Mcyuc4B2fL547iCl1zzfk8UuNp+T6SrzwtOG4pn+OuWtf918gc2nognzNCgOu4Mc5xrxvNsnhzbvGn+W/NnvOgE1GqdHHublFVm1a1A92tEmPsHBxY44rvbSweEefj5p4HzKjdGHlica5UPLalrHSuGGWBxfOt5XMMrau4QwYQimfL55xfLY5j7L3cxUVnkRvXdZVlWaTkfDDOf/7X3ypP/9E/O6cHAI++z1XyGQ+9Z2fd3DTNRCS0zT30sqKKA3JMdj2MjIhLIftuP/MQBS+K+KnBm2nWp4HOWK5Fusuy+mDN3Gi8D95DBjDt0bRhSrWNealNH4BtRYFWCLi8pK8NIWDazrzXuK0fSTYoahD/KKLv3QWZXRwwDDL9bUgihggQpRFY/2foBkZ0BSl6liNpqODpuLCtayNwbDztXEYAfPtXXidf8qR7dYkiJW+ql9x8vbFNSdNk0F8xeEfsOLbgqAdqvGspnZADXyrjhQ8IlYRgPqLw5mbxLnxdAB+rSOfviMJqM0dLrrio8NomU+8V53sadI882LXowoaIBwDGFQyegABxZAEYhuGhWCxW+EedRrtfcfMp9s0s4Gjc8LaLtbpiPDUDo7BNCMQvyy5Sxkm8DJ7qeD+1uqASXxQGt6bpNwc71JBhA+ibShez4zMDTvyRbkQgGtU+fyBOQmfvU2kLjvf53f/5T+UZv/jGf9LYecC9L5IvfdI18rmfenXbIOlzON6uph6N4rNtU7CJyjJNSWKoxj+cp2DbIHDYUYCB++VUkWBcLMBNM6Fd+Be2BNuldA0hizkG2igxvI+LbfNnFQhbsdJz6GIqmyd26LYQblfWF9GAM2PoVarbZnKce2HaX8D4eaATIA74a6BwDCTSTPaU4MsiQaOgct59lVLC3nTb4zzb0A9nmuMcQlPtPnG+v8d5ss0g4pw5maBN4b9ZA6CSAA8sb9qjbwUaRCWt8F2znDneyrJm3bz1jgOI809+4m/J37/v+DaZsx543UXy4md/SsdPje7ZJaUEiTHJeSc3Ms2TWsM6DDkXRzJBsd8tsIo3/hLM5q/UQjBZIESQm7xx4IIhG7wZ3OAW54sK1iLOWXG5kshkIKEixD648ftxHro456EOYOSg14AeZLkX8OPqdArku5GjzjQVwPKxHQeqYhz6sR3UmpvWx9EmnTWfY/PabXxLL9AIT/ZCXwQIMj5X5HNAsxHPLi7riI9pQD2A6mOoG6DvxAthVssHDQAIpTascWh6rQ0pUPS9pCmacDC4w0mV4BtaJZojTCJtHq6VsKWvVUzkmB0NVjpnZ4vzSIMbtzHuUSuczxk90MQ2k50riMLm4osBDDIBy9/pz5wndxbienIUzsT75EGX6VPoZ3yk1sKsdWH0gcnveSByhNCPbN3ozlPVlmC1tjhHPuelFztVAUGy5mq2eRznTI3Aa2XNqjHOURceQhq2OM8dMhQDwGCibLKXz83WFzW2xmtWyswY5265K90wxlEFbagqnWZGO7O7ZZW8rhKkWcodyufXPe5FcuY4n/MDgO6cVgyPGkI3piSbadLBc9GhUVa9oLIndg06AC+9oOrPcSg0nIaYJvS8HHndxACDRNML8eEqOZF01n4QBNS8p+KbQpoQvGk3Rw4Jlie9EWfbQh9CBIoBLKeKUn84zqNpLwXrSwR6GzGQCCo39L3YH77ONvommN33DKJuB2FwFTB0sw4uoCVDDtfnrgbAve52ofzGsx8jJ46mDiblk92mih9ikvNObCSlZBwupggwlIqFpaqRR4pv4tQeS0SscMK/8USOi7zKdqkqLBcNhuKescUKAoYeYoveCrZoMPg8WAEt5HkPW5t59kvR/ZODuhmI8hFdvAWwdXhisniTH4BexIg3Q4BdNuqAc/XBp2swe4WYiduE6UrPrHsAKyvq3+mQx36Ta9AuwD2jiypmPdyAGQK+NiXnjU9kEbiD72wcoJ9CVmuUNDMl62VxxWJ4FScViQriNjpbdRqYp2BTcxQahdAhQr6muAR+5w/fJS98ydvk1176kRUKhMDf1/7v97ONuomuKQIgqsUhhkmmBVFdFXia2qbZPI1p2j6THZhDHoM1egwD3uMiaoGA7TK4pkD1jHEO7njORY7mOPApne7TGhN3hJiGwo0t6KIOc9DgVqUHAGY+FmzHO2gfBEMIwKscm5JDcQ5oKqCJTkVymP6aq2pjiNQQZNllmeaoA4GiHM9kEGUUSmh+Eolc4rn5AKWfcBeC7ebiPxcUIB48YEOF+8Wgo13SCAYVZnFDoDtqaJBliJBBXMxsP3EPpiApSNvMrKvsdqukWLURgHK1x/lzX/AW+Z6ffN1tsvB62lfdV77syfegjV0hqHPTWU7T3AYAKVmxwwNmDD9YT6FgmFJ9aCXiwoxFi6h5TjaMZbgv8hqLSMI+yz5vEpFjzrTHea8YzxoygN6DgtKcdar524sOAFgcrMvnNPA6sUkGLeY4Z7pPNXFY/36MKAGqAXfF0Ry7e4IROiiQtzs8ww8vn2fYzFI+Z5oF53ODtBMX/1A+x3kZKU+uUi2a5/fPINuwcaPJdQRrGSAfrKtT+MDDFtruuhVfsAaQn0+ifGtDAMrnyMcibm08saq/uNXkMuRvcLXHfM7nYhpg50ebaArzoF0AqYb/ZqHHnZ2VQLpCwSiHIj1Cq4Hy9weq7pjjTTGfz0oCuV2ckyAsI3aslq3V4MVzcsHiGIJMqp+0o3wuxHGGA0L/OoZ8XvqBytny+aouFzhH0KnwAcDZ47zP56mrD0ycUpEFZjta1H0C+YyQs6BlIt6ONsmeIeoyoaZSapGbjxv8X2qWNWdSbUecBvmKp71Kfuv3z103gEff5yr5lw+9h52DmGJDNqVoTkABHW712g8+9nEQbxYavlamzOiglZtjIZRjFRfgq8T99yWrN/AdcoOc1xhFjH+Xc+4+UxbzZrQj5r4dakSKF4XiW/dAVB4lEJgGmCjCe07kbmR0Mc6FgUAAPsRoMP1+SApkGM4zRAFZyLbdEdGGN7j8U0q06IzqHtf3YLXWc1cD4Ce/68Hy+E+50nge4LWJFiYNlp/aFGue2gPRj/Jok8wrNxC8qFSG9AZrQnFoMABAsZ+RMKegG3/ajiRwCKsdoTBwwW7poQ9I8o5Tk8h2y7jkxANlxWNsfOw5YaKqEy/wq9e1tK2DbjeiDkHYO3xKUdZSZVLO/rL4ZQCfZhQq8xRkt2iRA6Vk8lusav2EZgR8YNgANvixX+TYYExk48J8PU76bZtB0EZ6kmhalrUQf05IxdOHQSzQhGbPfMqNuuF+z7AWwmtcBwshm9brpqGQwr57gHtBXmuVF/3O38lzXvAm+ZPXn/pHxcudLzkpT/6MK+Xrn3r/DjJYSv8a+ffdwIZshbBBQuKudPm6x3EPNQR/EttJiH81fYA2VUaxvqCAUO48+J7e6LCSsMhu8WIfmhAsUmZc4ykOBfDoG+ztKzZMm9k9xdnes12s7TxuVRTQpq5MVRlWniONqLN3IeFSsy/TOOSNivHqCCqP2IeQZRkEtMDtNS0PHcohEQHCiTgHNLSaNoIjZrLZhjaNhEXRHzMpoiN1Mn+5QUuLSIidTZXpP+hmTwbPeajFl7zKurairOS1wZAXj0XewH3eV71c/udfXn+bylnTFOQvf/szu2IW4pi4A2JMMs8bmZGz7G5HvJaOxsFNllPQegqZhGD8ylr7PSUXU+PvgUBD0e3FWS8Sy3E+0tsSwYQR19iCL9k1IFinhXVsrElS8c2yhyDbj3NsDrvhpLRhE7jDeI2WzzdxGKT7FnpKGPYWY4r+Y/L5uC12i9PaFaKcz0eIPAu98RnAXZYVbWHDd2r+sdGcp2gDgHHrDs4/ax4hzlMKHRrLKIZZh0YkTseDipiCqWgDeQRUGPI5mi3kc6B/Gt1BKzi25NN8jnsNAlhygNZytnzODQE3xNnQSqEbLMMBCuKFgWzxeADAwymgH8ccMG4AWaRxn+Y0xnlvzVeHgZV8CL/n7TzTSlgUzWPZkUUfSpy7nWCfH/KBOK8SDuZzjvOjDZCkinKYYuf+AYHo/XxOAsUbR6nBnWlVl5tmjyty5rhpACzLIqVkEmj1h/Zbr3iXfOV3vuqcHQA85r5XyWc+/F4qrBetSRU4aVTYsQK1K2rH67aKWAIWiAUG6ahEtbYBJGq/FMHj9+Y2Rb/3om7OEecFXzsMbfEabFiYixRxgT/cpVXt/nDwuX5lakAxW7FgwuE2TDMaJhDhfC/7+2h/FUxssz2LqHVc8uGGQPCPRFtDP3gPNEABbRL6L9DiMPtL7Zfaa2t/H0F9qj4s8Z/Z3yvf9nO/e+7ZAD7g2ovkhc94pKSYCPLo3KggVaZpkhCTFlSTQoaCbcVwicE7HA2tiIuJMYTQJkskyGe2d9RUYuOLxhlXOgvCBIOn9FsCEVdCbY1V1cO279fLAjIovGBrhveG7V8TOoQns3LxtJEFhJSTb5sIqu2ENgZuCVVMgKhy0pP++YCvmInLBfgm+P9oEdqzc8g+bH18eOKvYZ6jBLK8MoidcfyrKa7jgmEdg0RNJiuiZ+IBcoGI5+vTexfVwtQcwZmL0MZfOtVzTiJQ/866sUWoobgCpKoU5wT+ym++TX78594gb/4whQI3c5Qv/Myr5N9/w0Nsy4qBBW/RoiXv3Nkp4SzgFkDx6JQmp1xA1JHVpwPB/fkZjgUNbze4OHb+mAy2P9JZOvZcP3E4u8LsHQYZdAvSprUYWjEyw62uxGz38N7AXe/jvNhr5c2XFejBecid3dEUpdCQyBIh+YMD3g07tToUrqxiO+nWdVn2GyX8zF6U0u+MXCoJT7m2ByfzXihT7JnxgBRnhIdg4P/6HRmNEgEInZAwIM4nx5qocu+6rG26X1YpJbfCPwTylW5x/Esv+hv59v/42ttU3vrnn3yZ/MwPflKnj1AINi8SJMRJNptZNvNMcNbQFcsYAC9rJvpV77FdSt+82OaPUGYo3H0zU0lEqQ0nN4SiwR2222UrwLlQYBG6RI43zql3oTvErMe57Mc5cZSBCBk5jKbCjiaOtp+LxjnyOeI80Z1i+XyTzA1mL5/TsIbz3IeTzzOoVGFfbwOxavxv8i4/9L2TDjrXA3HO+RwNMQp43jzbgAHDfr0nWU8IgrwheN4spXbFKwZ1yCN4H2tu27FJaQudi0GQLg8FPY+e/4gyAMcZ0js4mM9zL2RZfOnXaWHIkM+hsj/mc3vv1Bz3uhLSCW4yLJ65ydakqAtGTO465Fo7fm+ZFeLqce4ojNDVuV2ck92hDOKYbBHJSw5DnoQeLWcinRQ/vLUF/QGaUKxlxZte0Ez75Uw4GOcMk86EBOu1vaKdcQyqDaWoVNt1jHPpRaMR59BcYI4/qLHbXZZ1WWRdl0Y3Gxo0PIsHf/ZL5AOnt+fkAODR97lSPu+T7iMxqRgyfYZoFotB+9UeuBQT6i46GOCBsA3uBq0A6fRR6p5mit0pWFbSUCxGpUmKn32hQX+kyAAAIABJREFUnowt7izPmHZAJVHCagtNHsH2qJui1BExalOpfSfMNahRToQdCmgoqvlVH67b/8Vk7gaRBOd5CefwftcDCCGaRoGQmDI/c4gMei8X9oaJVRGEp07dIP/n//MapeScQwOAn3r6g+Tx/+yqTqQEjbErmya1/kty4mgi8RAhbocr2AOOCzh0sUvCG1Tfqnvxz5NcVzvd90fGthwJD57wQaqsyklj+7zjXftZRzMggVnmObkfrTa3xqPT5BKpqIRSP6BRgPFgg9gu3tLZBpVCPqv65zu9UGOIrUEkP1VsCJimgMsXPEMUstudIwlK5Wl/JbpA1CDG1K5akY9NESD8kWz9RkusrM0UtAh2S+7g+BDBYgVc9rlmkaBMnLvAmgBzsOfYNS9kicLqy7ABnPSSKTJweQbOYqWtBNSvf/xn/1J++pf+6kMSCnzC466UH/vuh4mEJGtu2gSAz202UVWCdTurz2G7y6RCz5su+BWruCTUiovaOYX+OVUSQKz6c1JkqHMvlsUFC4pOFHsmmETnDL0Ac8nA/0Rzw0OXKcFmsNgGYTMlKdK2yGhQd6oI7HEepSgMDd9zu+xDgfF3QAccbZIVtqDMLGtLZuDsG/pBNxPwveeiVkRkir1qPttbwQWgg55SgkUxWQk5ECN80KXjhSOmMKBrQwpAH0cRL9dRmFI0qFog2Cli0xqRovoL4neDo2CargCGh0CzoUCdVCl+t1ul1txcJ9ZVtxJi9IuFYMif829eLq/5sw/cZvLWd33t/eTLn3SP7s9wDyaFmqU0y4kTGxWr7a044ZWMO2G3+Flq/sjtc9pAV6NU2egdtUXTnnoKVFT4crQWXoyDi41cLtAAcA5yNapBPwBYltKJwqIQK7XXdPE4D2ZFOObzbDzzHnLab/x79AdThbp8jqaKdCkYiYPzyIXhqF7OKJ4xn5fqvu5Ldroe8vluwUBx37li5U1zcGoimt+GTPA4R6UIyhzrL/CgoA0gW5aBWLtT05xmg+YS4pDzlOy+53xuca7/355vigPCi+4A/awKCXPhdVqcUz5v7gfBhkU2YC6uf4LPPlL+xgCA4eqsB1S5Ga8+HImUz3EHI58zUkIOfB+nHTgCMRzEe2hjPHitp6n5g/vf9wLGeO0LxTnHBYQZoRfBVBQ8h91aDZEKV4NAFLTtLsvRJrmmU97XGhhpG37P9payh/I5UCRca5k14SAg2Chp3rRNPACJfZyZ6r9UOgvRegAMojD4rERdHBEXS+6Fg4EwW5ZFbj6zkyruWsAU2Kd+6yvPWRrAQ66+VL7oUx4k0zR5EwE+uTX//pmYjlgTK+uEEwMJ11WpHUJFBnoSVuaOvBFbQgRHsPeaRQNdxQeIvhTh5V0paqUn1QZvuHswTA2ElEOPVOmbYekyUj7xC0NnQ4xDI0Ch/HhPXf4mFxyGMZlYa/Dnh/eE3s3B01WSDgIMlVJ7zn+lIUqDXAWzVIR2xgdOXS+nPnhG/sv/eN25NQD43H9+V/nR736oxBCJGyx22U1Jmtr/PEupQWKaOj9qXB7wbU0BkF+H+9lGnJLpjvhRDZpcfGpVZeAk+oHnSRh4fSmwCIQ3DZvJJzrgm22mQE2EH340hCKD8rIG0G7JthH0Qqf3A+emvagFIrzYeQOwrNn4W0sW49Ln0icQiA8eKUczMNwtiCxL7SCabAMH5wIvaBWyH4Mcb5WqoclftGBAws8Foi/9BhNNfJX9gmG30lSduEzB/JAzFYVig5EGN/SNAYYXrLI7JfCuW0BP6iTQqBTREAMBInR8TkhZuOP3FecwSgjy9B/5E3nGL77pYIzc/9qL5MuedI084fHXWLKDuA/EEp0vr5uIYQCQVDm6EpdxLUW5mtGnvzjvuiXHM/INnYsa8WacLe3YNxic8bG4Mzsv43u6kNxOxZo2pEURYzRuZq21s92ryl00SGMtxnuDmGGM0SgIMviI73Ya53Psign8925pMYAYAUdut7SffTQni3NcvkAUuXhhP2ABtDGmoHeW6yck9dOWgeccmN/fiQO6BzPuIOh3bHTIuLNBj9gADXfXokiio83kCt0h2nPablU5fHZl+6CTu1xcoDCGXjm7DT1Ft85K/UGcJt9IrHmVkotk3dAAtmcq2CrU9csv/hv5ph/409sM/P9tL/ucPR52D+Vt8P+jo1kmpaz5+XI3mhSbINuyy8bp9yLNLRzb2ZE+zvWe2i7ZOdQE7cfdCasuH/j42WAoOO4ndheohFzpYdhiYrEjZ7yUFsewyMRwcpo8ry3qU75RdMiyNhgKvOB52NrOaLVGox7wQOd8HmQfGj1qDLCYaNFB4j8kn2eyMAyHctWYz+nPAq2+wtA0gu9uFqzJ+el4beD1w6KzDZF8/LPbZcvB/LVhn5Aou0URF1MkHrU3uCZE3DWQ7d9JUB0lhbR6A68DVy6aaShv7gS73ChI1Oi2Jk5suMkCdTn7AJMpa5zP0RweyucjqqOQTR5+jtl109PKdObwpirZRobKT7SKG5KJ6QcA0s5WZEXjEw4sG9Mr8nwuamXJQ7UqWAr5AmcmCogo7e1QnHM+Z2cCzz1knwYhUCENmOTPDXFeS7VhJPL5oqLWR6ppZXpOWKwV6ZYqiHNDhxi1s2k0if435/NuwbX0mkG55IbSWBbZ7rZaE+3nzJe84l3ypd/2ynNyAPCgu10ij7nvlXK3O18qkw2bpVsgQKiT80uze8xOwQ09jZa5/EJOHQ6ZJyoZU3AHfjruNtZLYku/FCNRenzDH7o/L+o4UExDADFVSanVHcKCvU8fDARbCLFGly3uCHWaVfTU0AClSg3etzW7PtrmkzYBP/sQPEY7zv5I5akiUcU+7WtBe9B/17SjyD1Aqtx4ww3y3hvOyKve/C55zVvec4vn5DY3AHj29z1UHvuIK/ZgqbCtikFaATXNjQMRoxxtJi04Sgc3ZFgXK79X8ckSoHO7pU2+khULtbOUaaqxWacvDrNkmEmhi4p9i1GcYKrUWSQxf13hnjn33uE8la4G7YNPbrTCrth0uy/uMvlLA9ACrineI4SXsD0AXLFd5rFr9MD9YgjnNAUT24HKd0MpuPL08Xbt7KLQ/DCXvtb9Z4vNiyhPDdZGea+IdegZ+Hzg3OOzwPTTOIWaLLC14MKg+ZQ7rxXQ2UAcgk552l4zccXNi9153axie4gHCI2HV7z6PfKCl7xVfv2lbxcRFfj7tCvka55y/0FJ3jdMzLfCZcQ0iJX8mJmLislqHnQL2hltwwkoRuOCYq2BUeW0nxq7vRZEx6TTJHC7I6gVR3aAUL9fFC5Qa+7inKyjUMRBj4CHEctalMsV3YtVP08UoMyV5bOIzwwQ7xk0IW1kWvJyyyVQg7hZR9GfUjCY4q3F+TQMAGrFz4xdkwaoJdMvxjMG4SWoR8N+blngKhJMYd3iXG22gjQNkWWglUDMK5CeR0rYAGE4lXQ41RfMuXg84B4suUgIRfIKrmY+a5w/9Vv+SH73j97zMc9bj3vU5fKM7/lEW2+wfoMJZE6TzPMs8zwrSspFOkHZglI/mrk6KixLj5zBz4ux8QKlIo5LdzcJQXTNTi4OdnIKBx7jHA29EHXGuIewlRzugRSbSK8VhNho6704TbENsVPsBt2l9kMqzuf496UOTi5UcCJ+gAhjv3K24IWV6aE4P5TPgdKbTIW+aD73BVsvguVw7DGf8wb1bHEOnmleq6LK+oF+JtvbbiMn1eK8ihgqD8r+u8Wb9lxdnA8UAzQDR3M0lXzQ1kppjiXIa9vtKvOUCDbr+bzSmehzo1u/iYjVW5VQcOEs+RxoEnPAIOpdzreez1NyZAfn80OFcBjO+ohEYcSKDCi/Omq31N4OGOcMEPc8OMN4nLuTSmSHHBqs57L/8+FWkVd3mxqffbMf5LzdCxweinO32XMrt2mOkvm+4IEn9Bsy0CLJRBkbUs7zuTs6iTVzQnXqRofqhnLQOhAIAM/3pDhf3PKwdMiOhjBblkVyzrLbLZKSDxqZnvGoJ/+2/N27bj7nBgDXXHZ7efwD7yYxJbn6rpfJNCUT/O43+1hmFRsAwBWNrfNq5yZGon5UcxVF9IYa9prKQMM64cGAiZoO+h38s7hWDGJDtdxEuQzeL0MD3b6vuz5h++59vduN8yC+We/1sH9QJUKI9meRaA32cyWY/hQQCKU6wpQtM2MMtLCNNIQQxjB0tAlbvEZ/T0FdFqqInD51vXzgpjMiVeTZv/f6W+T/3+YGAF/w6VfK937jAzSpkLgLXSpTSnLiRIP+iySFjqeOdxfI2xgP1TloLizSH5i6xz0EtBEbDzRvPkkSn1wW6bhJ3izuF+OjHcSoElvIOoyhkP71DHLpuYQOYWIrIRKh0vFmLZV47AoHTiSEE3uuKCuCoxnDNB3JrfdndbYZXzS1VhKuKubjzImMoZsTweAqKVfjdTgvzT9LFHeWZIU0BejyQ+Hp/soO14EQEr8WTOMnm5iHzjqE+aVebFblYUl37ipxCo0LLa5WjecaY5CXvfLd8vo3fkD+7VPua6J8KIxbsVOsYWM1X2yaedPEdoyBNxqqEp+zC1GGA7DFSuIJiKdSihUTG3LgQPHovNceZsuXGttw2udjgwsdoClqgeNchN9jsDhnOy2nd4yWLL4pAD8W259DXOS2dQG9pD9b9n6CFy19Ygk9hDKGQW092PeRocjEMz/UwE2dYGhfeLLas/Fbgw8f2JaT7yoMMKr0KuYcWzzAYr7fOBxCnLdnxf7e9FmLyLxJUhSNVGuVkrOEUGS7XcwWkL24UTC+9A/eLV/2HR97sabn/tAnyWM/+fKOL8zblmlKsjnaSAzNrra5zPg9xj7XPIwLulVNyTVp5jlKLf0AIIT+TC3Kt2i2be5pHohikyJtysjS086sqguLcUaLDXltIJO9oSo6KHKrTR4whk7ZuYPnz67WXojjzgrUKJRASzhbnHPOH+N3hIufNc5T6EQHP5R83m14hqIKX3e2fB4HscFxIBuj27jWIc5pSUVIIM+TbCW5F+cpSGZBVsoPMRx+PlhUCNF72FrSxdrkrPkcukP+Z8F54oE9rUM3FJYDg3jO52xJyPkcHuV8Z6Fe4kFnb7/nm2lDfNqw2lW9mads96BaNjaUSCTBy+obdem1BcBXN9cnRVew5WGQfSen8d62Ybq4yCPsJQ9SF2p/T5lGAeXz9nfBBmy5FLN25HPM9tqHfMldDyHYAA1CdL1Ys+ZOtdrG6xLhQZsP5P2MhS7Oma44Ii7bM8qy261y85mtlJKtRmDnjR945uvlWc978zmJAnjUve8iD/hfLpGUklxzxWXmOc/bfx8K1G4AkEuxBp+56kwBiSRq559NcZeSYWDA4p+9Gw2+t7qEBbf/wzKLb1T8HKHhYiUq2sj/x7AKZy3FqDoCKibfofVCN9CI1Iw7AqYJHQPhiM2/uxiwS4BrTvFZ7PU0nFpQpUpSsUQXXwwd4lrUEcCcmPSsnjp1vbz/g2dEROT5r3yTvOf6Wx9c3WYGAJdfckJ+6zmPlAsvOM8SJXMrXJhtkqPNLPPceP+rbpcMOpJiNxUOoRWfW1UYtiZPYWNWEFMCAprFC+GWIHcK54U1HSuJywCpqsSrRWNd1UOeRXXm2bna+H0lGBVzFe2CFfdxHnk6XqhLL7IlVf3d++Cp4I+qhRR8gzFl3u6KCSUiOaAInWI0riX4WIBmg4ffNv69RyWaVvYkdus9iP61D38Czzl7851iP2H0ptabSqYAOPexqaHmzGrHOgDIzhHk4RGecxMT0uGHKtCuJdjnAhg1FJWdq36g+ZTeqgkbDthGxdiU5yWI8e9hcekIDlE7QrWhgq0UPQ/YOXGSXpZM29kBPqpcVHCDx23y+Mv47DEqZDN0cELZ26gUErRUwUeygKzEHwV33WGt1SGeGufN9aIJETVLySjbpdK2pT2xJqZGVlfqUuACZMRbVaEowLoBM4whmMXQmkHZgN5EMZQMNkwnNqlDoqCYM0vE2Qst8Jp3xIcXGeKcEBUQRvKiqqpDhQ+2YhjFesTFEadoQ6IpOp8axXaaYCmVdQMaZc3qhztF0zUAZxhDo2kKdl+295wozoN6iY9iXrUTdFzWbMV7LVmWdZWcV/VvLh0PHIilr/+eP5YXv+ydH7PcdedLT8irXvj4zr/eN76NqXhis5FpnqRKavQJCDqupeOHW96rrFXiW2YgP4K41V+CoCsJyXLzauJWtZrA46gBcLY4h7AcbGaXtdhGOhhks3Qq2rzlSzFYjiu1R9Vh0MriYIhzFEfmFCO9uviOBPIgqptLsbPEG+RCQoNYKEAhnxsTUxI/lM/Fn32KLloHGkCDGbt+wYeSzye2MdVnHHyV1J0P068p3nRC36jjoUP3hcQR8e+bxoZrlnT5XN/XsiLOg91dns+q6byYX7W+jmXJpkVwtjhnikqzAFVKIOVztpWDlRziHLbAuMsgJFp0MAJaymq6IZG0mrzpR042bYA5mmsRWzXu6GfW2ls5ysDzzZrDmFppg/YgdNZitwntNYl6ET5oSIA+wRQHq/c0n0+kSyQ6UFxLy9GbTZKoQ+4O2Rd6tvKirlgpRs1F7AZUrUnh4QHzvJlS6c02BkO+pW+1nOtB4PWayOyKr2+5BvVASsGGYvi91+2huw+QzzeKZBnjXKS5XTUdgK29RqvbNR5e+dr3yRO/5vfPyQHAxReelC985L0M8XjVnS+VeZo64Ty0gFiwVc0TjgqQjppieWIYsLh4ojt5QPyu9SORttmKVuZtfNh3U4nBqdyupeVLWffRq9bou3h/qwuxODGdGnOHqsRYINX9PSSPCxiqWTPVzE4bqUx/leCCgrqIjeR2EYgWIeqM5nMLpisEG7j2yFuyZdR77frTN8j7P3hGQhB53v/7RnnPDWc+pDNymxkAfNFn3U2e/g0P6ET2YBtkF26IIhLl5ImNxJSkSjTucxoUJ1GotyQtJqA0TU2krZSimgIulFRKm76A05SSC/aYb6xgy9kaZxT3Xig1qxFOUpMOAApZIu0G71QvfgLZETqUq9ntJZtMlYzCud/OslUPW3TxRCxI7SenNH3dKacMInHb3SrznLQRL/Qco0wKI4Qa7tjAbHVTuhkSKOwGlyWrmJr7104kStYKlxZ0gCGbUCBNw6pBuz0JuUCUX+qJvHa5IIOgVoN0FwFKqinItqgD79bF6CBCpfQIIa9b6cVxuBgDpJFRJij0mnhfMjisDUSq2z7C0aLoBg90BlaaxrPcTKGDRxo3Wb9vm7DXvYmkcwRr590qwsr9Tv9IU5RVG0g4L/TUCPd4dt5iG4zJEOeASDK9AwOAzZz8vFPFCMXiE0fJVILRuIIPzdScWoNy0huEFc+R4xwInFKqbJfGeZ/I49lEDEXkeNvOsUFMYYmETYr0YmIshrZb/XM1v+rJIZ7gWyaaKlepDRocfeCCOO9sqobhD/v7bhfnbVYM66YoKfhk3u8v3sBFOVZYMe5pL85b7KFRmFITOlzXIieOpsb31CEhC0aFoEMH5b6uud1BJa+y5izrusq6LJ1o4Bjn1z3uN+R4mz8mueuLn3C1PO2r7+fNKA3VsL2ap0mH1lFiTIQ+8gYPvEu2/co5G/osE5Q1Rm9QN9pgN0VrHU4q7BYij/j8mLrEuWhEAERyFMiGHIl29kOM1AhVbeDbLcLnAoMhqXCWqB0Kr8V5sp+zGF9Y9viRGHpt5kjDymgibeBDA7KPO/J4l5tukNYBTfCwF+6rFfkqdJzpoK4DudQhn0OYtD03aI8cyucpho5aZ5730BjR9wLLPM7necjzK+WQsYETQmiN+RyFKufz/pm39+VUJJHt4gJzIkGOVWhyQ8PMlILdD6vWYrB6g1ZHt5gYtvS4F2voW2oWaBw1foq9L9eBYWcS1tSxRkDcLz6I62i48GA1YcOJ6k8XkfYYcmcK6fJ5IEE0IFTMgjGDesauTyowKEL53D8DnBejM0494gz/zQ4C4O4zSgXweVBseNDXiwb2PzOadSk2qprTCgYSrrfkucQFm1n1vKdrupipD00NjmjWr0dzkDWLDoqiaYdsMYgLbTtatQ7ZKvVsTq0urUpNa+4ejqhFnMdQZV0XOXNmJ7UWe/67BQuudl6+4GtfIa987fvOySHAQ66+VB5x7Z01ppPc/a6XqWV67SwhXPW/WrM80oRvPN7JqQ8ei4jI6ZuO5YPHO3nH+2+U3ZrlyotvL5dfdL5MKcg1l9+hIQtqsaVFMJ586LQErAGtLqEZO1pZNacBCPeJ0p+xxPWGv5BlZ+n0qKBfUk3XAMuknqcPlKR0SC9C+ejyyHqQ6MLlCQWtjj2iomPxqEutEsWdW0yAkYbbKUajzWYVQnRKgSPPeWBy6vQH5fTNH37zf5sZAFx+yQl5+S88Ruajk8Q/RyPWLqAQowSJEmKSaWoeyigQnNNWRCounmoXJwqbaiKAvvlG4co2Wa3IahfgSmI3Zp2kyvPbbbYpEJJpio2vtKzVxP2m5DBmEaENRe34S9b0kt3YHo+GP7BaO6EyJJZEkEEeiLjwoYvbLGuxbWYp+5sja/KiyFpcTwEiQ0AAtITahgtt89yKDWzE0VDg92uuHUKg8a6iicVtd9mEjhhWZokOzTU2QqtbHrq/qZiNUXu2YU95ljmqo/czrKKw7cxK2k4GOw0dlKoJ/4QmqKebT4Zj+9TUa3EURNtd86PdbJJBfTvoenUNhFFlH9tZVuHGYCrT98IWPsZo78EKSoJkzVO0iybn0tFNDm3MGMJZh/PHkPWjuXEed4tD0XFugSJhK6tR9R5DJ7OZSaEblgAthHMzT1FydReAeQp2DpAUWhMUTKkYcQ57qHZua8fh5DhnW6INibPxdJi33IfifM8r+oDv/WRCXO2OG9Ewo9WibQ2DK5FDCLSUYG4fLBIXo0gCF7jSMCgEQqgEa8Lb5qzFKlwWxk3qmslZIkLEzyHHO93CjXGO4et2u5N1XVXBt8gxDV0ZHvstP/Sn8sL//ncfk/z1Sz/ySPmEB17s+g21dpZ8MTWr2nmapNSoatXRXB4qWboaVSv6CbA4X6tuuaOJLuKcZf1eTD1iG0COcwyRma5TilPaiv1b6ONkozaxl71vkVtOWTXHYSt+vCt2F2CgBesnxPl4/nFHI2dAWBACkFy0AEGwmfY3ti0v+b0F1AiQZH2cozkuHf0t0/dfsg/ZJqLCsSgtO2f8Q/I5xzniwDR2kot83mqc31o+14HiStS6kdI3a+MEBIf5swfPKzbom9rgE7SSxvtm5fWzx/mhQRhQEpWcXzK5FbAmAO6vTM4wH0o+Nz0mYaqZowNMaFFRCCvd64AFY1zmce+5HQgIfA6uI8MIDzmoss/c/I6yqNQtPksc520DOtBCxHWvpDqNgYdMbhmcKZ/73zNCi7UzINaJxU9HZ6wuYr2aIGe0z4NztOXIRMJ+RKGzryV0jTX6hWiV4u4Bns9xFoPGectX0GVa11WOtzsJ0gZly1oUCRFMU+lZz3uzfN9Pve6cHADEEOT8E7OkGOT8o1mCiJw42lDPS2b3XTPu9+yai9xwZiuntfm/tV93uvCkPODul8njH3xNt5SNxFs3NKPUbtBrkP3o9Y7x6Rl3Y+4hxekmNMgwVLS6cTGqqhJFoJZeY8fPvNsUs76E3yV6L9Uqc4qGzA4hqJWiLke9bTcLRjE9sNJECwOGBhS1IRo1OxJal++JGILccP0H5dSZ1vD/6qvfIu/4wIdnI36bGAB82ROvlu/+ugfIdin9i6oOB57nJCFMEmKDjB1t5i5BApqxxwkKLuyVCdrNXJIGcS1uDxaDwbGa8n3VDa5DaAHbYw9n2MZACKdNORXKRAktGgzKVY19S6/wOrWUQ2NpDZK42B+2hVYs5GIihX0x7bwyRgGAV2pFGNk5cYLkv+v8wknUENwwwH0KOROAF42vQ0GEAoI/OxQiaAI3k4uDrWrbiM8LIk2V4JpQv9+SdzuoHCg8YZ02088SERKA7GHuzM3Dz0SJsapAZFNZbiqkIbhndkr+PHgzi/c7T9gyq8ClDQB8oxQD8/pRgDtEvg7w2rEQ6jzcCebHhRWKi92S9WcGg34BotXZVwlZDKZeoIqLWBYqwpYAyvhBZeUD8a3gMY3tivP+iRtb/ZLuzhV4yMRVZXGYKaXenzxIF49oVBEnM21VAEVmZA+Kz+YK4F7iaFCbcKijM8Y4b3Zj7ubBCJP9OHeV6ELiZeNwDAMI1gJAQcvNVqFGkv1zR00NVtouCrPtrKA0trlpwv3RmrjQK1HrQYaN4qKUDIvz4F7AoVYTAQySZVmz2XtuJm8scM885gtfKn/7zo+uYNPlF5+QP3rBpxnEddQpKLWq8F+SKU2Sa3S0RBVZsucFszgyTRXSTBFXIt7j87LGg9rBrQSXbx7PYk4bay7mZMH3BM4lrBfPHueAiSeDj5bSDwBbnBd3NSBeOWK1NY2VNqrY1FQTehUJe+J9MQUpuXb5vNjXSkcBwHvizTSGZ7n0HO9V3Uc4zpHPeWvZrADFaGdJbQdxR+3nc7KxDUG9010lviiih+Mcmy6rEYLbUaUkhojrdRbEdFBYcwT3wKGzebY4h+hupY1xKcUG7K6lIDZMWbVgNftBRfoAxl67fN5DgHF+JyB7lGbU5XPiupuGRXCb4Nl0NRw9GIZGec19PmcqYCW7YS6yzRpPxV4PxblRqpK7QgRDl7g7zT69TjrdhjGfy0A2AFrAtWs85kWHapPSCEup5gJhzY8ODmMInfMC3F2SIkHEhklOY2mvy5dAk1IJsXxBPsCzQ5wDodjrRVQTQSylF0Ye8zm0TmBxhsVLX7eL5ZVorlNwUiiE7AlWx7f7YJUzxzuppdFg11LUljHaYunP/+q0fPZXvEw+Hn+dmCf53E++Tk7Oc4Orl0Kc92B+9Ly0Es1D73jfB+Qv/u798vazNJ13ucP58pRH30cuOP+kzPMz0xi/AAAgAElEQVTc+9YTWoZkpUwPojvzGiOJhDBNT6v2gtKoI0vZV+AX5djjjOKeDXsR1tAu0AsAT5+dR9zhgGnYugSpvRMJ54HmZBBM1LYtCBTxV50O69olgZxrervFG66/SU6fOSO1ivzaq98s7zh104f9+X/MBwCPePDF8pwffKicf95JtfvaV/iOKchmhup/khNHk0wpudiSTlBWhYF7I+B2JKWKrArlBXxZhC6hDF9c9wDHlqJ5rAedOvtW0yejlSCCSaZUdfMqcrRB4VG6LSjgvZNuIHFcASdZydZmt/QXM+BoUZEOKbqPLVTOuagjZ6G9AgV0Ahy0zB7txMmGUF+zpHABulKDlNwgU21D0w64URQSGu5iNmQxiGT1RIcmAjQacPEahA586FosaaboAxSI5u12qjyuKJwtbS8qKTibb/0u22fMxSOS6ri5YXGZFJ0LhI1m8grMGuZR/C1QQeXaCW2whI03CoTdUk0RO4ZWQEX9/NYs7q/NQ4rgBQILh3GSd2qB2yNyIYmC0wUFezFNFnzLuU3ta20FLAtSht4mvOP7ti0TBBMjCfUJNYWE7CnNMg/vz+J80mJa/LlBWA2vAc8ZXFMgANC0WmOqz2kzuW8wBi8JlJjqcd3QCFUbg6qFh9uTHakGQNYiCn7tHTxc34tvw4uhbQIVtngv7CSBLTtPrd2OqxqyhD8HbIgB8QyqMVFRwJI44pp9e2ucSt3YAQaO+A+0uVvXbIrmrTEQsw4NocUpxC4btaf9/Cn6Vg3cwRjanbrbLZJis20CPWOehOzB2u9zLnKPx77IhjAfjV9f95Rr5d899bo9qyQUE6UGmedZNpu5iTCJW1bF0KzxskJcewEqhhyrDg7RRUZOvFvNOYzW0WntmZq1cyXe7twGbIeG4+yRjK0zrMRi6IVXXfHYBw0YAMD5xUTWUtuSsKiqwZ/1PUHMFFtUpz+4IC/uXt62Q0MFA2TkPxssK1T9xCZaDEBkLhGnvuVzbCmD/d7zeXumfo7b+QOFq/NVP4utryHJ0JRojhk91jnOuQAOlMdjZP0FbfpTkEVh+9BVKIQ8xPAfWyY4FgAW3ygXyFHVNtaM3gCyB2iDo5k1bIKhQdpW2+mdXsh6ngWdU3joRLSxjo8/wvOV0ofzWkXMAnpstrvnNSAFFhp21aH5RkOwb87oFAfWjRJq+HdqcTkTogCxywKHlZAIjm5wilxbfAQbGC6EhETTtuiQFGfLESTBBEcZZQLhRsQAhmFolML+vFEqUdN2ZgHsm1FG9EEfgocfhuyhOGeEEdvyjfkczT/yEg8ezfWpBKsPV3qeiw4eogrN7ZYsx9tValklSFZkatnL51/5tFfJS//w3R93A4DH3OcKecjVl8kFRyfkdrc7aTx4PPuo2+2ogwB2PDk+Ppa3v/cD8pt/+tfypnedPsuAIcmD736pPOyayyTGKJfc/gI5Ojo6gIbqnVTYISCQCF8dhpcmWKqihbWWph8mLNYerB7HN4CTgA0CS1GbY9c0CJqrSgmGXGuW3/vq/Ob0k5JUKf59CqEpMD3RZ8lIhRCj65PAzodQuViYYfBw6vQNcvrmhsh4waveLO8+fdM/6PP/mA4AHvHgi+U/fesD5dJLL1CoTu0aEFxumzlJiEmqJJlSlKPN3D10fKoO164GW3VIl1veoNg2X1qdHFVxO6R2kdfOOoUFeZAoMJU2L20bADDv3K3M2GoLk0xcetiOYyPQczDZI9gtDHlT003VQ+jsqHJHX9ANa2yF2JqLTcsdMigGaxEaAMBD1+x1QiBxKRWtCG2gkUJTzB25hijQjNsFyH9tjZPre9QBAeHiZos9Ty9IQCGA6F+QYFw/55FF83jm7WgloSBOyDn3ja15zmtz2GA6sdtM93Y7/UVgQjhaSLNi7SjO0zaDqanuHoD97Yv5OI8Krx//zvyVqTnq/m0YVLIThLmafV8iHjgLh7G6NIo5LvbRQHLz2bbURaHQodtyg/7Qtryxg2dBGIUhetAACCTGWKoYxxXDs5RcxRZDq6g2eNngmf02J0UXk0wELUQMAF5ow7pQpWTRQVckXrd/toW2G5WaGBSuzCNFkYxNeopuX8OiU5W6tVW1AUCVwaASW2HcFVvwXVM397bP1nQU1D6MJ96Z1L8ZxYTvwwgJ3OkjD/VIG6VCyRpT8ZgajQaf37KuDflSshwf7xyGrUNXhtqevv4m+aQv+L2Pih7AXS87Kb//vMcdjPNoPO0k0zzJPM0SYhy0WICsKaZXwdQwPvs9rLO/a5Kq/IM6Mcb5WGg5+q12FnjQM3G00S3HeegcL9rXuFBu1BwIqz+Pc8Rpa24dgm2vkYa07EO/0ACENTvGhhHn1TQ0otMXeJjL9zz+PQ9U+jivnQheE6prf9fHeZ/P0ZitB/I5IzmKekwDRu753BER3DSb1s8Q5zyYDUaP6gXk+LNl/n+v0N0rzOfS11K1NtoaBqsrDz4HjSOxobT4/VFd6wKfrdFSdNjFnxsWG4jzXKo104DNW46G/kkcNGhuIZ/DrpS3fGfL56UwX1k6EdlDBXUY6HMYvMig3dAh+AYLQQgoQp/I8kfevx/6JkpokcIaQIGcFPz1zFMiylAwlyYhJXdYYjPNDTkQ9zLivI56Dl3NQaKVCulnnQugoEp1G0zkfgyCsATu47wXBPc7LBh9oC172vs8c7wTqVlEsiJ+i4k1AlE3z1Gu+V9//eDzPld/ndxM8qWfcl85Ojohd7rw/FYjqc0dVPOjIn6cTy+dk8DNN98sb3/fKXnp//wb+ct3njo7Uu6i8+QJn3BPCVHkoqMTcoc73s6tJ+EQBoRIFdUPCJ0Kv3RNNITCqwmGR7LZbvHsNoYWNx1qstVAbflTmqYENeawSBa12YsQ3RPpbCVRtyUVyQxEsWXHqeaiU0201/J5hMZXtEHjpEkAZ5wHfKdP3yinbz6WICK/8o9o/j+mA4BHPPhi+eFvfqDc6eKNpDR1ELVRzOyC847ahKRG4/5jAyjSHnymSxUK/g3CVAyaZFBLFZ0zES2GNjWcRgdjYwEebA4ZpmVbylJVYb2arRfD7Q55JvO2AErZpfRbWd4eV5rggrfN0PYOUtPeim0uAZ111e9gvuwtOTon04UAHRYHLhcuA+fEYXvQSgx4JbfmpGX+NgV2pUzTDhjsh9j7Ngy8PTwjVs1PAz8GNdXo6YyilC/1wBPAPbTEoLBcq0HL8Z5r7YXVGLIbglMiYoydD7w3wbUTCMyl9vZowcWfMnkrsxJvHCxLuK6INkUN9mxz6WHFLlQWSIywt7rEkIX933NHh/Azhg1cJu2MlKIsSyaIrNsAwQ88hChHc4Ndgd8J+DCGF41m4ZQNFGTm5UxNU0NOBBtosQARbGN422eIChJ7cqhnK4CAPBGFxE0EURwHKGwXxkiIW4rzOmyWIsnj+rav53Ci0IXQFRo5NAa+MYdbAYrgYEMOFGpocMbNICD5MSodRQs0+DoHhb81REOm5sc/GzhU7BbW5ghdHHLMziZsVyTnLLVkybnRANZ1JeTV/obqub/yZvneZ/zFP3kO+86vuY988effs7dlE+cItuFXo61tNrPyXUMnViS0KaxKG6oiXXPN2h4NQdLT3WLobTRHWDFn+pSki/NaeXvRNhHrgThn7rbz0tuQPRe3GsO2L5AHskH+ScyMRVIxfEWT4ttpsfcTE0TbegvKKbVziW21CeWqsB43e7mz3ew5+k6vaPkePxtf33muE2R9tAV0+1tFK8zN3vJQPndh10DWXD21y+2GpdNRAJLIdUo8ziFwy3SgaYrqre3ONvhsGVbviuw+tGiDWX/ujYZUrVFyZJUMWgLSqdMfivNpyDtjPmeEZRg8tzFMB+0L/tj1QD4v1V1kOJ/XA5RH/jecYzNxk8+Wzzt1+tLzike6SZXRDiy4bVjtB32sNeDPJqrWkcc56hk42IAaGQiujOVOzr6BLMNAEHlxHOT65r10to1ucYhz49t4DCPR7OEOAtITDkcQXzOtkKFuj9AjoaEgqDCcz4GmZA0T12KK9jlGdYxYlqYxA1vAkUKD+PtPP/OX8pO/8FcfNwOAR977LvKJ114pdzz/fKsB5omQrCFITKkbVjICFPTLM8dn5O3vPSW/8f+9Vf76vTec9ecdzUk+8R6Xy/2uulhSSnLlJRdJTMlcOlKI1qxX4vBXOjuov+0urlVWcr+pOgjCZ1hLc1cpuZr9X4QNYA2mHVC15+MtPNA8DNlPselKRdKc6mEFLQaCRH3dVaT0Sz7UejFEE10MkekQfW1uC98Q5PT1H5TTyvn/L7/7OqPTnlMDgEc8+GL5oW96oJx3fpA73uE8C7YtWVuhWYmxbVBiaAKAUAy2Sb5emqZ+Gh32yx6J4H5hKg+RmaOjyVR4mS8H2CV4eBA58sIjdL6wIn3jgIYZnD5AaH0T2DhN8xyNE8jqz7aRFrdvGTeD+/7blS51T5zc+G0GxVsES1JYFC7UTkFfuW8QswmjgMjgGM+ethCRK6QIOul7BucPyUSq8/Ow2ZvnpBDKVsylFGWK4s11cPigUPG9rNmt5hQhECN7gwKKWjsu3B78Vdi6w4snTJbHZqZKlUl5boDipTS4MGgTxarJTRNBZLaNbLDBSwyNcyrS/r5KMMgjhiHYOvvE2ze0gN9DXAkqyMYf1rNXzNnA+b57l0P1bed2yd7M1tpoFaSqb/xDi1c/e2jSR4GsrB0dC+S1RN4Gd7k27Q1GJFgjpBaPUQcLKBhEqhxtJiu8TKsiQUEc3yfY4DAThzXT3YLBoCi0Eq9jSs4ptUu7uobGRkUyAak15evOl3o/zsGDjiQSV8lnnpEFk+knFDk6mtqdqhaGsMeC7SaGAOa6IjQgKC7KZY1tENsEgA9syAhzy+iL5kYL0mc1CG1B32G7g8OCNl2ElHGv9iolN/7/sqyyqCMA4oY1AdpG54z89H97m/zoz7/xnyyHPenxV8l//PaHkN1n6IpnaIrEOIuEKCdViKk9W4YrV7P8atuI9hynVLs7QJTHv67Z6AKF7PsythgU50KaKowAAFotYbg9+tgHtzEylW+F+1ZxsbDN7Nx4vB8fSjQKQClu9WZWUyI2dG/uF44Ogt4M7vSIrS0V4v7eqw0Y7U5Rq85McT6RuKwQRaqJp1bbKCLOU2cXJiZweSifj009hECN4y/S8UyhFSPSNlZ4Xq530KM/2O++kiZSHsR4EefI51OKVviiBoA7wqpuSLBqPLRB5jok2mfjtsL8d6OiPigPQAyA9uV0jv69WJzrFi+TEw82uVC7ZypHJItId1HQprA2WlFDR8VO/BK1umFHY2+xiPfqd2z75BxhGvaqaM7n+LesM1Q5ziM5QUxhT1sHegobRVOAs467H5Z1sI4FkpVfj+tSFXOFMqEy6alKyP3LWjuKTfs9EDBtML/B0JfEancrxfkw2AQaBvmR66FoFD0fQHVxrnWQ2dMSwmhjdV21xQsL0bYzCnSDiyRjmAfqQ61FdksbLjf4+NpqRb1z8bX49b990x/IK17z3o+L7f9Xf/qD5Q7nX+BilvrQm5Bn0kH8pIMY0YbZt/DsxHTzzTfLO957Wp7/R2+Uv78V//mHXXOZfOI9L5cYk1x1+Z16cT6OS0IHYCHVtuKjRgdeS2v4K61TTCNKvz/QBUkdLapqDWF54gvWYPeCkDtBrq4LgLefWACQtbMgMhgIJiCObHZEjg8ve5RWoH8a5NTpG+WGM8ciQeRnX/4GueHM7h99Dj7qA4B7X307eebTHyZHmyCXXXbS4TgazLwVjjE2xf9pUoGFqIU3TaI1gRdrxnw63/iGbZO03a2toE/SFV62uUDRT/z3oII64Kh29nKJHQKCCX4FUslFAxT4QOuhgGjQ0dxI69iAz1Myb3dMa4uKyIBDZToACtPlD7CoyEQUt9qBEIsNAMAbVygKF3Ro7HDhrmsxgTFA75GEMUU2MTsULDpJbKrQzoPbKqQTDWNewYusHS9aZOQKO/oC2xsLON2GGb0j+L+PNMTgZJdzkZzFfHYhSAg6AqaAbkXJIih1j3sdKFANPqjwS/Z7ZpuvWnsF3oV8pcGNxqYERaWEIHMSopeIUS9yLnLiyC0E0fSimDKhn13pkqVRRNbaDZUYmjvQmu33DqltV8lONTZgy1XIDk+EecS+leLVuFmudCiLqlsrV79uyIMkFQJ2tZKndbVpc1W7y3V1Tj7UqEfosW2qNZ7MIUSbWDsfWrwFczFwlftADbNzQxuq5sSmxfmSxTydzdaGRF/sziCo2bJkK/RRwOXiUGHTDJmSCrh5IwRPZThrxBBks2lWM41X6/ZuTXQzDLZa/baIFcAB7V7N4jRaUceaFCiEK20BkT53O7d8ClrQCql/V59SyZqzbLeLiBQpedXGp5g+Cgtzvefvb5JnPf+t8tPPf8tHPIc9+D53kOf+4MPkTne6wKDsaGSQW3IucnS0kWmaJcYom82kxX2vlA9oOZ7tmovdnxgKskp501OIhsgBvLvUXrgP/HtAb3HOWAMD7iYpDYiSEPbiHIXROPBgNw2GstuWE2rgtMmU0Dc1TOTjOIcYmOdzR79tVSTOIOa10W+A8lqHjawPGP01Vbqj0cRC6O9QnHM+lx6ZaoKGuGeAlpr0XoAidApOf0C8+Jmp3Z3rIm+uuQAL3pUsIJHPITK4Q5xDNX0tHYWpKnze41y6fG4LDmoCUe8YyovjPO4L647c8e2Ce1mHK1kOxLkQR9zpShL6fC51n8qQs9hAHD7ziDFfvPhrtlhV4V4Jfv5ZJCwMlorpgOgt53PWeTBbSB0QYIAwz9H0PPg5475ddaB/ZJbA2dAtlZYVMbTnivw30SAlm/CedKKsmGgA+YHfV6mGFmVuPoQuoV8zTy6wzSisOiAsJLhWgP8Yd73AYNM4/wnwbaWRJkeMMR0w16JxroOlLKaWnpLXDLAAnxPbSKqFqJ4PaI/s1iq1NJTZblnkeLvKPMc9MTrcnw/8jBfLqRt25/QA4FHX3VUe98B72pDFxenboDdGkc1mkhiTbsyrL7tp6eexVeSmm26Wd5+6QZ7ze6+XG2+lOf0X979SrrvrHWVKk1xx6Z18OFeH5SHOcPQBVkcdEB8O+0IANYMPFWzpgSKkOmq2IQcgrOzvtVD+wb1tg8GgFOcYOhcrEY+tCgRDBaJEB71kuRuhU6IaMEAYifggIcYg73rfaVmWVV755nfLa9/2XlnyR0bn6KM6ALju6tvJs7/34RKjyKWXbGTebKyI4V/Y3gXd/k9pMv5vVQhRIqVPbDsNRhgchoSpN5rcGJ17j8INSYMhfb2qOlmfLaWDYhdK0Cz44AI3vaAD3iugWaYWbhB4nxCX2nP/kvl8ezHD8PFIF22K/RYD7wOFOD71XCrBpB1SZ5tl3agCkrvm2n2dCdSo56Wr4brgmsEka+1sCcUsEKvZ6rmth0PSQvRBgwudiWkisJiQCcNotMJP2gSzYoOjgwsH3nlW2JxU2RPF4++NTTC+D3PuQUuJZCvHNoDYJrAmBS67VdXQ0TzjojMeXOmpF+2stPPlhZn7F0eCva9U9O6WYpBehuWaHVzpNxO8EWNIKYtJRlUtW6GLEQFN9w0Y/o55zRNRMoJCzOFkAWRFiqKWmo6IwYZfCEa8maPxdvE51MLez+39LxgAxF7wDNoVieJcBhhgr1ZeSeyR0UjSidiwjWSKYurh8xTJ8rCP88mGoo7qmefkcR4dfgbxvEVXx3gtLGKF99iaJlVKNl0Gh+viDhBpjSiGk9jGpuSijWtuTflmk5ptkyGnoolqItmGEF0bQkV6XFWaaUQ+9OriHHfmssqaswRptAAMO1gLBHEuIvLOd94kz/zlt8jP/vpff8Ry2B1vv5Ff+/FHyV3uciQnT5w4a5ynlGSek6Q0Ga8SYmrYfKNpKNWbTCBPGuKsmsUq8l0hITXE+TRsrNPUIPFoohp1xc84N/WNKhJuNc7Zcs31PBgxUJXqVTrRUCBtgrh/uPHkWfArtdeMBg0bkUmHr9ud56hSfeMNZJqQZVOE8jjFSqXtdopBkt4fDMU+FOfj37El1FnzeQqEcmpLC9ARQqftETs/Z3xeOCPM3hi1iyxe5zhYaIEOICYgi+fONQ7b6/EwylBn0Qf+QUSmuVFDCtmhsso12oKJ/m05FOfRod+H4hzojkp0v0Iw70Mieu7AEMwf3ByCaq+jMeZzs58Th7VzPp/oXvlQ83mITcMAm2+O886GmLj4iHOuHSDQaXE+9a5FnM8gKmncfVJGR6wK5dVaq+QayD6RPp/oOZCFnDnOTdOCcMrQaMqldqLqHOeNJuRUU9SGTO1E3Y5BfEOIOU3GBq4pWO6K0ZsqXvYYpTSPlAvp6vY1Z6mlqOvMuhfnuEGWtcjPPO+N8v3PfMM5PQD4qk97iNz59heYX70MqBCJQU4eJdlsNi23Q6C3FHNqaWtG2Iu3rfaNN94ov/HHb5ZXvumWBRPP20zyJf/svhKiyO2OTsgd73g7G9I59N835TU4j5+HxlZPol4qYrbcQsMBCJnzIi5EheFrDaGWLG3gLE3wL8bQ6c0ArRVUINFoX1Wkksi3ry44FntL7dAhOIuJLMbAS+Mg737/9bJbF3n5X7xD/uxv3/cRPQcftQHAdVffTp7zfa35v/jijWw2G9uo9wIPbaNx4sRGcgm6UYwyTclE+pKJsNVBidh5wYCxctPRuNjVfg74o4DIt6LIrWywaa+1wZva5rh2ECe+SJjbNnI4Kw0E+LWz9RnDFbFBCLGHBnPz3zXJwRvDUWeA9QPmKSqnpXZbX/eCdz6diItSmegT8fSZn8YFfCD+qCf2SOtjErHD1L/0wVpK7Xh+LI7V8eSpCZPqU2XWMsCGs6ltuoXUnkDjHKUW53ZywcA+2Ca8Vav55ZrPOxV44FSnUeRqmIIH2yaoxVN2eNOsBTor7QKdkmK157yQCrJx0PWLUWAwPLi3Y3QhKBNtU3/edS2y2bQiFv65I78eQzZvKiLxoxxt01t0QoU8WbFs/sUh2pbe0TDeVKMZQXMP7Q3WTrDJLviywZXGMeBixDYGQgxhPRTngVSlx+KA/Ww5HtA4TIqKYWV0+MBHspbi4sMKFx6iVW5m4vA6K+ldtKQNhwYecI5xbjqzZMvFnFNGukTVLxg5vfxaAhX00g1FpItztmvt74z9mMmlNf6lFAlSZLessiyrvV88z0TP9p3vukme/Stvkf/6qx+ZIcDX/Ot7ypc/+Wq54x3O141U9cYzejc3pWToNZFolmW5YJgr3ugRhBeWWgyZbQOhqjDcYjDcqhefC4uJoqRSt/Xi7S0GfzljsBSNLw8BVqbomDBsDIqCawJg4PLzZyrk384wdo5VLpBG+7PR0ssHjK69YYUV3QOVhPGgTZGp2WVqBp43Q/nPls+ZmjRqsxzKexznC6EZMehjXifHlw1kpNex4fwaAsc367PEbgN/a3E+CrT5UP1wPj+k0RFDr5DPcQ5EGDf/lZoLDAByKWeNc6YRpUE0j+M88sCf3KOQP9uwKHRbaM7nMeHvgqGScFdikMTDmZUGTIfyeSHxRUP7qWXloThnKmmwZUgvwspWvOwKgLNVFT0I9xg09dMUJQWhHJ4szk8ctf+GhSrHOQ+PV3qNkQY1+Jns126DtRSNgttbS7JYck+H9cGQc/r5WLRnE7sm3JG20i3hOM5twaNOV26hGmhoj8+qyLqubYmVm84M2whznOdc5Jt/4E/k//7dd5yTzf9mSvJtn/cIiXYHBeOkm76GCidvjjb6HHp7adwLuWRdqOIzrXL6AzfID7/4j+Xm7XKLr+PiC0/Kv3rEvSQEkUtvf4FccP4FnhcI/cy2em0Q5HZ5aP6NO1+L1ccQcrdBcBCjJNt9CuSLcQ940BvNlhCo3pEOi3u4CobNek7JttUsB/x/rG+R2uEpTKgaaLH3nbpRzqyL/N7r3y6v+7v3f8TPwkdlAHCfe9xOfuq7HiYxiFx++VET/SNYmXPTdQIYo8zzrJu9SeY5SQxtK8WNoG+tok3gTYWeEqULhviWLyunqekNOMwe025dYmrRqQMA2mRC7RRFlNTaWc8VbsZV2dIbeYcG4/J1V4I+uSAJA+6PJpwRAknFmyqJzgg26ropZtEjF4PxIME0HM8RcDtsUtB8gY8sBhcVsxwSgg6bIFR1vtYxwaprFUu+sKliwartNquNkFshsvprFYd+dVY5oHwoB3YeOLCH+NaLOhIcEcwaQQ8BmaTFPQ8muBj0otB5PrultPM1+YQVAyzAT2f1lQbaCe/PkjMNAMDXbsOChmZhFWSH4XrRGEkwBVvGlWCQgIjG4LDPbP65+t+Ak5PHvRXTUQen1X1YrZDJ1ZwZXOlflfyXYtoWtgXQwcFOzyDHOcQlCw32vFgMtvFiReAQxeg2KQY52iQrrqRK41gG/1ywSZEQ9uIcQwa8PlM1FtkbusGnec8WUMSsTo8AiScnk0qoHjEqjItnTjTg4WakaCyl1G9ovXiicxqdgoRYhkAga4ow35rjHJ9BGxoFE3gUGSDHBNftgy+S7oGrhR+ReFiIzXvdhoG1KgSv6MCkDQCWJcvxbjEbUpHeQaE1hVne+94z8v3PfIP82u+8/R+Vxz71EZfL93/D/eTSS8/rBsSgQ6SoRVJsm/9pUvhkCQopdfFS3IEYgG+UCtU4vdqYVzE71aB3JNMpTKE4uN6Hb1VrZyuJOyTIEOemsVJlAspr7eM8U0OJfN03XLUTQ6sE7V5IWwduBxh6Ija4sR0H8qCH8QYf5ywTPQs2dFDtLzU4/3mKBqHPtUHgYYu3UtOTtVE4GOe114MxeLPS7Syfkwr+HjdbfKAJFJY1VIQ4gkha6QYQvXXwoXzOQo1eJ5QOFcQoAI7zEbYPZJxRgXSrjaFDg/Vn0xaoZyku8drZFtDiPPT53OJci/IQnV8LxAdTDPhXoYYTNC/cKexsgBTTpD4AACAASURBVJ+L/M1uKnKA2sGDVXY3Ed0S1lLPokNQadvuDf+GBgBOz5EOrdJqzmr3vW8+exHgRDVXpDjfmup+Usg8EGT/P3tvGnRbdpaHPWutvc/57r3dt8fbo9RNCwQSAiEMkgBNSAYkBDhx2eDGDpNJgKTsGBepBGHHlTJWKIdJEMcCAxLBOHFhY5uCBBk0QAwlZEQjCQ2toUep1Wr1PN77nb33Wvmx1vO+z9rnuz1AN6ixu8qWRN/7fefsvd71Ts9QaULj6I4eAUHspWvOJApBfdWJXooi/llQKtVO4txQvA3Fxjowl7WbDx2OitgeUtQQLZ/3cU7q6NTqKtbZ01y6OHc+dzB9G4vzwYelQ3INA7ShbM4Zh7sd5nmxpoyWhVH0llAW/MVveQduvu3hp90A4MJzjuF7vvZLkUJAYo1QRUlM/X8cI4YUMW42nVAlhwXoBE/bEFXunX//+x/Gv3/fLY/5Wa655CS+4UuuQQgRV112yhpjQ2HDYfw8N0HU8XsXLdjwjTE+58Xjh5oSYtOnVEulEPT2e+h6SmogBPi9t+SMCCCkeKS7QRBYf5ChtQ4AYoRRagDg4Ycewf2nD/Gr192Emx9FXPEzegBw2cUH+Jc/9hIAwAUXBJw4cVymhUHUvgOWAqSYMI4DUqqiXcM4mCUUYa6avIPCvAWyrHyvkQ0w+ekNLrzbVYuwMQHTTLGexm9q4mv03Vbo0pA8gRiPNtYGd0ixNk8yxfELyX3teWFuKconDR9hJpqcWfitIUxaGKF4ExJFmJAbgtqQRoOV65Y0CGKAiY6+6rsm9mY/T5o1b5hlezy6V271PK6X+5nd4hsLFlBtyOEbk9A4f7WpIKdz19kZFbOeGVvDpsCaJWfn6w2xa+q5qZrb56LOQy61gUQpXQESELppNjcstUjNHRdu5jRa1OmjeCebDZaoBhNmSN/dIaGJ12WbjDMZ61bf/HxL76dMKOdR26ohRRNTtG2u+UjDtQiEI9I3qTgSrVM3KTBroPW/T4OrnXqT7F71nZo2YaetCcxEWYjgFSkRa0QDvY6npec+sxEYx9gaaof+kevHAjQCZl9GkcI1d1QL37za2pHKsRnqpHpq0F9CVw+N0xjsbmFSQPuug+gmKA+aMLLYSJq9kwE63QoV11o3xUQG0MaLWzZynItxf71ZY9JKTaBTOf9sYKqQXcTh5HGO1aaQ3F8WiNNcoerkTh9ObYtLlFGLRd75RHBVR4AZZw5n5GU2SoduKVgsxlhw111n/kRDgAtObvD//vTLcemlW4Q4iGWjP/vNUEU5YhyQUlX+RyumDZ7ctg2jcIV10EtuvDrNpAaFyTnb3VOFUpcuRxDlFoMP42JUjRVHIx3ulu7u17+v56ys4L1VDT/voXkMVs+fA7fo4t2yhuSrhgHzeRHhwq6JgtuJaVOlIpbU7diMTRQQzp0fhiBOQ44qMKcSjfMmeNjF+cplRl1Q+PfU9q4f7LStp/SWbPDUUSCt8rlyphURpPB8tRQNR3SuvP+I8MoFJvZpjTjcpQPy+8hFH9tChNtkcq0tzsl3lTifOwSEu3+QE7+bavU+Jr8HswxmQoeWKF0+12ejAxQKafqd6xS0XHp3hW47LYMH1lAQt6B1PudnVFvJ3JB0UaxuVQOCw5ooDgFHxvke6rLfiuuAJ+05GAXbcBPyvxOV8D3b39AL1hqyrqEWSHnQv191X6LoAMAEuFOKR5xdav64Q8dupd+hca6WjszfFKzejHWwt5vcWnRax3kbtEIcmqgTQG2PkgsmojnawIj1w25ekJcFeZkxz4vXhjZ0c62m/+ftt+C7/8F1T7sBwFWnzsO3fOXzzb48RiDW/r8hSwPGTcTBZoPYxAB1kkZUREX7lm4JAqGR/sAvvv1xqdS/6HOqKOCJcYtLTl3Q3V1HDRS14S9F0J5tG5/EaUpWoh06E7p2se/VGvdGXy0oZu1XIfqwuwqGPGiDD4T6d8oKNYZ9V5FOWUv00+1eAnBmt8Od9z+MX/69j+K2e5+6IdNTOgC47OID/Nv//aU4nAouvDDi5LnHO+6UXQYxmuXHOA442G7qFD5G24C42nt2YZ3cQ5uLkslWIg86zXYf+rptMx9gTizb5oSNEX82+f8OO/QC3vlXnnjMiqKUPRgzD8hg6roODeVnIFRRLWbMLUBoCiqKU7Q5Et6fwv1qAjsbR1I2rCKoksh7b4qv2yZq1fRAEaWRVv9jhaft5mIiMurV2vHUWxNHuCFh+S6Il+r2b4FtUaoNUBbVzdANmSAIAW5W5obcCG2QQDhtEl7P0EbjTKIq8kZf62zWks1iLu/DsaPCn4E9qHpna7KnyC2CJTHuaUIAufF7myWUcAbXnF7dHqiQIQR5wkFLXDXyhFqqrRYXuqnZmUyLC1eaxzL9w6de/ITbH36mRTidhPvWDXJV/ocUGOR2mS1V1wQFG9KpP7VRa+bSxTm3G3oRkxrDDUvPVfehmsa5Qg9tONfFeY0fbvTZIFtTM6TOfi/n3PExA/qptG5MA7wIK4IcMmGl1hoEqA2Nq0mz4FbXhqqQng2hxCxmd0pBF18+XGxx3oYYjPNBxS5lQ8w7Uq3WggzCVHiM54+iPXODagIFEVkGZcXyBcUb52nCbbcf4sfefP0fawjwfd/xHHznN12Nk+cer403eg0JDgk3mxExJqRhqJSzsE+tsHeH/lwdZfm1GOXNUV+bhg7wzRlsU8ihomorZLE4orDYmcMZKcaOIsfconFu95RAbNWtp6xEmsgTVx2dcfDvyi0pB6J0glFXlZT6+5PPmfoIjHm68wxNHdyEvVIwzQPmZVLYgjSBvL+HFI/QpHj0ODcK3zrOh8onJ+efzbLfNaGDLVOoce0gofnc6Uf7+ZyIChdcW/FjofncB4RcmtigolsuFHs/dv7aZngngpe75iZQ4xGd84FqIKiF4jrOKRDMfJ5a86nDkr3vWnQr63E+rgYA6zznWhllb9HPpZGex3mlCfBY+dyH8KGnLAJH2hIGsVerA6D6SZXCoFofKjKWS3+fpOiDJrrXQJAosdNtKLbRp6AE9XrMiUryuYrlqj7Afj73MzTPSxukOZqHegod2u6IwQTjnKgh1u2MZdKgqLXBzzzNS4c8cNcEr9Ooa0Q7OBhiryF9csHhbsI8V72ZSjELIkxauqXjD/zwdfjnv3LL02oA8KxLL8Bfe9nzVnz6+p9DG74PY8Bms220DdJ/s1n1kTef82Lda12iOGXiLdfdgN94z42P6zN92bMvwws/+1JceeoCbMbN3vIKogvApZsJ/kkvVuOg6gxlcxqp91MWiwGts3WAzqeRRX8g58UHwGQy22dxsUG3KZSlo6ClIT+Pw4E6YOjJBcuS8en7HsJvffDjeM/NT63jxFM2ALjs4gP8u3/yUpQCnDg34Nxzjgufy4sHFq6ESw7DgM04YBhTSyqeRBdRyo2hYDc3WL31/Cv4fOghd5w6KtR9rTJc/zeLnZ4bmIVnTlX2knPHL4shIA0uKhNa5Vfa5oRcJopppgTzjd+JbRzh48rXZJKKicXWYgI2TF5mTRFlEg90nsPkxAP++wk/9smaW+sV9F649TNGK5LoBc4GzUXqousitJ9jU1/aIraA6m0KnftsPsLZmw7aFVL4jlspPkfySQmb1sYohAplJM+dX7iDVGcXZGShXUSpXs/RkkvbYnjz52JGVRRRvYGVB8oNALfcvGCcL+sUABd/KwYz5zvmRnbbPKEJ4e9EVNr3r4iMYM+KRfko9pDc0qhaeJDmjU0EaRlD44RrcUgOci9Q5j6udLxIqUIEwWEYt2slWNLfNbqAcwhXRUOz1lPdD/eRX0D7OoUz1+fuqIkiFTObKH1nWjHm3AsG6ibIm6fQwWxZKLOI54BjmuvgY2yxourIw0hLs9yhSDTObdDRWaUFg4QSPVFFoqLxL+uHaYX+7LDuVKdkXSNKb2eDw9lG2v+Mcmuz+DYvq2KPitGkT7DYT7G/Z2MrsuZmVzg0UccevlyLtXpjt22N2JqRY2/Wp7sd7rxzhx/+uevxb37z8Q8Brn3tVfi73/65uOKKc+33qqioiYimhGMHGyAkxJQ6f/cYYGJCkIJ8nhfbMLFx6GxGUTcajPMlV9htpqhYdN0W5SVOczGlcN2SjrKhXjd95ID2AnYwRA0374dTbjSFpouTeyHCUvbvONroMRZ0ELuOc2r15FVlEpuGy9Ice1IKxqEm5DfKMCSqcGvotQUUQrqO8718LhZ4pssjvHONc96tkIEBedHcMrr9IEwYjuihx4pzLiHWyAvSsyhCWzq++75uUJDmzTVJ/I5X7+9lFedFBjwqXKdxvqZ27udzrysY5yqSpxtvIoXORjfgoEIh/+t/z61tRTGUbsvI5pVc8VFRG5rPRe/DnkW/xBOdGRnyi94HKRDq7pCFGtjZ+g5OLRhFb0P1ZmYRbeTn2O0WbDZuD0kkW87N9gyOMgSA7Ya0BI1zpx2a+GdbBIXQCzxbnDd06dxybhqC0Z85dEopNnon3Gp01ZLo/cdBmS43WLfr+2Ocp+g1xjrO+R6Udqd3rqFzp7npASxNMHrZE5UbhppP53nBN3/v7+Kd77n7aTMA+OzLLsA3vuTz/TyRyhkiEgK2qS7aDo4dVPtlWdpSL4HPj0r9iw0qiy0kb7zjXrzx1x8fQuJgTPiur/qCag146UUOl7cLmeB9H6LVOymKlanmjGx9keo0aY1/FA3K9WwKgtgeUmRyXrJRFFQE1ay0BalbShBqggrL9zo5OqwNAO6450G8+8bb8f996JNP+Vl4SgYAl506wC/92EuQUsAFF0RsD451RcC8uDfwPBekITXLstpMbDdDE2CQpqc0EYZS4e31oqyN33aMTYF4qRPo4tNbFhfcWnDrq8OEYo1C4y41mJBPmDNCdCsjF0zxw5UavNq8ssmTjMFoBUuGTXlduRt7Q4nYmhNOGddbgSCIBi+0cxtIFLMt5EW9ZxvUKAcxNDskbpOiXwj1wNefOc2+adFNIzmH87zYtqtHDYROETwK7cOGCQirItQVMhRuaMq5sn0oBs1y6x5eUqapMPZKwETvqG0NUQypFcDTUj+XWjR5UefWULrdVJif2uEsojhv3yf6ZFq39EXstGifprBddFsht8RaxAVgfbntax9UuDl9kN3JwrdDZnVl03iBx4oPshW4DRI4zwo9dxg9B2AccEyN57zZJGu4+zhxeCHPMBsfbheSnT3GebRzQasleigv2TdPLlwYrfhQjldXHLShB7lZbGbq1+6tpEx4sOjW1u2UOJRzcaVgcZ7Ez1qHNjzLS+7tFLPxo13sbzctGMfUnCmAg02yZm1IomVQ3J7PN2RFqBQ+HNGinZsZFrRdASq2be4GEGT7plaZKrITOqtS5ulpZnMXhc+b9vi8pRQ8cmYCSm7DjkoLWJYFFHry7V5Tqd/tcNedO/y9n/gjvO2ddzxmLvusK0/gF3/4y3HlFSf2VLg1LksJ2G5HjMOAgipa68r+fgcszc5U7x53wegRGiYihNIpkdezHQzt0N8Nfm50m2fNSytyd9Ni2iwIAbkNTMHiXgcAszoGOKqLlAbqQUTVIQi9nkFgXDf7JPLxYWehYDd5o1ZWDTHrBjaBh6Ivgy4fknqzdMJqbBIUHaFFEOOccefNbnCEhQxzGNccwmqcq9I787mhkmxYowPMZmWXSwdbL9JI6tnbz+eVDsFaJ0sDXWRzZdSL5veeousYkabEZ804J+eXd7sWveGIOFcLPRVac646hG7hLhWkYG6GeEScuzXxWndFn9Eof7cXlyxCv+zzOelmgw4xDW2R9zbgc25C06Hn3mc5Dzp0GNM6n+PIfK45emmCdePQU+T0z6j+iw6hstj+FnNtipbfzNKsvVPVnZoXOjMpUiTamSVdhnoUzGm79nO2m2j5is4fCn3mWZhkYaFxHgPdsNChTBShwsXPMLiYs8d5byFoywtTZ4+WW5jjU3JUgC8Da4OWlyoyezjNiHCxOQ4RuFx68MGH8RXf9A7c9+D0NBkAnI9rX/K8rtawuEgRx1LCZhNx7NgxoyemmFp/48sClJpza0Prl2mALxDe/Pb34YMff3xb7JPHNvi2VzwXJ7dbXHTx+fXMqE1KaTaQbVMfTUi8dHpiHRC89Eit2BAM/Bl1iJc7xKtqAxAbUfsrmK1foWhAcQFBJSWF4HaCsU4MrPcgaiHr/djusgfuewgPTjv83Ds++Jgiip+RA4BzT4z4tTe+HKVx/o8fP2aTGm4qlmWx7V9BbfirIEgtIirX1wvitqwyGIrDjHKXHLnl5/Z+ajDWLZXG28Y7hSgvynlx0TyVi00sCUMdhN/EDWxtnvxStOIoBUS0YjuqAi91AKJtg0IoAg12eMu81I0nN7N5JUSmhXQ/rQ5NFCp0PFAXdnKROXMgENGnrBvQ2GsXROGr9aJzPU85AJhztqaP4iwZwNy4emHlRVvasKFT4Bf6h/O+HXmwLLnxP3tF/So4OJtWQSku5jeIWrxZxGT1Nw6YiXIIoVPhZaPFJp7wOlrYESFiibvxl6k2zC1Q76Xu0DZOlt3uxuklbKyIhFgXDrrpOQqaqP/odlaLVPN1bclatQoguhPabahXuOoQ5OKQSP4cQzfMZY/TD2lI9ZmXhqSpnzu5EGNgIRaqwBToo+4w6a5YakU2LQHHIUmcN2upXKCaXUW2yGbR2ZqJQ9MdqHofMfT0Hi0olqYODTi9QBvi1GyOAG+KtFkhLFUTlBbgTndyNxFtDLjFNC2EwYcBAAX26u/ZNOs/bk4oFLceOtkgsvhmlEJ33LLVYj/KIBQrDYdoSVE93tnkpKYNYlxr0Y7gzzqzm5uAU8FumrGbKi0gRYW78r5pRX2ZcdedO/z9n/gjvPVRhgAH24S3vfmVOP+ChOPHjlkjyfuRKt2VLjJgu63w/6VpFmzGZMK1Sew+uRUmzYOK2rzLeSfn0lOBSlFkW+ig4OtNBhsX3i29pkyva0INj0WcWEiF4qY4l158V+Pch6nFbVLl/to0xEKHtHJIlgkcLg22r+8aoXJTITQXilYyzpUXbQPgib7fyXjEm6b3wZjfj3PZqsdgW1FtltfnmAOC0poTIg1miXOKS7mrC1FO6FFPeX/7rHGuwqias1V40/yz4RzqZYFRReg2Qytfy+ezC+YaPYFw2XYvZRFyrXHeD+nz6n7QnwUoZSVYQ8yfRVQE331FeHiccwBAcULaq6oLhNreLkJfWlbCvesBQBTtHBNCZC0iDbJt6pOjV0i1Wtj4trOi1rt8Z7bgCY4M0DhXZJMOSSlGHY7QcmF9lQLdgBbLnO4pLtaWpXdcUgoQtV7YENtCTOL87Pm8X16s+dZFGrIsKLA1GoK5FU2TiXQr0jtUiDpTRwT1juE7oBbE3IZiHe0tA7mJtqSITvBTkR0AkJc6TN5Nk4gCwpCrpPrkUvDGX7weP/qmjzxNKADn4xu/4jmdWJ2p0IeIg5Sw2UYcbLftOaWOwpIbt77m/YySszXWpKvwz3/w43fh59/+3sf92b74s07hpc+5EldfdnG1JywwHYwYlb+vDbyLBfp/Kh23GIW0rIT8VOMqF49PugwobUbrXL07o4iDw+ixoVP6dxRCMBSZu5PU+/DBBx7GA4eH+JV334hb73rwT+UsPOkDgH/0d56PV7zwElx8ccQ555xom0EmiShqqQEpJcwLsBlHHGwH5BLMsiusLsRhSNasUWjNfUB770UG92SWSmnlHlDkUvQNKqFgatnjUECHo3FDuSz9n3P1SbcijGzGBebuyuw9RFv/LpvL2ixHE0hiMe5NkFj4ZN9iJOE1qi+tQ0+KBFfZs/0ZBhcOVNVcnZDxO/IyNzpAcDVbNt0uXJQd5ld6nikF6vgL8soqiLDxKOI3Y6KYU2/rp7+7QvFrsZhiNDeHgWgQ2UKmBuktKBiiQ+pD8OLZt3m+8WdBo4kNDe5z5FYE6LyM19x8wqW1KPSpf8ayVLgVJ+7rxoANGRsqpZZw0IXmx0wtBU7n+Xf5s02kU2LIXRDc+52J0SCotnGkiFM07YT6flygrF6KsYOA1iNeunOmwoXWLC0QXmNvvckCnMJGag+pkF4XU9y3k3KYV7bLncWdc4y92eXPjStovKJ4FJlEGLIW9iwcXeyzCNfWt9psJNm08S4rotyvzbqKX4H3CZq+iaBiVLE2BIfqU2BN+YNZzgQdVtgE9zx29QVfc+L7d0ZIcj3LldNK0TYWpX5v1wdTEQALYsgNrrcY7D3G+mymeWl6AjNuv/0Q3/a638MNtz50ZC77W3/j2fjua6/ByfOO+3BK4mkc6nQ3xohE27+YqhKwNIuz6o+oWGubkHILu2luG0GcRFhoc4jpQ7bYEFQN5QRgmbPkPg66osWiamNMAhnndpZnlg0CofiQ89nRH1o+n6ZFFLnrUGMzVF5+lkZAB2Saz0shjSd0/Gz14Q6hiD1qr5eg/Ov10HIzxiY2GLoBjjZh3NYKe6QbuNRGIXTimmykDakjOhAa56p/owr/hKEPookTgtYS6CD1UbbvamW7LuY0n7OZ03zO57vO51GcW9hwTXOfzxVunRT9Uf0huzhX2t5aW+Cod5bFBedsce7ONS42bAJ8NkzwgRfrDh082KCJSA5akIajkFql08fR76DijY8/n7c4F2ciEyVuQ89lyR6LwSlGpVSXDlI/mc8pmOe2jnwPjXoyZXEdCaa5EsWej/ftWvOKAy1FhA10K2l5azM2XaiisernkXUozwLrdtaV6zivw09Hz/ZuQC5yyveucU66m1JX+AxDqM5JKt6otTvP4jBEQ8KFAOx2E6apDgGqW1OvH6GN8ff+4LufFtaA11x6Pr7xy5/T3XOuRF8HANtNwHZ7YNouQ0o27A5Cma60mdyjXaUZDwH40V95Fz55z+NvaF/zgqvxvGdejGdeeqqj4TidrlfXz6UY1WSv7kJpC5rYiQQu2SmPRjcrrmvBfx/Espzxyv6A2bG6D1atKi6lSqcFUH9PsUZPcjwpMrsdPv3Aw3jLe27BRz9135/aWXjSBwD/6999Pv6Lr74UJ06cMMjgblcV18mLmOaMg21V+q+Tndi8i0P3krMU/LzIncOLBhFqfqSiYs8GmJCVoRXGFPyB8DdUMdkvoGwTRyYjbisdFIemMK3+1vCthMAK1afZlaMdkqkTcm6BZ1EjzoTF0qO1AHP2idTaJqlTdRbPZfXDZKHJwsYn9pWDSWsY3UJ70VUVWeu0HYaCqEVMXwAAtfmKIv5S1dOb4vnQvqNN1N3rnggALSai+M4bT674s2YiPNzNreF0zuvQ3AjmnIESjC/G50s1aFXhnZqqO7eZBmkWzQRrnmcVzXFxtc72AxBBLC8GclkXZsCSg+lS9PzVisCoFBFuPNpWB6UfHChvEP1z4s/azRXtUsW0slAc2mZIlZwNXl6EwpJsWJSG/sxuWoM5zyqW2Rfk3ADbVjG7wMswVAXqSTzE15oWLjCVVlaEPhxTRIxZxCzudtE7WPSXI9XKNc6LwBKnuW74h6gNotuZLUsVx2IsEr673SRDlDhtojb1Q/RizrQLjmiY18V/YeMuojkxNCvGXFYcuNA2pHWgtDQody5+ZlSzI4t4H3RTJu4WpoPQqToXi3MWu9z4EOHhQ51gjQRVy3OGOzy0e3FoCXXXNoPRLJwWBGSUsmC3m/dEvabmdx9jwOHhDq/+9t/Gx44YAHzNSy7DD/6dL8Tllx3H0rh8AyGsS2lIn/pz0jBgHAbE2BSTo4sudttV2eTFUDoaBc9XWDWgpqPRGiGH9Hqcq4heHWC5snWKdjBwOPV5TaHu1A0JoeBwqu9zO9YYomMAvwPjfIiKZEK35WSx7C4/7qmcpLGbF/f0ppOODlvMrtUGE7kNdampE0wY8Kg4rwK/i+mWsGnl/z4qzg3p1rrXcei3hEPq35sOBLgVDeA5ac30Ujp6DcVIVejtbHG+RjIF4Y1rraRDfKzqgVEGAKU4V511EHngbL40zk37RIZE9T6phS+RBhrnPbVFB0ea30pDxFEYERgHiXPRk2GcDymitEG1isgS9q7nyhyHZHtNdwguWvQMzEfk8zWMfy2w2OXzpXSuD+hEwPrzUtBbB5s4piDVKl21iEp+ixu1PJx6q0rafY5DsO18aDVTjXN0+TyXggPR9CG0PTbb5t4NyutgDiPdOi10saT0G63bVfzW6lMbhipFBqYt1OdzdE2XxvnS8kRdsMEdLELoageL8zbpsWVS+94700mq9eqZw6nSyspiyFMT4oajZFEWvPJb3oFbPsOtAa+59Hx801c8x2khro2HIUaMMWIzRhw72GIzDrWVb+83BuowZKMy1bO92D3faU+Vgt947434zffc9Lg/38XnHuCvv/TzcPG5J3DOOecYrUCpCq4l5boP1Z4RUqPXZZmr7PsgAE0Ikgs/RbPW/qCiGjgE6HTExGqeC8sQ4kpTIIh+gYsXutU5Px8w7Q5x5wOP4J0fuR3vvvHTf6pn4UkfAPzo674If/nV1wgXzqHP5hOMgOPHtg3OVRP4OCZroDThRlE5nkUdVSewqhIM8b0+3FUFz22bUhLmTXE687gNnpBD24pSCI1wQhY/vPTWE22KFKKQH5ZtyzaI5dPaezyKogWbzbE1yAFqXdQnG4O8i7p0Nohz9TjPpZg6L/ncVN3dTd5glaKwuNIJEKo9GHnCFIJTX1TyuSAiHQW9jVwWqFcR7jf5MPx8QYo/Wp45/z6YtyyF42oS6v8sKQ7UAJjnXG2qRI0TtHcUUcCygghWobtoUE0TdQQwTyyMk2kAlEZ3QahQsxhDVcLP2QYeaFuzAoGELtRV8CaIm5kY9sUFKXJVJ9totmxhr5ApwiGMsXq2x0ShqCKcNh8mKL+XyuGMF998R99Itu3g1Io0QrtN6yOIPsIQO+VpNLXhEOj97gKPQ0Nk9DSBYhw8irDx5x1sALdkXgAAIABJREFUksf5qLBI3wYRBl9/T7ZzvDQ/Yb4PbUJ6lWK/c5y7C3MTyCUjt/fMpiXb9sr9lzlsUJSCbcZFNIZNhSYU+kSHdvaqc0HvRMD76/BwMSVzhdZyKJba4CJTPErinO+IDeM0LzjYDpbY2WxRydPvYReg49YpCUR8nv0+yTaI9YGQnhWqTadYGsICBksPIaz8tAsOD6dWHC6YlqVuJ1rBQKEx3lU5F7z629+G62988MhB9l/7+mdi3IwWT2O7P+aFU/2AoTX+4zhgHIe2iS8d+iZTBLLdcW7T5RSTSvPpKTg557bZ5LMjl9ypaYzHbIJkxZTQSYniwHtewZ11k1b55KQFCeUlBkGBCQ3KfLmrJkdFVwXRC4giJpgsnwe1QJw5lIc1AoytggY5l2FJvW+qheYsiAZvql2LgFZh1CrhfaB0gHVz3dnLHRHnZgMnmidKe9H8xviqmgaxowOoCrwOiUiNU/g88/nAQbEM65221tvk+mZaaInRB+e0AVznc+aOecmmt9Ln895xhZD3aDD10lGXlsXjoFtIBHcdCUZP8pzF56mOBhrnzC1JVOd1cDavahIVFPTnFFZ2YD2l1J1V+iWEC0v2tAnGuefz0om/apyHIAS3WGuDuVFHKzTYcydrI6KzfDDk1E7TSTJ9GKxoDcV0IxAitmNoVrdZBh5BaBVeB6sTFa2Smc/p+jCtnCQOp7yiu0CG7SLeR2G1udZuel5DCNiOajnr+XSaS5fPncpZ3amI5phmt4Y8Kp9zQ71oLHYuSjWfHx5OdRiwVIoZkTkx0DbbtUte/0/fh5/6v2/8jB8A/NUvf45TmeA0qxgCNkPCsU3EwcG2svBj7NBha7n1pSlYE4noqCinpv29f/FbnYvKY/3zws++BF/xeVfiGZdciCENe5pWRNLpfck+gD2HORTANZOKiPLVz1hrKb+Xs7AGKgp4WbL1Y0VQUBxOuXaZo0OJGohCS+PCJATXDiil4FP3PIgPfPwuvO39H/9TPwtP+gDgjf/wRXj1y69Yqaq7GEedMA442NImqf4/WvEpl6sXAaT3u6uJLrlCuceO65Vtckjhv+0Y7RLiBH/J4nfvfaPZ9zDRG59Q7LgQ0EGTUFxLIFI9vZTO6qfIpBKiIWAFhU0mHZYY4GIuRXjXnLiG4NNpLf65SXa+uAsKjUNNMvOcEWJoge+Apq6wEji2CriweaEYzLwUU6Bfw51zVpGkYrxZ5TL3NoXOq+UnG4zn3w9BbPoXuBkpJsjFi0BFa9jk1sY2OwzVlMjrkCQLDFm9fQ010uzhmAS5eVEdBi0oHQFSOp4iOgGefUirqdvqRbOyvgsrB4MgzfI4hM4CUNEecWVjFORMryGaVJnPcu7WqBN+rjVclEVtydIY7LzoJJyz59aGzp/b/Kc5+BMKSslNbCzUQZ/BR4d+AJASuZpePPPdkRM/zaWDL3bq6iuILYWsykobgaKXbO5ptaS0CdIZhvY+HKIL2+LQppN/TzVIqBUQQkMdUCCTFlrFBxAdfaX0Ip20R3RKTtkTauI7mG1L3A9IeOcUgWy6GFuz5xENCUVgKFeUhSaEhuJnzM9ckFgEHE3CIniemygRCqZdVXMOoVjBXtBvib/+v/ktXH/DA0cMsp+Pv/q113TbWTbmpbljjOOAYRir+nUazGZqHedue1g6JXaNHf1MawGj9SY4GEzRLRTZgHic+0aN5zQ3Jw02CtrcENZNLjbQQ52dNhc7OzS9a9RBRYcB3BrOTbmfL11tGimIWTVioiGZqGdTCnCG/uFtY0yYOAd4jo6oRW2QfM4YyqXgcLfYEOzR4tx0ntTDWTiozC8q+qb2q/Oy75LBWFP1aM2bg4qQrLRVbKtOW6vs6KyZNL7QnxfN5/zdvL+wyueddeYQq21WcaFQz+fFRA+JYNDPqs9L70nN52z00PFsJZ+H0GnaMM6H1AvdMp+zGcURcX6UdZjpd7QBaylu7ci7Jpf13r+5tySP1SGdJZ/PZd/HPOjyI3fxtM7nrtGhMdaaEXWvyKr/01MPstwfQXIQqQOLIPH8z2ucZ9tsuiaAU8hCe8Y7FdgG9vJ5PwCo7ePURGuBnlKKFucxRmwGYM71TidyILcBZYqu+YNGUSNSgBpLRNN5hVusddW6vSCcNc7rnb3Uu3Gecbiba44vxYa4tGFOEfjxN1+Pn/j5Dz8tKABs/A2x2+qYTYrYNEebmAbR8hEKsG3Bcz1HqAJ9KD19is/w16+7Ae94/xOzS/zbr/kiHIwbXHnJhZUOR9RyENu9gD07wMBBQDukQWrxvGQUnvdM++8MOl4ZBVn03oC+9gV6wb8OJsUYFu2T6tYTndYcGF/AJ+++H8gZP/22PzLBy6f1AOCn/9GL8ZqXX9EpnU4m2FO3JQiV/8+HkFKsnEEqtw+eiMLKj9wt55plx5wbfJgQDIfGk6vfc/TRcdTZvEVe6mYlBpkkeVEWhM+tPHU98GotFtBTDNRDdsm9lYr9DvQbAp1adnyo1mCpaAs3t33iKdYUUzWcsM5u86HN5KoIUlVZFfY5qmnlBrkUSIINbUsfuqKWAyKzLwtiN7ISpCJUvELOafXnEDSz1cl98tVhTRIhQxWc0wTNhnlIwbZn/YTdFbEJsYvRi25+/8rT9wJwml2Iaj0sIYQ0Nahzzv3AiDAzFR9hMmchxc+u9lscJrGxY7KmsKAXXtSeWHzrnkun+j4L5F+F3BjpUxPEUQ9zg+G3M1Nh7+QP+kbKPXmzQbtiQCvqYHGuEGKP8577pzSinoMeEKMXr2tLubMVa8Uae3QgUA5H2HhRayKIEr4XoNEKSBZk6jywvog7Gk8rajg01AFf9+eSb4/GoSm6T3lP+6SfmoezxvlRg42Or8k4hwvauD+70xFYUOqGYEi9YFTvqV5/T+V1uhe5CVHJmVvzoEtT6Q0tac/LjNzsAec2QVQO7Nf91+84cgDwUz/4InzNSy837rTGec5Vr2K7GbDZjCglIqUohadvWFWxmLBJbpAUfUMRPVJdIL7045hM1Irc5grn7R0tnPPqlrJBnn0uvWtEir6xIPoohNDpgNCqUQv62SzwfBvTuw9E45DTTSCLEOs6n++LtbposAvC5i7OlbuuOjixQXuJ0iPdRkXRdPixjnMVVDSNE4HWrwc1UekJ6PmqkG2TiRmLPVlfPPpzeLR8rnG+mHZLsGH0Os7/OPlct/wK5VbRKx0k5LKv47EX56vmSuPcrXxLlxuVxnVUnBucvvSoPf09UZrVjaAUed/SblHz+VoPQXUzklgzT4JkWt+t6nWvcc7vRO0dcwTKuYtzatNks7BmTBRz8jFbyFKMCqOLkZQqEoY8eNMsMreH0uVzFQMOITRh6l480QXU2h0tdfumLYGI7Fi/L6My2nf0fH5U3d7pXgR077evA9yG0uO81rzrOM/ZxUiNUqDin+1uTSuNgZLrYHma5uY0k1cuG/V+fMPPX4+f/D8/8wcARADs2VimgCEkbIaI7TbhYLutdUdreqP0NaRt+IY92zBufc/feMe9eONbrntCn/PqU+fiL33Js3DB8WM4/4KT7gggi4zcIHO1ry6mkQUVyg6+OIVUYqQCkB5ZZFJJqz7V7Fk4SNPuuSMnCPzfqNdEsLkrAAfz9z9wGg9PO/zSOz+KO+5/5M/kLDzpA4B/9voX46tfcnnzyQwdpGezGSpctNT/Xoorx49DNN62b+QoFOJ+nQqLpj8s+YWarOmFzMtRIWrVdi+bnVEIIgRmnCM/ZNPsPEvdjFgBa5NCiI9qMTgvkQX0S1b1eRZl9IzXSS+5oqVNGemZS3hdWTe5q4l7gNu6KETNL/9ifN/UlOqNey08zXWTogWEaiuI6Gw3gXZfeN8gqiVG54c9mrRGbShzE78xWF0dAMy5+qMzqZu1HMWoVrZ6BrELyr9PxuFamgJ67zAQ9xIZuX60ZVMdB3vGLBjaACu1jdSucepsOLYqXMqqUCtr0Ta4QmmFwQVxaggioFSMz0busPFSxT5K7SgJ4z9zOGO7SUix0WYaX5Ycf0L9itg68TzbxqsJ05GXqc4FVUSu+upuNz6pN2goreEabNy9kbNbckqDHQIEshy7OCedgpA+41nb73DYLb+f8Ub1ji8yDW4Q0xR7Fwk2ItOcbRPJbZbyjmucB4vztbr+bhKesUBJAwv0XEw5nRsfCmNFueeG5gdO20M2nm6F5falQTYovTsBt+39xkut5+pgLPiII9QtLgXtAEXfuGf7ZlO9qUvmuSEs3geuzlttaBHqLYSAcXD0UYFC7B2GPecFZ85M9c5cMnbTbHaZpC+95m++/awDgK9+6eVuhTctdn+UEpBSFa5NQ6rfPLgGxCHjvNMv8cFYT+fiULvsiUayaa4/y3VjXEizDgwjmkhe88lNqbnKFDSrzeINm9E/FmwGNgm5UX2aroIidNoAnzoVIcCQdYZsWkoX5xxcTtIYLCYQWNfXzOfZYjW66KFsIwnF1eFllKKfgyJCd3URYArqDRHk+dz51jpMt1zaCkbesQoBD+T9apyn3o6V6J9pdoGy9Sb/6Djfz+c6nODAhUgfugjEsB/nqaHUXDMpPOF8rqkvrpTgVcVfPy+f6cKcuklWcHMYMyo6qj0f6tjQAtLj3C1oiwwUnGZU6ZJGr1y9B3NkWOm7aD6fRItHrXp9OOC1kA1fNZ/HfZFAawZUs6FksxrWZ6n0FdWTGIea29RCsnKdg71T0mKI+FIbVdbem5bTOOwZx9Cg+q71Qd0FxjkH+qREmF1r7DVixoFDhtDiPHs+b814v5RoVsvz0g3AOUyvcb7IciRI3Z6EorqO83rmBi5Y2udgPtfB+5oOUBEF7kKgbhaM8xSBgCo0e+ZwwjQvSLF0CIDNGPGjP/shvOHnr39aIAC08UvW2AeEFHF8iDjYjBg2Yxv2BBsY55JNe0zh7TXmc6PWxk4IEAD+2W/8IT58291P6LO+4vOvxAs+6xJcedF52B4c2O9S1f1iSK2Grsu9e002LnJBydnc2ajK19PIF6fZFhdqL+gdqtAoLP4cvN7Opddk6pwLAu++GXfe/wh++T9+DJ+8989OM+JJHwD81A++GF/zsss7b86aqFKdcKbKH64Kw6HzbD2cluYnWovHQxNuq5X7brdYUkniDV+bIBevMe/YnV9MBaH9b988mqppKwq0YaRNQwEhSKkTjNuO7u9HCDs6myYRcWrbjWluHs4iupEFFk/RoCFJ4lXe0+AbajZXymEr2RtE/l0qNmtS1MazmEJ7TbanD+ttxsQN1PfC7URYN6qo/ONhcM0ECko5/Kafyqu/L4ci5JhvjFPJqaIq/1bxjMGSijc0h7tKaSAlYjdXCNBmjBaoOpg43C042AxN1Ks2q/y7c1Z4dek805dSPUdJA1jEC3jJsOERmyYIlJHWjrVYzm0TULrEr5DRumn0f0eF0SVnQ8cMTWWfsDg+s6HjInqRzeec5LsRVaPIAm0mdaPPBt80N4BOOyPF2KD6NVHUOO9HpHVjUAcA7gftm4Zdg6WSz2f85tZMaxNHr/vUhGvqu62FzGaQOE+OgFD/cCjMdM52H7DAVYtPQ+0IHF2968mzp1iSqtXmDBsa1YEF7xovTNwhJe4JiwWRwZ2baGMRvhnh/PO8mI4Imxkq5JIXPQzVOpHwcXL1uckhb9IFboCC2EQCo8GB51ktUIPxhM8W5xWymW2Apr7iuSlXxxgxL77dy0C1GWq5ZLcjFLjni7JRMwX0UDDngjNnpnYOMqZpqVu7ofHrl4LXfMfb8aEb7j9yAPDql13eNUbRGraImEhjS3XrIZsy0oZ4RzgKBZ0IJu8iiiJSgJbNW5ahmoq4KYycLhsa59xQ+uArrDa7QVTWixfZ4nqjFmtGs4i9psggzgA+KA12nxxaY+DWs0NyVMmaZkKUgopykrtPL3j+vErhK5bPq5hkMfXuaYEJ8OmgeTEh2tYc8u5fxXmWsigKSo/0orLSzDA4f8tnkMZz7PQG+rvG0G5H5PPMwUpxn2kOTAgFV9E5buc0n5/ZCT+73VV0HuHnsnwOmBaPokrUJQaPlc9LFctcigvIrpEiRpEQQVptiGsOaAKMHdLT35PHeaVDTVM2HQOlljAHrlFHSrFYb+o1hogO4L87Ks71vamtrNIY3e8+ittSMeeYqbN1dHtaor64uFkWHZoFLKTHiaChxrk6fxSzeC4GTXaqRTAdJf57Q0IOfZyH1RDzzG6xxR3flQ0kJM5Z23F5YDmuQLQ8itXt2w2RQ/U7EGGlQxn72e13EzWQW/zwu9fhh1MYeucf3+Q6zSA3hxwf9AAFyzxjXhYcHk5IkfaOdKgK+JGf/SB+/M2f+QOAv/Llz4GwsZr2VR0EjEPCNiZstwnDOLaa1e8K/n9W/4lzTM77zi+M/Y/cdg9+5jf/8Al91uPbEX/zKz8fKUVcdelFGNJQ66niln+wOtbI+9Z4cAhX755sav+1Ec97d0FpNIC8LEipDc8FfaLULQ6aMsROM3Po5TULaclWxwH41D0P4jffdwuu/+S9f6Zn4SlAAHwZXv3yKxvcNtoUniJkQ6qCf7TTIiwiwhXnlRedUp80vSiIVljHULqJJYViWDCMQ8S0ZCsQyB3i5VhFtIpdtL0lT+g48BSYIUKgoxew4Q7OK3MBxGiCLEGUYZcV/M6V0GETThZ7vITmRfQMBoU1UvU7iDVYMDiXPRvjs8K5lQA2G9c8UG6wToZL68RcQMQnYD3dI+5BwLxRdYoAtzb8ngjO1+IzYCGdW+PtsPUWxAXSEHsihhQbyq/jMIQb/qXB61U0j42ubyp8e5bFqstVqpXbHdtFg45LVIQGolBFsy9chNu3lN57VXh/qg6vFBHjair/agWzVQ7hURZsZQW/XNtnqujl2XQJDE4nHsglO4R6t6sc7W3jBk+Lbzh43tgY9MI9jqZBGxRS64Pbojm37VB0RMQiBSy5mXUrhz11f/r7Lk0x3nyEgyMBGOd6jjXOlwZHi/SdXQ1SCO2lNz2CCP+JewP5uUTXmAjg0qvg2tAm9IWyDuq6BmoTbajI58QNkG6SlP2qNmchEh6qFpWha3L4s9dxzuYlqK0qm+t2Po32ww1COxhsgD3OgwtCspoJQArOy53muTXUueaPRo/IpWCaFnzNt731rAOAr33FFV3CDyE2WHxEignb7QggdptbjQlFieXsDbfCjAsI880y6GsbCtE4YJHDP7emnRWXOsZmk0xktHgi6eLXFeR7KgXpAqbZA+xxmWuc+0A18Qys4LSu6eMbxUEG9Is47LB5zbZl9A0x8/kZQQhODVF3VD5XR5axCZh16v6iKr50YsCO7yy5j/Omc2lxzqaCSCRHevQOK4k0spV/tOdmrSnqOQ4yAAjBL/m8Qhr1cV4kzrOJqC0S50TJ7CaPc93cg4OP4gUvaV2q/aFNJm3oomiRVKcl//wa50G0ldTmcO1Jz62qbvyJfjA9DqF4kWNOi0QdvKi4H+Aq8Pq7+zh3O2FIzlX7uLUloA4WktWK4iqBIKjOs+dz4yo3vQ6v/4qJIzNfq8aPin3a/SN15DrOu4Z+Bdde3xH8TqpPkQVZsptKp91FPRqD0VNYcpN61wYZpOhZ1sUdkSEx1mEQ9YGsse/q9tC5TqAho6KhGT1f2aCgoaIcPVQadW4xoUHW7TV3VavZeV4azSx3cf4jP/NBvOHNH3paIAB4Hy3FB4B16JawCREHxwYcbLeC6oQsBYI1/Fq3m0U5eotR/u9//c7r8a6PPDGrxKtPncQ3/IVrMKSEqy8/ZdD9grJHB3BNdUed1hzWNAGE9EDaljsW5Gat64jKvKI5qQaM1vbVMSC75h3YJwVbAvI3ffqBR/DbH7gV773lrj/zs/CkDwDe9I9fgte8/Bk1AW2iQXBDcChO7OxBsnl7zotDC+mRzaaGtn60ZAuScOt0tEEXjbPlnCc2MYSKKF97DcFV8SW9CIHeNuYoi56+CfLyec0rpAURBYrULmINK+IGjiqpLMjICyRHUD2CR4MVZksepiTbxNGKbY28aCXkc9cuYH1P+t0Vyuiwb6rM5z0oo6kTi4Ahjkho6wSoDTM/Iyfma0VlTYq6jSF3mdw3hIBl9i14atP9vDgSA8Lp66bmoRcj672i3boohp7raVzgsJIUWlEkFvERpng5rdSIJhhiL2dTRExpM3jxawJZ0XmNjCFuNTj5302LJXdynTltJ8w1NH5yFuVtKipTk2Gal55fTnuWBV2ck0toP2cunR9wvVS5bS3Ngz4YrejwcGm2PdwG9VoPjPNwFr/wNT/WtSiKccx7PYLyKHHunC/VL9A4t3suuO6CQcvnXkiUnsVaKEGGQryPTBeA57yU7q4aGn1CdSsYN/zduynvxbkXxS5ylkuvDE/kSm60K4h9a08HKaYngRD2Bk19zMOGwhrnCvlWW7itUQzoIe46Iin5vc3ijcKBcxty8DO8/Npfx4c+dt+RA4Cve+WVphZd556xFakRw5BaQ+9IEt41nbPDqhAqDTFFcduOmtG4sSqAJrRH4+RSR2Q3LdZwMs7Z2HTw5QY9nObFnAGmBU0d3OkElTaCzoUjhoKpmuk05ISjEqxRaQ3fPOWuCWLe5Yafm+cg+hi5UP8gd24msenUFOx/P/Uv5/llPteRyDouz5bPdcDJ5ulscX5UPt9sKppxbs1ylLw2DMGsQpWLr9oq5VHyuVrh5YY+00bO47zesyrkRhV8aq7owKFDG3Q0PVWG96XM0dx7tTbe59+vn+2aHqhQbAjdQTnaShkklNf0BQZHomk+JzJv7UDAQYwiY2zREwKC1BIURNTv1g1AVgOAIs0A3Say+IK7lR+sbgoIVu9Bfs7U4mg7OvVlyU6/qtpCrjPEZxFXKBV33kA3HKdzBQdPI/Nqc4baiNOC3tnM5/PswrZKY6pLI9cECJ2ek58pOh6p7R7RuzFFzE0rJBfe6w1NHH1Z42es2LJR43w/djlkiqbn44sLeraXrn5RnQCjPqJgt5sxTbPpiNXhbv0zP/KzH8Qb3vz0ogAUoQHE4HS245uE7XbbbKxDh6ZgRiY603j1TRSwrBBPEHrQ//QLb9vT9Hg8VIDnX3UxNsOIZ1x6YVfvtXa/Ne5tDt4mbDw/Jp7u7H+H/psINus0PSNEGQTTEwiimxP2zEGbNkJwQeck3Og7H3wEH/3kPfj199zyGXEWnvQBwBt+4IvxTX/p85BiaJwsVyolvBaNB1FQsNBrlTD4VgBthmBcQ4qBlWZrRyXhXNyCC8Jv5sVQE1kCkDv4FgskbvvqNmzpmkryzskXp6eyceajeNU3W7XFeM89x4j+jxWFkI3TWeF2Dvmndd1mjKZUrBBOuhFo8kbpi0w2D1glpSKqyWwqKfbEomWzSZ0OALfwuWCv8KmfzUVhqIZr8NHUi2dp8VXh3tFgcSxyJpnmEuqODn7p3GYOONhw+/Ydnb82hyaVfpHs0p6bVVtq7yVnh1Pq1pxiPWYD2QpKsxxcbTiAYi4Uc6YmRBSotv9d+uUaV0kgajtr6qNtyWNQjYfSKdsW8QaeyHncRIGbJvPmdhsb0ieWSk0xCkcbALQt3HasSIt5CU6zQbHzOqQgQjz8XY1L2w4M7dxUfyPGgM0QcdiGRq4jEaz4DQ1lMhv0uZiyunqvppVwk8a5b9sdasnnyIaIvyOleiaWFk+Dxnn04nVZYM+QwjNsSNRytMa5ixpys1+V4+t/Nw50cZs1jfOogjfAkaJI/IfihjEGjE313AYHdD1od5tzRXudhrVCfd00wc42tzbmcNGehxXSgA2ZGPeM8yG5JSs1OCie5pDQuuGvfX8dWsX2rGmjN4gjxER9DzjPnWfdILmNBkUKAJ/nS7/xV4+0AfypH3wRvv5Vz0AI0ShoKaa6vSy1GK3DuNhQXH0ZsKw82juEAGHiEF2NTTKvcKB0wlt7zjPtTpyW0mhOTnVhbqRiu4r3OZKrbU0b95nPaTs6ciIXempXrnBAMcTNIqrrYVWIMf5IWeCQabtJOH04d2JbHEy3+YE1q0MKXT5XBBcH+MpVP1ucaz4fNZ83ulQ9b+gaM9YTHuf9Xan8ed08c0uUBekz2ZnX4bCII/P/ltZCUkIpDJWCsI5z5WTT3k8dJqi9wPfJGpQUqnU+jw0hUMShBOgtZUlJCegH3FrvEJFDqstRce4wa8/1Rfn30jDrAGCWd0NrUXWAYD5fUwAUrk4dAqUzGtKo5QFSPua2WVcNKQ4/+jjfh8VXF6J2j3X53Ln5pD/0+gk92soGO427jzZo6imXHDS5dfE4OtqKrg5Lq+U2g79bd4AAzuxyR9mZc6VfDYNDoVmvKJIOotkwJEegxAAMY6q86yy5Vnj3FUK/dHHOwZbn84IhJUNZ6vM3O8IYgNBoCEKfqm5WjjghyrM0blwUi1RS34INf4KdNc3nS65DgArQKA1BWxBjwQ/90/fjJ3+hDgAuPvcAz7rkPBQAxzcjDg4OfHCxcusopeAjt92Nex86jfsfOXxKm75LzjuOb3vl8y02IvTZ12HKNkaMY8DBwYHl/ND0fqi4z4GcLm6o/UHEhFMMfFv/lutuwFvfd9MTpAIM+M5XPg8AcHK7xQUXnoRFHV1I+B24GGhbfy7elPO/NIvAwnqcemjiBGBD41B8uCD3axDqQ1CarFGw4csDBNz90GksS8bPvP39OJyWP58DgNd/7/Px9X/xClx22YWItBBB8EZeFJzZEBXhveumiRvGNERE+HQziVfs1HiFLgwTbVLOBElRQYeWcsvtCaaq4tfieJqamAicA+eepsUSyK7ZEvGyIsdkH+IdrShZe9ZyGxKUYy3b5GGITYtgX0SHh3q9iWaBnjNMkIhFXWye2movYyrAhKKFgBS8aeB0ndtWcij7gUgwSgB5k/NSg6vfNpSOO61CR7vWJI5JPEcF1s5hC5M8NRwCqrCaiY61ADWbs8HFoPx8CFQvVzhcnGBkAAAgAElEQVTwdjN0kFfqUrgYUW3q0SleB3M5mEWVm1xKJpFOjTZiz0d6sca7nce1Wn+WxjY2pVO4x2hpaqYODw223TMhxZYYbRpPEaQpW8FA7QyH+nOAIc84+BnVbSU3c4TOrREza/4nC8tJNpdReP4s8HLbinC4w2aS3Cq3/5E4F7GtGGADHBOWbL7I3Jx4nDMZhHbOYTaDQxTRyiWbSFE26HnoNjhKl9A41+k4YbGEOfOOKwUYTcDtLHZZ7ZnPc25oK3qru2Co9xGuYhsbjYDbWd5riwyg5rkXxsyFdjZBIOf+PtSxAgimPRBCD421OAc6/QBikENDpJByRFs6fU9A6IYUudGBxqb50AlrChpkbrQO+ms//MjDeMU3/wZuuPWhvTz2Q9/3fFz7Dc/CMA6toYkYx6G9b9i9T468bjj4dXQIOjQuOweKRFKc2S3dADV3ce4DR3ejoWI8zDFg0yDwbMZ4t5fcn7naYPl74B2jcQ7JebF5lrt1aDB0jsZ52NuMQvixbv9ZB84Fw5CquG2p34Exx7MxjjXnqfUSG14dYPtnDMZ75/ffrfJ5f886p5rIgVpv1GZjI3oAdSCwT9lSYbqgiKcWX9UWq/15eqpHt+1kjmYtUaQMc26rwNxLRUJZw0Uu+F6c98MnbeA5HKCOhKMwi9GtsrjCYJULp70491gLYS1cuM/bXyvwrwX3uu30Ujp+si8PYoOCo3MvyFlrlGJxHoymGFYb8f6si8RKx5f39106gU5rmEQrgwKdXEjMS7YB/m4u3ZB+adAJouAUUcAhp7rvsO5jPifikugRHYDmDMQk+Wh26LPdK+hFOGOEuAmFbuBYraqTFZmhg883UcxFrW1hqN240rbhfX/Y9DPcNcahTraoEocrFZJOKYJshFnoHoxzDva4bFP9iSGFpg/SC13uu0g45dVdTxQl3FwAcm5xXJve1/3QH+BN/+4GnH98i295eYXZX3jOCVx04XmdlpS2XtlcX+r9c8un7sOnH3gEdz3wCK7/xF345D0PYc5PnkXc+ScO8N1f/QJkJ451t8+YIrZpwMEYMIwDhmGQ5j90gntBRPTMCUXcfpy6IlB7FPzQv/5d3PPQmSf0uZ950bn4L1/4LIQAXHTOMZx77rnyOdgnlA5xsFj9VPb+jFEY0OzQgzvEEAmqP18RAOxflPLn90PZQz7d8/Ahcs741T+4CTff+cBnDBrkSR8AXPvaq/A91z4bV1xxDBddeIFBeVCKNwUy7luyKvX3TQI3V9zUuziKqyRP89IgyO0Ctma82CRySG6lE6Uo48Y4xapkStixcgK5BagFem6wfR9AaIKAwElC2PdcrxZOFZGQ23qUn82fg0+jauOSrBgvK9icFplZ6A3cuFW9hNQ82EkBWFmOhcYThW8tQnBBPDZRhIktzYeVar2L+I4HhL0hBoAqChdUJCOs1N6bimvuoeDqTR8EQhyiazaoVRDomqCevnCO+iziRsZzJhSO/y4G3yjDlZxtyJR7yzLj/y9uGTIMoUNOpCifvQnQTLvFJuhJRWoGF8LTv9uL8sSO69/7lMMg4bRR43CAGyAKFarS8SiCScr9C4TDCmQrpV4lWEUCWeCkoRf/Y8OZVgJmAa7kHoMXNSqYSWgqh1mKlKgilc41Vsi8Ohe4+0W2AcisStJ2f4S9JkittBTeui4UlZJi/MHZCz3le1vR3O6ScYimfXBUnHOI5QVbEBpRsIJ9njNCa4bXid3iKNQBKD2TmeSm2UXXiJLZjtHF6BQxUfw5E0mkG/+svtYyoLLhTowC08aRfveEuKoquVpTsglze9VGOckuZElNAApt5SZ2d3h4Bv/yVz6G/+F/e89ZB9mv+rJLcNVVF9Qh5jCIKBdEzLPIxq7f5NGmq1r58bk2Hn/ybZ0OdHj26s/vERnqb+7DAiJjgqndK7KOoo2Mex2WHwVv77nMEDV7p3OoyrFutUkrY4PSc92dwkIocVkpsBcR0+RzGKLH2enDuQ2UHV5ULfGyNSAq/KZxTviqbp71z1WKVzwyzsMef9qLPy40XDfGm1Nt+JifzcLxbPl8cL2bIM+WmzUdFCnFoKwQBPzsHIAqf5vNF0Vt56YUr7RB/lwdIOw6ekDPE3cKFcwadVn8nnusOJ8ln3NzTdojRUR1iE5IL6HhQagFbAqT3JPqgkPEoQ5WYtQawgdOFPnLogGgXuCh6T05Fz26KHX2gVzvYNHncxNjXMW50VVbDjG7xMWbaf29hNfb9lH0EBSFGUJYDa5gw+MiNZXFeUNZaoPsdLk+n1eka+ncuwocbcQaf16KuOIAmyayXcVC9/P5YE5ZdfjIgdXcaMFE2XDjz7gmOqWn54TuXazjnG4lGufM56Y5E0tzCKgUAJSC+x54BN/796/Db//hp/BdX/UFAIBTJ0/gwgsvqAPNhi5BQHf3cmtch1UZZSmYc279xoK8LPjE3Q/ifbfciRs/ff+f2DJuOyb896/9UltSGHe/UcWGGJBCxLFNwrGDDVJMhnRVetT6P4vYRFbEaBaR0NAN2QDg+3/h7ZiWJzbYeP5VF+Mrn1epec84dWGlbhCRkN0ZqjoV1AENBR8VhUSVf2rkmAbNko1CYJ9ZKaMFgmyoi+ZC6gTJCCV3Q9y7HzqDnAt+/4Y78K6Pfeozig7ypA8AAOAff98X4aVfcgpXPfMEzjvvAhxOiymjLiXbZsIKMmkIY0AnUoW1xFTzU6a4D5s65Zc7dMrVHhXqZiI7Yheml24n2NUs6gwOslKFdwXvYFPA0Ik4lRWn1ocMy1I6iyQTVWJz0mDAefXveQlz6zkZHCuZFyo3Zyyy+V3NZke2Py4KGKwY6q2NchOzQPcclXNNDittMWLSwj9gTaNTbQKlSygn0GxycunsImuAejKHJEtCj860LXaSJkJV8zURTk0ZnhsEFqg1wZBWwfOnauj+Huh/y6YKYtMWg4j5tIS6tOTBQmxtIcRkTKE8E8tptoIqukJhOLVh1IKeG9o1L1f54a4cnhsSolkELvXdsxCrZ7inrBC+vqNonk1T3arTOYTBft/W4MfYi3PCsIYx2rt2u0wXWQth3wveES3FziQhros0UaZ8LkV2L+pU+mEPejvGR4vzzcgGkRv61ETpskEcCWms9pXJFPKPjvPYbTtY1PGcuBhj/Trbzh6zf6aMc20MuDEJK45r7/Md9uKc95PGuQm/0kmFlqgd+qHnCKdW9PNd+FbY0VAOAfeC4nDnxaKeoySq5aQMMd/sdmfw8Vvvw3f9g9/H+z96/1kHAK944SU4dhBx1VUXYRgHE/IhfNUFW8ueENtiau2ls2UsKHsNWqW8uZjg1N4Dt7ZmUZQ9dzKn6bOc515Px6ybxJ0lpd6W0nOhazHwbh5XcOUoCI6UQnNjaTKwpXRDM2poGDJDUD8dd63FG4emFAqkiK3BLcUa1QWYHFFYOm2M0A1LGOf2nPbifFVjcF8lCvfaiK41MoYEy7cVhdQPR6N8Bg4A5iU/ZpwPTX8jyKZTm+0un8+2ctuDkyehE/GOX9MENc4tn8uwJ0bsxflePodb363zuca56pFwkMszqcgzp1i5Zd2wEshN8lk4ACB1REUVlbah9CkVnjRItFjtchmiCIfe3aSPc6U0rOOcugwKXw8rFwGHUrfmWlGTxdFnSrPgfVlEF4u6KdO8VEcnEd5k019sCeV6DhbnuVL8krg05OIDib2hAmC2vhzGrWOMjgJ810lEOV0cuRjKC3JXkjZpwpwNgbosxVAYGudcuO3HeTFdl7W9sg6WKSpNpMNmk5q7BQyJMy8Zh7sFOWc89PBpfOhD9+H1b/gQXvw5l6EU4JLzTuDUqYua8HJBKJ0IUbvDmz4UHAGQFwpbz8jzgiXX31GXlgE3fPp+/OHNd+Ajt9+7J9D6eP656Nxj+I5XPV9qYD/YqT3rMURsx4jNZkRKSdCr0QVSs2usBemH6BDA70OBY3WaCSHg8HCH1//yO/HIbn5Cn/+LrzmFl37eFdiOIy6/+PxenwRF6pXiFDpBLNXv2urxpan4m5ZUtoWXIZUD8Ac33IH33nIXbr3rAWyGhEvPO44XPusUTh4/gHm0tHultME8ANx/emd5/Vf/4EYbbv25HgB8wyuvwOu+6/MRA3DpZcdx/MRJt/lonCa1/aGn9hlupQgNapdq5eX6ZU3PYLPHEzi6y0X1Fyz5n9GSbOXjp5WYVmpWWqrwT+Vfm2RDxlgGZijiwdtQCJIw55Z4VZ2cPLUgkG+D8k65EwCiGrHB+9slz4uobo+jbYVQ6t/j4P9McwGgfSF5yDGEOm3MznG2oQA3mtm9f51qEcSuCRABZZsKQxIv6QElE9GBzk1AIcdJPGupVrxjod+el9oMBbQNZaMuxCY4RXhsEEEfd5QoHRda4c7cSI9J+bDk6vO5OuUhCBRaRaxcoMQnhNO8mCf11MT34kokiVQY5VwH+VxDZxnYD3FwRJNVNwjA2Dy/K02hNTOzb3xY7KsWAv/uECsn0L3kg8GkODQjf5fxOc2loweouGdteptIaPYzxoa8g0s2zQAqWZeCrni2Ynsd52NElrgbSP9o22hO86l3wd+hugJH3pgIpj+hyKUY6/aj2uMlpASzY2Ock06wHR3pkBqPuQhnXbnYzvMlvNNdFdi4kdPKwZcLSBX7nHOT8U1q3wa1hpM4D25DFgNMdT3YtLuIUn+/SUAI4mLSizX1kGOHjnKD1XHi2wCm+jm3+6ZRcIhEOFwV1hwOxWYPtoiV47wUPPTwI/jkbffjLf/hdvwv/+T9Z81hz776XLzp9S/GkIDtNuGZV12EzTgghGj377DmbqPs8e0pOlohtHlPSEy9xZlHCH+mEKf61Ovv0Dh3IbliAp0xRQyxNJpIG/yJR71u3qlYPg5VxItwXt7/PF9LKdjtPM65cVUrMb7bw7Z9pkjozGFjhMCeffhc7xBaivU2lzUnLtY0ztl1JcaW97o4b7kmpoB5Wiwnw3QG4qPGuYsNFtOZUf0N5u/ebQSGvCHnezsGGZYGe6ZzLpZDLJ83Ad+l26T3g8ehDacPJ9dK8jhXC1lHN60FuUgdKKuBabTvlbtFCRvEvXxe3KZU/10BZPAVjbKX836cq/YMz6Rxv0U4jgOAjVExXYxwEevhEB4tn+uziTYQUAqqN8+k2MAQp+uFiQ/H6p1jMPcj7pNp5USg35FDVF0qYXWfWrFeiqm2D6lZW9PhAbWmQKhDKdu0N4RsaW5XaO4t07Ia9hDS397HbhKXGPggFkIjjLF+BtbtKE5/oEAlVCy0aa+oA00uTnwB9u2Q+Xu3G0fDkgbAoSApfeoCQLoAGzNHbqzjPBiPO8rlWmuPgN00V/eyIbY7TIRKp4xHHnkEN910Lz7wgYfxgeseQYwBp06ewMUXX+Qb7zak92Wa0zijCSVWJEFtIGt/Mk0zlqUOAZa5DaGCD9t+5/pP4P2fuAv3PXz4hAcAfM9QClODw6dhwLEBONhuEFOqdO62Jq/PtAkyroQXl5IFGp8bgvMIYVAElDb0+clffRduueuJweJf+bxn4AueeRFOnTyOg2PHbaBsyEMRdKzDh0UQPOICUHJPx8g+NLjlrgdx0x3347qb7sB9T7Euw5+rAcCQAt765lfZD7/88mO44ILzbYNCKHqFusG5vSLkw6FUNtgFOg96+nTTEoR8DZ9o1mKY/F9ym5OJ8hSzIiN0kcUYp8A1sWfspqaUmmI3+WQCsWlt8cm9ivmkUDcl5Ih1XK2o2gI+JV/bELq9XDG4OTd4rnhfzKO4tIM8CtcUAA62qV6qU/MbD6VxH492U2CToRs1TVYquLPmJ9MmiBfwTjmBcgK5weQQQ72RXUm2bVg2CcilGwaxoMjFhawOyTdNDpVTaPiSXUshG1wsGJQoCz+awkcptSlhURVrh7v56Mlt3fw9CqVltcVRayjdyhxVcB2lqMwCjHDcKlrTbyCIUjCERuydDlQ8ahidj66cKKDXMlirIGshySmsQnL1eTKeja9cnDsdZGOQG5yZca6xpRtJbtFpI5REcK40MUUW7mZTA7UR8zhX+5cgjhmMXxuKSSPtUN7m5W5DIOf5E1ZJTrc3JbRKdB4lhfW4GWSzXTI6+yyHAkejPNCBxba17Tsetriu3Nj6Z4ts23NTW1bf7nWcUwsDcH9vqrDz/B1OS1PM59kNXaxTu4NTd0LeyY0tpQ4AeJ9q4zDNjd7SkEBsJEy7YIEpwwPuYlFQ8MjDp3HjTfciAPjeH7oO737/PY+ax772ZZfjB777eXUDtI141rMuwTikLl6M+x+D29FOWRTGQ5cz1GpT6R7rTdUaYpliNCs6xs4iivwGpw6OFopBz6cjkLCilThlqle3DyLy+lhxrj7l7iiSTSBXlZe92PQBAK23HJmyiqumFxDAM4i2odR8LnGe670OaWLdZ7wir4hQUQegxxvnnXYKNWlEkFhto6KozbsKejEuO/P5WhyxrCyCec6Z32j1lwtk+BokzuNZ87kONZTCZNz1I/I5Qn+X2bBu3G96szy7GHq+OYeLndiyarDIZ2Y+50BFxV71HHGoaHdG2ReG1cFqRVq6XbCK761F/XTFSL686tiE1XBI0ZGPFeeOWstdnNu5abFs7klwupGh2wJzlrvQaJyrFaXXmY4A0LvJZ9xBnDa8bh8HHxp21L+4j6qw9yNIn9LcQugyMgjyyTRi2uKg/q7Q7D+D64g0pwIO3PPimlaMgaUNMMYhWq2zjnPWtayXYxKUb6PjMp/X4VoVRq5LrPq9Hjl9GjfeeA8efmjB//FzN+HqC87DqfNO4NTFF7qiR+eGkDtdA9YkHIyEUFCW+ufmacY0TzU+iayAC1cWB1Hhg5+4G+/66O244/6HH5tLf/FJXPuS5wp6QL1AQ6OfRRxLCeMm4WC7ad/DKSQIFLosSE040HQKKEK7NJWBjsJr+FsbaBYA/+EDt+Dt77sZ95/ePa4ec0wR3/PVXwgg4BkXn49AEWWoBkDxhUCE2BOytqnPNYs+wLJkvP/WO/HeW+7Ch2+/F3/e/3lKBgAAcPzYgN/8ua+0KenVV53A+eefX6d5hA3DYYdr1fygXCOFKS1lL8mo6r9yj9wqhwUGoVMU+cp7DWJMtRAZh4QUffNFDjxhpGxETSBENoEKgRs0oR/RwPGCWsTHWAsy5dCxqCU/LSAYpFPFowyW0yDw3AhxA0SRt9iKVm7h1NrHfcZXdkSlt3SZZ1dy1gvPeeLFbGh2c+8XS5vG1Hiqy+LK0oQqjtzgr4RY+sRbbBKsyYxN4Zq/yWdNd4ll3reXpF2lC8TANpBOlyiCAEGvelrQcQrJv08pmIgOOnE3mL4Fhe343KNsbsh3tC149O01p9K5ODKmiFqrwbVbPB2lIo/V1s1sVBqPuAgHlJDtaJu1xdTMLc7b+yuaVOnZam4IQTi00az/1nFue9biW159t+RS7nYLYoxGtSnCIVcIpKkEM66barMiUNxL2odu6i+rcb4u9nQ722+j/J0WgUoz5rS5b5S0zou6iO6IbQYTkTKLbdAP23+3757Xce7WgwrvVXSWNd5tWFAXOlG0CaKjrdo72E2ufg6Blyfho9MRRlEOOoHX5tViGg5D1jh32o2LBHKIwzjfTYe44WP3YF4K/rt/+G588GP3P6489rf+xrNx7WuvRs4Fx44lXHPNJRhsCODxX8+kNwaMc8jAR8VMtcHMEue5E+DDnjp2pcL0ca5noaNltAHXURZtRTYxxl1s9z63ohvxUaf2CoSn7xapTfV/NbjkJsjcPCR/09VHi3f3Wl9pvqzyuVITqPHjImSrOE+umk4xPg6sCWfWRpSaDYQ9ny3Oz2ZjNZh4pedFWthpc6k5kroY/u7EX1o2rmySUhNsK20jroKxFHPT2mNe1gOo/XyeYi8KqHagUe4kWgoyzjkAcKRZsFqtDhQ5rHJrSdde2M/ntknMxWoJHXaPggCwDW7uNZCWVYNVOdboBQMThQ3dxrgUdEsHjT8VNbPapi1R1kMa5kZq+micV80C2CCXA5GyqmNNkLVhfmhnCtKrAMQoNrFD9IF6zqv8gz17O1tIBHTvJMhCYTdlE+rj0IRoAD0btEAlLc/sa1v9qYsEiskRIs5lgnLFsw67gg9USXfVxY7aIO6mxRw5vG6PRpUoBTaYt3wmNZsPOHMb9Jbuu2pdNA4J0+4MPvqxuzHNBf/zj78fB8sWX/qsK3D5JRd2Oj2hQ8QV96nPMLerqj5fTBBwWRZMc7UbLHlp7yBIs1Z8uy3/t1vufADvufnTuOGO+7Cbj1aaf+HnXI6XPedKmcsHWy7EpnUwxISDGHDs+LY6MCQR7EVv6Ut6Wmh6bSWrCn8W16rQclLc0wPh8Xzre2/CW/7wBjweZsPJYxt868ufixAjLr/wZEP1tN9bevvSFGO19yvZck2t9Rd787/zgVvxH2+6E3c/eBr/qfzzlA0AAOCi8zf4tTe+vE7ixoDLLz+Oc845aVM/TmaDCZwU48TSs5y+jiyOqNpbIUcJh40/svbojea97rc4vdg34nFOrpmpkjcxriG58u28ZBxsB0tyVhhD4ZrBbFVG2ay4rzw5xmqZU9W7qdbLRoFK4Llte4xrWXorFcLvvNgCqBCdTfW+Wa00hX0K1IQOAlXEU7v4VL/B2pcjNxG+UaVAlPJhOY2fF3Q+tCX3GyJOlU1scZMQWtGy5CoUUws1f7aAFsqxnRvhvGLFBV4hR5T3rrZRmixUS4IWMZXn2vPmCo6ghTT9ANuwGp+yJv8kcF4WYywYRrPocSEuE9Jc8Q+zCI8xWZvQldjaUFxuO4bOnjA1Xs0k9ks5FyylIIm9ndsL9txgDoqoAUD+bhWvKR2Vh8xUjfNIa80sw5voUHgreIdgjhvrLarGuSIliABYpAnkoI3iWRQNYvwtueofgIJxxbdo1IkwJeYmMITSC1W6ZWC/MT3Y+jnOOYsCci0AhuZ0goAOSppbIR0N1hadzmJw21wLwBDMi53DDz7YqJY1qotAb9+ZRXcRf2R08Pm+wapDMy0Q2RgsRwxPOPhjnBPiXxsu97a3O3SM5vnNOF9EXZjojLPFOdE4ORcc7s7g1pvvxTQXfP+Pvhe/c92dTyiPXfvaq/C3/6vPRQjA8WMJV199CikNljr92YQO4dJpxBTXq8hZtpGtOVEIstIz1nHOe4p37Tz30OeCSv9wq01HxGmcE65P3q1ym2sDiQ6tZi4XFufB7neL6cURUYTl86ySu60illniPMZ6ls40q0D16HZ0TT/0Zem6GZNt4A0W3sV5cQ2iVkNQIZ55lrSFaaW4flQ+DyJevPaBp6grm3CNDzbARCK4fVufz2PwHFD/d3PfKU5Rssb1yHyOPTQHEQ/cvq4HAkbxyCoEt5/PbaB/RJwT5s76ig1wbJ93DcvXfF5kmcMh4OOL8/7ZrFEMMaBT7y9CYVyLHCrKTrWq+YsmcS/p4rxzu0H3PlVUVukmms9dDR6UDms6I/W+rXRVDlqKDX+2o+ddc5hA765AZ6fU4N0a5zbkHujv7hQiNMi/xbnl82CcdgAmwK2aVRwEmd5Ms3bluRrGaIPqsBKT0P/NgcCSsyEA8qpu1wGADkfV4jAInU7jPLf6Uv8dESTWuMtiSTWF8rLDx2+9F4e7gv/xh9+Dd773Lnzdl3w2XvOlz1EVERfPC1Eg9xSPI8rC6R3zvDTr8Rl5mTHPc0MPNyFzySUBAbMIhivabkHB7334NvzRrXfhvoddbf9gHPDffs0XdYM1PRMIsdXyEceGiO2YMIwbhAgMsaKlIfbLrLrcSYO6a6oFkKm+0GI0uhhfEQFlASO86a3vwYc+cddj5ubnXnkhvuoLn4kYEy674Jz62VD2tBGiufOEbmk8TTMeePA0/q/f+whuu+ch/Kf2z1M6AOAQ4Lu+6XPwmpdejmEIuPLKEzh53kkrXGzbIBsEWjdV7/O2DWqXErdaVcU8Gj+/agD0CVkvbIrDGKeJBdEgdn+lWjjYNjX29nFMEMW8SLOJ/2xGvzSTQYlgzRSCWxamFDFNi8FT1famU9gtXuj7JSUFB19iUWGRYkr4vn1xb/Iq3hSMf8yNY84FMUUTIHG/24DTh3MTO/Kt06bzjXfoHv93sIYLjX++n3xdJK+p984ZYysQtAGjmrZuavhelAIQYrUQZCJ23+uwZymkmxAmlY1sEZUzyM18vehCx7lmwUTBpiiN6GHjs/qwQLfrFfau1BYVI5rbcxtiv5HHinPsz871EsjpVZ6j+bKjivVF8XCfVMxPRIe4BR7MYqhqGKQUHV5v/O3mX9+EfphUGEtsmsl9p9UOCzbCx4PZewq0u73/wcSYejjkusGcWwM+Cg+SXHYWpmmlGqybZUOViL0SGwMv6Htf7yy2Mfy545AwzQXTXC0m14WHoleIhuDnZ+FSVhBU35AE8afOcm6k0Ui+ZWeRtIjitUF0W/Y9nOrdQSEzblBig/utKTrL4oJg/LmxqgE13nuUoQxMBDYvzv3l4IGaBd58RoOMLhSXJLc9+B0OBLOG1ThnsXv6zGncdOM9CABe/9MfxK/91if/WHns2//yNfjOv/LZVRPgIOGzPutUVUdmPMVgeitZOoec3aWBjQHvHRbn1GrpzjXW6MyyPwAo9dms+cypijaLSKdbYrJILytEGs8Mf049w7Eh4nr1d49NbyI5COCAfENKQBvacPhGb2QKUbpYXs2Lh7vFKGKa//icwRgk/zp4TE57tp6MczbeRBNpI9Zvi7s4l2ZKVe/Z8Jk7juTz7SZ1A8ONiL5pfaLUuXWcHyXESRRBsu2sIzz4XfbyOZsv1QNo1Ejmc6X2mE1iduE7UhwZ53MTxtMhfh/nRVxVZADAOkmHVcXvkwL4ndEoAOS2h0fJ5/qc+B75HdTvnsiRJXt9R/QFhxjrgYAKGZJ2oYKKReE5os8SSrNDVhvH1QBgXXari1QVni5m2UmrVz5nQ8IJutIAACAASURBVKHaZ66D89S6uKqjcZS4oJ9fswCevbk2+2CJc1IlGOeWz3M9qbbcoNVikAFEl8+dgsmlhNlDdsgYH55pPqfOl1oKWpwXR/Ephc/jeh8V4nk4St0enYIjule8P4YUMS0ZDz1UdWRQCr71+9+Fj9z8IADgW175Arzw2Vd0g4xKS0h7FDAXKHQRvtI2/zlnzMuMaTdhnmdHIKIfjmQULK0Jd+pkQe5g7sANt9+LGz99Hz5x94N4zhUX4sXPvqzvIXR3FQJiTBhjxDZFHByM2G633cafKFQq5AWj9lV9gxCFjy+oBtYsyxE0sLUNKgB86ON34nc+9HFcf9vdj5qbX/bcK/BFV51CCBGXXnBO56rS/WdzBKpnaMY9Dz6Cacn4F79z/RO2JPzPA4An+M+1r70a33Pt5yDFgMsvP4ZzT560yT0HAPw0hMhwwure8XUA4F7AzR5MIIGAq2SzWCSf7UwTTEli3zV0CaVY8aOcfzQFVi0Y0NQtOTUdmwiJFXjNrs2bQv8+FBErDcIfQ4Uv6XSZkDGDVxISKJcZ7RF9El72mrckQoJ22Vf2QmvYYkMRoPPOzgCiFF7mP9824nUzG4EO7owOTgVpNomQUEE9tZqxlEjerGwXyDfURJHaO6fXOMU1Y0C3mVOOvBZxfL4Urplbk4GuwBVBpqANng+lMtWczW4IYjtYxJrRleYLFBIfmvCkiJ+138GzYzoPKpi1qMJp2eNNU8VWp/AxRQTkjqc7tY20uVxA4823XowRFkVmW9cmv5Uv55PgocWO2hFyAKCcyboFhXnL8nPsJonzNsxjHE+TC5ZVP/MFQaCoVfuj59Mm2YTCCvC6CeTzUUhb6QSutBgKZslFaJkVWu0KW+zeEpGiVHlyh7vZEE+EXRKIbbHPwc4KqcKYmUUFmxSKGFxYjXDRzSZVIaG51xZRxWsdOvWDIVgT6JaQoUOguIhgaNtm51+qcJw2Bhz6EWmwv0Use3GuNkJG1RJeMu+jPs4DTp8+jRtuqLD/b3/d7+Hm2x7+E+Ww5z7rJL7yRZfgm7/uapw4kfCsay4FGnqiPlu/C7k9dthw20yIrZUV87Y1dzE/1Q/gxpaICD6r3ETz1BGDcF/Cg9cWX2u0XIyxg6VqwxJa8c9mljlCc6DG+WgitHX4FoSn7BBjhSZnF/FN9WXuJvdOn2byfYPEecDG9C1q/mLDSx74kDyetcHdg/XbUNafN6ksdViWu+1xdSQpjdrhz1ch3tRC4KJibUuo9xRjYlnFeZ/P0em01Divz5VaJ3QSYr1DvR6zuoUL/+3lcxmYpojV9nWf7jQJvefR4xwd0mBZof84PA7iAoEj49w/03RknLteUFF6CPMF0FnBqj0kB6F8bswDCknWfM5GUGfx/HnKY2d+rpTL1MW5DciL50qjotDeqH2AcYhG/yCEPQhsnXoE6gBEKow2bKpFwRpybW1p9VnunbLqPZ8N5cd8nnMwLZYunwcc6UhEWthmiO37lO5dRVnMHVrdXu1ND6fFznVXtycjlHfIsaTCl0ojLK7273FOa1aPc/YPfA6zaHvcf/8D+PgnHsLP/quP4Zd+/eM4fegw+2991Qvwos+9sqOAFnEdMEpmQwC4pR5pMrnVjXNFAuSlIgHoAJBrXc7mn2YJGcDQaoiltdKsMSsdhEKi2Y5XlicUoPaUATElDDFiEyMOthHHjh2zDb5SmChmyEFvCD6IC6H2D6RUaM7JZWVBa+PtVcfe/g+33vUg7rjvYbzv5juORAVcdO4B/vpXfF5FiseIi08ex5CG7lzagDsEPPjgQ3jgcMJ7br4Lv/vh283N4D8PAJ7if178/Ivw46/7Yuymggsv3ODyyy9eXZwyqWwiOPNSCxzd2hMuuxSYYr9BXgFrFA53rgpKuB8Pbha7mz0RoFy6bVuRRoxNvnN7iszSghVyoam+71pzghX3XyF7i8DZN6OLK3EbxlfE5KF8Ld1mF9sSevHAZsx4kcEhheukBfRJAfJzyV0DqpJsXm2lFf6qtk6EmeqzU16/cx/jis8vmg4ipEU/VnKWgnj2QpKbCtFwMECrHIjGgCZK/mzzcF7xCTmBVnV75+I368DY+0vH0FvuEOaezXIvdVSLIJtaQi/JKVxEwK+etdJDaZUvXdBRbdD8wk31WAdNsi1a0ydUCEv5zZy423cPfjaSbO0V8WBcrKjiR+hEi7h5mVeevhQ1I3efcZ6bKrk1tmLbGYU3XjeMQTiapdNwyCK2loYKld2Pc2+yaEPkNk/LykFD0AoIXUwCMEoAxUk1IcYQrPHVOM8NA8giDui1L5TmEFVgqH0ePnvb+i65g1Pz/3dh0QYTlxfG76yQf259OczqvMQlzjk0C2eJczjKsj1f4SZGyN3L76J8YRfOGoeA++67D5/61Gn8zL+6AW/6Nzftne0/yT9f8rwL8ZN/7y8gpYBnPvN8jJttc8MoHWefaDGFOmsjqEKizFm0yIqhWphR2Ih/loMoLW66OA+92vlRca58ZnJ+q+1esPOxLMXoShTS1AZxPkucH53Pq2gkNUPqXetbXdXB8Th355ZNG6QznysPf20dq5vPLses7+uWS6ntoVtSjXM2u0fFeZcDZWiqcb7dxEeN88fK52sLRCpc13wqDeTSiwhT3AyAiyHKz/XBNDrqBotuRRRpPqfTgmnn7MV5Fks3bSLLXtPe5fPi50+HZzwLqnei+dzOo/wdrM4Cm3H+97yq+3bNrWKdz02gNdbvuuRi9q1rekAWdxPTAFjFuQ4o+Dn4rI+ixgRgFedBKFV1uFCpg/W/+52uyzQfmOr7TskteTXOmfc9P9e6j1t7jXOetTUFordtVn2jZt0nd1ySun3LfD65LligPaxQOLIOACTO69mMXT5njFFQt8iL02eb2rKB+elwt3SaBiHUnPJT//yjeNO/vRH33r8vVvetr3oBXvjsKw2diaKK87k1y7X/SD7FamiZ7NpIoQ4I8rJg4iBgWRp90M9NBk3r2jlDwEK6s73/bDo0aonHYUMnxsq7YxgQQ8Q2Bvz/7L1rsG3XdRb4zTnX2udeXelevR+2LD9kE7AJthNCTOJAXiYJLkhCQ4IhJN3VCaFTRTXdFDQ09IOiOxgaGipU0XQI6SKQSprEdsgDB8dxeCUGA4b4EeJYtmzJtiRHsmRZlnT2XmvO/jHHN8Y31z6yRRPHknxPFcT2vfecffZec44xvvE9zp1MOHfuxEfF3JFaJGxSMWSSpHNCa6NfgcsrBglrAJGQBSffJ7r0J2NbfvCjD+GeB4/BgBffei2+6iXP8cvhxosXUOy1eu1qwL0PPoK1rvjXd9yLt91xHz7Xv35dAQAAuP6aE7z+e17ZD/xJxnNuuw7zPEsURpODv7pxWI/g6EgYi8Zil9/W1bxMHamP/HFuOSLL2rVT1mxyA8ktLbf/fE3cRu49YxZOBaZmLKXcI2FS0I4YOdQZDdHs+CXV4vvwEmTBZ2RbkkG4uypbY2+X5LIy3gtiIBSaKw5FTZzuXUsrZnBrjaFITavg+dtRvMP8Y3QK1oOsMgZt0lica1V92kiR1E1RdlM2YxNYckO1PFjKB8igoEkSmxUFeI6arBbP3TRlo9yPNPsm0UBsaLLk8abcL9+tFbJS4aIBMsPDgSKZ3DkVQp3XDZLm5ZJCSlq7FgVuVVehW7I5nKfwA4hNBl3rszM+tkNMjwZMTp9V/TKR3pwjJqgzRTqlE4LA++cuLBn1M6CZG7d2JXdTmnUZwY+zzvl2s5nEgIgmWBxK+PvpQKTnnDS1ZTVPA9Eq8+4oJTZmayUdmNrQ6nGWIXfoIBCHFnpb+IYe4a7rjZV6bBhLhI0sjSIHxTujeTbmkTznlPQszOht+n4mB/o4BKqWsxfluCc1Pzm2A0HB9Q1+UYPTHIZB9udqlKRGhQTC9HUOOmOJC92e8/vuewAPPbjHn/+ed+Jn3/qZKfJTSfiSl1+P1/7Jl+LSpR1uueXaaOoQYKxuu1QrXi35YG/38rld9rulb0yy5Ja3gbUG84LwrXdJMgRWA/ri5/IZ77GjxVlS4znvTe/JrmxkbuppADfl8nPewswVbkAW9xKfUB2C+hY86NhkxyzLGkCR1GPV/p6lGeY5D+PbT3HOhSo+FXMRr81ZL+uZ5zzq496lSCnquZ1b1d3zOT3ZFR8iuGnW2lbKSK3nNphnlvV8m1euAP/2nGudVnPPAQCQjb8mScTfh5s4aj1fa9ylyg6I4fp4qEjCjoLUL12seD2X+5YeCupRon2IshbrGfV8nvIQSax0+60pHu87AmLb50zfR2z+PUGf4Zy7gVz/HQ+WNtC32s09OAiWrMIGgJxzxgu6Hw22qQ1toL7D0jLU5JcCItba/aHasG3xvDmeZ1+YJd3M5y4Jk4XJOiRThVRCQc2Sk7PQ6BGghtcK7ug5p5RloJ2nNHgW8f7Rc85ySJ330Le7N042in0b2MCT+T9BzmqvVwmffPRR/MCP/gpe/zN34+3vfmJn+D/yFb8Fv/VFzwqgrtELonqEakoJ89wH7Jy4kGrBGGj97x56VAhaq8YAWAB0xheNtzuboG/zC8gOMKmtsQz6+1I9Njg28M0M+sRNI3XZIlJGmQrOl4Jzu4zdyYl5GCSfx7BJoYC9FngscBbqvwEWFgHu80eK7b+bKzcM7FNoupZJBSb7+Xfe9xDufeiTeKeBAc+9/uIA5u6mIpK6hsNh9R777gc+gctfnwUAAOgJAd/29c/Dt/ze5wEAnvWsC7j22kuBerdOUuEWfCoRRbK4Diwus2lKkoltwzkSTveLgQfH5kzUVWXxD4htXxVNbmwQs2lQubHpVL9+QLumV7cBnTq0mhmN0tKgkTNWbE8P4aYM2fh2F3s5pC2Mv2jqN7AK7BMlbZpxhvtDi5g8+/nJPAoSG7bWZDsR3/fUssR3NHZyk7j+7yHDnGsod4wla0571C2D+hpwuNR4MHIq2PAwFihhNBPbZv8SANjThGnKUaBNV0fjQDJDVqOVe26tfG11tcrh0NzZnCVOJo8Zvkqnq61fYIN5m0zdTTZsHMg8m13SJg4rB2Ir8A1Dhu+Bv6uZxjUzmosECQy6TjcBREMWayJlbWhcFQcOHy4t/o3bobRpuNjI7qzx2NJMD0v4U/Bslql/X/U42GZEh5QlHZ1zNqmHg2hHgaMtRrLi2WT4WDdnl07bjJ8L+nsYXJ3sJvMkqK5xDwlF76i7zt5ASHswlqVityumlxtN7Nh0aVySAiF875JRpeOcF2fCDPrwHFQ+BwjtPfH4JaM6rxKz2f99AIFdspTGc5469ds9DTasKm54OvCVIwkhxX2z37tdsn2vfhfOU4/HCjNQ9aHo98vhsMcH73oQjzyy4Nt+DSj/T+brqgszvvFVz8Z3veZFuPGGE1x73bVDGgzvcjUvU4qo07+tvjSRNQHwcx6RfOFLEf4kSaKtQgIXkW3hx9IB5NGBndTuaikxq9w9yTxxOBRr7jdlDcradOrzlMPzxF6/xtVxA7nfryhTwpTZmAMpVQG8MGjVp1LcrEvjx5oZYOoAvI1L9eisQQvMxIPkta5ZnWwDHT7AJibLLBs/hmZ3Z8+tr16rmrm8r2vDNHegtWLEixfR748ARwygBzmf+33/vM7tim/UdFBl3C0wnnPeZeqRstY2OOY7oK9eBrtsPiGRAqD1TWUvPOfqcaTMA/UwOKrnc0hjaOIW6SbJ+6fW6MIfA3TOmmFv9bw8wSBfjqP+loPU8zTWCpUpKpDXY54jKjb8jUZ/Ak1gYR1iv9YGM0z4Zl79VugflXI2eWQ1ttUafawYMxcB6PycWwRfNQCaxtBZWCRAGL+Gp08OFmtt9jzDU6XaUT0Xfx3KT+2zKs5wCHAtWInBlKF0l7IGreeDyeGmnsedpgkyFr3ZRpkgAJwzwJM0fb5/PXYY+NGf/BX82Js/hDf+83s+bS34li/vAACZF93/BUd+JgkJZS4oubg3fgd0q52j1YEBN8Jtq3/WrVa/G5dasTRI0GpnRvtzapx/Z905EyC530AfwLP5rPW6Ok1T9wGYM644d9L/zEBpSmKCKSOJWARCnVzZEFkWW4aVJNfwOdhIkBixKyFQEcco99pHPvYI/sOd9+Lt77vnc8rF/2kJAPDra195C/78f/MStAbccvMJrrv+2n4hGd11WUcd9LqGOdFUMFwsqhvrud6xGaL5y7o2ySXuG8yIqakIQ4tAgPt2PfQj1CHO5sgahXga6KhtQ5939ByhfUeLS963mLItpaOpOotzwGli8JdS5Lom2VSzqdhNfSAmUJHE7X+/BL2qa7qOt/GnbrwV1MsxblB+R2v4XG94iExiPdgRdaiGO2RS9Aaprm1IMUgW2+emjTVyaflz2Ej3rWpz2v82QWI08qEGL5zxdXBySmsyN1sbFtUxWAu3bhHUoTmeh6Dpc2mYpcFU2rm+tynHBlYlHKSH94ub2tXxgKuuX5/3s7SLavC0bjSRSTTirY7nkz4WpPZxSCXAEM189Ri/XsQMDBHnfk9loCRAzrmae8bfLSi5jXFTopnXz1vNHxnVpl4HesaiGaoBoCFMOxW0iUikNmzG0UYvCz4zqr/0+8aTFOScJ0iuPDyWMbYt8KFlf+g03PMn02AsdSo/V80MGcfYz/nqzT2b5XkqqLW6w7rHlLZxg3M49J/F+0PvUpVbtWFwSg6wsiH3c+4yE0lHAX8OZU3J4yYff+yT+NCHH8H3fQYo/0/m63nPvoCv+7Jb8K3f8DzcdNMFXHnVVW5U27ddbbjLec4D+4tnj/cHfURqrV6Tmm+1OiOunnHO9ZlR3w6VOXF7TWC6m1oGU67HaIZJ2vacB1OrYbJnRM85mT79mWvuo8GaPNbz5M+GJ3NIpOVUElYDiHfz1GnEjbFVwbByEzaRy5BlQ4nZunF934tzfT/nbTznVcDZT1PPuQlXo0Se82RU5CzAHiNPl2VsZmOQDfBGExN2c8LBXue5kzKwtvYSCVhF9xr1vEk9T0f13LerEkWqDIDT/WrnPEuMGIaIzkkMfwlOEeAPU9U2sC+X2jeW23rOu5E0fZW0uOnhxvCO9aJh9H1RSRQ35Bo/WTe1kHWeLL9k3k2anqCsqdW04rz7t7IEZWwoA4Q+BFuWAuv5sBV3J/oa6UOyENJ/m41l2aUDaajnWcyFXdNf65Oo5/E5jkATfJu+rJR+9rg8redRA46lhL1vD7bAzMUQWYfi3xNyCYKE2Y15KQngcqJv1ANsSsnkOAYAtNawtkDR1rXi/gcewnf/rXfjB3/ig0+6Bvyh3/ESfNGLbt1IfZuwAJJr4nOZcLKbUEoRv682TGStVUthMnPuBBv+V9TW/28HFiuWCizOKvbYAgdg+9msxsJqXg+qMQ1gTJQ8FUy5x/7NKePcLuOceQDQB8KlA6xJYnDI3tkZB0eMmw42qEzC5w1lirlfQywsBiZtDrZz+Ff13+3t77sXb/7FO3Hvg49cnvCfygAAALzouVfh+//3L8ZUgN1Jwa23XotSig9QTjc0ilm/LNpwUaqDNgc8Uk1J8+FQpLQxUrAmoa+NdLGIpTnZZWnIemOcfSNl8WF2ebhhyzbHepMlutU1ebYn9U/c0hktjsjbOgAjach17Q1QGIgl2xiQqeAbWjt7lA+kdHa28Vb/zNcQlMkowmpC6I7z7iCdB4OQtqEIxoA2Iro+rDW4FrGZ1hybhisaHouoa7FJgmrpzN3aPwtDlZs0Ttuta2TOYwBZiFASYXU39BzGlOHELXo2oZ7njVYxNvXwLX8SAx/dqOfcnwtu1pRCyvecUXjqOO0GRJsBubbmTarKJCgHUJqfxpvlFGY985yHmKZFKH306hhofdYQ+Fn1huc4uzrMckYzO5UX6OYTLULOeM63/hCqBdzNalIFk4XATRl3Em0XZjbjOccTsAy4v9fsW7oU6+fu2vYVA+Mi3HbHCEs+c/OU8Pg+tqb8Ox65KhFmOcfGQX02+HvwnHcNZ3KjnGIDrdPsZokHS8pWCTVgFcp/gAtbsyq4p4FuGD3myZ7dfp8k12uua8NH73sADz10wP/yN9+Jn/1Xn11d329+0SX8ga95Dl79Fc/CTTddhSsuXNHPEMG8Es1pDHZhSFUlBUfPeaFB6aFudMbNHNsj6cUTJqwR43Dp55xa05yPz7nfDc1lcD6M5s5OCLNIOTybz7QMuvS4S1U+sNao57wPB1ZOO5Zf5Rwmf5T25E1ygp7z8RxG27MbTCfhIMT2nHOrrX3BE53z43qOM885ZWtkJdBTh6wK7sEIgHPzynM+lYTTQx200B5BKnKoRYbVJ6rnfE+mEp496tat9Zxg0Vn1XP081NugboDqJudd6/4wsG3qObfT6nGijM2SuzRSH4JPX8/HhcWo/49FjDMFUwAkscVv/rq1Tm3PuZpUhrykOUA11vMwVfU77gnqOU0CCSiFSSeE6drZZ3XwiQrvpCy+Lb2+5O4ttKnnAytyDebH9jnh50mjZLJ3xnre/R6YXqKyHJWRztoHJel9HKCMxY1S2cdzrgbhyWWee6ODn7hxcu9/H3zwIXz///s+/M1/8N7B4O/JfP3uL3gBvvplt3dGR6vgyou59B3kLQa0JOzmgmmafaBtbkRM9igZnLUzwDz1ZjUQbcFqYECrFcvaU3YWkR4gAck8BjhkV2EWtHVFs+/dF0wZOXcJwLlccO7chJOTE9/8qyeanguXqMpZ0HhZspJzNkP1lDZMgObebMq6qq06iyW7MUsaDMvDaFE8QnLGv73jHrzlHXfiww88fHnSf6oCAABw/lzBf/kNz8cf+frnYV2B5zznKlx51ZVuqqTGZqqPW5bVtTxq4kL0lqiboqzFNb7VEWo6mpMa7VS1FMVpNyfXiXXaenYqdq0VJ0bVXyvdoFvkhdvGI3ThOTQzdlkTbVWjrr3R7Sg3aCKN4EOu+qF1be43UMVNupSeu6pUv7SRD5BmnTexc0eGfIh4wZxG92UWJzdXLNzcx+fTNxFBHe1RTdleS8JhWYfNYugXj7cvtTI2cNy4NInOKoyxSpF5Xjd0zJUU8y0ljZtuoZaxkDk1eksRbG2Ivwmku1PjqlAVtxrELcV7WTHoUZXWShSXxX0bzchIRTYySkPe3gD8jLhtb4MOd6SInhW/FDFJq28U2obiehY9lJQ7fr7qFUFao/8+3uyP2xTdstOIsdOIw1yJr59bR57zyNVOvuWOPPqIM+ubQtu+icwg6IVh+NjjMNMQw1iFfaG0y2JgnSZl8ALi8+OMkhTFjp8tmR90bubGPDZ60eABwfxYVzU5i6ZYm2o2lkXOYZeCFB9wyMApJVI61C06pVEnXkoenLgjmze24Dy7kyQ4kIlBCVYH2DKWw4I7P3A/DvuKb/0zvz6U/yf79covuB5/5U+9DJcu7XDjDRcxzfPmnMcG3em/wj6L7OTxsO4Pq0QzmvO8RLYtS8U0lw7w+s+rTt3PVl98EBAwciUjTu5QskhaozSIbBKrgYPpAQJsNCnbfr+6j0tKof1kBSAgwM/efXnyuLnllp3bSW6J3ZHeNofzlIdzTrCDjBHWKJ5zGhwyeWBvUWjH53xzl5Q8bPIpJWM9J0DoZqF2h9D/QDXyVT6rLKyZKr4ZVUxvs4A9vJc1kpRnuRs5jpe2GrQpQKoN9RPWc9nWjgzAMC5mfZvFNHCo50PTqX1Bv8v6YmX8OXzNvDMpj5s2AKdGw1Eao9TiKacjUIlMhEnOkNbzKvJGpZ8zUnKt8M8XG7Zd23gaqWTOhz2MsbsE5Q6HLiNjf7Iay40gaa1jRCb1485+lHNSN/V7bXAJp7LXdLgDUtRzk7EkBfW9nhev1wQ1qcuPep7OqOfVAf1kF5ImE2RhRxwW1evHZztPBcuqfXv4b/E1njsp4alE5or0Kowl/sQjj+IHXncHvu9H3vf/u478rt9yG770827D+fO7IQI1gX1aNTAq+e9epoJSJjFnbcNQ3WRITq4KaP55LGtnATAxYFkrlsXOP58VY4T1KN94v2pdj3PyCLJOpacA7AquOH8u5o+Ndw/vjyagmkoBxMPczRarGRP23qOapDgSEibzG6io4C/qgN3a477pIQb/3PPgGxO+AQ3vu/dB/JO334E77n3w8sT/VAQAXBLwZbfgz37HiwEAN99yDjdcf83GrCUiJUruxaWbbxW/4PjrUPubc1BXTg+rRJE0zxz2okKtc21BRReNcTYaEjWpDZG5OhUg8kSD4kst2rz5maSGwrZsI9oMZzvoz+2Xqmr8xm00NvoabpjpwO+avExdIIYB9ywTvqDjJTe4IXuV//6wWJyabd6pT8vpOFe3bvSGRLpni4ehmZo2FNSZDeZTCKMqai7ROlODOcCQLFkdkDsFt7nfAh35uVlTwGM1aqLGFymVbJGtPYTC7E7+DYO7b63Nt5lHg79EvTV7n1slVTQ6jKCCw9H0TnuHAwKrGSoljYHK4S9At/BtTBI/7576EBnMKgFwTTn9LnIaXIK7XjudAQBU16Z3LWlEIo2RMKFnK6kbCu73kW2ch0iZAAvcWXylU3ZvWR4/XcwbIg3U/rWGNp/nnD+jVjgVmM8pm3fS89Vzge9Z3xwmyYzOoeMv4e9R3KUfQ8KBb8d8QA9pT2ttoN3yL/Gcz1PGfqlu1Mh0hpLMHXjTmOY0Xv+HNTxU+qa/DmkG+0PFuZMJCbLx35zz7pWRTEOZ/Qy5JrTE+9fz3jtoSlbR2pppubMAcJFCcmr54Mv+cXzwro/jh//xXfi/fuiOIwrtU+FrN2e86ktuxv/8XS/BNdfucM01FzFNk/jcwLeItVZnevWNLzfjAtDYQBX3YzOKbwBNqxmjxha0eb3je7QTL4acMKR06L1PlgGcxdEbuL6drcakylDmKs/5zkzJ9qapn6zRzim70VUTQDMZkOe64zJu8jhETOb9UGsH32nm100MF/eG0LpTN7Gm9DAg46bW8Cbh1SIwXgAAIABJREFU/U6JDM85axuZVn3A7b4ZkxkBnlXPS1Zd8RhL62DPAP7gTBYem+lmoMCynlXPFbA2n5+EM+u5RhbWDS18f4h6vriDfn/mDtSJl3TsH2AMD961Gt+69agg2BOxo83vrV4fwjtodTbjGF3Ic7AQ0C9hvuy+IWnUHbt/jERHJ5caRFxmLGxCqqBJGolywNqc7QhE7Jl7oMj/vmX4bRklR+d8zujBvWF4zIeEG/tg2PWoYsZDckPOlI6RRRY/L+dYGrgMruSj90LBWgX0d/6+WU8osa2jNAkBcmKM+U0SAVzd2yG8oBj/yPhqjw6VRCBGY6oPAX8GGRgNEUPIWo+24Ed/6n34e2+4E//qFx/4z7rvX/a86/HlL74Nz77h6jDbqwp68dKPGj/ZAqs/LwnZgO/ow5lqoK4hFamlwV+gs6t6ZGCra5cn291b7d8fKnz4rnU9g/HbBJRLmErBpSt22O3mkC0j2MmsCRBAjwyaWsN3pf/9HIDIYGw+LiHDewNHaTdtk3JFCUET+aWmsSUEEwEA3vWBe/GWd34Ad370MiPgKQkAUBLwfX/xt+Fkl3D+igm33HINErN+GymNQM6xYd/N3UBr2BKm3vjzIuyNFvwiWaVpd6dYj55oTsFspnsjTZaDG7XW3PDnHBcmmxKkhMceX/oWoDA+bxzS2aQws5wD6cHWv4NcQJrBrV5sjMtpHtMRgEI4n57M4YgcBk85NDpiGJR8650G8yl37Ta9V2xOLe7GqN66nSCtb57zEHWYrcBqXmcWHwBFsqnZThisEUVHtt2uE62OOELq0mmWddhQ7OjGjhZuxfM0OvBqFJXmmDO5QRFKDqIcBEnrTKKbjM+YXgLYIPJiEiaAD5/R6tu72JhsY5Cya/RUDx7JD970iCu0b3r4bzZu0izq6u5bcmRmr5pZj5Fin5DcFZlDoGov2aixIdq6IBPsoCaZOerUELLRctMyH7D0nAftcJsm0BvOoOL7FuxQh/cXAB4/XX3ztWzOOb/miQNTG5qosxp+bBtJbogEEKziN6IykvGch7Zan9skbtp8Hw4iq8kpIoUIAh2W7hLvQArScM7VcEnPeR+cVsxTcQBzm81eW0JJHfCvotnmYJiErXL//Q/h4Y/v8T0/+F780E9+8ClfZJ9/6wV87Stvwbd94/Nx/Q3ncPWlS2LuFpuZ4Zy3trnhMObFyzZX2S0EX/l5jdTZ0PPqQBIpNhAn9ONzrowqZbZV21CqBpmsNer4KRVZK5k34them2ztqzi/9zQEykr2h9WicotpYJsPm72er659dm5QzmhyjjjgqnQweVRYE013chkQ63nvBZR10I48UlxfrrG6n+acn+VK7/Xc7kL/N2ZazHOeUuiYmTihkrWzz/loOFjrGHdKo0PX5hvLhIaUZIkcFggLD8NgxTvKkyjE/0J/rjv6H9XztqnnsRVdbMBX8Ge1n8OIOdekY/QdCkZRGpiDs9Q+mt7q6ygleZziJOyQ/l5HpnsVsCLqOZxiLrfZ8JyqNIzgkQMaa7DGCP5oD8nP02WINSL2UsqDFITMRY0lPque93i+ALE0alTNnNXgOiKwk0Rbw3qf8EZiEs0829ld2yDhO4iXFxBLouLpXREhqcbV6j3lYJ7Ucr4nvedb8fDDD+O/+9/+/ZMy+HuyX1/z0tvw8hc8C5euOJGx2tg7GSg2CJO11wFGixu1+L1knjw0SiWIwIQgOMOueY9Kan1ttQ/apvk/LIv38MvSN+xrbVgoA2A/1MKo0D1LSsHF8zNO5rnPHqmhW8i2Id6Yz24zM0O0JrHex6Amlxd67zg7KCVfcjkrQhcfKZYucB4xzFfAuAgtxXlsFWpJ/djjj+Ft7/0I3nfvQ3jHXfdfBgCeagCASgJe8+rnokwJt956CVdeOO8FpHp8xUgjo36tF+C4vPWXdNf/TXyYok1kADRNASAVzzVytq9MzY3LaNg06rXGQYAXqhZBd8NMsVlw11hmp65j/I6acYSua4zM0suCw3eyVIDIRz52TMZGS6NaYW4qogiGy3nOkWdcSmyEs+Qj872JvN9RU8n3ughw0WRY4zCtqCEvwdDLjwi00iVj6A8GwMH0lHzfCEhoQS9iptQkVkq3ORppo1RfpWa2TVqgbu6aPcu9wcpOA01p1LaNDUL4UEyiC3dgyhoXN41MGPSGrYUsJedxqwxz+9VYH98gU6+3tmGDpXF+YV4ZhlYDFVJeT5UYK2yGE40WU2qdJkCkNMassYkhK0ffb30fs5x5PTuthWs+B6Ji5mkcDNSgcRFdtz8P8ho0Fi6lYAzRL4RnYmv8RdZT/+yyo+DVkwXGAsuscTIi2HgqeLg960n8RhzoTCFPAoLZw40KAZxpCmPDMbO8+cDf/23QG5OYWCk1lX4BvVGLJAE2GOta8cG7HsBjj674E699O/79Lz29KH0vvv0ifucX3Yhv+8bn45ZbrsTFq650udYyNKuMf4JvaruJ1+oRnn43NTXwDMaGMo6yD9uQVIDsG5z+rCcx+xtBMCCo4NllQcFsY0Pb60+YVdKUlznioaUfTed08K1iSMfqzW1gmL7lMw3bFqnn7gXu0oE459vNetxFyRcItYXRpw7R6+ac8/WO90YbjHxbkzjPnB2o09jMwVwLuiTAMCTzfTks4vEzjVvy4zPehoqjNYqfZ5GMeR0UV2H2eD8lUkCVLapUS+s5784kkbVaz9PgI9F8UH+iek42RSldqrGaq3xnjXDREHcXI0WBYCFMwn6on7Kej5+Fgis4guhG+UXcw2mUZTwBONBff/ZzPksM6vac9xdlbu5WD3Pa+hDpOSb1WiQVEmlIxh5BsCT/f2fNJpcwdr36pp439kxtiOSk38Faw6+riodPEukB6wV7ymw/wL2rip4lHLFV/ZynJGkYeZgVppLw8Y9/HH/xb74bP/RTH/w1Z4696Jar8bUvfR6uu/JKnD9fwudJokKbSUOpiy+pA3vTlJBz6R5oJXegSLblzeSzHLYZh6Fmuz1uz4ZxG9d71GztzL3D6glj1aLEG5obWC61YZUh/doLJ8ilxHIwdQCgpHxkLj325WHcWNVVG7F8aWIImGkai7H/aCkSdVQKjAb3utDowNqq9UXhpeAggb2Axx57DB/52MP4mXfehV/+8McuAwBP1Rf3Va+4CX/hj38+UgJuuukE11577UDpiHzpcZhWOnZHKelEurq7aDNqsBvvSMQai0ffaK9uWILWsLa+oeLw2MT44rBUzy/vr6FHEZKuxEvQL3aM1El1tYc7XCfM06gHostp3Wj1So68Ux1i2VxyeKC2qjWL2FiDms73LajQkbzAf6dUvdoCjeN/h+jtkngKBNW+ePTiYQmn9bVKNjyRclKAbBCd5iz02TDlGRzVodTFcBEmikzK9m5XeuJEC21REk0cMOrck9AN540L8kh30zCTrR7ODGfWGLrpLdGQfPhRQ5QstEZNgig53E8DpAhN+lSOm9auPWtH7582umzu2MDz3/rm3WL/1Exw0GLOdlYEZPKs6DpmFDdEE6SNnm7GWLC4ESCzgq81suEjFaDkNMQKOQPAigyb9GLvB0G17KkgEQPYNp/v4F5uQMd+v6Eb6qAmuko26jvb2nEIygIKNAE1l7U6Rbm55tRi+MwFukx8v7fmTsmHO4IL3LbCBrScIJsVbbQaak1DzBmH9t7kJaFYxxuUUjetGs85TLeZBb3XBpi0U8bX1YgDW4HDacXj+0dx372fxI+/5cP4Wz90Bz7xycPTtuh+4Uuuwd/4s1+IS5dm3HTjRUzzNGyL2cBBtvY567MEB854npqBcRxW3O8jRYqGLWfMUKn5md6e80UkK2yoCeSx+SIdP6dwbOc9WYwVQtd7ghzjRijGWZ6DxZ6bk90UQKUBxnrOT04mrAbEhbxOJTzZ3bO5ffPYN6tfWsv8fGG8z33QzHBAk6xBmps1JLBkK9CwrCMzTKVV0yRJM2n83Oc5O6BdcvKUAg6xZDhlkQppPXeTvA0rjQ76Ws+zGdmplK42DCaBzmIrGDK2e80KYJj3gH5vgvIpQbxNLCll8xp51/M9UiM4r+cIQNbveDeZo68DBlkYa8pZGn2VA+7kc1I2gtLX+R3cWymHdCEMcjF4RW0Th5L4SrF2sgbwfnSA9AyfpREcjxrITXNnVJJRUJ3O3+9VDEaU1OEXemilHF5BYjAbd7GATNZnk+GRBLWKhRY8YUZ/d0aOBhuBkYJdw7c/dPO6k7lIJF8WFs6KkrPIB5N/Ls6OanATX9iZ+eQnH8Xf/sH34Hv/4fvw4Mf3n7H7/St/8634/NtuwDUXLjgLLswAOxM42CANQK/HpWTs5tz79pSRc3HmjBvsSrQne2vGSi+LxQe2Klt5A0JB4Ha1xc1qn+8qPiE0aAw22O5k11lHKfnGvTWCKdl+p4iS5ILGHIiij0ckBzhro8FlhAQGXI6CWDLx6VIJgs5PDuZazexynTARZPSiRhR+8rHHcN+Dn8DPvftuvOvuB/C5+vWUBgAA4BUvvQ5/9U+/HFMBrrgw48YbL3XKP7VE+9UL29Zlf6CCCVWGG47DssoWo3nj3i/h0bBJUXVhiB9R8el+qtm2vUBXy7+OLFQFEPrP5wUWsUmM1tJhqxcBuMlQswNDF2NuflcxZiGyO0tkYlOqjuS/H5YxN/3UhhvdjOqWwjecAlCUnI4i/zROahYqODPm+6WixkiILfWq7qMduGi2VWQeOIdiDjt8T7I1Fk7lq22IPtKM4nnKbubE4VO3+9voHx182WCwCaYPAWOEeJlD3ZMrRANJ0yd6ADQvzhzAwvSvOrDEwYCNjmej77LH9qhbtmbSHqid1AYJIaficzdmcR+bu3WTK6NTWsPARlJdmDlIKILP6D5tJFU/W22AKVNQ33WbUI+8L5JvGXnOdRh1mmbWoqppAOOGYWvsFE21MUpad/LmFm1dGPsHycM1hH2NIdw1jhtttoMhOXluM3XPMP+TVZrQkGfEUNid4HvTF3FYZDXk4ZxzyCNQwga0IR1p9QLQaYMsiJFT3GZ6BKu4+cc9TT+EJvRQbm7i/X/0ExXv/HefxMOfeBgnF4EfefMH8KNvuusZUXinkvAlL78er/2TL8XVV+9www2X7GzT8Km51nkq+ejsqqSqx3jV4ZlQZ+xktbCf0zZQLpX6zc/lsNB5OeK+nCWUYiidCtwwU7Xkmh7gPgZmPrVajZtyRMMF6Nbv0d2uuPdA0EKbgLzlCes5zzkTVzw9JAnNXoWlOBt0DHCuueFhFQMy1uCeQw8/m3HOR6NZPec8E0qP5TDNc85a7fU8j075Uc/JjhiXH9uBi/W8Clj5RPVch97kMgIMxrAEONz8dDjnyXLX2wZAjP5F63l4qdjPMZmVmsGpg/5Z9by2tnEGj9dVhd3F/HRlcDxhPScdWWQXKtWLxIeIkNZ6rj8HGGMQK0ZkwRcUTl2Oek6W2M5+l9piqIMwMfgc0JOgSiybS6RT/2x2c8ZhWT1iT6UU23q+I6Bfm2u5OyBVhGHUBn+gaqDzbOxY9nJkJpGB6UZucu6c0m5PoJ7znLP07Z2VoOfcSWOMjssJp6en+Ls//B68/k134+2/DqyxK3YT/uuvfAmAhGsuXLCozmAT1xVm2NicCdByxpS7fwnsvM1Gvc8lo+Q8vEdhTml+aEvvE5y30QKMaajuIaZDeGvN5VENzYbliIKtogvRVIJhgMwCNNeI8iNr13sokyvUpiwrkxSV3KWKkoziseCyoFGm9jFhmTKBFEseshacDyYxhQBOH38M9z74Cfzjf/8B3HHvQ5cBgKfq17WXdviu17wQr/qSW5BLwnNvu4grrjjn6D2NR1RP2Gw4UaofUWPVflMXrpr81kaHVrSxWFALWW1o51DH7Ymb1ajGBdHYabPO198qxHwwDbm0uzkM5SA02y2tKHukj0SZoTuX7z1PO1gBbKZIQdUHIRC9MGHhpsGHXSlwQw6vUPiI/pOCfDjUwS2dW8XFUNHJNJ0ejbOhl2/1kjvXH7ZA1TlZoZ0RhQZ3b46s3OoXzM6yaKvJHDSjWfX1kfksn6MYMwaNVeibCUeaRG7SRg1kAADegG2GMN+aop25ueLric8pDPaWpQ5NzdYzgVtFZYfM0gCrH4LnepeM08MaEo+SBi23vj5NAZhMt0kgYcrhcM0kiarGTal/34iHDKOdLM0pzzk3hXHO09E5d2qqNaiqBXbAaG3DZxc+BOnMZAQ+L+PmPRkdPmjD0dCFNEe3o3qOmjj6ApHjvRgYuLM0k9oiCm4RjWuzoaXJsBOpIMfnvA/jo8nOVDTDt3nh9m1PopHk6ue86bNF86i5GIU1qNYcfmpruP+jC972Lx7CO9/9MSzLip/6xffjA/d94hlXgK+6MOO/+F234o9+0+244YYdrr3mmpAAsCEXM09gTCSptZneurkkLcnWPztt2DSjZ53zFJGkYbRVh2dIz/l+qZI1juEsJqGl8pyj9RhHettwm3fqyTQBGgAh/1CJg2rhOXio18daawcpjGI/0MqNDbDd4D6Zc15bGGNtExlcVoUwvqJXiPqhbM/5NMWdpvVcz3kTqrkyGhuAkzkb68LOkZxz9bg5q56T+ePSCQOeg52RvG6O0gwF+CHnvA7n3NkcBDqFOajvt/Y3+nWyK0NtVENUZ7acUc+3PkgEKndz9m08AZX/1HrOJYMy1tJWAvAE9Vy/1sErJRgpzeQ9BNiaHlKR/Gk9p/77U9VzAoCrDelZgL7OlguzwSln7A9reHts6jnPh54D38yiP2+Mb6VnDwF9JtOQMcfPNc75KH8ZTSmjnkfEYB9aZ5WDpli2RK2peMMb34sff8tHfk11/k/m6+XPvwFf+huehZwzrr1wRb//ZPjnGNo9LThM9zmkpN6X7uYOBkzThKlMLpfILp2z+s/+tekSJECxJH5mTCXQXsLv1taMch+RwCUPj6L1ojn8geinhOZRgUNyG0ICEUaPxo6xRV9K3f+n8vv3mBhyAka5V8pYahUz7AAYPFWltkF2mzeAd0NDasDaKh5/7HHc8+An8KZf/CDe+zkIAjwtAAB+vebVz8V3fvMLMZWEm28+hwtXXmVDbUG2OCXSfhoNLqw4L2uzBtfQarIHTLdEVIo025T7Mxh6ppE+qNs7IvHUOiWnt3YkVC9y6pO5DeNGwTcaKTmiSq0TDZQc1Uzmlsy4nXZWXFMY2uxY+KhJpIaGGc9mrqj0ZXf+zaNjqxr5aKGORj8NNME+fNkGMiUsh3Vwcq8a/2LioymnofAxVx4ttuyr5zUz6q4OjZq6vaeNEpKIMV8HP0fVeVNj7sO20VmrUErr2kadHSI2qhgKSs1cVgqS0/rrxsU7HM8JUpDmnSW0OYwYERf4xtCOWkPV/isAkCWJYdDR1ZAP+NBZw+dCZSpqnDcbHTAndEq6fV6MZ9rqJPemIZ/FUIlmkYtQ/psaMTIWyV9HGSjE4bYNk+H0BoFNKrOiea4XGz547g9LN+RpLZ5x0tr2+06vm83ccKEh1sZIa6SqhQdAP+fhd5BToOc853wvAqnXCCQrkKoHdMBnBABgjS8RdvVhoMGVAg0cEj3RxJgWq9x11c95ca2h+gp4U1bgWxk263xeQ5eO8JygMZx93ssKfOSDp/i5n/4o7rrnEbzz7vvx8+/5iDejz9SvF99+EV/2hTfg27/pdtx00xU4f/683wl6dhUAYJTt6CRfvQkbzrkMH6orVp2xmrcSsEJjTGp423T2ajd/a2JoqfIi3ok00O0/h0a0vVFUYIGpOLX2pIlwoIenSXCoyZmu/+uQIMNBgdr/IQbUXOxpjhhLgjjnOmRz28pzTs8b3QI33zTCTQ056FQF9Df+Abspuy5WWVvUi1fVSmxo44ww1NepA+YR4ChAw3DOSzYnf7svi3gf2Ha24dig0Af+OQszJMkzGVLKxVImyJhYhBUwSOWS1PNdEZNbYXPa0KiSCm/oxafnSddz+7u6qec2+4nrebzHIyMnDV4+ysLQWOomm3AFXNRPIW0YKup5o8+/sst4zhXc4j2gbEeyrJrftc3fFw5Iy1qd3s2zWWwr3aRfwUbmeBD2Hz8vvseLSBK1np/sImmix5nmcTKx34cmgDTW3kuqgYPw0pfmBPzq/Q/hf/2ed3/WTGJLzviu3/X5/stcff68xR1WwLfhPZKxjl2zS56K3WFlSiilYJomFNPj03MDNiDrgqe1Nvg48UEJL4n+LK6tDTGbQGcEcIPeB/U2RAZDY7GTUIbMINAHbLrwo20kNeJzUzEwY5OwBrxPzmkTdRZSw4QY/mtN8h40YaZSBqCApsUxEmytKz50/0N449vv/JwDAZ5WAAAAfPFvuQ7/5595OVICLl2ccc21V/XDUSQ+YoNs59SGfOx5LlhrxX6/Wu4s/OJu1uxkQ0FrbVhqc50fs4c5CNAAy+NqaGaWmm/VjqhPc0aR2DR6FBCZ5nHcHzR7PA2IHXWA1EFxqF9rxVyyIH7GTLDfn0NUMiqnbzQZi4fu/p0EOTvYYMfC7Zc7pRV28dLILlnEHN8vN4NBmEQFbTPoiZRBEJRxHVeJ1+QDBZ38p4gh60PEGOczS2Z0KWlE0REbddUBVtnuVkHjt67NjvbLKTrYxivloIZmaZC2GwLm/SYHPES7L7RHLZxliIqxBryGfl3jFs/aTCxm/iJz+qCnUgqeSgK0AdXtEIcQehRoAzTq8sJxfIiHHCioyanA2bwQOiV0DfqvDT/FjV/i+x6WJo1L5AjrppO1K4yK4GeTYJtnjNsQNEaoiazBnlWeEdLzh5iqNQCMNsgbbEiy730yi7EOwm+AND//nHIyI8rwiiBwxHxmuqMH3bb6PcDPj+aAZ51zlS9xMKBREBsJpf7uDwHo1IYj8zTVjC+U+5inAz0r2trwnnc9hjf9xD145HCKf/nLH8Hb7/zVz6mC/OLbL+J3fNGN+PY/8ALcfPNVODnZdRCwxdnU81QFNF5rN3maDRTde2TpSI1mM9Xzl8etM+8Hz/h28Lq5kWM1/epuN3mzyC0jxM05oYNsaEDJ0azSsHatIQ1RYFMZK7UGm4oAN59z+nDMU8HaqseHFRt8CKJR68w4YGqKkTodPptpaf/vds5FPsV7yn0zcpj36Tn3miPnXJlbwzlvY+wVZTy8D7csHd90o6EkOedWzyHDKgdq14xLPXfwNfW+QoFPyrpY36tKsxgRux9lDGpaSiCD55yfr8sOLWZ0njpIuDUI1vdy3ejPz4rbZd+geMlQz+X3B+hLhM2aIj6HZe1RnPmsem607LjHxIunpKN6vq1/ziA15ozWczVt9hosn5mCAzn3Xmhd6hAxyWc0NNTjOc9oG3ZJMB17lF8MbwFy9d+qA+2w579KGlRFKUzggkUL5+H1JnkO+D7wvY5zlbwmao1LJmFT2SF9Dhh/STd9atYfeeQT+Avf82785M99BA8+vP+s3uXdEPC5/r5fee48diUerlYTljYyOB0MKBm71JdmE30aSsZuniwlYKTCb2OXq7Aca4OzspLOEa2DOk3ZKEwRkH67MkI4J4RAOR0NkMdm1ZF4oS8uGwiFxOdbNPxIg1yVDJxkUYJV70Nb4qlZIBDS42D4BNja2RfwGMGQyjTc88DH8eP/5g7ccd/HLwMAT3VJwB/7gy/E7/nyZyGXhBtvuhJXXHHeT0M4zJMmXY2SVs2xNsy4+qBAV91+oXmhaU02onCTGkc6XQvXY3MYCwhgSBFwHRyLnKDnRAu7+UaL7HnVIcugR5kBTYDUfZiHh0CGUhqJRrNh6gc9qH11k0VfxJDmcFiHeCTdirBJ2LoPl5wHqrRvozcu1UmNc9ZwXm9qyiaGV+ps7yY7OWGpDcsSRmyUNIT/Q6CA8b83cU8FdrsyOOb7ZjpFdN+6jHoz3Y7ExiD8E9xbgWY/1riw0Ts9VI9Di8Fq9LDQyEE2EDEwN4lTTMg5soQJJChow2FrGAw2m56IAht/v8Wp+XmgiCbZDinVT78ouUkbh/GphA9A5CBH1JAmRvDzZipFsW3k6lvEaBTpSsztT2cmhKSDr6FkNU5s/p7Q8Vo3gQSUuFXha6BZmzZg1FY26BCRnZ4HReulgGp817LWKLNp3BIADdNUzFCrumaV35sNEzdI4VGxvVfCvZm04Sx572edc91YZTPxWTZyqyQbR9Kl+czQ8JLSptoa9qcN/+ZfPoyf//mPYn9Y8GP/9n348Mcewefq183Xn8OrvuRm/A/f+Ztw042X+jZPjBrJEquDgVsHAEiz9WSZYkU+hVSATCjWSzKMCID7Oc/Jt4l8evb7OOesJSrzGFI3rHb1emp01dokvzo8Y/R1a4RbHu5GWAqFashjs0t23bJuzrlEJ1ZNsWHkmDB7KJVTE1OXpbWI+eM9oAAtoM3ryPw7OucSBas0d2WAJ02kac1TV7SeT/LnPOd142OSskY9tsG0blvPKWPcnvOcozc5q563TZKLUu/JfGKE4BNJoVjPKS9zQ0Fh7RHEUSPZbT0n62Q1NDIpQ0HkjZSo5Nx9enQIP4sBoEy77WKheYZ9LEe0j1s2ccP09fEBO/anzpykUSNaDMBICYf9MvRBIBsyhVSShWT1XgjDa1/ElJkeMSllH7hO95E6MkggEvys6ODnbAGjn6u0RFO45hLgQxa5wjSVM+s5k5S0n2S8N8/rz/7Lu/CWt96Lf/jGu/HoY8tT5h5/+fNuwCt/47McXb1yd+J3YUNnAGwBgEIgICWknDHnhALzysjoC895Otbj2+fDeNNKdqQYBzJOkrJJH4Kt5+o1xUz8LOqh1YZGGarLXYJpxTPBBYEP38I8QhNmgCSE+Gu2oYlQWvP0rGC4OejhQEKXfvH7b+MGB6HOxudkcfOJ/p+L/WL3PvAQ/ukv3Y1/9/6PXgYAnupff/B334bv/IMvQk7AzTefw6VLF/2yp3u2Ft3WqlPGefmFwVWPpNCHiMMFTLQZAAAgAElEQVRDaF9GNLaKgY7qCFkENc5PneDpxsz/sdY2RO05zRexUWGEUESjWd6ruawSqdNIG2qMjg/GGQ+CRCAxnozfK4m5URL0Vh+jnjueHblvGN2ESeMkBXXZaM+5nT2bTpU2gEEvhBzmtKkKdLo5Er6NjFRqvObaslGhAZsWuUn0Z2wInS0gUS0cnD1HfWME5NREeZ19o2VggYAHiw3MzLvtzYowRqCyFW6VmzdxefPBqz6STZ02nmSN1I2+XRss3aCouZ0+F3xvzs6+js/6uOFtDtBps8aGjwM3276cY8DXZj+l/h5RCzue89CzQ1gzbShWG1S+hSxmKhmJrl4pIkX1nJPiSRmISoCUQaImgyPldxwCaqvy98dzrndcEWOv8VyNjZo69vZzPup6i/zZGCeWrIGjyVrbmF01NyZyt+8Kv9tyHlMA+Jl84uMr/skb7sV7P/AIWqv43p991zOe8v9kv666MOMbX/Vs/Klv/4245poLyGV2oMkHVBkdWqULcg1gtgWPh3/m8iSRvoU+u4rFmMqWzj7nfcbquyu98zXCUyUjjHrM4pOi9xj/Le+nlLuXxxiJ2v+M9Zy+IcoVLUaJCs+EdZC96AX0qep5kvxwxvkN/jebYW8bNbiVoEGlPNBUkjb8/Sp9w7Hx7qev5xrnuIrHSVDcjxcO+vtzy0/AQHshjU2EbOi1rtR2LCEIMAHu1E3ZlX6PqOfZGX9NIgS3QAqkLwrwOAlDIZYI8ezGvT1J7G+TZ53gBlkJZFoNkohNrHMkMVSXUXLh4/VcdfNmPOxRftjILPm6BXhpLc553dCy9Q5Q80Vlxk7250h5eP5ZR/L2nKfQhftQ38b+cNB+b4Cjbc772fW8GIhV5TlPpocvJomrg/TmH/3M+/Gmf34PfuzNH3rK3uEvuvlqfN3Ln9ufRQAXzp9DoRzTPvNsQz+HYQ66HQjoHg0lAZNFbuYM5DJhKsUYocG2yHYujLAlMlGyBNdgTVqMJFo1thbNV6tfWPSbaoODv/W9KQ8XWxET5+x+AdXj/ZgikNOxNxbMoLgDBTn6HvrKGIOHoLCCSz4fIA3341QyDuvqQHk/m2v0Y1Ybl9ocBPjI/Q/h377/Xrz9/R/Fo/vlGd1fPK0BAAD4lt/zPPzRb7od05Rw8eKMm2++xovn3vSHXTO3OmWO5hOKsjrlmegyt90L9chpSAXwPE8bLnreb3ONVGtRcJWONdKZxqgzdyxGE/f1Ed3ncLk3d/DZjM3WtTdtqt2O7fVo/DdNljBgmxCl0xBrW+s4sPnDkrq51DSN5lGqI4Nf0BZXZrTHin6/cEBS4yKPnlsDIe/UJnMetcIWMXXhIupootC5fRNfxgFI44Z2EntI5sT2i9twjfJRR2E2CdHwjhsdHbzZbGGTt94386PDtzobT5q1LRRwNSByw6VsbBbJ83ZWhrAYWHz1OQ2mhcREGb17G3GnjATN6D0s/X3tzJHqTAlldISTeBqYNZmMAGFAJHne+3av+OdA80fd1vfzWiMpRGMA7Rw4qFAjUm116nwanhN+3hE1WCKv3MzX6hkgG5+vMHVKQgvdalCTRzf5cG9Ri51VYd/LdNNNGtjWWBSFHrs0jw3bmoO1BpOkhL/DmeccJnGhLEZ0tDHMCLDFiLZddubRNBW52+J3djf4nPDRew543d+/Gx/75Cne8cFfxT/7jx/ZgA6Xv/hsv+Kl1+Gv/7mX4+abLuLcyQ77w7pJMwmadJjg9gGr2v2RbUNHVlREttWNOdw40PK8lYn09k7rzzk7jV4BKbKH9vvVgLK4dxNCu+4yMKsBoTEvUUfsedsfrJ7vClZul+kLYgazpMp6E1xb+KUQSJCIzm3mm5/zXRk8TIDRxT6e+35nDOZtwJAvr1pzN9VC6MlLTjg9tME1P9hwaUjSObuexznnPewma/Jvzz7nsbX2Abqqjn17r/XP4GRONjxHM76u8RrCeLkNMi9llQ1JLy1SANQPaZKNP9I2tSV6pcPSTCpp7C2RIW4/L43JrOKOHoyYNFCICbI9UT1PG3A75Rjau2F0MJ3OqufOcFCaPw2RbRB32Yqc8x5tmYb3nedevT9W6Q1qa+b10o16m+nIdcCPet5/9k4Sm8i4oZSH8ZrhhZWO67nIwIr4QSQ0TAbgad1hz8h63pBcGsJ6/4afvgNveetH8Yaf+dDT4v5+wU2X8OqXP8+f23O7E78zymYIaw7I9H47mQyAPXUCMKWEae6fxTTNIjWSaOjWjCVQ3awXbn5aMbnRag3PAFitaIwpFK8LKCO0+eDNoduXeA1hTo7Q5UO2+GvrkhyCCmVYDoQRaWvJ5w7GDSrQkdARk1qTpX5lZ4AmMUkvSWpaUpapGSCah0EzsOLej30c+2XB3/25d+PR02cuCPC0BwAA4OKVM/7YN9+Ob/jqW7HbFTzrWVdhnufBoXat1QeZbmhWh2x4dZBkNB1zualrUxp5Mk3V6aE/8ed2fSt7ul/7xWfRKR3Ri4FG87FJwadbeW+K4WjzgLAvbUDeTw+rZ4evtW83Sk4OCDC7OdDq5mYrJ/MoZVidCtYpn4yR64O56e9NP8RMdg43BCZ0MEiCepyyaZsLaq3+3uq2ksY3boZmOqllheuf1eTJGQCH6g0Th8Cc+2XiETbTGKujdHS6XHtM3sasiVKCras0/7cAbMamrrbRJVg3MdpEsnVgju6yhp5yrWFkok2PmgHpJiwapsiv1lxkPfBq3EctFFMslE3A5bWek82yenDS17/LKCelR3Lz50AI4uKn38U85aNC2GAgxJRQkhpINc+Kp+8EjQmzgD/7gzmN2+/L7QbNKzvzQww5t5tzwFM0yHKJZAHZyEi8XuRj5zjnU2x+CAJyy85z2s06G3Y2PFPHPcnvVmwjwgK7ejRZcp1mQ2/S97JlWnww7+CCb7SEjRJmkAjANIc3yhYA4HMe5zwSVua59IxiOjSLHKVW4P2//Ch+7PX3YL8c8Ia3vQ8f+hym/P+nAAG//WXX4ZtffRt+91fcimk+cRPcYePqBp3JNNcQL4EKuoMr4Higq34R1pqm2SAYXHsz1KWvRM6sReOTsdbq238IWMdBgXdzto1P5LlrtKz9W5VjAQFM5oRm+n0mCmgTfTis2M1loOoTgB838qNOv9ILJMU2XLfYPOd8Dapb5/BbSpw1RpPytacU992pACPUsOeUBpnWugLKFj8YSMBz3usd/QH636VfAod6PeekpbOeq7v+2a73rb9OYcsta/VBtW2aSg6m9Mmh3ILmhOruTtNADvG8t+hBor8ft3d5q/mnt4nQ9slOIIvvsDEtpJ8Snwf1bGCtb/JGfMp6bsMMjQzDhJP1ZQTWtZ4zDYlabo+pFX+E3a4gtdYXKa07mdPUkcuPwc9HQN7sAH8/u76EsmKexHOpM2f68LdnMgzNoKeMnJrFvAWbzpcINhSeHqLuOChm/hUEbCYx35S1Efa2mNPnYjITzx/+iffg7/7InfjFX376mbVdPL/Dl3zeLfgNt1yN1hLOnZxg5nO0+btt8397OkByacCcMiaLw97NBcX6hZLLESMyEnvG+25twZ5Ea24suK7ryMgVslQY9Ukf6Iyl2Oxn8QPQRSj7vyasytD/G7vB41/jd29QQ9QwFwwGV8gTKA8gIw7C+OUCxr1ULFGAaWDKbLn3gY/j77zlXfjEY/tnbD/xjAAA+PWNX30r/ttv/TwkkwRcuHDBN621VtGni+t+HjdZI10/ssv7kFn94ebGn4XpZM5uTMRNIQ2TkjvTrl4Q5im5Rq6jVvWoeYJQAWttstVsvqGfCnyA1wxhUq9YUHLqDQPNhjh0zOYoHJrOjMf3dRhuNa5HaYCD/j2NuZ+8vChFyFkN9nqDoWZ4+0NIDk5IPVzDmbqaezN14epsrVR+6uBVix/DKo4HaYyRh9xcN5FcbA0PNepRNxquJ5UhaevauzXYiw2SusenQe9btkVyME0iPTGe2VVydjWmjo3Bng7S0+jTkNOo+eTFr9FCQ/QKcOTuf3qog043KOWkNXIT1wZtYMJIH+TmjFpQDtgq6dAt/ZZyHEM1oznhz6B6DXAAYlN6dM7N68MHXBukQ88Zun/VBfN32u1K6JpLdrMidfHXD7aKhwJZPGgN81ywWG5zd/F3u+fh2SW44cY69t6czNmMUHsDPuWEUzlz2eJ5gqlwfM6PfUniudrSi/nfp5L7NtfAiv2h4vHHVvzTn74f73zXw/jX7/0I/t2dv4r9cpny/5/69fIXX4Pf96pb8Ye/4bm4eNWVg/4ZNrwyBhZyB2p0KJ9zf9ZQfYMU5wXinjKec3rCBI26+SbXGUXcbqZ0dM77MJb9nMfdk46kLGe1Lxz0NB8953xmPScLiLKtZajn+QjIWtcx5UTPebD/er2enX3UvD7pPeLvnpjzakTeQWLU+vcx0E+YXlkiOzsAEXR3UsB3M1lDHWSZSvJ6zgHt09XzLdCBJ3HOCXZC2BrsIZRpx+QC1lHSdLWed+A9KOMd1KY0AZt6DpdkfKp6XltsB7f1XH0e1AfgIMav+vvnPCbkJK3n+xXzrnRKt/hBOaiTYea16QnqeR4WQDkFu0WXLk2i8k6NZTMXHEkvmiyhujzQkqkwSjawiSYEeu+435zzkJaEcbYzJY7OebIkghUpA1MpviDR4eMsmYgC8Ota8fde9x687o0fwjt+5env0v5Ft9+EV7zoZgAJu92MKRc38lSjRpcAQOWW8eyUlDDljKk0zIUgQE84c2NKoR/T/iUn7YWbp2hUH5hjg0555PGzgXGjP0iYk8hiNX1gZKpVmTGSDezd9Jk1JzmS5aCDMAo8haiFgWkDhohP/u61NRQyiTdsB70TQxrcn+XXvv6tePgyAPD0+Xr+rRfw9//yb0dKwMWLM2684WI3TVkiOoRbxdBZdSoUN5Okh0wl8us1YkM3doMp4Ib6V3KgYAQHWKTr4DAcMWRs2Ki11Aig3lCHDpPGTLWankx8AzqtPMy2uA1ZJMaoI7DwAllyH8qHLQ06XQeIGJsmww1aGzYKvCCiwNYhgolu0kxGyCn5Z0ETkXlKHscYTITQjeWSrKB1GncTOrZulXDU5IpDdSL1P/nWV53zmZpwMucjJLbWdmTAyI0VUVDXYMmQ3AZn9SSURJUR9AtuUVOrcoY0YY1mM4CVETQiRVLzdbVhL4N+TwfyyG1lk9g2e1/qE5clGhFuuZT/EJt4DFuavrXI1lzA6O9hDJNLbBvHbGR5Pa25nCTiAzFslSh5SLnn6zoNv7FodXpylozdtpF6KDXY9dculRjlPGRBkI3D553GYtVYQkjJz7myU8iacAfvGp9jbSE7ISVvdiM9+DlfxWCUTfNUEpYaWc40+VO6M5+hcJFOLiWg6/N2UKA7b6ed0hQxXLwnc2tmM3D//Qv+/vd+EB9/9BRvfsfd+I8f/tjlSf4/8+sLXnwNvv6rno3X/N7bcJUBAU71FCnQsHlBaI6Vtt5kG5nFCLTTRpuDcupjsa6rm7OS+swYSvq0UEfd5UuxhfY7yLeHWTYxotcXXf9a45znktivGmOBediRkc3IrUlkN8M5t2YaG3aUgu9+Z0tcqp9zMQT2mDu7M5otB7rePAC0wyaVpgrjj/VcQVsClMM5F48a3k1TSW7GSmPF/WaQHc55058Revu02UeqQWwpaViisJ4P/U41x3zGB7fwVCI7Upl2fG/XDVtB69m2ng917knWc02wieF8lDI0jdq0/uUsuFvr+dZAFwjXdHi9YVJMGkAt+vIsa3Xpy7EZcbXEljHKk++ZgziI4V4B9j4gxSZYgfRYFvX0CN+WIgUzQZZGZG9S7qd9cBn8EOBsyJTCLyCWcm0DQgVo0z/PBX/l/34HfvItH8H77n5mscNuufoCfv8rXgg0YLebcTJNw1ms9v+8b+bnmGR0S0BBBwF2JaNM3S+llOJsxIBu7awZ06qf3RUQn6zwcmk+fEeSSZIzGH/e6ihnJcW+1RjQ+3Nj0klQApu9txoSvozJlpik5fOXLUgUtCIwkAcOQD+rwlZwyLvBPcS66XH1c00jW8Zz8zv+5Tf8Kzz4yccvAwBPN5rkH3r1c/Gd33w7pinjuuvP4fz58+GK3uSST5tsX9PpnVpxnyzWKrU4RoPhilMrR8Oe2qJZ4vx2EJ3eYFbhRb/6htvNteziXK0pKGXAA7Guq8sT1pUuuiPocG5XXFO42xXRdfcGoQMA0Vh0eUF2+uFawwiHRUf/fRN9YTWbWM1FHi+CQOGoD95S9WJAHulGVTXMCEM7sgS25mkcoNgcOcXamrS9OPay6aInAkGgk7lIMx0aRf6+WQY4xmFhQ19iMeTr6cNh8szlUkad51wibrEhGlf9YnOpEV8KUBCtJ2Ckg7RnKsuQyUGRGjuyG44pr/ChVwv/bs4RnVdiGKcMYRvN1E3eEs5Z3FZv1nvh8AQONNS1N4wZOoRn31RS+sDnZ7vhacZNI1iUZQgqGU5xnErQzLCVNwzbnCc+5x7RKb4RSfihLEIHOo1bfjlSsgGkmaQG8kw0H4QmY8J0KmZBEbkIm7FVsp2Ruv9BlzMl7A8tdJombdJhxyPm5IqJ9yc5JTyi4OAsi1U2Yd54C5VvXRs+/MHH8Q/+3l14512/il/4lXue0dq6z8bXb3rBRXzlK27En/ivfgOuvOqCN+C7KXmkHlJvIqkFnkpxU0uCBTTInaZsOs023JuLg9HBVOpmfNXZRzvbDAZzJiQqHPJml8n14Xayu8Kp4rqplXPuUYHCLNH4p8PGIT4bXb4bWKYhFqthdLMfU3yC4qrmuxptOdYrkS01DFFnGtUJGfKL1C3WiJAuhfcKz5DW8yoD7anItLSeQzbZs1Dkh3qOHg1YSsK0qW/cJqux61bDr7+3elL4xngTUeYGZ7VJ0s84QDN2ccuJXsVkmaw7+l4cPk09X2vPnk9n1vOIH6uIe1+Ha/2/jGcl87LjngnLspqfRTLfjR6jR6lkpVu/gAj0wWiAeymx2+QQQ0lIKdr98c8o9VGjYrgRIJ8jml33AT8YK+wZdSExz9m9AiiZ1XquMkOVyJ3bFX99C31+puz1b117D5pFtkmZB3vNui74c3/t7fixn/nwZz3K7zP5dcXJjJc993p84QtuRM4Zu90ORWLzahtjmItp59lzWAIe5px7NGBrmEuPOT/Z7fqwzLQwdP8XMnDJqozo59U/o4yIciRLmhItJg+EGaD7ITsQm4TKsCq7Y0hlifQkRvMx1cnZTghWQIC1wgQlG2uIF0+DFKE5fa0P9hPTbFpIdZOBsy4RYK/ccBkAeDp/veKl1+Gv/umXAwCuu27GddddcsRpEUYAN/OkfjCCyw1PhPZVNxF9lRoT2Y5x4KWO22NkrNkhjaqdQcVzRMo/oHbGJhZuhASEcSCjdZi7q1RwOvnOlpMczX5Q5E7mbPqtvjXhFqfrtXIcNtP+qfmb6uedMpREbynIM4dLpgXQGIfmYaTrJevomhjP6cZEHX3zxnk+PcHmYETwxyFeXem3pnXbLbnq3Zogi2e55OqGmNq3qZDejoHGTz+FZJKNVttGdw3P+M65N2yQAZXeEvp9me08TaMLOy+5A79XgUcKUj+6HXJ9s1TGuLypJKcF8/Uurk3vr4cbGDY0QMJuksIvmnRe8n1ICW8KB9AkGpIsB4JFKjfhv+fgoZ9ZE4lOsbNPR+dlE2Wm0ho3wBEN6jgQQ5yZMdDe+GSOdDYc+TyQqRJDfWwhyRSaCwEAOH30cFgBc0fn5jMl80pYmlNFtzpN+gtMpZtDoTXR+BYHN1zzuW62wFV/V7hhV8rAYV/xC//sPvyLf/4Q3vzOy1v/z/TXi2+/iN/5RTfij3/bC3Hp0pX2+WLQ6lczx3S9vTFiFKzr564/M2SYJVTsl+ZGfa12B+W5JG/wD8vqw2fPfu+1hVskDgazU5pD7sQNNlISeU1ovoOB0iwPOwBPMlsYaxdGrM2bQhqoMhaPYACHIqXce2qIDLQhmRnv3bxhxugQrRvXvAGpeaczXpQMt6RA7Rz3Nj0SvGaLjw0HaaXaJ4S/AOOHeSfmPJoZFzFsHet5bNn5Puvr13ruUX6FhoJwP5TMOij1fLL4xSoO/7pFXjdRc/r5bGtiSABHlop+JtorxBZdUo7s+cg5DZphLiOy/B6Qet6jiPsSRmn8Ws/3Zrys7BLW4VOpc9yUJgOG/fvOfchbW8O69HuZw0vvKfvr9DpMvxqCQxmDTIjnpgMATeq5ncMlmGyUnSrzbzVZqoIO53aTD1EdzMlBR7d/x+/J5QENKN/0L+7Gz731HvzwTz21ovw+018vuvlqfO3Lntv7oXnGVIonAsDlSxGV7IAhgcvuSIZdSdhle79zw27eIZfSgTpZWNYWCWnZmH1Nm167uBSAYopacuZUyMlorspzpWawDpwai7obZPb7F8LUahLV15n64ckx9Of257UlAW2beLNZmkKN6FmyAeDgXTUgnGyI5nVG5aWtAf/HP/rXlwGApzsb4A//nufi23//7djtMm6++QJSngXJb46IE5Xi4D5QvM2sDPKwaI5xrXIANjE4kCKphaTJv9eD3dHl5q7yNONiU0A/gAYxLrMmhoMff+7+UE1XOJrKxVY+dHOzG3gdF86t7o8Hvfihx0D7cvSNmeUl3I1Z0BUAUYAkhq46eAsQKDiYhlppnMfRQxhcfp1OntOZzcNAC5TBV7+KJENweNO8ZQ5oOR1T7HiZnuUBMJUAAJT+uNiLn0o+0sodBABogDfoNOJaK6UkAQTR08I3LyXo7TRc6kkwptV3DX4bomT4fZrQODuQ1gbvDL1klrUN26Gg1sZGgecs5x530wCcWgyL671w/BxGjGc0jnQiri5LGHO1Q1JyfAWywS2FueTtzBguNVAjpbo31hHLiQY31XH6nA0ubNr13OxsK7oMm3xjypTwM1lWiLSHQF92A0/VwGJzzjuwRyMyvpf670YtMKU68NgtiabagGl+Ruy5OH18wRt++CN4/wcexevfdgfufejRyxP6r9PXVRdmfONXPxt/6jt+I66++goglTjnVuN6XSGLZB2kWqSQd80x/BmkgR0HNZeeGRigrC4dkEvJbljGLS+jMun8Pcb8BQ07SSY0zxgPIWubOrfTf0LZW0NutdGpFeB7onPOoVIj5rYMqZRGl4QmTWk/583PuddzocXPUx405myKlyUGyNYC0D8sIxgxyjvgQCwZQ0+2nmcHPTC83vYEtZCgLD+f1iIGd4wCTkffQ+u5NqNn1XPNgVeg3qMAN8/a0OSSaiy5424waCaW2CwMkgBQ21QM9cBx6YbX8+qMvRjULVZvU89rrQ5Wq98Ph2f2aowAZm0Ic0oM8Wy6xe++Mdk9OEqJKENNNQhwBkf1vPsuxD0Qm1wMywCkNADpg/9FzvF7IcA/Sn0A4Md/5k68+efve0pH+X2mv268eB4vfd71+LxbrkUuBed2u+EequrlwP6prejGecYQzKWf4QZMuT/fJyczSpkGyUirbRi4ewyg0ZyrDv++grRD0wZtfsK4ZY/4SdnUNwzpYJEYJkN/il5a+0NlSTdsZLySduBdpkUFNmh2TLxWXX6VHLKsAGYjNYBff+n1b8WDj1wGAJ72X6/+8mfhz3/ni5FzwlUXJ1x18cpOBwMEiez+k6eHPmDudt25nqglh/IoCL240kSIBZv0SG4NgMjRJNKeEgbNChtmZre6vtGilIjerxIDlgY6crKcYwwZy30bU9wtXBsrHShd7lC7a3pKo3kR3YyHOCbRFLrGzA9XDKLcTE/WAGZDKUlPZFScatNp2JMSN0nVB5GD6BBrGwtcp56nIzfheUpHhnPUpZcy0iGVjr814AMg1KhwT3cRq0sUMNDtdZOkm58RMBp1uaGfE1OgnHxgpjaUVEgQKbZIwe2AeKSnx9lGPPGf28CE2DZv9YxNV7BdxgaD7xlf09bASg355rmImWE0hxxOTUUyaOfTpvnmc8ItRbLn1qmwZuBJbT7BMm3suRllY6fPkZ5zUji9WUQ/pwo2EcwiLRhCl53N0Z/NPTdnYA51iv9M9o2ec7KNdmz46pgQMeSng/danPPIJEeALwkRozqNqSJrqz1GKsWQ5wkeU3Iw6KGPfRKv+4f34Ufecifecdf9lyfyzyIIzgjBq68+j91u17fitfr9OsSBYqMd9uG4DZIn3yjan/eGr5+5cyeTOfcHgM6fwXPR3dIb1pY6c0XuQpfQINJSAkyN63Z7zpl+kGy4JFuqGfVa6dQ85yWfdc5DhqVAt0YE6zkf3MytdqgviN7V+0MNnxtjwblZLUJCEM1pGrTgO78v6mCepnd4pB81B2yGem60bxpz8py3M+q51oWDOPkXv/fSE9Zz+M8a6+hiEXhkduXSjUnrxjdoNR8JSsf2m89nW8/XeixvcOPkBt+EboF/yhxZV1Tm5ZGB9nn7EFG2ZyfYXByI2Msp5RibiOCxnkfEY0q9l6iMqLXa2Tb1vG5MG9XQ7Jj12IakEIhr+2pG2bVWZ+CxVyNro4p30LL2JCXG9DYB6sMcMhsAEr5FXSKa8bo3vhdveeuvfk4P/tuv3/qCG/Gln/csY0jNAfCgeU9ZLVmlmelU18oXH3TpZ7IrvY/e7SaUqaBVLiaqG+m1GkuQvqjIAzDV0IZ+MDX7d8CQFKASKT4fYyy4ntUkHjTJlze83+id0TC6VwcTN2IJ+f40Ayi6VKF5YgL76UFCK8ywsQsePUBqa3jtZQDgmfN19VUz/ug3vRBf/1XPxm6X8Jxbr0GZgvZX7KElhco1jocVJ7ss8Trc8lpW9hSZw8salyQv/ck0t9wmMjfYXYtTsu1vHSjuwPEgWuPEDUYq1HsxEzyXTq1bFXFzevVo6tGbkOT07C6JyNjNEcOigx3pagQMlqVht8tY1168d3N2ozTd8tINFKn5hreaxmhrnhZSiBjse+Gg3hjmnEp6UYqnl80AACAASURBVPONRG29mQk9+xhHowOYa97EBZ6UfXXo52fhDYxkONcWTZcXQinyauCkWwu+R9w0RAxif29WMzgcspvtMlvobZC1gVHH4TBxbBuKqKP8JTmNMbYJpAWO6QqkNfbGA/ZsjADLag3PJIAKGzL+/n3Arf6endAY71CFTTJuWACIkVTQmLcAzsHi5eY5TOsYaaW00GJMnIje4jmv9hwHs4Ygk57zJjr+kJpEtBnlNtOU3A2af7ebVtYxBlPypoesZ6iebpSZKCWa9FlGc9Gld/YNaD87/BmM/NofOvJ/7qQ4XZtsnR4XVf2cr2unoe7mYBm4npbn3J4RNOCO9z2An/7JB/H9b/xl3P3A5Xi/pwoQ8Ntfdh2+6etuw9d9xS0o04nHxpL1RvnYYhvm3S6jVdKXTU5mW+ti8W+1Vj/nTLxgLVlXi6qyGsSIL0DN3zKWhcBwb2JPPbLXttA2SJHyXGt4g9BokykE1J0y+5k/M6QQFbs5uSyJ0gOVSuUUOv66AWW1ntNTQ9loZFSEiZu6TsfmVLf2aVNjUg7zOKWmaz2vtfngDATwp/cBN8K851i7xnpehwUA6zmfAb9PW0Ndx3oeGmEBD0rEKXM5olIIZ3yhM9gWM/8NinoAQYwu3RkThff9dATMN4tDjpjC1UEGTdzJzmLCUT2P+/5T1fNcTAIlJnnKNiEovErKAWswdcwcsJIYa3KDzq1sEjbhYVHPjP7zOfDQLJr+NP33bsb269GaXG5pPSczrzNKk9dhglU0cd7tJutvrbct2dMTdnM8iwBw7mQK0MnYboUpM+jPz+t++g58/4984GkZ5ffr8XXL1Rfw+7/4hUACpjJhmidfRpCy3uWMAfSQidEsvaGk7t9S7J7d7SZMZTKT1A7i9617tfuquv9Rkq1/MwbIWpvF84XjSksyNBMwo+cXRjbJVnpJDyY+64O3gIOOaQA1w5ASPgvUWpF84dj7HIIcOWXvZfzuLmOygXu5STSFggXf/bpfuAwAPNO+ft+rbsWf+NbPQynJ4wIdwW1BiaGTPhtzan1JzVrXyPvuf7cd0dD40KWEcQvb2pEusNlDzU/FN6QenZdkmJPmIYfj5TZiZTWTGv1fGQ9IfVFE4YwmGu4wTpBhyr5hyaIFcgRPEMCcucG2KEI7ZDRzco1giy1TkwFXXdg5QBIS4OtvdcyjV62lSgdK7tsp3VhzS6maQ27RI09+3CZoLmoRb4BlHZs4skmGmB273NwZPYXentsY6mXno3i+NPz3IhRrfrRKz6/tGADwjUcaaZncNmRjeFCPS+CDv5uCFLXFe7R0yblvxjUykM8/WQnd0HCUiVC3yPePnhrwpqvZcweJegzAax2egSgACSPVNW2M/XjOdZNJQyc959HoVsxTcX+Q4bm35psAwP5QP+U5r+I9oXpWpy5P3KJgoDVzY5lSHtghfO2MB+zyjuypEpFzG1pNPn/cxFaydVqcr8XOeZUHPwtTpZuOZWGJJByWA37pXQ/htX/rPfiFX7r3crzfU/SLEYJ/6Otvw5UXLkRWfMFAm6dXCTfjU+FdowatzYfRagB433DHMFVMbsQBcRVdNYceygkiAg5jlCdUWpWGu9kdxg07Zjyb1hxly5CqGttmiwpGSNs4rI+DWXMAQKVoCs6r/CGnYOphe859MKwDAKBsK2cCber5lsqvC90wgQ09LqNO+TtFbKNt3cRoa8vwohnjkH7zJOq5yiW0uQ/afzCcKKvsy4BR77+t5wSYa9NNOj5NPceQBKVDK6MHaTzM+z0JHXgSw0nmE3CgZZ0ggMTnhwlF4cmEgc2mccIH/mdhafQhJkw4mdbSpOBvY3xZf0oh4zAZ4yQjoXo9J6vBkxmk59kCAMpu4b9lckIHnaNGzFMRpo/dE+gyuB94/XvxujfejXf8yscvX8Cf5uv6q87j82+7Di+59ToUMwhk76GDvzNKW9yZ3WGf6TsJM+N4p4x5nn3D3vsfi/4zcIF6/oagyVcb0H3z38aleRKmJHuixXwHnEVj/mH9DPRIPmcXGBABG8ijZzJfC1KjcIZnAPsbcyFsSAOAwPNWz2QTqBiYTIQ8eEP9pddfBgCekV/Pv/UC/p/vfgUSgEuXJlx//VVGX4LHmWk+JDf+qzXaLPCky5TcvHHhxpJNdcmRi67UK2qDx4YhnPapkdrNBfv92huPnFGpiWwN1Q5qd5ztB2Mq4VzO3HDVdzUZKtXsp5SxUE0ltpmOlgkNUmllnsMpg3AxFkJyh3OM0VPWdPGigWSAcmvK7e0i0gdtCAicuAGfbJ0jIz25iUoVAyhuCygXUFOeyO1NZx4aFlA2DC7bEBOlkVgUrAMd/vr2ndr98AA4i9ap6Cgpgp693fgZwre5Uxk3M2wW1aXezV8QP4PxTaRxJkRT6tGM8nrZXIap4/gZatPF70PZDRtN/h1vyiSuM1vJO92vbvKXhA5Hgxr+DlPJDs5pAkLeUDaV8gz/e+M5py9Fc8pZcnM8Jh4QJGTjSZqsb2skFpQDiINKQoUjiOi66iYZ021MlGA6BCUofs7RsG4ixOgHwH+bjLmy981fxn6/Oq1voOOlUZdd8tggU+PZGvDQQw/jA3ee4n/8a+/AL77/gctd3NPg65VfcD2+6etuw1d/2Y246sorXatOVthUBCAGUEq41fMsBbMmua8IGS56znk38Dlnw5fSCHS5l4gHQievhWw2dUjfUqDzZru+2JCvAEJxRtDozM/vwdfIWkIaNJlBuYR2fNSDwwf0KjTyhKCAT3PGcqhiZjrKycJ8Du5wz15EPX7WdWxfmfHNc54lDUgHb8/ydpD2mOqv74/X85yOEgK2SQCq1+ewqD0V31v2Smcp7Mj6Uwaky6kSPEqPTJCUAgBICS4XOKuenyXpU7nJE9bzo5QHSzGyuqAJOx10CCCZ0g94LcgDEKT13N/LBCyWagBhI1JmUI3ekI09g8T0pzR4Faxr7b4EUx6kBkya4NJqKuptBJSpL1j6htUkAAhgfpry8DmFL0hxkJ7GkH/le9+BN/7Te59xUX6/Hl+/7fab8MUvuhndmLEP9v55tPA2UVlpROp1dtWcEyaT7J47t4tzXvv8gMGMvA1S1Q6Khiu+Toy+5Ejjz3XpicicXd6a498nMTvvBoM5/Ls26UvqE6D3SxY5gcZ30iup2iuIc5887SDZwqswGjaPyWPAZQ+AZzwl8jWvfi6+4w/cjnlOuOmm87ji/Hmc2rDNwtE3nsDpns67kz+6nU4Serp17RvL1GBZ7nVwTGcEHCP6PLtXTH04bDSjW5E9oJvP0E6HCVro7SPRoCE5fc7BiEyU63hbrUMrqTbcJvBndto6XCfGwfN0XwdvANjfbehF2Qti2f78JLFIvYHqGvGgV3JYz0kzpHs8Td9YF3Oy7e8lXW97kxKbcjZl1KFHzN64wQ9n9WiU0tCUWIMFyXGn7k9chJmbrJvicRMAaf6iKfANr0YopWhm1rUO3hMhFQmav8oZ1NW+No3Yaj78tgpxu4cwPEZGC3XzTslPkQLAc7VlOOTUBr1qlw7078P0A/ViyNJsstgsog3l85xFI38ww8vuNN3p/7mkjuoO+uNmEWUVkz1v7tg8Z5ye9mF4tyudYiwGYTznPggwHlEaPTV25OYpnKJt44dAq/umJ4yXVI5BvVyvsjGcqUs6QZndFI2uU10hgJ6cc37LLFk+a9Vz3j1Fpol+HP0czVPG4/u1O7ubA3lrDffe+zB+4PV34e/8yB145LHD5c7tafb1db/jFnzNl96Mr37ljbjyyvOwcGXzlSADwOJTPRIw2FkcMooYSKWU5JwXM0Xr56TkLI1WHnTZ3eB0rC++WbdhadIaY6wq32Bzy4Pw58g5zjkZTHtz0u++JP0fsV4E2y7Ag2AGBfOL55osiXnu78HBGBUJEFA00oSino+AdtTz8AeYJAaQtdTp8KKvP0iE3lnu+Hwxes6r3xchS+w1OoUXkjm98z3om18BrMsYJzvKKfr3XVaVH41Rj5TTEQzWpBxKOFSOVTeSSA4LpOvzd9FnKmRx2YEE8WUdQIbaRjAkUqAiKcbruckiAEgKVKQyraZpdgfzzevyyEKp59UGlGau+6T8O6PDzAW3gEkHp6vo8Ol4HqMWZadiSYtaq33GQd2fzKWftZ5nkZLK/pnHWWcyyMmuYK0Njz9+wN/+wffgdW/6EN531+XB/z/n64tuvwlf/MKbbalWTD7bXCJUW3V/oJTVL8USfdAZTudywskuY96d+DKpL3lWJETMH2UBvnnQHRHN+xBxwZGLlNwLBtozN2BttTNnpLc9cyDl9zTJiA77tY0eAkmiO8mmGYw6U0w0VpGCcerdVxOPGjX6hDEALgMAz/ivV7z0Orz2T74MU0m4/roZl66+ctg2LEaJJm2NdCkiqp5pLAhvQhOzuuwNgsezWNNEfTovW34skxlvNYnTcECiiqar8jA2z7ONtAEzXrPhe60srHlAbTkYiL2AI+I5s1GCRQj2WJqIMuzFnNpgNo0+6B22W5E26gUZmbNWH36m0gclDly9Seho5GQUM2VlnO4XTFPGbLTOZW2u146hemzo5tK35Jrjyy06h24OnFv7AN/cy1ZXTfN0+7/fROOtbqZjIJRsB5a1X1WzUEN7bFsgsjFAV8+1Psvs54nNkMxroYxRSykFIssmJ3k0YbUYr/57rxJNyH87Tz1nng21AgDawLo5pugzux5/3TAFhOaJ5hmzQXWU7ZBd1qtQOp3pIU61q1BUOyOk+sa7tsiN1vgtYtjLWj1iU99fDixFMsv34iHCc89MdZ4RnjeCBkrpjXMekYhrCydeyn24ZWUD2c85/JwXo/Kf7vkMFtMQjo2jDyWH6lnZWTwpwjW+s5FoNjrPGY8++ig+et8p/tzfeCfe/NZ7L3drT/Ovb/uG5+G7XvMinL8i4cKV53HuZPIaCAPseM4JjmoKBVI3SuPQSP8YDnM8512fLJt8A+0o1cIAQmc3zx2GPqG9K7jIzf1s7ut6zgmG9sSM1eo5nGYfMqzeMOo5J+uHg+hBvAUcAJgispRU7daiP2AMHgGKABXi3I/59MHSY207melHRJ8EM+fdV7uLR7kb6znvxgPruXgoUN5DkGaespuNhicPcFj0/RHWItJo3ldHgIJb9VkAAbIbNGZZYwopG2GSkUbr8a5d7ZkhA42fAcFtRl+SCcGove0EQjYUGV6MPOYwoi7/2Zl3YvZY29F7FfU8OWgMCENBzFn3EoPpUjWJhq2b9CAIu4SyLmeGVAzMtsNhdfkmz8bJHOkDWs+dWTglHA40qCQzLlsUoC1fyFYzkLm3QBUfe/BR/Pff/R/w5rfed/lC/TX6+uIX3YzfdvtNwQrVBziNdHj70PzO60BAxi71835yUnBysuveKSatqghp5CgbDdp/FWfM7CDEKKukbMbv54E2E0st3snbFIAk950zDZJtK5K5gqXsd9tSK6Ys8dYpYgZ7/cgRrJ7ShvSfhjQRj/y0HuyeBz+Jv/4Tb3tGP1eXAQD7uurCjO/85tvxDV91K3IBrr/+HM6dO+eXL117tVjl1GnJML08WkQWsYDrMHNqNFsaL3U6Xrj6VtPHxJY8CnhHrmKDPJWRbsONyrLCUXdtUjg/TFNyxLoOupqO3AWVLuheqkUP2n7yzOXWRrdiHv6SYytM06O1tsGJltTEvt2gQ6xIDYxRwI0ChxG/bGwYoglPO8NMja9pWVbXZeoWpycc9KEUQvFb67i1Bo79HPjnHGw5MPHD48Cn2b/Jm81x6025NL8Xm4spj5FKRQZJAkHKbOAzos7T0UhgoKuzqYTQpMhC4GXv227RxQ6mV7Z1UtMn/p7cfrNRyZIrrIjrWsf81XnKPe91NZMYoQNDmqNax/zv5i7FcK0bDTP3otnNTiGtA2VsNxeXB5B9wyGf2yV3/UdQXHUzyBxuaoU9fUBAIA5O3d6gSxicjgwMGzR1280pHJh1eNrvV4+yaWbk50VyrU4JDFnN+AznwWMiOyuEnhtkGXgT2ioefOhRfOLhBd/xP70N//H9D18uIs+Qr9ufcyW+5fc+D1/5iptw/XUTLlx5IbTQpT/P4cTeBtYLkOScJ9+qQ865puiQTr+a1IzynmE9K14B9KZQeRjvKtVL11r9zw+yLeXWm3cUB7xuPhisMA64y/r/sfemYbddVZnoGHOtvb/vnCSQk3NOupMQaRPahB4twL6h0aIoRarqFqJe77UskauPYnXW81xKC8q+Sq8+dfVCSemtUgubQoSLiIBAAEMSukAIhDaEBEhHmvPtveac98cc7xjvXPs7QSDg83D2+qGcnPPtb++115xzjHe8TejY3SyYgL9K65r3+pjm1/73iXTu1wH0bdK3RXppHoOLOM9hXst76HydQ4YxX+e8h+PewvMHQCSbzw5JnP0B0JWjjvGaaSbNYK+BeWLS/Dxn6R+K+vl5Hl4Rxc+iDfZVivvCcoX5ec6+LXzfQxLQSx8mMvbb/zwPCdyaonnBxOLz3GU1KfwkFuY1gIZMCfhJaj5MxHSB7wK+n/Zn7T1nKFoShplJG/gC087eX6PVlyFPDEYJ/IEaKGeSi0Vjpd500x3yKy+9Rv7g1R+XO++athvpPXw99LzD8q0XX2CMlewsUJFKzbiYHASsqhS1W1UZNcmBhcrBg7sdY6qLCaVpvpIEUw1MxR6GPQLrnZ3/B4rO5BhNRAY22XLv8SGUFuP7FYFgzmbCkMiN1MNE0OVNSo0topBFKakmaiJx+UA/6Xv7NZ+Ul7/16i0AcDJdT/v6c+WnfvDBoipy6NAop59+mlPioGlCFM+QQhYwpDCVgPZuzVRJoxzjtYK6G4kByGavpco4Du2wqeK67kLTATRzaDySmyXZRHYIl32weXLGBF3c6IPzyQEAwCjGnXhzNFWsm1wskh/CQOyh7Wu+B4nuQeo+g5K52mhoJfJDHSBZh866SkOy0cxDBhFFQfJkg8nQdKCA7OqJSSofiEk39fqg9ilN0JnKP+XS5SiznwJPbGJCTs0feQDwZpoJAKh+r6pHTlUyYXIn+BRFXTjF9o0dm0q5rrWjVkUT76AITWQ8o5iYCD5hyfH9eoSWAVpKkY0lF5OgqE+XAETMDwIUzJqCKgpKJ+cuF5j+CSYWbS3iWSykEYWxGaYsoKTyFU2DhDbS4q5W9NqRmx0a2zBvtH9bIkmBARasc0h53KxKorB1I78U3xmmeFjnnBstBm4BsAAlGpnLrPFt73MQ1T5Kitd5Ij+PBq4AOGrP8TSt5Lrr7pBffMn75Y9f+wmp2xPkq/J6ypPOkZ/5kYfKckfltNOWslgsOgAAzDGsc4BneI6Wi+SpOIn2mtCYNiZOGtraBfgEcC7W+f7a/NFZTCF5QgZ5m4wnYycUmkppnJkqHju3XAyStMreOpyrMd3CuvKptbFyVhOd5zCqBTOHNK9g7LErtnT7e+jAnX1nNNfJqNWQOHi8KK1zNO28DL2Jtj10v3U+P88ZEEZaEH9msAG5cW66cZ35KySKwQsJAfvWcMSiiGz4+gxDMCDZvG/O9vCaaNBuGjlL/er8AjidB89YRCqGBjimiNQ850reOySnmEWj4fsBw6RavRayl77mKybXbHVL+545OroSmJJSTFbhP+Nu5rUfVlSSirBBJJioxaR/OM8BVi8XSfZW2WP85ud5dX8rlWl9XH79ZdfKK15/3Zbu/2W6HnHBUbno3DPk/COnuYu9SJVpmvwZxX7iMj7Rzgww2dQyaZIDo8rBAzsxaK8xCHTmkino2fw6DLqDRC/ucxKDlH7a3oMMvnYJPAupY/w97w3JHvow5lRnPrAHDNgKMI5uIEIy5mPIoJjqj99RaABTpcpv/cW75EOfunkLAJxs1+mnLeSHvuf+8l3fdJ4sliJHj55qU/p4WJaLVkTvrVoj3f6+GfGlQd0DoLn2Bj0YCCoygF3raBpnHHqcaR7mY9XzjYHcQour0qLJQI9LjKYTXdsbOejzKzT4/eSZ6eOhqScN3hBxUVMusrscqEjSWUwcAIBmmpMAyqnKapVdFwjTRNY4gp4PvTk2KcgsKvJMa3MWFWkUQmTJRwGTOtq4aGgO3TTFGn8GBNLMfZ8k1M6QKDNHZtfxl14XCU8AbrYb5b73F4Au1B20Z8ZFXuyRpjQc421SQZOsObixR7IEyBSYfugxj6blXK2zU1tJYuvFdrXYL2gwRwJK9ta5m9jsLNpzgoZ6/ucGKoWRpTPa3OeiHTBMQeW8ezgeYxq+nrKZPqo3Bkmr0TMbvRGpBAAAOCUBlM7VupjuXrqJP+iPU84+cYRmGj4JmTSuPkVieU9XtAdajmYHUydf51OYk4WjdXGzMHgjRHIDnqvQ8Yu5AEOvWmuTYTS9p0ouwQDSJGYSqHLnHXfKrbes5Ud/9nK57D03bQ+Lr/Lr0L2X8n3PuK8881vOk3POOSAHdhexzseQ2ECnjSnh7nKwhrF265wn7OvJmsNK02KKJ4PZaFsjyaeakVSSnIGDZlJTAxPYn6P6VJ6lPKmbWuEMAgAQjD9xdsCUA7CG7h/pG9BpI01FJMwMy2ydqxjQb8yI+TpfLgaXHEz7nOdO16bznCPdYODmyQVgPdn5t0f7+ZSDZaZa3YsIkq+IiUseGYjmUSiiGFP21bq4BAw+OssxddKyuWcBzmKWfLXZZfw7RD6e6Dz3s5fPc92kzuN9iVrs86wITuSpMn/NMDMMnyUMaXAezZNwam3sEpb99bJBk6IZIJAG9f/tHY8BP7U2A0mwAnCeryABGLAWARq11zq+ynG+S2Oiwr8DTJx2z6qs1gZmL5oEAHG2XlvN1vnq+F3yvH/3LnntW7byr3v6uteBpTzgnEPygHMOyfmHT23fVan+tBafqhffQ50tb42v136qRnm39ZaSnLYzynK58H0wUfMuJruUzmw7Jlbcy9dZOzl0jIBo5puMKznrsk97CtmL0NCu1vgNXRygaGfir2kGACYRqer+G6Ji3gmIPozBXTBxkuTa1vOnbrlD/uMrL/uqf8a2AMDdXM/8tvPk+f/LhaJJ5di5O3LKwYOmVawe7wPHbxQM66mZvoyOqLbDazD6DCh9LCeAk2U7OCKKBVPlOIykczfO1hAvSV84pyyGHjhF8bOIIoun91hPk+XIIuN+ysW9A7h5nqbik/BdMwQDXRtH63pqi9od0DO5Ktv9QS45Z9Sy8/TotLee0i+1SlUJ+qhtbBzVtFpnL/jY3RQNF9P8nfI39Dn088x2NOHh2B+GhpjmzBkAYA8w6plncXyuRxKODbT7qT1l02Po/F73Tf5qgt6wB3VEyJfAirg90j9WES+gAfis1tkmZLIBAKAZWI5JijnQY0KCv08UoQXtoTf8VohCKgIqJ2v3mZpoUa+yHHXD2wETN6e7lzAOHJLK3io7NZmdy0GtrdZkz9FkkZBJAABYk/lhJZ2qx/KZ7r+KyLTOMo4R4QTwBo7MjKz3jujtw4YuM57Dto6MsdOZWVpRKupRUFMWSzUYJIXf2kZUWKlq5p7qpjlia+T43kpuvPFO+S9/9GH5vVd8VO7YUjxPquuxDztD/v63niPf98wH3e06h8xrd9n2dDDksH/s0QRZRINmTpOYti+ryQywM4M2XayQDTd1TJexx8LjpDuvRJw5w2ul1HCnbwBFW+9+nudIaQGtm2NcPZZPesPAiJKSfc9z1K+YaMV5HtPliAgMU183cNVI4xiMpbQmNl4i81iOm8tdTSBdbDAAjnkyjk/Ua3zPOL+hsecYObADPEpyVMmQcsFxnz1bRMiAr3ZpMvh3fJ57LO1cK3yC8zwkkZBbJJ/y+VlMXk694ZhsnPn4Hj1K1aV37VVZVxwNUwxPYMoHSWU0WNUntZU0y7jP8JKopXbsTXgALMcYuiSTBIiqm1oD8GgguRIbAjK5xoAJk98q63Xp1jm8j0REfvH/uUpe8gcf2p4F93jjvyMXHTtDvuFhFxCbE4ya4kMpZnvknDuzpzkAgKYaCWApJTk4iuzu7IgYQ6ByVJ7UrlYW9lvxibkBB6LN5I9YKJ4QQNT6/vWVfkfLMnd2JGJGa/tZvE4wplLn1C8Svioe/YeaSkWSJAdFPC69FJK5QiYU3gpv/+An5Y/e+oEtAHCyX/c97xT53Z//WqlV5NRTkxw6dEor5u1Jdp3UGA1tSknGVN2xGA0csoyREQsAYExCLuNEmy4UITb0Bhat0Ml2+CZvytpwUd3FPeciaUg2dQ9nTRRNoL1g4ohJuwhPs5X0PkFv45gg1hjHAtVZ04z4MJ7iixdhMC6cRwwy5XxOI+oeZjqoW4M7OAgyb+A5ZkiEsuQlYv4yOReLCrn9aqcFdDo+CoMUWlRMK4CaF8qN7tMVYoNl534vhBLTLA2ESptaR7jUc56v35MUGnURcWOq5vwrHbU0GRWxWuRdeFzUrpDl+4AiFYivT2ekf77xnPlnNadnMCXsPPAYopA1BJocDsqguUcMIK8T1vy7BnXRxwhGLFMhYK7RZz1+a0KEVfsNq3X2QhnfFbw/UBQPA+tUxSnJomrTrGKfIaihzgxBrq89JxzlJxJSiCGF7IWna5UKSdB0EY05kFa7p97GOh/HwZ6FIjff8jm56aYsP//bV8mfv/H67aFwEl+/98t/T570uDPdhXy+zrE/xTrXMAHEXqNIzdFu+lNrGNLxmcMGq4XAT7hNz9c5Z9PDT4AlY1g/+FnsOdiTA9CvruP2dZ6tSUthGDvyeU7rHADjvud56idokX4QZoUMEuNMyNTMb54nxWVhQlpZ7NE4z4Ua2yGF/IyZbCKy4UcwP0PZOJiju1jaJrMmus5+x90Wp3SewzgSpolfzHkORl6TaknH9GKQBM8wzl2AsxNJPEZKFcLvnkiG0p5ppTNZT3yel9pJP4pL0zZBe1Cb+bOv7SziCOBaigEdHJUYCUJI98izGgQab0R6nmid//JLTaLY3QAAIABJREFU3ie/9rKrtxviPXiddmApDz7vsHz9Qy+QJCJZqsVoo8ktJq0x5397vltNYfp6m3onmvYHqNSevaWq7O4uZBgHiukmhpIDWu13qE3tk+nnoZsvnZwlWCxKsaBK1P9sk3fe85ImM/njNWt7P9e7tXafBftrcul1JCRpCsnomIZgWypHElZPg1IGMOz6z3/xTvnwDbdsAYDt1ejNz37qBfID//B+Mgwqx849ILu7u1Jr8YImkdGMSKPlYyrJ6PRIzt3I7mBNIFxxNalM60a79Qk/ZQNjwwa6LUK57NQI5IIF2TYH6I7BCGCjjUQIcTjc9xrwMCcqlLcsHWVdSWgXmmzTY66Lo+dzLwMUYyJ8iGuH7MNMcF4AcEER7zd1DWE5QUEDR2aR5oaKKTwObEwfeNFg+jIaIo8IuUKHOdBzUESxQbH7PgM7aysuxyFotTDbktlCnYhpgqlJ6FojSgkFzfw+MKiyZp1p7XXzlYomZMzzdCY0m4lioqprMkupnckX01eRN5ykGfR58YyIF4mJVNMqxnMwDjHRa9OJAFy4Ce69IjDda/4dk9FuAdAgzg/PSfMhUJqE7L/OYzIUzyprLp0aN4TxWMQcVorWivebZyBcm+ZHnCEmnnjGWQNdSkhJMPXjIi5pKxJQVDazxdB04nWnKcsNN3xO/vg118lv/vcPyk23rraHwUl+/dj3XSQv+N8eQnr2XhIzzda5m5Ea6Aa5EZzzmarNzzukPeOgnRFcYxtkBx15nbf3k3xtNnYRHPqzrftogrAvYv8IR/UebA2js5gSYSI1JO1YefOJMSJuIf9Cmg4o3nyeg76PsyjTkACAAVIVQLlHoz+Q10hk13MSTWsQ2yQ+XtPZP6VuMOQAHHBhDL8jxJRyrfC3O88l7qNGjnw0BZvnORIg4jyv/mzh8wawE9M/njpCv44UJw26XTvPKfmllIhCLFXc1Gyy6Bq4+re9OBrv/c7zkAfoCc/zSgBuA4+KJ9Lg2YK0jf0DEpmuYf3td55HakJ1b5fGaKnOHkv0uiK9bHS/df6s5/21XHrFZ7Yb4pfagKnIA84+JI+63zlyn6P3isZYormvRkv3oYg1/6LVfcTwjHPUpIqBAbXR2xdJZRxFxsXC90nEk4o1woUafPFhYfgvQW4D3QgkytzU85CyltpY01JlsPdTgZxp334GwzXWZa1NwjQkJBqAydN7fdQZKCZaZdBgc2pSAzKqMTEDXEFNxnvfv/39N3XeAlsAYHvJEy45LC/+iUtkMaocPmOU008/tUVsWdGcrTBnejUaTOTcgz4419WgWYQGTFwSEJPEKpsuwYHiq+uxnRVQa0dhX0+5sRPG0Pu467JEUQEaX8Ts5U6XmPwwtmYkGyW7iicUsCMznN9ZT54i48lpn6FPlo1ou1LN3dxo6Q3llKCsj0qIuIEMqdfywUSJNfilbsaD2P5h4EmAA3yBxZSoUFssUnOAN008G/4JvVf4J7DvAu+JKj21jymhDEB4gWzTicUQxk7rKeL4eBISr2vOyUbrHEfWkwclFrFLKD7mf2aDLo7Sm4M0mbWkxDpY2J9dt5t6oAWUT9zPyLiv5JSfuhi79rnDrwDvbbXOJgeIKT0Xj7hnxSO91KeMK6JCNm1ue8aWIxXNNjHPOdgViOyp5uycKZaKAQM1syhopPeLdmzPSrXIUKHGICK4hJ6N5SJ5VjBYSFh2RdS8FsRjBtfr4lTt2z53h3zms2v5ud9873bqv738+vrHHZXf/eUn/i3WuYpqkr11ND1Ve3lRO3Oiqa9VZLlMTrVv6089nhURc2uTnu2YzwAvlRaHlx10XtuaVzssEJMGYAGUejTYq3X1Ji+ie1t+thAg0OJR6wY4jDOlAZxh7IlGDCA2pvX7rXM0kXyewweHJ84AUDiOUeksY10+30uX3RHrALTbQmcHJsTjIpkUiiPn0qY/DJ+PNc6J/a4pB+OJfQ7CcyjOTbAw4jyvFOkYMbQOOPF5jj1PwKSSaGoYFfcmxHwPapO14TuAcS3ep5/nU3UWxYnP8wCrwXrDF4RGvu3ZxvRQNdlYsOrCW0FJRhCDpXZGKsX8NlC+ltqxQrKDG+LGuHjfqrUDi6Nm7df51dd+Tr7lOa/dboZfwvWgcw7JRccOy0XnHekklX0aQ2vISwnQC89sJSPAUsXr4uQaQmPyWTM/Dq0GH8ZRlovR5DjNu0iE4pK59kB0n8osJrx2a6eUavKS6j4DpRZKEhJ6bRse2b/LlSJaa1D8G/DRXqfVYNWTA8B6ghwHYCRW/WT0/kGTgSHaycWaiWJ1SSbXuqoiN9xy50mh/98CAF/EdfbRXflHT71AnvUd58tymeSMwwdkGAaP+fFm1BZvaOLaRI3N37B40JDBWKZbXDm0OK6P1k3DmXFIoaN2fmHQeuEuDtPBbO6vqnVGjYwiA+91z9BnFADL5dAkBUndBHC56PVGA02XkWWPhm2xGFp0nR3goFsi91z3QUlLjUmKG/vYocaHY50Vo10zJD39nR2r2XkfrvsTgIRBZ9mooeOO6av61B+IejSgAWzskeHevGArFPXGjdzAMYAwLyTjo0z6dBRMMamJ98TNrReO0MySrpPR5EyuwZHUIN7IT8Ry2FsXN6kCNb0aWJOnyIEGJQvgSAFoQ27XcNEGTX1nMRBzIRxn+TBq3zcxH6Dvsm8O976Zk2UHSEAB9ecoJaPaih9O7IYNoAPZ3YWiEmF2yGwZ0OUQE8bTLExckADRvrcw5Zmvc04XgcuzJrW1HOt8IOPRnG1Kxr45VcP/w0CEvfUk46By0813ys03T/IjL7xMrvrgrdtNf3v5dWB3kPe++jtjnVOMWz/lRuNLxlC0zp0VpeEo3tZ56ibvMX2OyXAusecPRN/HQGnPQAZ4EyzMgwd68r1VbuCBagfSNhZRm7DtWPTsmprRgpjdAXtGdeM1vMdMkrNk3i9+3teYjFdj9XSTL5z3ZlC38v2CzsEiHYOsnecBkqRZv82xrzjPj5vxLvbXHTPwFTuP239LZIAXTe+aAHSAweyJsJ4gF4u/22/qWWtMzDH9ZkYaAAtPjtA+uYW9ZEQCIM7maL8YdCN1AmDOAKM9ej/c2DRT3oi2rfRs4fU2DPcG7cBwPs9xVoFRgeQWTmjar+bDBJ+TltKgMq3D2BIpAHi/eOb5PK8Ur7m29dmYp8mZMMuxHaoNmG/DjL1V2Xedv/L118k/+5m3bzfDL2jSr/Kgsw/JRcfOkAefd7gBds46DfCpOMjXTPgyeCzYY6UaZV67QaCjXNK8HlRUkrTGHDXNYhxFh3DTL+YpIBb1VyCzcuPM3gBwIMPrag25G1hyFB9p/cFQwbrgGh1yr+RsU7AKIp2DHaydeECS4o61VMMbI8BC80PQhtIVaG0NCEj7dMHXfvpW+a2/eOcWANheJ77+8dMvkB/+3geIqMrppyePC/TIHG8qmk5/uYgYIFD9cKAgBSCX9hBz9jc7ynIcCxDDvVWr/JfmqowpCSPtKUlnnIGGEIs7pq59zBtr21imkJLuu8GhMEKDMY9IK4Qug14OF2Vo2aFh56YTvxc+HwPJKPA5mk5fu6ZdiOLmpjZEjwNAAH0h/h50RlAn04zemBIVrkTpx2f1pn0mXZhPbdqUBBIDk3AQYsqfve6zaAfa/EDv7Dfc8GtAkz4RKAKPgGmfqTPTM+c5wZ7fbbRTTPL3VpnAn5B/YMrD06YWjyWdP8Pc46FQTN9IBZ1ShCF0YKCEgUK/WCQpmXRiajGS3giUzhgSRRbHHeKXoKnBZ2N6KyZGnInsudzwTtAW84Q1iLhESHFASW5rvnRFMw7B9bp0LBOwHnBIr6di+lBDtVNbC6WTyegshkq6WK677tqTz3xmT6apynf+szfI5+7Ymjttr83r1/7tY+Sp33hsc52PAQhjzxssVSOTrpnHriwhY9mZO1erbJg/8SR+ZzlY3KV0jd5AvjuIocOaRJxlImYYT1KFWEMR+6e+zt1INMO3pnasrlZ81s6HBeApfAPCi6Pf13ni3PbLPgUGBoex54UJqJyAOcR+K5/vPGfPHQwy5n4k2I+LpxjEeYzznOMW5/GFAC/g1dDFItJ5zlHAbDpYDQAodJ7jbAuwo0nJJjrPAV7w72Tj2NKd52rMPjzLiYwdtWNhCNUXX+h5DgZAqQEgwwOnULwjvIRY0z8OSdZm7IxndhiivttgliROF4pnNyJrzTTT7v/xE5zn3//Tl8rrLt26/n++a0gqj77vWXLsjNPkomNn9EZ7BgDMv6fie0GVVEUme0iZ6o4xOoC5Ko0Ny9KBMcXzIDrIznKUcRzNSJSeSRGptdjUPNjHqBVKCV+rXCzlzPwGakVkcNn4bNG0q7Og8fyJxN6VzJcMFk7Jhn0qfQyge8NIgBcufzQ2xEAUCvVhaooWFzKHUjw5rJJ3Dbxm3v2xz8h/e9P7tgDA9rr765ufcJb8mx95mIiInHpQ5dAZByWl1KGvnGXPBxRue0o9eo5GOqVGX2zT6qGbavNh7m7vi9TFeUDXA4oeDt2mWS+2eAP1RzQTTAB5Kr6ihmOyoialzai6BDqyARlq9DV2IJ4/fGxiBKS9bRTaOX2W2vsbxKEtruNOQ0SrhcNnTBRaI1a7Ax+TW/881OBPoOuTYQ+inpQOcGyWyKxXmvg7u6PT54UTfStGQeGUyPSVoHBiX2OdLL7fIcUsY+0GVfNJBOQV6nnIKUVRwhpQIMB84CjMh2ziD40vQBs0pm5UNPQO0Chw2CGaI2VQFIW/RPX4yjqXGOTeONMNKyVyxgHoYDrE+dcAtkDH7AvlPpcWJkyIJIO/QCHgDHGFrO/s3bjjaVej6wXjx9I0rNBkuiwze0opvs4BHLlsxRbNyuIWMUGC9lhEKWe8dlGGiNkcB5Wbb7ldPv2ZSV7y8g/J/3jNJ+TOrbPz9jrB9b1Pu0D+wwseubnOPQKzunymegMZUWpCLJQ6a4RhoLdaly6KFNPbiH4rvr6mLBs59zgnADo6tdRMQ9klf37GoNniiS6aOnj+LEZ1qjjMcfFaiaj3WLNgBolEzCuf58kE+5j6L8YA7JlCu1pHDBt8Z/jcQtPM5zl8UtCMr1ZWE9B5Pr8HfiYKm9/2poR8nmPf3DjPJc6D/e419mPfu+g8x9QZP6faMwRw/0Drz5RNzww0vi8AT6zNcY8apXokJBtRqCwAQJgHA5/nOmMgBGOkP895lKkSho5oaFS1qy3YWJbPfRvgOwujGMtNNc4YSML6s726VG3h7ILa1tLYWDJIiloukkc+ztf54575arn+xru2G+E+185ikIvvc1Tuf9bp8sCzT2/fRd1MaVJpjKgsvQqF7LOMJQAZcW1u9tIzRrS2FjepyiKpqEWWjqbxGIeh1TJIE7NmvE3uxQEulRZbjrqEY/yUo65FbHhjn6nUpq03nwJny7Awar7xq3bxnEL7Buo3AAp4D8x4baCYmcBSbGiXeJCSe4qgF1D77w0EKZZkNrWBCVFxLr36k/KKd3xoCwBsr89/Peohh+RX/+Wj2oGURI6eedB0tNEgY/9vDb2SXi2cjIFWo+iptDjRpHtDKNJpqRvogCMmtGFAj4fOLb56M49Fisn10miPoDe3tIJ2EEEbPJEzPiifMN3jDSMa4IgBbDrPQP2HMUkxWhyKuua4nJyuiSkn06xFxJMNkGsLYymfsu/TtCdqhkHvyxQR6Fos23j554DCQxMn+6D6SlEpKOjY7KiS3r4VpzXosmKFrFRZDKljT8D8avK8UnVqPvSryC7Gc5Bpg3WPAsTSTTFVwbPlU3YrLPl+TVN1TftEgAZHSc41o37PJGJjoC0Ns8CQmUz0O5mWyxO/bKNBaOFLDaYIZ0s7sGGFESQxKzKHhObYXZq9WIsCNZFPAvsxTKU6hZf1Y2gW1mQo5ZIKMplcr4tT7yu56Vb/PDA9bPRcPOPcTMDYCbRMNETM+Ggfu4paVYAifGlyCjQGt9x8u9x6W5EX/dZV8srXf3K7qW+vu72OnXVA3vT73+6xl0IeIwD6kCOfi/oUHQ0nzEoz5AHU5apPXqMJBRV/SJuTV5wTzNyBYRqYM3wmMejL7CYGbNHwocEfh7lOFBp9Y5eNSntGFLR4z85ekvADwVnsv98o+UgX8T2usHle9SksqOCIB+XGITPrzkBbRAXC1wDnOc5AP99LdZ8GflE2pgWN3j0K7N7AaV+kj+Rb2r1lyVvUOwZ2k6dPd55TKg2Doxvn+dga/PZ9hScBJX11RrnwU4CPA64wVA5jRrAw6uw8LyZFWSzSCc9zkUoReizRrJJtEj+mJFNpxn84HwulsqC+YPlfKQFSlc4YVzyaGiBwzlWGMYnad9K8GZSMEcVNa9cGCOwA0DCQCev89W+7Qf7JT7x5uwnOroff54g8/D5nyoPOPiQiMWWH6WW1Z77bI0SjyZ83sDQQiyY8nudBVAZQ/gcMdNq+sFwsjPIubqZcSpFKe3UtpUtU4ec/IvF6RlFjKos75me4DUuwhp3RJTw0STHQYg1/rd2kXwQm5WGWDDPiJiNmM+3iYNhioLpf0W9Fj5NrkeUwmg+TyXNt6FJqkWGIiGYRkde+66Pyl+/+6BYA2F5/u+sJlxyWX/npR3qzf87Zu7JYLns6XheZpnQgJT8QsxVHMLXgISmm8jhcvWAxRHqk+DcuVvZLBVguh44ej/W3MKO/ptuPhYZDC4Y0uYjsLAMAmHIcXBGjhAlGfJZirIBBe8MR0JzRoITmXRzdL9JohMOYQj9uGwsKBlCnMSWBPpRphDyxBu2bJRXQbq+JPs0RQ3OqJcAMj9kh11wUQ6zZzFTYspY7JaXvIwos3MsoCmbTcKN5OZOBjBxRpLAkgDWVi5mOEu8jE0sC9E2kU7DeFv8W8Xp4z/xdwHMB3z+onfMpfzhVqzvYQxYAEAdFPyZ/uaN89v4PDJqNQ8RhjeNgObrF9b0BqFgxr0ITjxQOs/Q5hNbNPGXBCz0DXPJkBn21SlXzlhhiHaC6ClosJxaEd0Si5xMmimgiAEAtxsGLbxSi69k6R8TfapXl5pvvlDvvrPKrL7taXv6aj2838+31t7r+3195onzdo47su86F5GClqlSbMEKq0lhv6iyaiPMMD5p2DqAAxJRyaEWvmUwlE3q2yW6yRq5JfYbRQEhV2dub3AcAPgQ7i6EDWcPErjoDqHRO2Cda5ybnsv1mJEM+BzsMDMbrF2jVyQx4tAM80lC0M0tVSh9hY9hsZ5mKdP4z7dzpjf4a0Lp5nuP8HoxNwXsHU/7nF/bBYZYegC1tyvE9lhq03US1CYp9pSQe3INhCBAHMgwAGqhp2IAXUi0+zxN8WdbFJ4rszfKFnuc4swCGF5LDceyvamMQQI4FNgrOczFTWOSoMzDcwJ0wASylymqVY6JP953P8zb0VT/PsX4aIFzd96AxLCJ62Cna7rMQEjUA7PjM//433iO/8Xsf2G6AInJgOcpF554hFx07LI+44GgDDM1grtTi97eg8ZSZ2bQCGIj60jE36syS1cxVRAZBFJ7FCavIcjmKmv5+aAWzT+uVnPZDwlk7pmyxZhiRetgPc43+QTnpS1tT3/a50q0jZ3GClp96cBJrvRAzxlm0UiVp8ucZzDEACJnMBgvV7SmpZJKRsYwBgITLEezNVtrnZVZbv/Gqj8srtwyA7fWFXA/6mtPkt//d46RWkQMHVI4ePcUPo4E0bmgIVSpNGJKhUaG9Bv1tbvSGDQEb+GqizV8anRhxaqD/pUEc/S9FOtpgKWjuxA/6FWj+5iKbS/Fc2Dqj6OF3uMneFLrrhkrbxLdiato+a87QUdOUVDn+J6QEiIzirGlsNkxFBIqNQ8sp6vu4I/N7R+OJSQPT+xhA8ck+Hf5JZzT5Lp+3dDRITLrRsM4lALmEwR1Pt/0eKU9Bik/5Ow0hTeUhlcg5Jk04CDAxgykg7udokodKaAfHU6Jg5s0ezXChKBYGG3wiT/F4tfY+BqwbhnY0DqfqEzYcTpFp3D73OCaLcqrdJBDvBQcB042bP0eY8fFrewTk3GRMxIEQUMtgGJjmpoyYsqyzlDrXYAYzp3qjEdFRKDrHIWjViaQvKOrgaN2t89pABzCNJltHPKEbB5XP3ny73HJzkV966fvlf/7VddtNfHv9ra/nPedC+fEfeHBnduqNoe3zzA4IABq05mQTHu0m3FjnIqFhdcf9ITwFsM7daNb3f3VPFLxwM0WLKXQD0AeLggqj1l5rHSyl+V7GFHys88b8qWQAO4uuTRIUWpoGCzWIHkNoEidnRqWI8ASNfaD9j5lvyKkvdCZCntTMQsMgFs0lg6i5BEiN318rg4ep2wMHimmstfcr4PO81oiEXIyNWVjoPGfvnC/lPAcozmbB8APi2gReMGDJIZUhzvPG/qr7nOfCIACd5y0aWDsPALx+APb0nBL4kO33c3wsR/EhxjKlqD2UbnSrMcTBJbxvGAP6dyZt+omaCia7fJazlEBmw4N/9H+8SS694tMn/f53/7PuLf/gCRfKGQd3W8yxjflRr1Qz15smkamG2WOwTBuYVYg5pPZdWoKysT1tn9R4zkUa7T5psoSTIeociYhxeB01TwB1OQpiBVvCQCWJVkzlYQCKJtGf41Jj2p7UJQGeeCZ9g95JT4TMs1Uk2XDQjTq9iU8OSok9r5XYOfg3DmxUe/edYSDHiWKoGh1v+36CQeSDxlrlmk/eLC/9q3dvAYDt9YVdRw7tyJ/+X08SVZEzz9wV0eTIPu62Sk8z44z1ksndXgLBS6bx9Sl0rU4ZhGHGOKBw0i7bMhrBQKAjIzYOZ9d1q8jxVZu2jKlKqeYjYBMUUMgXNkEpBfFhYcoDjSSrmzIdsK3Zxu+MYoqp5aoqa5vW7ywGybVIJZ0jH1ZAx0NHWDvNICLf5i73ONRheDT3T5oj/Pv9XSu+9nc8BtsABSLu3TBwnql0dFQ37itRXMAzIjTsShMUddq3F6ZEc2XzvMSbuvbGUsjqFpu2ayJ36tKbRsH4jzX0XKzwdzRPZNhZDt39Wy7CW4ILXW7KgWyXUiVXKwZVnHLZJh2gw5sDrLQJ95DaGswGOnkhXKOwdWZIR+E18GmR3ME7jHFwP2rH6uiBgurgAv4Nr3PRPl+bfRwcUTdDUNbxwmAs8KBgNyDKK+cezKjEQkJhmVTkwx+9TV7wC1fKpVd+drt5b68v6HryY4/K7/3KEzvtN9Z5LrWtc2t6qqjtgXBYB31Zoyu29c7RZfCDWU8trmoxDt6kOkvI1jkYTYWi+9inBk24VCUfHnH2kqcS0Kwf+y/21/3WOScVANAPg1dOq5mt86l0U/NhDNNfAPqF1jmmif7eT7TOneJb/Z4fXxWj1OtGLKDvLWNM5kFFL25Yqj404EhDPs8be612fkN8nvP9aZHB0OtLx6twnyEHQdokklNfcF8Teykpu/KrLMZWG3WMhNl5rvR7AQCEmV8lFiN9v3SeF/MJGEjzX4p4ikupvXRkMgnCQFNSMeZDMELFDIaFjIerpdYMnQmt07BFOskDojchbSgF0YkhGWCpYHeem7kxJKZ8nr//Q7fKN//Tkzv+7+DOKJdccKZ8+yX3lYO7O1KlyjRlmywb4NhMSZwFMtnzW6giTgYAzGsxn2pri0gdhrag09D0/M6iGQZy3Y99qDEPyEyVqO0K4ztQ9A2AyyQ1xrM6N7NGq1itOIK/FzwJfchJbB4MrZrePgDYRC7+PsgbTJtvr83SARj2QYIA08Gu4bf0gNjBOUkpTJDx/rTC8yD8YyrFAr7kde+Sa66/eQsAbK8vcIM4MMprX/INcvCgymn3Oti53wPtx8PYdCxB96tGN8RmkRRWNWpaf6WJLBacujayNQ9WRIlIyU11CP1lyaH5wQEK5/Rag1aIuLRWMLT3CR1bNTrdSMZG0ICDAdA8CtSxTqB8TYumTjXDgYtVPE1hhAY9WrFisk0Fqgv6+F6AgdCZAnV/34CGLueekHZ8Lzxkr1QoqW66NWdo40cqGFjzrdFk8lRkIh0iGBnDPjGDuaCpS6Htg4bbzRrFo6T8M9rrxp/79+76WgIrVhzNZTTUcWzURKZY4n5NU/W8bvYTqMQAmJsIwh0ckVPQayJfu3d7JgAAhyKiWzamaNDp0zM2JI9DSto075iWgT6bS6O+ohDmaRokCYiPnMtxcqndJB6JAj1LJ5Bql51Yk1FqaXRAN3lUP5zXU298ie8e+tVNMzHxCRzYG3CPVhVH6dlAalCVvb09+Z7nXSpXvO/m7aa9vb7g68DuIB963TO6ZzW5hhiSsOog3c4i6NyD+1+E/rtLpCGzz7YXqlOv1ac2cYb5/rXAnmS6bWObrSeOJhWZbJoKFhDHxFaiqOaivr9mau55nc8N/dDg8lRbO1ZD9T02kX+MpwKRMZ7LE2idlxrnBTORsOdyZjfOnT3fB1NE8ZpvQDFWwYIkfC4B0P7ezinzkDxAvubfO8X8uXSA0ocQsYj7U2Z+NdiXm0GqgQzesEoX9VqY+kvnOYyE/fm0M4bPc/xf1TjP2csGIAgAhnI353mbmKud5+Img/g9kwHQ8CcA6AA5JySPJt2O70Tb8MT9czTApEiuiLUh0mIehxSAGOqYpMlN/hYLJArE5xZRWU2ZYg17c83/+ZefkB8+ieP/7nfWveVZX3uRHLn3qebCL7JeT1JrCXBqKrLOjQFQS5N5uI+HqIzacIJchcyeW62VtJp7vYiahr2d4WNLB0pJhtFM/SRAKJ2lNSUNvyQhhqob5lUerlSvz1U2afdgTIE+30lAJaKsSw14AyyD6o5k4RFQCFwID6Yk2VgJ+DdcEHPccyQZBb2sCuQQqdsDVFmSgOFhcgYEy6UKsRRURD5w/U3yX/7qPVsAYHt94VdSlTf812+Wc8896AczUxdRLEVR0E9S0VA2GloUMWx0FBNW+3mNSDanMZte32MFqfmDBID16UDzOKJqjSMWAAAgAElEQVSDJ98cSTPXRTp1zZyd20GbSOPfgIakrUkBLZpNb5jOWCgC0dHBKp1TKKg/DFBEVKB6s1Zr3Zg8s5kaFxC8UbGenYutSnnO42gNV5VOpw+aH4pEUMNAw2oGPUHXGihmcITD9CzeB5pKuDtHhB6+A/G4Km8IyUQJn8uZBUyVNwZAyfG5E2ksN3wk9vEPwPMHcIoPCxSIDphQfBIAjJiQhQkmP+tD2oxRAkgGxkuxprvpWcOPgsGIwdYGpurMNFha4gbMkOCXUQkAKLnfMiP3trqcZr7Oaw2DQd0n+mr0ZqWBPs2XpnaHHxgZ2bSG3BBNPokyOVEBEFhtmhS/L5cqz/rRN8o73rtt/rfXF3/95gsfJ9/5zed36zwm5ckpprzOpxzZz6hRAzRUp+BjbxfpmxCP+ySK85T73+FgmYSpHMBtrCUAAM0Er8jOcuxMd1mSMPcWUTPSxdlxd+f5MMDQU3yfdy8EpchR4XUepnXc3KFJHVkehQHCPud58YQVcQ14Sr2x6onOc1DufQ9dJGIxzH5ON89V1DDjmDrAAKaFTGPnQpy9f7xJcEA19lI0rKgL+vNc4jyXMJPFuQb6e58pHklILJnrI3Xn57nQcyhSSsTQMgORpRbuEZBEip3n46J9uOzyOtN72yBjIrNiN4YEE5DqIoDFx4kRkxG/CwnF7DzHWbw0ECISatQll3imnvOTbz4p4/+OnLYrj7jgqHzbJfeXnd2dpp+vtUXnSej+EZNX7RxvdaqxQkjyEckO8Yw20CjZ+hhbbPCQJBm9v4psJBShMdeZF0Rr8o3SL7zubbC2nhwIyFYrsLN/sKciLQDJKWxXqL6HVK+P08ADB/F/B4ABNZ0oosmlkx1ErYV1nLo0MLj447zB6wI89tSNWkUH9dqHJaiV9tsAb/rhVSlVXnXFtfLX7/vEFgDYXl/EjVWR97zyW+WUU04xx1oN+pUV5nkyV/7FIMXMeELfEl+QUL55/zvUkLo60ygm8g4obqZTSSPIIEOj8BVfGP1UvJ8y4M/cVAk1fStzXQbNvTduU9e7sR6b85tRqLHWHPFNkBZUNhRKKnurTLnT2pnDcdHHsUVpZv5xdxey3bnAi0Y+ef4xJhJMK2eTQZkBBHPJADSKTjst0v15ylxsiBcJ/Dyg+IOZXDBOAmCAERTTE1GMMkCwGFNDq022gKkOABhoylHY8L2tHSAWxfFi1O49bKK6m1nWPeVdZgDY5vfM/g7zzGaAA5m8BVJKPoFnI0k4LYMi1zviag+e1do98wy0TVjnZtCHqSN/Bs4dDxZB8gOTNbCsVVYAR+b0XEvtXpOfe5h+PfNH3ihXXLVt/rfXl3Y9++kXyItf8OjuzPPzYAh2jMxMmXRGAcV5Vzoqav//i5kASiV6Kq1zBgix56KZC015okIyzhx2VOc9B8Xggkzf3HX7BOscDe7cW6UvuGqni+X9jyfhlc6KZMLgdp7PPIWSErgifp4XmhTPJ2n8Z7AQUST7IMKM6TitZe5f0va//jxHgwITxPl5zp+Xz3OA1HurqdGf2bh3n3jB/c7zSkDv5zvPq08s4wxE04zz827Pc+2ZK71RIr4D5JWH59LCTFjXU1D1ARqD5cXnIeRzfM/9XBSVaaLzBKw5Ak3gPYD0lwaiVQNQcG8x+GCzuKCWVxH52u9+1UkX//fAc06Xp1xyXzl25HTZPbDrBnreyEqV9TS1PyOFoxTJ6yKi1Tx3bMDD/iTYg2z6r2b+lNIQA6SkotLWodbIqgczoLiWnVmx0SuUGt4nwaosYcpdipv1Sa0bwz7VXk6MaG8iF2yuM/sLjnVuS6X672o/l5ytFNmBlRVhsT+RRMxZE2AkiFiKjLqcy+UDCnCgcf7BOAtmQt0YVPV/rvLCP3iL3Ln66o1E3gIAX8bre59yH/nFf/MYyjqPqYDHf8ymDvNGm/+MYqlSdnrTPIdxGRt38JR0HLVr+KFlFtlMFtgzR/blotHoQAkHdX/KLUYIhQYoebkEe6BpQCPXeDSDvEoGZ3zQVehFDVzwDc5zerUzF+TNYEU6/m4B2z2YTOM4f/CjWJR99fGYbjs9FD9bQd+zaCkDc0YqZtgp2OUWEnTMxez98BQcvgirqSG5PG1XonJyrBGKM47iQhICxxHOP1fdJ64qEw0VmcJzt+9xJi/wSEr6bDwlykSrhH4V9wn52jC3QuRemplndoWyVtezsr4VUgJMXFRFdpejvb+8b0IGNLuIL2s55BGlhcgtmAKqMsGTJ1eFDPo0jAxrrPMWc1Zcn9aBgpVVgrU7jDvK8yo706Ez0aJiMqX2vlGwYE285k3Xyw/9q7duN+ft9SVfx846IG//o6durHPIXRBdWkt1V36P4rTpcqKmppLrdXOlTr4HrUw6sBi0k/Mw8L1LkZlu7FoiE30xNlbCNLWJZzGpT9tzm6HWep1tEhxgwXyd19l5DoldJcp0FfKikT6TvgM5idIdLLN2XziJZj51H4ZeZ88/j9fHno37wdHBTrG38xwSCdaqlxx76NISglZmGjcOaWPgkYiZUQ0AwB7K/imDOZqxt0x3Dn6+89ylBfEFKYEC8V56sBiAzM78PBeN83wBk2Lx8zxbvSN2hgxE44dh8mLsPW/EXhPDD/yswm/C6h0kvSB2eBhm8jk7zxFt2cUR2o33dIEhkqAaeBJABGIA/Tw32ekaRrlDpDDg3qw9kSLJG95+g/zjH3/TSbO3nXHqrjzigsNyyQVnybmH7y0HDh5wxo1IoXO1xfVOJTu1vgEuaP6DUg/jSXTw8COCPn4cB3Lil6DvS4A6Xq8jZk+I9m/6yMFeQ5BEINVTAsAOaPr9agyG9lkyMXq6BWKNf3gf2SSfDDMR5zo3fsYLoaZEnYK9bNAYTuLjueQAZphD6urbMJGu7g3FHgZu6DwM4dlkzOPoraKHamupdiws0Bve/P5PyKuu/OqNBNwCAF/Ga7lIcvVrntoiAaU95B7XZtO4UhoDQEU8G3i/JreL2bBDphnX2JTCJpWIF3LX4AlGaOpaJG6sQNv0oscOtWQmPNUcxjlqCBRwoOLQ7DWkX9yER0TdkAboc61V0tAOo7rRjIuBCyj81POgPQqRDshEBzsof/uZz+VSXYPKmdUz0JKmxLphpsPRQe1zhgkgTyOcIbHY3xSP6akcsYQYKUyXeKKDPF80u9yMJ5pEu8ELZdpjSs86/tUqAABoI1Wk06FyPOU01fg8pD/nST/ippz9kXrqeiavBp9k88R9FUWfT47wjNCmXekZxrM4DGrGUlagJcQEShcDuLbvAo64jXHSCrIpl4gBBEii6n/GZ3OacemjAHsgoL32gvK5S6nOBJpy8TjMUtngpsYBiKLfKJqY4ixGMtskKjJLS9AcJXyHtM6f+9OXyuvfesN2c95e98j1h7/2ZHnCI4906xwAMXLllSZaaEYXo7azIukGs6dRaiPxAv4hixFNPNa5ugGdkgdAa4CCqs3NU5FmGrizCAkAdOnqZrvq3jQgKn2+dc6RdGNnhCdOy93vPLdULd9TQLtemFEe4lw5gQcAwN2d58XOIAdXQfkWmP61vWgNevkiyZhaihB78UDWhX0PZyKiD4tRbJPKhonu/FlAFOBIzA0/K+gMnj7PeQ6fBRh/VZre6cZ5Hg7mK5q4z71xptk9g88DzlSWsKTUy7HiPJfuPM+5uGkvagaATVMpHvs3ABA4wXmOxpOfAwbZAtAPk0eluqEYAKeVznPycGo1mcqgqRsgARRJSeXF//k98hu/e3LE/51/+FR5xmPvL6pJzj96SHYP7FrzWb0hb2s1BwPG0MBK1Hzo4mH8XVU8AQXU/TYJj6HCmODeL50TvtSeDVy7gaEBf26IB3AtJKbYcBrIOfmwAnVVLtmM9WKCns3HoIsxVaYTiKcNlFp6bw32CwFYMTP2Y1as8t7PXgKQAqh2DLM586AxhmxgVYrLAop5h3kyCN3LqRSBxxq8NlQjKhCbyc/+0Vtlz0zYtwDA9vqCrh9/7oPkx3/wIY7oQocG+iJHZbg8Rln7S1Frs1xa1dAh8oHtBzId4INt+LxuOMrOI9asaZjTuznOkE2C1miUTMe2ntrqWo5mKmMLZ7ApiYpGJEqN6UzoHoX+nrPYq1Pgk4aOCsDA/IHukcLe3XdOEeSmFcVSi9uJNAFom4A85in8CTDt4EKFf19PFZducoXPA8AGxYVvjJRWwDRIfibwPMzvhcfSzXW4aOIJSOCs6c5ZegYmsPvzYkxdY7yiHGqmq8+jntg1nNkNpTTKWqbpH0cY5RllH07LKrWjvS7GcJXF4SCeQR7rzcE4k1sAEIABEgo4tSmLT74YsabnjF2bWVZRZ0hXLWE2FjR/ZvlIt87FwKE5a4OTLVbG2gFQI/us88ve/Vl51vP+erspb6977Pqx77tIfuIHHtytczZ1m69zBwlTSGuG1EeVuTGmU617/w7Xvo8qSSjDOUXDy5GZbOYKTTQc1adiRe7QNO5o0nAOZmLuoNCOKX7Qq3mdb57nvTmf7xtm2MkFLfZMBiLTrHlnnxUGJDKd532Unm7o0NnhO5eY0oNFCG8eGM8uBmKlSZiTOlBjzTbOKLzfyWIN+TxPsxhF1BVqfsC33y5y7UfGLrtbReWB91/LYtHqCxjWdpGs+5znmIZrEj+zOZ2gShgWcpTven6ej5HaE+e5dBFmLO/Dl5p0f7kh5DFf0nmOusi9BeiZIaZbPAcyY/j1aQ7jkDpmI8CxpCLPfv7JE/93/uFT5RmPeYAcO/N0OeXgwa62FEH6w2RndrH9qO0jMLVrnhLoyKs585sM1gz8BqLT9xNzMZllIiNkmSFs6tP6nHPUhhZGwFn3vu/gsaQYPOx/DXg0ViHqG2Yfmx6/VKtDrUgvJSTLhWLF1Bv26jF+2O+c8SXsq4IEA7CJjBFpDy32dkhw/Lzh4YkNrMCLdJakvUYmc0CkLEU93jMAcH9UVX725W+T4+uvThnAFgD4Ml8PvOA0ec3LvnFDizOnvuEQ4r9jN0scajkjA7S6SY+KRvyOjYCxKDJRh4Fwuf7RKOVonqCpzxw3hyYWyLSq7O1NsrszelOFpislawKp0YMxR2+iFJ0T58Z7lnu3EHvpA9gTXFxxFm9HcUzBUEDhKPs88GjsUpJuys5mSYjI8WkNIeUoSJdmLgTAY4KhDmkD4YTM335k3kvnCozIQBRm/FpeTCXtGFuepQ16PRnwsdO1o8ei5kgtPl3DZGZQdXkDN5ucXODTh2VyyifuHRIhGFiYT3RgaMWaVUxRwjWWisYppufhKt6eD5gl4TXhqdAKoNTRd4UbFeWs2t5zYe5HwId0K8x7DwBez91ahltuLk7dZQ2tkgZusEKsve8wgqoUU1VqH0G29jSG1Hl4MFPkl19ylfzqS9+/3ZS31z12PflxR+V3fuGJ3TovRO0OrXfEpfI6X4zJ8+mbvr6PeotGMvTRMD7bXOdVhjR4Icr7N/ZJBijmcXrzvQl/Zso9a3jv7jyHk7wDAoI86zDPwnmOfwPQuZLsK5OMAFNkACF5lmDjk/OEKNcwiktJZW8vyTXXjvbn5JP41ZRlabp0uMR/8vqlfO725BRZ3Ac/P+xz3nVc5SMfHTcLS4/fij30Y58Y5XO3p1k7pb15hJ1k7b/D36iYQZpK81WHK7nI0SNZzjzST+fGhciDHzg5SxLN1n3uM8mppxQPE1JROf30IuedO3m6DDModhbJz4BxUNtjkzfaoNtz04PvA2tB4FGjTas/WCx0oTqhySFi2t4zHkoYmBmNP9tgZjlG4wUjt6RgXUZU9GpdLDWB4nDd6b86iwMsPgDN+OzXfORz8i3POXni/84/fJr86FMfLQcPHvTGOZGHEgz/Wu1XIjmETPjcAFubuV/qIu1Qj9AknUBBzrKv7sylvsdhIBNygIge1tpqNo4SbgAPNbgaze+Us2tNeKgh/hmK+xT4e9F4HZUe/IrhG/0uSh4I7b8EQ4Ki+KbSIgMZHEkkgYJfhbrEp6/RffJPQGSx76sDRToPgKiZle+dvd7P/fHb5PhqCwBsry/y+o//+mL5B99xX9/g5xpC1kwLaeIjTq1RJxu9NwxnVKETD9pZIRQSiBgoQaxBQ1PB7vBREJg22v68t86yWCSnLK/WVXaWyQ/LLrYnkz6NDkPO0h1SXzAB2Ss1Jg1VGIiQDo1E/i0+I2h5J8o1hrZ7v8k7fAdwqO/hsOToJaLQOYJfW577YkySDeVkXWSVTcr+fOHNJQ1lI4M57mshV+V5vdRFCKo47RV0exSjg8kVkM+KzwNq5NIKhuzPkHaxd6A9MsDD/9bzuYkpgu9vPbXnZGeZ/L67J4BN2lqU4uBMACDo4axMz6yKTAWRXhEJhenHOKqDLZzxCmZD8wto7uDjEPFTuGfwtgjQxGI6qRAHAMDfRSFgJmh26q79Dr7IPP9XwoDRdM5SA8yAuSZ0vOt1Ns+EuH9wyIX54XydX/L0V8pNt662G/L2useuA7uDXPOXz+j20/XU4j6TN5RBu4ZMDXslQOJ5k8lxqetJPGoT63w9FZFaZbEc3J9Dae9tSRoNKPYM9UF9fYABkEmWN9fZq6qsc4lYNNKa8jp3k9lc5cbPLOTmm4ceOKYi/6OfGOW22yOuthjlHw0CWEvHV0mu/fBIDtgzg1QvoEU+ft1Cbr99ILAyTBerTbOc3isiteZoqGuVKqUV5sLxXckA+iKcYB6mWtZEzJp1//3VvhMNuoTTfnXzPNzI4CWHdJ8ouvFXEdUhzj1qmATp6tA802f396UMUEj//nQQrUUuunBPxmGQB1+4kjSIPOj+eyJa5aIHrOXggV4r79KFLJ0nD0fLloq9XWRMrWbIps1Pd1OEb5znNpQpmWR63miK1zBSq+zsDMRuQNa5uI699xMgloI2YzVEyb3yr66TH/6Zt500e9oDzj4kz//7Xztnum9o3OEiX8xYL56zNsHWFLF6KolYT2Gsxz5dHOtX6QEDJZ33mlgyfQoST7Nl9mzEf68ymV7Ff76EKTMm9gnUflG22xCh+huARwwxgravIhv+Li3qXBw0gAQqZATJafjsp4J7WskEtr1WInPCOosMDP+V6EmUkg1kY+LvP0uf49//ydu3AMD2+uKvb3rCWfLSn/9am+gFaodpOVN35/TvwSPpQBmODQP0RjgVT6wNExjgZaMcBR0e01WP4tFokkSj0FmMYV7Dru/Q9SFaBxRP6OBKrUZh7DXiRaq7lePwAeq+t2rvEwY9hehvS3Ojl5kzLppSn1jTgcbaOUyUMU3iWKlpRkNc09Qd7ru432wMFRrymMiGQVxPWYeLs85YB/30p28GMbWHHKFRPKsX0tAf8rRgoHio1bp00YcicHYWp2HhN7pRI5ygbbNkTS/LVlqjnjxbtpgDNhpsnpA4sGHvlYEYfL72/UdDLTb5wM8ko2ZWSiiIrO6ebgxK2mLU+NwD9Ks50g0AbI0RGTjlakZi1XXHuIcoNLGu4MYdU0XIF2oXZSa2Rtm8qznXpm6dQ1/YGo5kMiCh7whaXO2y1lE4N/OyE6/z//Gqj8lPvvjy7Wa8ve7x6zf+z8fJd33L+WTkWmVnMXSA62DJNHurLMMwiHmT2jRNfJ1HqkrsfYhEbfIbAJow9ospepjYRgxare13evNk+zbeHyJTl0aBd9mVravJDNM++vGF3H67yl3HRT70kR0puch1149y222DTFnl/deMVkRa81pTaGa9WsckD40pTaJ8ut40cKDAtj0kBbTBYl9rDJphFjxToDvmPRiTNqViV90Ju8vrFlBfBwHFWawx7seVSk2z+kTez/p9fi5otYOEGQ8+hwuY3SgMgIWQEVpDrQFQWOtcw1TtRABAoOZBHQSIEKyGxjQQ+z3+c9JMXKMJUnng/SbZ2RG539es5eBBkfucv5KDB4qcf2wt975Xn0GeVNxrAXIEsfMcngP7nedNwiI+xV8uBzcgxrlWvRYKeeCeR/NGbFo0Q/CFCgmln+f2mIL1h/P8uS94y0kV/3fhscPyz5/++GCKqBBwUimfvm8YSy0iCumisVdEOk8APKXzRK9SihSpMkhE/s0QMvf8aNR7S5iwh0mpnk0a4EIvwSxd/cIAU1KwBVpTXWp4BESdZgxQih/sDKZr9XjDXEpX4/BnBjOABzPQ+UeDH0kBkFPy/U4pYsbhL9Czj3qILv4+wAA2TK0mbagl6n18Dz/3R2/fSgC21xd/LRdJ3vmKb5Pd3d0e2T1Bri4OD6XccNZG8uEJvba7Kg8qI9Pd2UgHhhgeuzTLZs+y4ay8MVHo4ovi/bEJIJp2dRS5ugGTEtOBEw3WTh8fZNBGFYJ/wHI5eIODITvYAaD5oYkS6ZvPjUmMSGeOBzoVzNTgUgxqKf79nB6Kph8u+1PuYxpZr8ffK99W9irgzGAAAKz5H8amn2LvA465Y207xyAGjSqeIxzsrCtl3b9LT4yay9FHrHPEe5nTejlNIIy6Qp/a6d7E5BIeVWQmX+Z0v99wKHJdi6PgHo1TGoqMqEQGd/aMAbMcGRBIxqwp7tdQ6DNzAoSSASTeB6Z4oBV7NFXt1zlH/QWAZ88V0e9wGDqqXYJuOxjLZTW1Qx5ABgMJQiwg/vOzn/8mecvln95uxtvrHr+e/fQL5Bf+xWMkDdrp0Oc58ymJm9QuF0MDFz1+ViI32qrceSIOnzmIy0WsKPYdrOsw8msAwDhYKkYJJlXORd73gYVMk8gddyzkuuubrO2DH17I3l6S224X+ejHR1uLPdWnbpRNfoqL1PkZxO3xbLLHIADRfUWSgwHKsaqdMRiaX9K04v51dFe5mzKv7lsWohHuAIFKYAJRgjec96pIFZsweqMOcKO9lgMLohuT9P3ubLehxslJ75fuYReJR1Fg7Puv/RkcxOAAYjSl2T0BhbtYg9e/Jv/b+xyb5F73ynLu2VkOnV7krKOTHDqU5eyzihw+NHWpTHd3nhfLlmfat7U0oilJycXBDxgzBuAcdQ38nXIufrYJxVG26Oj+PEdt9ve+59XyyZMo/u/CY4flnz/t8UE/nzFHtZsU97R9Z1fiaST3++x1auwhPjWvtVupyvsEovB8Uh7NLOIBmUXFa5/pBEgAiIa5+rAMhstJevPBoOArmRQ3n7JSY13gZgTA0Zvxqc4b8dgVWe6rgu1TWzSrMSHTkLx2BbPAUzJs3SaLRPd0JbwuarNcYk+r4S0C0AHJBoiaxeu86E8u2wIA2+tLu573Tx8gP/GDD6NFFQX6MGinDe8jLSIyDwixmEkGcj7Z8C+pmLtoi3WpKqKYZhgV2GsH0mFPpIOc5wUjfmNcJClG8RzMsb01emAu1G76qBRRwxm5KNiYyhMRie3zADCo1pBDa45DDU0UInKUOkRQvEcy9qsoSiWaQhx+bhhkRnvjkLwRnAwdTyIemTTQtB5xRHkWtzaQy3IVzmounfbds1ZLGLlxE47PClfeQnIFGDyy8Rt08NxkQmeIWKeYRpM5ISbGRq1nEINjFGESlegZBWMiIrXs/U29+eCKnnEum+D8nyjOD/4H7TtSp6hFLnOwGXDA4HlDEYVnbDRZASKPGnWyds+8zA4iXKDRcxOCn3NfDOj7azAdgIwDKBGRLk5QaqXvX7sM9ELIICYHQ4LLbZUpR84z5zSj6VrP1vmlV3xanv38N2034e31ZbmOnXVA3vKHT/F9aD1b5xxRmXM7nxZmtAl5ldTISYe+M8z1tPe1MM8QNrLDXllrlTvurHLNtUsZVOWGG0e58bPtnHrf1QsREfnMZ5Pc+OlhFkOr1ORXL+R9os+UcZ+0y0aDGMB8OSFEoLUHESq1006Rr3UWCxrN7yaLoJt12c+Xu2nzsWemGWsgOSOAG15v5IXMsYgTXPctIWvfnHfvSR0gaFUKqE46u7fatQqYyMfPxnfCbRWi1rr3qvHdutyhcRKt7ZHue1b7/prcQEXs+XAQwynW2V8PDAY0iPg7Ia2ypkGkVjl6pMjRI2s5fMYkZ59V5fChImceXcuh04tccH58r+t1JmPeZOkuiJO1CDeKxkWdWOkchm69Ja6pAd3ia7WQO7vXC6Jyx52TvPmyG+X7/8VbTqr97MJjh+VHnvb4zoWem30H8tEkSpjktbqp1ea51Lai1NKLMG2WfiIOSrqSBABn99A1/AFEgJ4fdV7UKE6sKXWucnFWkRKrqIFM1fck1C0ABmDA5wO86juNA5JJgz3Kk33pojh5Z5HOowwGhEIgg/urqEiRqLOcMZA6+CFMv+0eD/Y9dOKw2ic1ACSEJ4EPXzRMCV/8p3+zlQBsry/tOnTvpVz2x98uy+XYaaRzjsifMtORs7a9FUvxoA/mJoppX2vkMH3R5vov6lRl0TadUXN7ZU05jN04jg7/rmMqUIMBkz1Q1X1SPQTFO8zdajcdR2POjU9o8Y3+jBxQmtYIMQB4Az2+Cmo3U/TRGCGfHtPlfSfyRLXDZ5tHSOVaZb1u9NHIu4bbbm9+xX4EkCcggqplTofHAJu1oenkqS4mIGuj5e143FXIP7gIrIVpUn2Oshfd5LyNxn0ck0+qoDuttfkdDEQxm3KRXdMXcrRVxBGlrlGe03oXo3YZtiLRtEJH3Ir7zeI1mnjt4hchHQBrhCleLcbR8p2pyYBfAXsA4NnEBVYA2CHx3aB07zNoofsc6HUKorUWQ0wFqPkIP4Eo6vB644D/Bmfo6u7TbS3BALEVdYhNi32jyk/83OXyh6/66HYT3l5ftusPfu3J8sTHnOnReOOQHCDm6c46hzkTG6byfq42tVej8c9/rpDUIKnK31yxI5ddvpTL33lQbrs9eVHX0XUxia7R9CkYaFRYQruekkl/ijVx2nvWVJouc0Fb0YCD1t7Z0/fT8zlttTIV3gvt4r+FM7L7iZluTP+F3odT/jV1TX1o9YuoDPs2xVqpTFTtZA4d9KG9kr39DlDqg0ftmeTQ3JI0ISUG9DoAACAASURBVBqV3L1f7zO8iWifJ2miyC7tmwE0XmwgWOM9qf1slSyqY+dZwI0Bvqv2uxqzgX0Qwk8hxYRVUNtkYrMQKwP/28CEpIN7MzTDtSSnnVbk0ZfsySUPPy4XP3xPTjlYXPNfZ+yyZtIcdcTeqjV5PBhIlCo1lSJWEpo3T3+eq6rcftskH7jqLnnZn18jf/jaD59kAMAR+bHvegI1k6FlH7rv2aQuVcyYOGoDUuF7tKc/yKgtSvFm3b358KwRC1fJ6K6UattYoedAOy4R3PmRRpCtr0BD6/WvTcRarVwd1NiANTXYnO33KxGRKqV8KOn32f+k7svygfGr6HyAGNF8jmOoOiDT+RtguOYGtOIsgKhja4BgJONBokGtjUnR/C+qbU3V3+OLtgDA9ronrhc+/yHynGde6Bm+oU9Hwy8dtbdRfeFAHJNJTMmZ/j6Y9mY9hdFfIWdgsNl44oxpJTT/0G+vp7aoUWx5U220dEywWWMPD4CYqrRm/PjKaPzm9rxeF2vIIq+0nYfqrvHuGF2aPtQnyKvcaebQHCOaaDG2nRQyBL7PSfuIPaYelSJdQgBP2Od0ajTooNKFhlzcgR4rCzq6cLpv9w9TZRTLAGxKDkYC39vFqG4aCCO4wpGSqf9MHqVCjsKltMlByTR5FnhRRDZ3lXnWarhI4zN5TBSbVYqECSAlFUy5NecASJaL8GrgWRHAA96YMMGo9Bmcvojvjn6/m+uIMQk4l3ueUV1hIJjs/fXmllgrMOkCe2FpIBOYHYuhp7BCk1lK8eklGp0FRXu5oVmpskZUpzX7DOA4c8SqisVoIFzmvHDxvHA4O3MM1MOe8mdy6+fW2w14e33Zrh977kXygh96qNGHw0yTAQAGCdnQdbkYvDFqsh6lyCY2dYJTeZLLLl/K31yxlHdceVDuugu0730QQ2pwo9IuZOcps/WLKfHgWnY2rnP6N5gCIqJVaXIu3jy33yvWHFqDV3nyPpv6S0z1RVKn243CurhEQIwa3E8WWUrQQI/WpLIOnvX+8W+rj+yqewD0s/xoWgXa/pobmLKPZpk1/2Y1ZsX9YNFoxc0G+beEVCAJ04bZBtAZGeyyWNUbpqp1zs0Qmlt644HfU0pxx3Y8h62RiMiHqsx+UL9/PbiEBz4kEm0iXKlBoxxJv9dVSslmHmeGjto0yaoqD37QJI9/9HF55CV7cuzcSWqJhCVng9l5uJ5aI7fg1B+6D0iBECle4/B5XorIey+/U9552e3yf7/m3XLtDbeeXADAeUfkR5/+BK+BnJ9jCT0A3uAunygxxGsGy9YuYuc5UdLb8C6aUv8e1Rg2lRpUm+LXXDzWruTchjIpJu0uBSHfIMghnWWgRpgvGBIOMo6jRxHnnAMs8v+PwU0ycMISKYZErEXtJBFVDcQodWP4B6kuKPpjsmGkP8dRc6UhBSDgaiftZBAhZyWvC+1TxErp8UklcVQBCFPDMNETCqyO/tmXv1WOr/MWANheX9r1TY8/U377P3yd6yG5USvW7LZGLHLJh8Gov4WmnXPrcRE3HZtyTO+h78ZUM+c+L3adK6HDNikVIYo3ub6jEVmXzuwN5mk7y76gws/OI2fQnM+1ifADAFWfN1SAF5jkLxZDm5Yb1Zun+uOoLglgKnrFtFQj+oZZDeINbEQComGHiZ8QJQnmUQtLG5gKa5MCPXTKvrEZempr3B9EReH7ALWvVmoczScB4A6SGxLnokrEyqERB9iDewUKfRQMxQEATBRYaxW+CEosE+m8EPiz83eGHGZ8R9DsRvZwfLaQA/SmhGEU08z5RjK5XFOEYa2tma6lys5ymEXTRMPR1glrIRmoDvMxlt3ggIKjc84AyaTLUu6i0JS0ahqeChxbCVZJk7YMZqhYHACQmbOtr10CvSrdZ4BRABZf9sfXyr/8xSu3m+/2+rJeT37sUfm9X3myx8YtF8mB1URSmfZs1i6usp1V/XOO2D+A0LfcovKOd+3Kle88IG+/YkemNWnTVTbLmMqGdz2VPlhtNFWqQYFVM4hzOnoVlwegEegn9qkvpDr9uYRZlWSRyu77df8irPagQZjRzQEAkxl0BoLRsLhOvW7M3ohlMKfJGwOAAABGVbpEgUoeAfuWlrz7ygzs6A0L43WUgIw0A4A4xSaSCjanlkLShOosBP4zSxiY2aAGvHBUsdaYCMIcMG5plbmhIkwZ/Gix91iqdIkO4r9zkDBjtM+kcaIXazIBLB05spaLH3aXPOrhK7n4EWtZLCxZiSSRqIWYMZZo+DNQ/C7MY9Ew3XlXldf+6U1y9bW3ya+/+uQ7Oy48dkR+9Duf0MXK8VQaNdpk1H1ufjnaGhNqeBVlNwouXrvlnP15K+Y0CEf7NsyrFhspXU0qFju8noqwWon3klIAjFYfzoivLJgrqw0IBxmGoYvl9lVfe4B0MPYACAPuXTVj9GCP68390ka0MicOMO0f6wR1EJgAAGAkibMlfG8y1gNAmVyKaMXuEkkA8AEAENrSDmlfRkLWek9e/KfvMF+ZLQCwvb6Ea3dnkMv/5JvllFNO6ajsWARY5M2tmEzUyOwOmbHJ9GCgQi5gumfT2jC8CMr1RFNDVfX4N1DIQbeJ5q6Pl8OUF9IBmLshLg0pAEFzM12PRlHHjudRpMSRy43lMKaIhTKjOmjR1+u22IGFuGnbGEBDi9BrzVGp4n+Xc4AdnGMviJGz5qxIy51Pg5UM5Myyzq3RBgDAhzu+A7hOe167CtG7e8PA0HbRlJp/lgAAyCeEwJxKBEjXpNEUuMUAaqfJ4hQAbsZzqd3rhUs2OeFCv2amX5AUAGhg2j+afjjXQ2IC4COpyN66WiOvZDrI2bUohgzMScg4zuEdUKp9FnXqPKijcPPGZ59T7Z1eR5m/nMvsB5FEBNlo6wiyBIAejGYPqbf/irgedRqhSw9wT2vtMnnBOOBkjuZF0YoJbOUjGxjaOv+Gf/IXcs1HPrfdfLfXl/U6sDvIB1/3DFvnLSUGOn1f6xbpJ9qYM9kSO5LOnaLbur3plkEuv3JX3nbZjrzjnYuu8RRos9G0kp+MylyvHw2kx9xZ4cgZ1F7Ip5neXffXv3PcFjv1x0S6hm03fm9t7znAAya1qgMOwQiobLfXdvqaesZBZ7KncaZW3WjA56Z1XXIBcr8dABDfo+Y+f9QSi8xMDGWDjE+zeFViZgTFmAGAYCcwEFOJnl88sk9mjIBgTCC9JdtzkyieTLvzr53L2UgByY3TGKAJEAhpAMlPWyEQJkCMuHfMRnGfAFWpJQfQQVwM7QCAYAr4v7PoOdVBhqHKJY/Yk8dcspJHXbwnZx7JsmeAMkB7MOGgDsm5pTR1BrUpPH5u/NRaXvXym+Q9H/uM/P5brj75AIDzjsjzv+vr4rzegLOEkjCry4gQa5c0pLnQ3bfvoHT6/CYBiP2iZqpzcjx901Qk285WapVBqkxsOshRgRhA2BNaiQFS6TEdREVnw4XBQKPd3R0ZPWI7d4bkIvsYGYtQcoF2kYIYIGFoyNKGBI+jUmzAqD5594g/uuuDsQVgkBymyuoQjdCwEjVwLrnzZoEJaC65S2XIpQTYYXv3jbfcLr/5F+/cAgDb6565nvWU8+WX//VjujMjIkbEI0RyqR0AILPygjXmVRrdPQxeMF0u3SQXDzom92gwO4O+qh2KDhfSATFJlqPMNHYAABX0M4AKfX3StMnaXP2rTT7htA4mAXLvhZBX3CNsNmz2BnBjNTUUfByCEg0AoNHcWkM02bR2ZwH/gGLxasn8D4pl+QYA4IaCZNKChhasgqmIGxBmS2MYZq7vmFgjpjFTw1klHLJBSc+lFcoeBUSATSZ2QeikiOZHOn+OupJ9Crk5AMD/Bp4QmLoHYhvNbs7VARR8L+OgDliMnLhgSDGmE7g3wW7QzhfBvQ5E3Dm51sYCQcEids+K6/gbgwNUyIEyvFnO4V4W7m2BmMUGBJUqsmOfq0gg7BHDFFKRJg/oc8VDblK9EIumPuiYuUj371F4VDLjwTp300nIMgRRPQ0Q4Kiq1116vTz3BW/Zbrrb6yty/eYLHy9P+8ZjbR9LMPhM3YQMTJ/B/GYSObOupyKf+ewoV77zgLzx0h35wIdGinqqFo9pwJkGfbyUTPr2zRa0WjxXZ0pIBptM9Z43kw4AdNNuNs8LfwDlFnsjtiCywus8pqoKmVtZsUqGfNo13GjsZ+aA7m0QDv7C72NWP3TFB3+OTqdf+888Oz0ADXB0sZ91XdMu9Cn6ZpgBAQdp9m3cI27QQQlNBnfH91c2AABiLJDvAqj+IWaeTeA72jwa9yQCXT+xGOJnosEXclxX7e9XH8umHYshzCYrFWF2fzQ1KjQBAMxCEBE575wsD3/YHfKER6/kYQ9Z98kwfp4XH4DMz/PVusp7r7xDrnjL7fI7b7hKPnD9zSfdPvYg8gCIIU244M+TAIT+d5WmIa9SpeQipWaPuFuv1+HDkHNr1o0lVY2RlGEemJofUy4Vg2rJM7d+AAAFDbNEJLFUHkqFH5CUfZIGADhVlYOLJKedejC8D5zVwA29+ZJo9bWFrYT3q8Z+JBkxUxC0hzW7ZISqXYcKUKWxMfs42B57U2cSl1q85obnlTj4UGNwUgnODEsCERG568675L9deo1c86lbvmqf9S0A8BW+Tj9tIVf+2VMkpcEpOkmDCj4MyRcTJnnDMHPmtw0oeSMMIwyaPlNzzgAA9DvZ4mVY7yzSa8j5YhCCqdP4z+OYIroutag1diz1SXQRb/JbY9pM9dbWaC9s6g/6FDbc1comvYum9VlPbZNk/4RxEDeXmswzAc0n3G3hTA9/ANxjAADYE+Don8ll11MDyEAPVPH1FCg72BgwQASDwyUG9hkn++5CAhKvH/rBoKOz4V5LV1B3881FOvlENpqfiDiaDPp6sQhF/B6wICA3aRT1MJ/EPUtDeBGAJp/zXPcf2bkt2nEzwo9ZG8koajD+48O0fyb7vx9mEZBgWORcNuKPwHABCACUfLXOzlwp9N1CR4nX4WlOkjAh670iSmd+yPIFjntaG8NkGJMb+WQbKg2jbjxryXXPpZP2ZE+TCLDQI4ns+f3JF71ja/63vb5i17OffoG86Kce5Q7NAK8yyWE8JYOAsOs+OcjbLtuVS/9mVz5+3Uj7iBmoIeyp0uQ+bVLEYdS2abaXrWFTn6BqGtr6k4h066XoatnvrTBuDWTbZBtlWwgAkD56i4BrNuWLhiHNyi5QEdSn+EIxbZEMUEKCAHmeq1nr7DW1c5/fBAGYgsgSiT6BSDrDvdjgcR958sdGep0p4T4CgZASACDKAV6oeGO9KZfgAYXO/jtxEsx3IHjRzH+oHSeiNxAMs8VaEdtmjXYt9t+G+G3+fCQHYCISLu+jkVYyDBQCj4Q8Efj7VIpz4yazzkwdGX5qa+XgrsqjLlnJIx52XB77yLUcundxXyjULqjnUGfcdWeR17/6FvnUJ9byi6/4G7n1ztVJuZf99Hc/Sc47fK/YX+xxKYghlln6RYn0Cejpc5mazr/9H1lNpe05JaLu2hoKlmC2if7kzttmUHeCxg3xdb32vdV4/oMdJb8HNbA+VJMkTXLa7iAHdneJyVBouISBXvLpepVgUrrEBCvZ06yqT/eTJjfmQ38AVg7kNcEaqBENC15XYhZYj4GqsjngPB2gOrsAe1Vhg1r7LMmGaaVW+fN3fFDefPUnv6qf8y0A8HdwvfD5D5Xv/54Lw5yO4/LclT8YAGlmmlbIzALULUSm8eJmp39VRL4QGkiNfSHT5GLTRNDt20Q2NhiYmGESjmkoprgwKRSY/FlcBxolxNmwRwC7srMvQDbzEzyqmO7moh6NUyi3MxHNiCfgrVmzTacE3R4yBxSoqv2GOU21a0hBWccUCSgjfAbQ4OLQr4QeQ1sPrXah3Os2xQ3teJgUahd9iPfSR/dpFwNZbUI8WkOf4TVAhwYSHnKOKBZM3ydz3Ia+fJp6RkPzWJDOfA+bdpnp0GBQiXu+XLRnY2WASXsWzJNBgfRScoTd58VisO+D4r/MWFEl0izYDG/tpovaTeDRlEALmTTJlPOsQJ1p4WpPnnVvCPrcDGyEl4C6tAdAlhrVDgwGuPRCUgMUO+IcKTI06QZDoFhhMtrzuzZjp4uf9mdy2+1b87/t9ZW5EAe4/zoHYNj2i49+fCFvePOuXHbFUq7/1OjTTo7FTE7xj0Y0pqmZTO6KMwRiEitE465u+scRcygM5zOoXncugqi6yOpmsZVu5syzphzsAZ60y/5gQYufk07Xz5NhUI3D3b/OAACWJ3C7GxR/mbMTKk2x+V+7HKB2n68PCNzM9JZ9ww+pyZ0BFaHPt8m9qBn4sbZeZtKOGu9X637p6fGT3LnU2e+vYjRjotwT8OL303XHkYagxggBfb45oIdfUvUItmZq2X1mTfGdlhkQVFV0SD34w5W6AUHFAJTaGQkaAwKyFgK5pKo84H5FHvuou+SSRxyX+39NdqbhmiR5t940yZ/9/k3ygU/eIr/zhveetHvZTz3ziXKfM+8dLD6sYfsektXQFYZ/tfqAodQseSqS89Tq+Fzs/1dZlxJO/Yics52kEO2STfhyZQasOxp5/Vjdubn9HXwFRIIZkIlViXVWqLbQNMgyJTlld5SdnaVPw7F3+1ujmpWXHNYnWKyofTGYjKQO/LviMcf8/CsGNeSdhPuchiYDmHKLffboQUpCKwRMYIDCaw+Dk+K/X4IhQx4Zt9x6h/zSqy53tucWANhe99h18YWnyyt++5u8oIfGtzXSEQFXpelyYuoeG9EwJDtoSl+wWGbnNIWhxoLo+UNqzQdoR92m4FTz1hiNHleI3xm58Whgcg4JwJSrR6KgeYP+h807Ro7ry6DeKE12Zd9pMmjgbnqnvbdBNYAAk/QlMuVNWsCadtx7z65fhAYOEgDQ7hkcwJR9PlFhN3ym4/dlSXWzwCH1JQsYElNuVP1i4APHycGQLpHx3GLsXfXxOk0CkRxoYLZHSBRCHoB4vmI+CDCpC7NB85ywSLvBjL2YGpbdGFHdQA+eFmjGdxbtddAY7C6T0+/bhFs6CQekEh71Ump7xmswNIaEAxnxYUhqoBQAbQaWxRt7pSY+gBAGSfAZe2Cgr59Td/AYG6DGRIUBMtGIemRAB+sw2AL9Ou+ahNr7RxTyMgDDY8pVfv2/Xi2/9NtXbTfb7fUVvX7/Pz1JHnfxkW6dV5NcveeqHfnrty7kHVfuymdvGmluqUTn1p5uS3pqTDyLsLFfTPp11nzHFDwmu+wJELt3MjMpNgUl1lHVDhQOyn0NV3/p2XllJh9wvb8qTcCFWlftenOyrPaNJ37fYAV26UwGZycKnU15RtXdlCewz0F4JFTp3WVmU09qtnvdfA+qaAceYHTRN9g9PaEEIMTmfeYHIGxw6AyG1hwjeo/BDoBKLrHwWEUz+FPt7zW5nrlCQHVWNgN/iN8tEpT/1kiAYRKGks6k6L5sBp8SxbpxwkNxJkp0YkrSlAAqxHwkUhqCAVObiSBAozNOr/Koi1vM4CMeelwOntLA7g9/4Li84f+7VV7zro/IG6/6xEm7jz3nmx4hj3nged3XhDqrPTLBwgAjow3usrEsixv5oflvMcSlg8mSGrWfdgGzSekGVAw1AvCCUbRKROJhMBANdZMVCLv0k4wmpaENkYZBdjTJwQOjLJc7DmypVpcoVzI6ZlBko153X4/wr8JEH0aK7X22d5OIhYyhV62hx/f3ImzS2oDZUkoMSGf1OcAEcQZyMdkXBobiQ0wM86ZSpJQiv/HqK+S6m27/qn/OtwDA39H10hc/Rr71SRd0EWqibYpXSpXcZcAHwoZYP6Y1o7YpBiGCDQB90WKRbPpfZHc5epPokiBKAEDDzxdQsCEFrRkNMRpRTDuZgYAZSaM21kgaoAjAcACVTvPsmj37ves1GnPxshGb2lRiqg5KdWv8Qj+NiZTn5g4RycYT9tW6uOxCbMI8DkrSgmq+A5WaMMSR9FnW+F3JsuYBPmDDAeqImMD1VN1Aq85o6AAn4Kg9TdVjB/E9QKcPE8Rx6J3s4ZeQaxwwIqbL1Yi0W01hmIcGFikF1Zgpi0VyRkAp7X7h3iGqkcEWmIPtLE27b2DRcqEyZb4XEWWE+wzgao72VstcjgNEPAWj+y4U+cjZm3EAAJAgAPiCp0MH6tAuWap43AySN3j+BErbOCiZU3KEWXyHhZx5O0BdVdYGZCwXgzurB8BUOwOzZrxTTYbTQI7v+P6/lA98eGv+t72+stePPfci+fHvf7B5woi87bKlXHbFjlx25UG57TZy004DUaqTT87CmZ/n2RKT135OHcVmrdTEZgl3de3j8iSy21EYVgMVhaa+COnTSo0Vm0gxW0DEgfiwoA/tPGQJMdnnBtMo9hT7JzNdvG8OAAF4Og86OhkKAiypYeLTgQp15pSw2ZjPjBQ3GAmUmEARgN1OyMyFGVwO74XQ5vMO2u6d/x2o98ymENDwyXxQe2PGzltA++i+kBa0CsVBGp3BHDbM8GersqcA2JGlc0xHYyKI8bP32mqd0jExwrBwUzLRySdqNE8BYok/M5C8FGevkJ9CbQBA0sEo7GxsiSehyMUPneQxj9wTuesmueFjN8tLXvce+fCNt560+9hDzjssP/yUxzbfBRsY5M7PqXiOPdZwKdnYi635h19WS5QszjJs9Vc0/Hu1yqASwaRk5DcXzxTiMmWi19dSIvWoztNF2nvJnibR8KqURquVkiyGQRaqcsopSxnHZbfkYdTXE516qZDHJKYkuRYDRzgVqpdzzj2+tPZrGP1C/HzEL2rS8Oug96DkYcLDzUKvJSStFarx/H+Lymuv/JC85t0fOyme8y0A8Hd0fc93nC+/+jOPowapdtntk5l+JXLgRAOUaDIJPRdM0QolBIhNv5shWttOWH9f3P2YHghr7KEb388TICbz8R8xMY40g2iEQZfiBhGfGXqqUiNuDo7sABrYOXRh7vIAHcZBLRM9mmyeeEf8SgAjoOt3m6XqRjwJ/ts4JhlsU+Y4vfm/x8+AVgUZB+vea+2NDXHBmJF1/qVGTNY4BFthuUgORvAMCXGPmCTHBEgcAGjvK6bXqs34Zz4Nb5n0RI2asR2WZMJXZm6yeGZDyxUbbKJiUZ2qX7zwHwdEYOZO5w8UOLJn++l5HMxBOWYDMlGVvb3J7yWAoURyDPY+wP3PpFkOXw3T34+J6HrMAIjIyQDRYp2LVF+vq1UmpLx2pk1Y5/CTCOmGylSyJ1M40GAeA3916Q3yv/6rt2432e31Fb++/nFny//+3d8o73jXjlx2xa7c9f+z96bBll3Xedi39jn33vd6BnoEGo15IECAgCjCoUZGFGlREzXElEpUbJWiyeWyrFhKylUpV6UqgyuVsuWkIg8Vl6PIkq2EGixRlCxKLIkjOIuDCKCBBkFiHho9Aeh+/d69Z6/82HtN+9ymAKUKaLDv+UGiu9+799xzz9l7rW99wwZpQxYmylTaFyaLY2r5zoEcqu7O1PxM1UxLE++i8ggpTH0j5Z20uOda3HoWF7sGXJv4JUyC8QQ7G1XYU9hrw86NP75R2x0A4EBL1dwzHJBAJVIQCAZ08lrcxJ/Gpv9C5V6MCizFdUIbG2g+Cgwmp9v3rxHOp0ksaEpOckwFb4hncYEAGtlAAB4Y5R5aykvgZmjv75lkbAIBPqhNSGDHJMCS2L/2etp1T5SUjo8gHxEDwuQALwMAGCIpcMwDjp/ev44VEiZfEGNLYaeI9rpooHNgh3jmgYHqT+PTD//HS3odW5/2+LtvvxPXXLkPfdd7rzj1AyleSuV7LEP2jMWQqwkfYzEMyANXjx9GHgYMzAoAaFyfq9NEwkn69zGDw57I+owwa7JQVnaBSwaozXvOgxJHqMb4UepqzddhkhK2TRP6vsN0OnOJKlasSZyh4JGdAKiukTZNP1wkInTyP2rs1QA7G1PIR2ZKDwAaLVNiCjuKFRwZn2Z01GnqAsEzkqPEaGsxx//wWx/H1mK4JO7zFQDwKh17dk7wuT94B/p+4nTDZULekTjZZ52mDo15UgQAyH6uiY6T17VINMtX9w8Ls2RuRtqymKVN+qTatnlDAR8yVPceppW1mBIa+3ye1YVT4ETRnpfpaPldofEr0u020ckk1cYa2hzLZ56oKZtJFnIuDAb/Pr6ckaY6UPyT/dwwlIgSP9GedGYUJ+wAZWMAITZFUhGqcanq64Wd4B3vRQ8+nZiJYPmuU3XQNgDAL3YygZfGnWAa90mfLAVgYk7YWb+zatYHa1qza9SlebXXhb6u3VesrARyjAU/rRYPALk2skmIlGS+KEVK37EaD04mpTASV3FpwOfzXGUkpJquUsRU34bBGBYWcVU2sCKLSFjkXFMo4nPpJRUCALDLwS3XuSZDeGYGFUPG8r1ZKgDcfSOvmatMoutS/c4RZBMC5BFFoK+kHxjooNJVBxYNA+Mn/9E9+PNPPLNaZFfHK34k6vGm634azbgoNBgFFO4c3bxORTk79hdULwpfjIKC6d6FG1hxbc+wFGg/he5s+qzTV5sCkcZd5eAoDwUWsgN9UwAA4mQr6VSWmwY5nrUHAHzjmeF19Bxe3zWCbhgetPiGZjhH/aFxuy/eBF7bH4ADHuvrCwthiOWjgh6i6x8Co2JZ2emn3wgtjqPxYxmYQBYLCLPvDhR/B8rLYin3n3fn13Mg85WIzAkaSR8io8CM/UiZIqjvNyBRb67/ZCZmflLfQOwxiUCvkUw5HSOiTn89YMI8qBEapVQBLmughGXiwS8vmTjx4kM49sz7L/m17OffcSf6rsc1V+xD6vpQE7HLrJf8ekLR+3POlUo+IC+KJ0+iAkxKmo8TbsCHPGYwBqYgM9VqWcD+EE1Y5Qf1/zNrmKguBjkPmkghr9f3XfFfAoH6DrPUYdYlzNYmmEwmYR1lIDAQIxBHgS2gdQEp8QAAIABJREFUhqfwMamV9Zqa36/XzZv9mcSR1bVffcUqMCaeZAaypWowm0NELLtkNU0ogdVLlGIsNgD8vx+9D599+NKpnVYAwKt4/OJP3oxf+MnXV0fw6KYu1Hqh5gv9WxphmQzO5yVmZDq1iaIkCyRd0y2j3E9ot+Zcp7lJJ8CAz2RPOimdOLf0rXmh1KsBmTMKyTlql0XTXHLhs6Nzm5mhp/1rc1kd3XO2yDjZx4bspvN1Up0SqQlajGIr1G4xhhPKet+Xh3+zshJ8jJ065HPNW++SlgCLSk0XrXVJLUBIPPCTcm34veRA9fXsihDzU5hMkhq3iP6+NOJZWRBYMn/YmhfqvtDLFwv7bsVbwNPkLVFAUgKcy3+9dq2fwJDLeYoJpKQ3eFBCWbBs56Q+DtVcsLDhDEg4vzUg1UhIcZ711Eq5RosmZtKip8RpltWIxksj5NnoJyVKaWDzMkhV3lGyZg0oE2BFGnAxHxTAwm984vLvoxMnvc34SvRSUtq/TxBQ3wQIY8cMC1sAoBevinlWcKxzco1P/+UJ/Bd/70OrxXV1vGrHjQfejr07bnRTVjT0fKBLfdW1jqpHnWKrvl3mZETBbE4nTWHhsSZeJ9EczffgmkmdClddPYn2P3W1lh1qwWgyHj9NZo5u7OzMS+FKTg92+Lx6q/BbACA2/GAaG+1ZAHcx/K7nCuoCg0Jo34mMEUHUgbhSmTEUQER2OWc0GBpP+Og6HxNIjUWgIx+TpSZoI++0/EDrDpBGNPs2bs/H55EHNxwAkBrAyeIFc4ja0++vXr+UOt1sOOfKKrHmRH0YUhoxWpwuy9ggVNkKkGuNIAEQ5pu0Rrn57smxZ9SbwTftzUCl7AMLA9EogfNgzw5z+b65c58hAyolyTj61Ptw+twqPeYH3nQ9rt63E13qcM2V+9F3vZOTFFq9si7qsEESAEoM96BDnCEXYED2/OyYJ76dl3phALsYaVutBr2f44ADLrViGLLajTKAvFi496t3Sldo/wRC6jskENZ6wvr6DJO+V+YI1Wg9W6ZZjSsHV7/7dTezT86qpsZZmEv2HOWhSLOq56UN0Bz+ZudgiSHCmPQRsjo0SWTxrl5K3A6fyNi88nf3Pvos/t2HLi3fpBUA8CoeN12zE+//te/E2qxX2nbX28R/GErjzSh59OKKL81aSnXa6Cj5xcisRv0NWXWTog8XurVMJcu0WxB1aKNpphuRGino2WzaacMik1PoFB+WOS80niaT0zc5gjWqQ33tpObzAYzSFIqTqm92ZDK+cPp3hmTTmwv+fMHoakSgxPXJBF7PvzZW8+oJkDpSQEDi8eTnZbLr2RZlWmwTbfVg8GZyHN1YxddAkNFFiEJ0zXWIsYMu8hqrV6UXW7WJFgAAsCm1GPLJBiSghE8w6FwskNwzCkr0JXJxkaHNrGemTCZptLD45lbuDSLCtC+gjdyrQvNPKSlayw6ZFfdrdowVM8usDJP6pmWqT/qe/ncKc0A0xoTNrQWmk0KDE5mBAFmLBtjgoA82l1sz6+GghRVmh8hVzJSSg1/Dwj3nAui1z3nXVQ8PeV7rc56a9IVEwC//X/fjf/vV+1eL6+p41Y79O1+HGw68tTZ6OTR41RWmTm+iYZynvZNlTo2n+t6lnaIO1NzTXePEg0a5KRXbGfcx5zKl1elwyTHkap411mW7zp3jtNab1XnnenYUfZUbwBrKEmmI4OxvE/ho/sW6VzszwnrdAHITaz9fxHK2BLtzdt4FCE1qBUgcF93SDTkyIGy854AK91oKCOQgUfDyAWYXzaiE5xxSH9TUUK9Xqpr7ZYwT5xUBYz+IU79O4MV/wUdA6vtEqIKaWMQIjvgIRlZAYqiMiZR6vbeCPIbae9zHWcZJpdcPqqQF/vcQXNT1d0UCw8lFS1oKBIPxuUd/HVuLFy/5dexN1x/EN910qKQTpQ7XHz6A1Jn3RNmjC1mfxAOg0v+HIWPIA/KAKu3MhZkxAC33J8PSnrg87uoBIE/W8efP4fzWAidfPI+zm3OAGbNJh/VpD4AwmxSZ6uHLd6qBuLnq59AjyHQ8ESHVyfo0dVibJKytzdB1nVH3xWlfegA3sVeZgJ/aO/mwB0vgQFtlI8i9yVbn5Tygie0Aa9qWeToRLJVL6mGPJZskwRkVshkKcmNumpnxb//0czj29OkVALA6Xrnjn/93b8C7vvdG56CeGkdw0qm3jybyefQ6za1xgmqIB7KpsKOpi2kdu6m/z8T0U/nsdNb+Zum7qO/uK91eXE5LXJ/lbBCglGujb9fJcxdj8HxBxV4SAKiZnzAhiBI2q0QhkdGAWtM0od171/Q22s07szJH8CM5k7bCOjDX+K4jB4Qk1TmJHCIRxWz3REgdqSt9ASrKuQ/VzM1HQ3b1fshu8OON4BIZ88FLO+RekkOaWpkwCRCj02yYFq2Yw9jkvmjni7zCR6MIi0CAjDxYfB3cvSKv470ihsEMX3JdmOU6WB1pvgLe5Karel9JW0ru/tbvizkYVlqyQInAWSxqnCXMvX/aCzsm6/VsUx/kPTUKU2hpZSesmj/o+ZlLv/kqyDOZXbShsTMoTIj8cy7/JuCRyHDkOb/ze9+Hk2e2Vgvr6njVjvXpZbjzyI8BQbEa/Uo8LTy46HuDep3WJIxj4XIwqgsQQ9U8GwOAXcNmU+hEhCEPSrOnJgkgK2U7xWadWnM9+SyyjkqzXBorDo2qa+xDs7zMdK9O9bhS7tXfAM2Enl3DmZo4vnaH42DiZYVgZBeUSbx9JjjJwFKmhWtKqQEPIvAgrAiZYnetWr9+xmrSKAAH+WvUNubyIXhMB3H8BK/h99GEaCbpovHWz8L+G/NBiOSAKRf9CGuuUZtrrufnr1mI+QM7ZgmNgRr/ulWuYhNgb5lpJoDe1NFAsYTMi2I7SV3Rrzs5y8bWGXzxsd9cLWIog5dr9u3S+mzvznW87uqDmE0n6Igw6ztcsXeXZsorqMPFJ2ixWKjZcannF0YOYWCh8AFw5mzZs8+cO49T5zbx5MkXcfrseZw6ex7nNuejmuqCDR0Btx3ei7e94ZrgBaK3WIqNcNd1SClhPSWsrXWYTqc68VffCEo6cZeatuUsaJJRzmrMLAMeY9tA2RKZxXcq1UhDDgNGaBqAeKNVuULycihWIE9qJIaZlNsgietaXyLIw+CxfpZPHnsS//GTD15y9/gKAHiVj7e++QB+/Ze/TaNCuo5GumSi0sjLVFNM9sxJvrpv5lyNzFKgGIt+eyG6+QQ3jU/OybNMndvmZhhy0DtLw+e13WLWJwYfZbIq0/hGAUhxg25N79SFX9xHYRRMMWkzWmKZ5MoiLXFwc3WyN0d5r6uXFAUPSojLvTeCKs0ZtGkVI7vBUbkZPsaRwucp13M8jS4ACZReL+wMAQSkMSc9VzP9E/d5AXtkGi7sAobR/8eDGQ6Rk9KEyvfAMBPAKAGQJATo+6aukBt9Pbmo19Obs3gWgtyLPioRADbnJb5pVg0Ocy6eBCUuMGNtWgpC0fzLuW5tDeVZEMnGYqhaMVPYiefF1jw7IMbFQ9X/HgYzBfSGjH1vbtXDwoAB+d5EqmHyncIaSWSMC5GriEFl2WMl1tE0nvMmgaF9zsUNV8AULxn6nfc/gv/6f/zMalFdHa/6ceeRd2N9ejnaSDjRhXeprzRNq0pFCx9iADWRI7smBxCP7LZpBfkGSBpealrQ6PZvU+zkKL21eaO03I0dGJsAcg4NrjRdHBpQ19gjXdjLgBytFwYAOIet5v1sqhbYAqoz79z0jpsmvS0FjUDMwbjOqOjt94pAZKYR+EAj4zlx50+BjWHnlOo+TJEBoOBPCqesnwcDzD/AAzbybefl/x6MB9maYiaTATjJwwjUYPMZKEASAB7q7SToLYfvK6QlgMA0VLlmZ11i/X1GdtGHETzKPOi1YjaTRkp2zwSDSMoAJ0dBHyAeECdf/DIefOaPVwvYSzwSEXZum2Hadzh8+U57PuRZy5Yo4eP5NucZ57bmeHFz/rIa/Jd63Hb4crz9zmtDo0cUBxhFpkuY9h0miTDtE2Zra6WuoxQYTKSeYrW+C8ChkzNwHFTmbBGWYMYi11BDtsGVDLckmi9GoQobJ6mxdOkDOiehNbDAYacuvcVN+4LjvxvE/sGn8NTpsysAYHW8wijjJOH+93831tfWjFLe5LrLhG827bR50ex31xSZa7tNXf2XvBhQtfBlE/JTZGECSJPZOVM8dg98drR3mVgKRbxLxZEfTuM8qLdBLSMck0Cz3ytbQSLzhIoui0IvXgTzAZ064luTKkZ+MvE2g77yOvPaDKc6BRYzQQDY3MrB72DRNG++sZfrY871UFPCAryQXhturpd3d5epcjG7y3Xib4aN8t1uVfBhKoaBLoc1MzkAwPJpk/NAEM1/G2lXMmlZDeXaOdFcJuMOAOg7Ur8F/9q5MVpZLIq8wgAh+0xKxwIw5LJhTOt1F4PDibtv+o4cANCFksvMK8tG29UNq+j/WRkD5ERfQoWDi7dJbmMrn5sqC6EAV9NJ0jpNGnuhrZmHgsUCeiBG7oJBQSUO/96p9wD0v+3ak2bcSp2a1dDTvk//nP/Iz38EH/vss6tFdXW86scdV70LO9YPafyd6M9zXlTQq7emWaelDFRzPp3oaoOWnR8AHPV6SQnDrXO9m4Yyhyg4mY5yBR4MlGj1/tG0zc7dTWzbXPfq2F/W4CZikF1D65y1PbMgGvAtZwfApR142v3IQ6Dq3P0UO7w+xcz5tuH3n5nDVD3q6a1ZiFIMP20jJ+Mgkrg6kbSlEFVnIE0OTb4yB9xrlmmqeQBE+aIxR8bfYeNVwSWdQhkm3vwtD+VnQsyg0x0LXEIU3M4LHXkRzk2++KSNuDcUhLIL7DvonKeja2zA4Rlz/2MRlS7mUmUQ+tpZX/vpM1/EV45/eLWAfR0cP3j3jbh2/67R8wet30sSwJQIXUpYW+sxm0517ZNYU6mtigTRwLqcMwZGkezWib7G/NXfy5y1Bi6T/xIRaHWNrVeLxRAJVvIMECmji8BIqVOWdFm3vTeHGZqrMXRu1kRhLNQa8SP3PYb3feahS/IeWQEAF8HxS//VzfjFn75DZQDypSQ1zxPdsDWCXWon50ajl6ZQTeSqlnto9PfSkAkdSM1F3N8/+NAMnEsRc8P1c8ym1nh1XQpGdTINl6NLZeqqngWVhmMPfGUvdMlpgIoPAjNjqPp7aaq35gNACZPepuNe59PV7pj0/KDNuTTwnlbfdcUTQNzoS5NnGv2cnc47QRcdqvR8oaLn6sKanGu7n4D7Ai+LrCMBw0ImwBS9g5z7aeu8audhJiY6wXALvchJsnOfF228MDVSMlM99tdknmMd6wywpKiauKk+I8YYKhCTLUbPFuwS9ZezUbUkbcEnIsjvFG1XeedEwHTSqTeCl2qIl0DOxd110tnrdlWKsliwmvXBXRO5ZgKonNvo8OhjfYiIHIaMyy9f4PCVjkkKhHP3E3qVeiTSZ5pI/A7MwMzHIUq6gPhNCAgim/WQcwABOmcm+bHPHseP/oOPrBbT1XFRHLde+QPYvX4VWld5nVa6aWaZWmbX+CdLBXB6U2CZZtw5RpGLqGMOk1tfbPoYQMEZcn0gWZ3/k82zyTe4of0F3JQM4LBeWrSb790dk4CTRr+NqfTsJlUUZQS6t9RJORPsnVrK/4Wo/0ui4BxlnMK1hep5xWhQkhGiFt1R0QkjkoCPByNQSDzgpT4FKZ4tLWMDGHOkXCeLbvS2hAHmJkStvnoysJM+SDdhjRDnOHGM708mGRndD/Waag9unyrBTSWFXSDGjuGsc5N7LvtijGpkYZ4Q1fvCvhlvzBYaQphR48PH/wzHXzi6WsC+Do4je3fiXW++2ZpeuWMqUESpNP4dCLM+Ydv6DKlEGVVJMZQJAOchwFV6wnUdSkCd7HNJMnAeFEr5h+CFGQlJgYDs1ndxLyl1TlagsMSal6m/PpckRoDJfAUIMbLcyZrFL0D6D7+m/ZPf/hhOnT2/AgBWx6tz3Hj1Dnzg19+mzWyipmBANB2ThksKgeTcLed1Eu3NzCRuLFdqvm+2X3ixw6OPdXjmuYTjz3V48qkpTp8BvvLIBBsbon3M8DQgM90xE6IDe4GDBwej/bjc9umU8LqbizPtolK9pcFbDBnXXj1g106uLu+56rvL++zexbj6qkFp2WIql7NRo4Xq0yWhK0mDy9WXwAzTpGH1YAeaP/stXp39yUAXM4lj15xZ80vJKh5pgPWa6xSfRmAPtxJTVyp499Oug8YvSkFAiPVYVA8aQJK6otP35yGarNYPwr8uvPldNSoEAQ8c6zHfKsVUrvrUztnhewOwEyeBJ5+elEk5UXHRRROjzQZYdInw5a9OcP48tDBKKRXdLiJ1HgoA1M0nd7jvgd5ylXOlOnLSTU3zwdvpkLo6m3GXfDahrN52yyYoAQf2Dti3bwCD8fpbtgACDuwbcNllc5VyDENG6gQlF4PEXBkj5KZ31l5wnbRd8Dlf5MqAKb//D/+nz+A9f7Rybl4dF8dx3f634OCu25dmwrvNTSfhZU+oVM8KAoxp/3Buf7JIdaEx9rF2SR2gS053ck7wo+fc8+dFNkDON7uiyjyivluEXs65gvLk2uEMRrIIOF+bsk3iQ9OsZluu0RMHbpUV1OaZO8ckD+2eAyqksWz+3Hj3j76rBvgg/51INKIkD4QkAPmzxeRFdT6515KYxaixR/PNtwCAgAPx2/BSC/8dNZCHSgLIfUZUZxjn96CAwOhFXKfRAkLxn5UFkXwsmt9RqwEh+RZtLDGg0RPGtfmPOn+75+t1ZYsf9B46KY09IADg/if/AKfPPbpawL4OjpuvuAzf943XY5kzBqMYABIRppSwNukwnU0w6fvg+h/6j1rPiYRXvLgGMRWr64EwXyzZjzXaXNaPUqeRuvwbqFkYnzLoKHUT9JxQG3lJ+ZClsTCHWNdhf94tozo7r6wPfukR/OFnH7pk75EVAHCRHP/kl27Hj//ATWAAs0kaNXNiXic3s1LSc3mY+k4MYKBxZNLMPfbEBKfPEB58qEceOtz7wBRbm4QHv9wHKtuymB2IRowJqToBRwpezKQFS1EkBVelgKIDEiHnRaXzJIdAwzJphY5G0I3ectwXlQ7UaXGUXDSITak5urLzmNKYIC7y2VBFEMBDpW06rVDjWWDvEeOTdNP1hQxnh/DDGU45fZL9o8UktT8Ldu7HLs6poQy2dFTLQ200hG6qltWdOUXYgLDUoEmKQfs3mbwNYbKGMElxWkOXOWzX3umyCJX+Lt+JgR9mFlMnh4RApzR37ToPYV+A5nIfghwA0LniPrvCF05jS04TarneMXvZx5Sx0n9vf90WiIAD+zIOHCivcctNGwAIhw9lHNhvGybImDlUkXNhWsyd94Z83ORydW/9rvfizAvz1UK6Oi6K44o9d+Kafd+29DmHPstZHdWd4586l5PfG5pGRZ4/boA6Py2VdRPIQE66PngneNv7SoEqOm0iH/PWGNsJ5Ts366Y263aOhRmW/EBKjcJiY9nIDOCc5yNCOmrUdcULBn12DXI1EiTy657fD7Ot56P9nANgIuCB7cFxzZdm0ycUWI496/v69VVeS1zwBfw080VEhttIogAFXjRpgJL9WfdzkZKQA1X8fp51Ei5AicZD6u3p6Hxk9YwCGnKO2abtVhPE/RzOmE8iDON+Hht0HzFpkYXex4JiTcNOv82lEvNmuvZ9mdziM1/51VUCwNfJ8cbrD+I7Xn9E1xdqDCKREnoizFLCdFoSAKhO1MUbzO7zrFN3M/SzZrsMFLMmu5D4e7B0AFJ25vrYlxpU/i3Vab+wHMmN8knlClaXT/o+2KGop5Sz1mBPs6xHXyWcuU5i/unvfRLPnjl7yd4jKwDgIjne+uaD+NX/9ZvDVM9P/RYD1+g7hEnCYmBszQlf/soUZ88SvvroBKdOd3jy6YRnn53g+ImkG1bZOAFADD6MRkkOIuNmsy0FVRdMY6hBn31BJWeX6gbIJGi1YI9x8skKAAg9dPmGyZxjKDw7yrVOgGQBWFbUWCxVQheKNNSfzboJU9RVtlFHGp+zJD95FH2FUGxqjJOjIflzIZfJ6wEBn3HMrgj2BYMVM2ayV75a33xzoBl6WmeY4tA46zq3AIDPYQ7aTRi91ccPwYolY1ckjfrzwIh8D+IKGyi9Ugs3Obqmo6z3TM4l0zsPZjrFCACATGrK2I1CwxG/70qV5Bitpc9LvUdyruZPDgySZzmPKBrlu7j9tgUAxv69A/btXSAlwh23LQBm7N+/wJ49c6DKJ7yEg4jwnj98BP/wf16Z/62Oi+fYs+1q3HrlO62Zq2CZrFkpdXUSw65ZF+CRAhgoFR25dV+MpcTozOucOewxLgYQEQDQrHREgDbXvSMFQ0FfNYme3q0JocVv9fcU11x2+06Nr4u/U+QBwR4wTJ6TNeY1QlD3PAElWz+CAODmMQCgBFxxsu8CNYvc78c9KTf7ZXZgQCsX8Pu5AS8AwMSBGcAtyOz3c7T7OWwi6DwLyt7RNNXe7I8usL7rV2b7eeas+08EfgeERIJRRe1jIWvtkaq8jLPt52Qu8il1of7zADcJKEODRvlxkGn4PbpTSiNnMwVUcJ057OcbWyfxhUdXCQBfL8f3vPEG3HZkr9YdIlNUyn0q1essJcxmHdbWZkq3L0BS9VZik7hac22DNojZISP4l6j/iXtfDwAwu0QnKlLKJF4BApyKNAvCLC3rsvyOLHNdZQqUYRZCCEp2D6Rn9x578hT+zz/93CV9j6wAgIvkmE4S/vIPvwvbtq1XozajhgPAs88lHH9ugqee6XH6dMLDX+1xboNw9NgEeUjR5TXQ9bM2NcV9M9emR5qYNNYUarObXURM0k1OnHZ1OsOWdevdiYlSNeUpKL8cZvLjqX5kDW7qnG7O5SiHiT+7Zph1QUnkiyFPc3RxPHqtmqKN3MQglHSu+AyGR9mZ6eSA1gNY6pbMIc6qzbxqCh/OjgXhaZ3UKksxNr1q6YahjKt/8s7JCMWZLySXOx+T6iUpJNa6SC1ktGKE4nIcC/XMcWOKExcDHkosjTgeWwFm9F1Dp4X2L8V1pBPL7y500hf1q2m8SDbmV0rb5fhndtdAi8TM4XMp8OE0tVLAhmfDueHKVbzt1jkAxsF9GQf2l5/9tff9Mb5w9JnVIro6LppjbbIbd13zXyrY1j4b5blmdXxPqWueIwHNhKEzNEAq2zrDsleRo9r7SfwCQJvlXgyw2LuwV9d9YSH4iD01rvOfhb2jPBpDVVYWkmcQEVpDLt+se9iYxiwBIOrfnXGiX2tH+zlSAK3ZrfW2n49Lw1bLHj+Hd5GPIIlE5xlbIEXjOplmN87+gUHlz8FT6ZUunwM9v92xieJ+7hlvIhcb7+fs9vMh+E4YW4+DMaTfC9v9nKtjeqlpUsk4D5+fw4DDdptYltOS/Vxeh0KKRJNgAOj+mmBAO/Oi2ePKa5/bPI4vPvae1eL1dXL83Nvvwo61aTOHsuFcoro6EGE26zCbzdCnpEM1QNKK4prFUcWFYcg6uU/V50jo+AIkJJXXmlkgGa5lcc7VeNpYPfJGlUcsEYXJ9P/iy1EMoO28NC7b9VHetPrXP/glfP4rl3bdtAIALqLj77zzFrz7nW/E/UcnOLcBPPSVHi+e7YshWW3kUyd6Zrf1+Vze4Fpszasg62WzSbVp4/BwmwlTUI83BYEYOXXaFFsRxUvvMGt+UjMh8Rm2FuunWxLFTc+ABjEaIWfK4/V2ndExAbchNo130KiTAgexnOBYYLQJR27qYB85OVp5fNRCDFEzHRszBxhLs4DR6jxpiTYVSwoJr1tFnfL4QjK5xRZhctEaX8X39fpeV9guOX+51kpHa8wFzcMhftd2X2dtDILulYU6PLj7qKU6kg6ikgIU6QLRVraBEXmH5/ieqYnTis+g+WT41xUwo403s4lV66Ewfs7lWp4++1U8+Mx/Wi2eq+OiO+488mNYn+6F6q6DS31smPxa4p9dkyW52DgXbxfXC08QI2e0WQFKtjXVL98Kvrl91fYVbsBvM5Eylpn3w/Gmr+z2yEjt13Na4i1ADRuAl8XO+fGXsq/G+68ZwdlcbrQbuP18HEm4ZL9rWtPgnbCUvB7jGtvvN/gSUGx2zafBwa+0bD9vG/K6n8Pv5+a3oJ4L48TC4KLf7ueh8wn7ubELC2GwMwDA6ZvbEYG89tg7gZcAG9HjgFqmyWg/b93QkjL+KAAA5TOcOPswHnxqtZd8vRx/9x3fgJ1rsyCn8qkUqUo/1jvCbDZBP+l1LdSfqcZ5+vz4wU22mqgkLOXR8iCxlLL8D3mog7pqdp2zNvvmzl81/dnJUJlrbKHo/SUW3MylSYNJSFMLhGEggxfZE068uIH/5XfuueTvkRUAcBEdfbeGN137U47eTS4H2RsFtSh03KWtSHKbigvYJEdr85N5fWgDJbAUWyl1LpJmAFFvBUPI7fTT4Vzz2TnkrWtjGTTw0qDZw0oUEUc/aVE6eTLqeaGJd+OGj8f6d6+VZ3Uihov1wdLvIZj++M/t8qz1r2hcKmVnqITwfn5xbRptsqI3ah+HQKmPcglu8qulycTIyAkuKsoDBNZxIjpsB80oYBIAYUXU6QvyCEiIbtdwaLGbzVXNGQGB1qtFLFcaZY6AV87DKC85XkthA0CbEaFjciik/LP0tYvX4LKtmbUY6WIB0xUrw8Fu5uY5d9d7lHHrm4mEh49/AMdfeGC1eK6Oi+6448iPYOfawZC/rJROdpMdbu9332d1wbzNqPfZstfDU8sBaJRnk8i55XuttpdV+aQAZSFVFoKyC+DWVL7Ac948r3D6bqSxuZ/fz0PE+3ABi7k2Vs/J3JBC680uLjBI9sKeU/dzdtePW5A5jSb9tj/ZPmLyMZtK29l780HoWk/soukoKSMhXluJT0EhAAAgAElEQVQO3gEWxdfcPyyJMMnekwyEaPdQShhdYe+BJDR8ZbLUvVivHXFTm2Rn5Cq3GUd2ofvZRB0oEYZhUD8Jz6qU/Zyae9rLXDIP9S063R9jCkaOdZQf1bB5Oq0iAL9+jst3rOGn33bXKH40VDYEzLoO632H6axD30+b2ErUGokCi1FBy6r7h7A4m7VbISud8rNGMVPjAdBXZ+vFYHW7xFYLMDvpeuMfJQMW/OBQYU4xEUxptFYCwMcfeBy/fc/9KwBgBQBcXMf1+9+KfTtf1xjxuWFJ8jS2FIsAic7wcRjMgcAXp89N/NCSzcWKlzitCBMD18BAafy9PngS9SYOoSnFCCGipLppaRYFFRc6IRqbO0+FlImq1xZyo70zXT2H6CDZsEPkUeOmHDSqHKdZVrulJYWomyY0haNfjCIYkUPB6cECbjSU0TQoToZi1FXrCZBDceZX6VAcEML0OppG2fXU5lbymtUPIhpKjXK05To7jZhRJMv5C3WSgSoNcdeEEQql7GQibUOtRkkpoUhn2bFS7Du19IexdAVuYma0TwNMRBLhjZ+MdeOeL2aVruQ8hGdQzZ7SEmaOK9qkefjMw/8Gi7y5WjhXx0V3vP7wD2H3tiNAuxZWgKvcxpXZllIwf9NYNr+utiCkl/M4cCFEAnoPE++s3/ifJHTRXkY02+zWgBbIE5O40dScGgCRnSQtNd4ynpG2TK+PyMjj6BeghrXtfs5xvVGmRGhw3X7ufQwqmF3Os8onnJ+JgeOydo2vDxo/G5tyN2Zkeq7VUJcIGa1u3+4LqKFtpywL9rp+5iV7DEfwo76PQ6H1c+t2ncbAA4X93Mn2qJFdspdwRXPlCP6L6SVdYNhg+zkcQALnrSO+RSWOrXNfO6sBpcbdMprEC3IAQI+Hnv0Ajj+/aoq+Ho5br9qL73vTTaPRhRwSmT1JCbOeMJ1O0HfFWC91ZnKZHHvF7IvKQjrUqT/XGHB2Qy526Vrnzp2rtx5jsRiwyOVplFQqImDb+jaLGXR+SQzUBAF7VrokkZ9FUtrXCf8w5OCplatnWJTYlH//V+//LB566tQKAFgBABcZcrf9Btx8xXe7xit+XX6qH5mBrE2SFg/OkT/UEULXpqgd89E9VujIa7SBOxTNBakrD20e6iZnDIGyV0qTL5n1KRAHBCkfNTuAasThnXDdZFQcR42q3U5vLd7HGx3FO99pEcNyOc59hndd1gmIi2giK/AC6Y8Qkg9aev4Fp1fLDBcveK7xfqEmyxmt78GS3/HgRJz6+Pdpm98xBbPUs84nQSc7yUkeHGTCrrFX6QqNTMTkPcWJllih4BCnZwUttMijWmhzaMQxdgf3BfVoNtnKL+J9oU1DeA0XjQNfgMWIpnar1kLd3b0VCcQTJz+Fx05+crVoro6L8jh82d24eu+b3XPe0KCrUNM01k67rxp2uNg2mAM/m6GtrR9wKTaIbCh4NlQ1RE2pmoNWulZdF2yjdLp6Hj/nCOfKoymUPrXeTDD4BESgwD/7BoZQWMfM+A+N7Ivj2uwnyByvo0X3NVR7OO+Aun8XgMQb09qGbbp5YxeEOD4fbzja9YLbQbx+OglPbj+3tVbj+sjv53H11D2ScvjbIBGo7+Wvn/rOkCdm0Mj41TMEDOCXZBoPcnDwGpD9T/d7amV9S9Z6p/EnL62r9ZfK3rjhu7k9RbyTQFzTlvw1Kdfzvid/D89vPLFauL4Oju/7xhtx65F9IV7aVxZEhEnfoWdgNkuYTqfVGDC5pY1URx9Zvhb1PajPhWeY2nLz9PHTOL9YaAkjP5tzLNkoJRzeu6dJ72JjAdRzSKn4AKgHWDLGKFdgY8jmNeDfR0DQRMA//vcfwrnNVWrSCgC4CI/brvxh7Fo7tATRj0i2N5YjCEVniRlO3dTUEVcNlwZtVmLUT0TRLTYo6tT9dhO1fGWzKlqdIW72FDX9QiXXSUSyAg+j8/CRQojxfIrac9TqLSl19LX8pqtNfA6ZzEsp+TD6qDWztbDUaUizpVOMr8ISFsbIWFAdmZsJgkbXxVWdvdbLgzQN2MFAcNQOhS4o/i7xyOMgFPAckqThtfMCAABpBCyFqrCabykvIxlYZGY0FYwS+m79vrWYzVDWQZGOUUgxSEEakdRxeSmwESZjHkQCvEYzmj3GMt7flxHMylXaksITDA+oVYqrpxz7bGopIj//2G9iY+vkasFcHRflcWDnrbjh4NuaVZhdYytma8kVe62RrKyNwwjUNRbQCDIW+NCBDhIPc+HnHDWJJkbQsdPtx+dcm3ji0XMe6PMyaeUWNFjys456z1gmQRJdP0VJlQIbla7PcT/nZg+KTMBqFKw/y8CS/ZyApT4No31hZDZLdUq+3KeGGhmV7ZdJ9x+0e7cYNXp6vofPZT9HDnuaX9PJpSGUsx1CFG6Qk7GB1GgGLcYA9NGMgibYfg4SMMqiZAsA0IWZgrI85b1EJrfE28bqPyjwI3UDt3uVYzrkkWcE4ZNf/tfLUy9Wx2vu+LFvuw1H9u5a0viX26rrOnQApn3CdNJhOpvqvUVE6CpzpCROwCbpzMrIzNlMuc3l3+7ZF8+exYnnN8ZK5TCMNDDgqv2X23roNP5DZixyNvd/cE0rSELXhOoB6nPuvQVEYiprxv2Pn8C/+ZO/WN0kKwDg4jxuPvQO7N1xo01Bndutorpeu86m61NKYEV5xUXf4G0rLAp13oEILm4uRvKIbq6r8W1DddtPblKTnDkflK4DiOaHRppyo8cldVqXDF8fCxeMBuvPDnnQQiHVSUGIxFOdp//sNC7Ugv7dspSDZtDlGBsNsclAlo1XP0tTtAWaH5Z4Diyj10caZUtL5zDdbkqCoPNnpwlxkxs9Vw7fxWiFCBOoJbIIOMV9oKybW3Mo4l2Rn5mrTisaZdmEr04JtWkvjf+IhgoDYbKa87H7DiP9XjRrYlKjQJYHGtoISjS+CcGboT4vWZ6xMlVMbaZzk7OdHRAhulZ2GxZzpLXJZ9rYPIEvPPb/rBbL1XHRHttn+3DnNe92FO6mgeGx34ys/anuF0Zbb9faQYHFsVt+ds2PooPNBFsi3Sw1RI2siBqPlqQgZUwXaLXYUaceE1145AvQbETGINPnvKGL6wrgG8SYnGDJoqzyhEAtX7KfM0qkHDtAYDyVRgstj9f+tqEeyTi8/MPWU5kykrte2eXTj/dzCjnh3p/XmwOTAEktzd7JCvXcqA462A0cYAOH5qtCculE4lWjOuiaUsM5g6ndz+HuiaFmq/v9vGV8uf2cqnGvZwAEqWDnIiZdMg9RYAOoUa2aUTI2tk6vIgDrsW3a44ZDuwEQJl2HHdvXR+UQs7nZy3H2/CZOvXgejxx//lX/DD/1nXdi78512AjGjpTKpH9GCV2iqv+fQCbqBSBAZZewTvbBpRGn2vwjpGOgpgAYC+CxZ08CzWBRllOfECCHAADwwKv7mTK9FwCg08GQJAzkEJueq/O/pUzJOdxz9HH87sePrm70FQBwcR6Hdt+Ja/d9S0MBdMuPFDFVqyfU97EOzmKRzHjM9IbmFzBUo7++iflbRkPPWsgRPAUuaVlAIb/TxxC6DVjPLbk7UHJyu4a2Taq7XmbbG4zRHGvha2n3MYpSojBxbrXocLIDaQ69YRs7hgZ8AafOvRHVj4BDPJeorze5xDjn2b8Wmpglxx5wxUzU0MYISK8x9IABArARm/pRZQREGq+ZDNiEijoXU+Vio7yJFqIhHhx9XgomTQdgCiaEImkh5ywLBwREw0WbxnDQDsfvM+ozx9+bFpyAK7K7oEAQ85tW55xdMUujCZlJaLyXwalzj+Dok+9bLZar46I91iZ78Mbr/k4E/kJyB+vamSiyakCS9MEu1jWNfGnaWNjQLLpM6rD2Xeg5Z28Y6/0EavJOzYL33ifBELU++4min4Fqr8Poq4l142gk264xft+PBm5xf5a9r5x/F/ZzonZfqKwsLj8bQWjvRu/9FNp9o9mfwjrY1gaoE2+LP7WhgzTPsTm2pJp2P2+SGlxcrOxBwnCw6SAFEFn3qnq/BLafN933QxLEpCRS5qIB7dywK8zIEsGct+wRaKIg434eZQ5ZvRriPS1DmU7NGguDrh0UWCsW9/MBZzefwxcfXUUAAsB33XkNbjq0B2trM1x9cF8ZkhE1JRxjPl+UQZSbjj918nl8+tgT+PD9r56UYu/Odfzs2++q5nlx+ZCpeJ8SJilh0hPW12Y6KJT0lJQiMFkm/kAiLlr7OkzJ1bWfGq+y02dewPPnty6cTM3AwMUHQI4Du7djOpkGRmuupVFygyBSA8DkDAMNhAAsQjDnrEaAAg7+qz/+LB56asWcXAEAFy0CuRd3HHkXLM4m0taFPh6aVh7Hw+hzRxwldqF5Y0ev9HnCvh0htFq7VppgLsrW1GmsGaWQ7UwOLGCUOBIwIyM7rT/C1NYWGDN8I2/cNqJKI5x7YeBRcJCO0xY0bvqxyGqpmMRuchAa4FYrPsKOR+cZ9f9AS5mPVNZlj23782iiAQUo8ekQkZ4avQcAr98MbtfMIQsa4XMs+bzUnj9Z9JGbAikln5ZERI5kIw0VVO5Pmb6LE5KNw3QK5NMdIIi001VKnCCH4pqWSyCcVEQBHPLfMTn/CjMJLI+jnMsQGDIUClEKcZaesvzkqc/hsZOfWC2Wq+OiPr7ppr+/lI0UEu/Vbb+NoR0/cQjGZ1AzTbCTSjnIkdvoQfkzW+yrGKqZqSgC+K7GnE7yEx3y0fhrJxcBKOwBB2CPJFu2n3NtkoNZbAAKXDJIWB89TV00/u1+HvfEIgm0PcSAVm78crzHjktNcAkDBnSb54xfP20Ny4hafL+HkJNERRf8sOaCHCsqu6g/iqOBpk7y0bwmA3AmttV8NcbL5saEFwHkgGuqMnPQ/2sUpAIx/vv0HkzUfD8u+lI/Cy1NyIiRmGjkbaT6b5ngkgfa3H7+3AsP4djT77/k16tvv/Uw7rx6H9ZnM1x1xT79djyLJSXCMDDm8zkWw+BqqJJh/9zzZ/FvP/B5nDr76pjzvu7wXnz/3TchLalCgTI1p0SYEmFt1mE2nVW5brlnus6tA0yB7SCDEGHgArWRV9+McsM9/txp41/VazPpJ9i7cx3PnnkRw5BHy/zlO9axfX09MJpUjCTLR0rhGUxJZKOkjAWtH52XgUgCnjr5Iv7Z76/qphUAcJEfd1z1o9g+2xvQ4Lao8NF6hUqcQ6PnDZZi7nKKTh3e3RhWrES32mZK7bLK21x4RwBwJjsUpQpsKJ0YDZaoQnL60KzGeT7SLrTRhKBB8kaC1mhyBAOcA7M0WVYUNE68QSPqpvJBK+icnSiaBI49ALgl9zXazLHBELW60SaT2rvsexOm1sQunq/3FuAlZkcu/zo08rggu8BP96jJLFbdLjplf2jRTzGqxXpdKxZF3sJieKTnxj6/yeVJGx0/QBB6L9WJPy9zi26bjua7aTZWaop6i7vi0KQYtZXs/lHmQXJfLQdJRQDzChaPo0++D2c2Hl8tlKvj4t7HjvwIts/2L01KseectVmjuh6oYSh5d3oPguWmgayT3eb5XWqUytF9Y/Scs6193oyPBDSokyWi5Y7/McfdPece3Bil0XgIgRtAeEl8rT972XAZzsAUS+RLXk7g9/MMqA6dLwBMU+MJMGbiLSsrLSmlvho5QHOJdazVI23uvQeO0TTikRIPNgkI4ORZSzwf4GN5iZphQ2Swxf08uXsXVt8QubrM1wVkEYWBUYiRjwGcRE735a+5n2cbjqQUYmJlry7Tz6SNUrufP/rcPXji1KWti/6mm6/AN153AGvTKa6+cv8Sz2QZDpR1IQ8Dcs41fahMn4eh/MI9DzyKP/zsl1+Vz/Edt1+DN914xTLpffn+idATYdolTPqE2Wym0X8GwGakOsDg6urPyOCM+pk5lIXkDLrPnHkBz29u6VLXdxMc2LMDO3fuQGbG5sYGHjt+yiIB6+Owd/s2rG9b1zpKgDU/7Om6ZN1GEk+AyhbIjK4rf14MQ9gyfPzfb33svtXGvAIALu7jtsM/iF1rh91ENC9x1CUsix3yGzdzE4njXZcFsQ8bHcC8MI1gpZOl1CmyHbSN8PE4dTMit/ETa5ZydlrpQlkz2lFbzPjIuVAoiEmOMwaScxIWAhGi5pTH7vpmBsehfrFmOIIbIwr/suY/OEjLCXtwJU4RYl5jayi0TBLQvlacxgTKqKeghmImRvf5z+RBj1ikRCfjEP1Xr61q3V0mc9Rt2v3GPjPWn2+IkxQPiy5MB4e8KBsZdUF3y7mqUHmh0yyJxrTPZn4UxVnWoqc4u3MlFP1m/VwFxR7iFBMIsYHhc3Kg27j7KipnTZXCLnYqj9jB7XPOzPjUwyvDptVx8R83Hfou7Ntx02j9VG+XnBXcS7JuUHnOiwlU79IzPNDnPADc31vaSHJAaI4xtgIUuIawq+tMKXJFWof4nEsjtwRICM85UbNP0JJ9Jo+YeghMIw4MJ1ZDrubz+v3cA/Weh6aePl1dA4dKJScDAFysb2Q7tGwvMxqU+N34cy1Y7dJ3RGrmhxEujjDuKY153mg/h6VGeL8ED5LrXoax9ILaqbv/HtnkIKmLGeKeUeBrD/GxyU4uh1ylLdETIaU+ePrIfp7zUCNsE6KcQJgOcc8ubIUL+NPU7yy7GF8Fc9h7Q5Xv+/4n/wCnzz5yya5Td99wEG++6VCZ/B/cp3VFAgIwVL6a8udhWGAYBuTMWAxcbbdYPSL+6e/fg5Mvnn/FP8vffsvtuOKyHfpnEUVKXZwoYdolTDvCbDZF6kp8ZN+larqXdU3Jul5WEKA6/6N+Rm/+J4zHJ46fAnNGl3ocuGwHdu/a5erk8l/nNzbw6DMnQ116+fZt2L59fTmtn6ARgCXtLNXhii2qiUwCMLR1VD3f//ChL+HTDz252phXAMDFfVy995txxZ67mskxBV08N9RG/5DZBmlFCQdqsqfgjKcYy26PaDiYdDMur5Pqb5YNMqVOm1SZgsZzqnrJ5Jt2jrF1FblOqUfOi5BgIC7xxXhNmrVOT5ubjdqui6OFUjdqfgNlVCmQ1BRrxppYlgANV4KNmr4Qm0fN5KLRzI98DSKVNjo9wwELCN4FbcMvv2dNu3vfYBBYmSXkzJ2cdh6NptTm56nxZfAaSrs6Yr6l1DIHyIzvzQtMnETPWVkkXCcd3BhIUo2oTN4IkTLAyaIA86AFthpT+RgtiC45jwARA26cN4fAHnlQ/Zo1BjXBwHlhyDmSAhjtTVXumrObz60Mm1bHa+K4Ys9duGbftwavkegvA30mjT2F5udaE9lcgeU2dcNr4M0XpOScG2ANWSPA4ykvGJxLk2aSHvecM8AuatAAdIoGn+45FzC2ZXuRAylElYCR5p6Dkglhf3HMO+Zmn+ER8BuAWPbxphyMWY227gwDIaBzAVjF5yB4k4AbQ1tvYgh97wJEOFNHLyVwyTQKzrq6Iuznbk8v5sGdM1B1e1uQE7j9nOy+If2ufb0UOQqZDRDWfZfifq5gLtvApd0nqAVNvFGv39sQ43gvvJ/7eN2SZOHNbMs5ddX933xyvBHgXz722zi7+ewluUZ98y1X4BuvPYDZdIprrzxg8lJEBgBRHAQNwwJb83lp/NmifIdc7rnPf+UZ/M4n7n/FP89PfMcdOLh7++jvuTbJfdehJ8LatMNkMkHf91pzpVSGKVzrH5bmuzbiWQcqQq1n9WkhlOn/mY1NHNizA3v37tWYwAJAeqNTxtlz5/DE8dOVDQpsn61h32U79XyT83CS/071PuZq2OwZAKjnnLOZm+eGQfmPf+OD2Nj668X/rU973H5kLwCg73vscuaQbc1KAP7sCw9jczGsAIDV8fKPPduuxi1XfG+TseuckXOOKb4BdE91stJOFRw1DBeK5WkWjXZa7Kl99U2LR1kXHYY1yq2ZjGjB05j3pbGvsD1Y3UhrmNXccCwFGDeKFCPb2KKNFLtcRs2kFOKnHLoQXXabd4yZzMvAFV/oxM/s6fQcoufQAD5QmixGtEAOTblpYLsGSCCbYoX+2qj64OpkXGMguYkujPFYRmklncRFV+WWSir3IvP4u6dmSmP3UMyvZs8YUTkIhUIs+1zx5nsiTjGr251rC+/oNQt007H54dh+J35P5PSXFg0lUZ0pRDbFCEvGsy/cj4ef/fPVIrk6LvrjwK5bccPBt154z1HafxtRR2E9GPnaBPM7myhzeM4jS8saqOwYay24WPemWmiqqWoegneMBGzHSXt2exzZGhx8U7wBnAcAeNTgY7TntDHAHN4jAgDjXSm8NlOz0qUwiQelsWGgygWWlZApmAwHKr3LCZB9SLyBkttTbK9r190WxKCGDSDNe3LrdAoAgYANjMVoIGFRuKZjFjnk8jXcEQVqahG1CUOVjJGd0bH3VvDXqvw7Acv2czI/gXY/T8KOCSabkQEhUhXisp8Pw6IaMabAsrxUIwB3rU/xE99+KyaTCY4c2ltd5P19ZFHacruJ7nxzawub5xdYSEZ9ZSTKUCxnxj/7g0/gzLlX1gvgF77vbky6DuTKOjHrm/RlvZx1Reu/Npuh77sgJxagaODiAVA+S0bOGUNmfV0/qZfb7onjp7Bv5zp2X3ZZvX4cE4xCJHNhAogcYG06xdr6DPNFxr5d23XCX9z/CYtskdBdKmvckBnTPmHIRZ4Q/ANEXiDMhBMv4Jd//+N/7ev67bcexp3X7MN0NsORA3vLObDJFUoimfRoDGTgPR/+Aj5y9PFlyeQrAGB1XPiYdOt40/U/1aDHLp++mZSqjjLEENUWq6HTp9DIJbSjxuCWjiYW0J0LOcMl0+xbrq3ZeDTNbzMBik63UVvOzDWdwMf1YYnxDev7BWmC4YlhEQrFoLuQVvRQAADK5Ndv8LlMi1vKYUPVbjflEGe1JMS6ncaMPzOHRl6nHX6I79ya43kBCJ4HiEUQ2WcjB26w00i2MXbhF0dSC2cIKZRbLZYH/V4SFVMZnc7DmBqG+CJM6il1jTM1VWperpPENEpLEAMrtZ9UqUrSKT3Y3t8zEvzfjUAz8Sogf32jRtkiN838Ul/FYQqCXjMuvDIfe+ZPcOLFY6tFcnVc9Mf22T684ciPGsW88ZuBmMS62M4Uot/S6Dlv42mjizo77xCvnW7WL04OcCUnPxIWUTcyGwXnekrGJOBG6x6f7LIOGcvK7w05eNJc2DjWJ4vAjEz9fg7fRKdgRDraz9kkfnBGfhQiT8s6V9hIkVpuoHQCAjuurpsEl4yTl14bYRfUycEYlG72E9k7oirKpyP4emS8Z5J+/wUAKDVQN5KV2EDCah2P99p+bp8x80IjkaOswyQfsj8jMMVaDx/EOFi0eUJxP1fDtZewnzPXmEeXpON9Bs5tnbhkGWVvv+Nq3H5kH665cn9pkuX61UGbwlFUDOfkqc6csZgvsLU1YGuR4a1HqTamYMZv3nMf7n/8uVfs88wmHX7+e+4usibHYtCniqi4/3eE2azHdDpVWr2AGzJcTLUvkCk/1+m6NNTZyWUJhLNnzyJ1HS6//HKN7GP3c+Qo+ikVUALMOLdxHk8cP4WtxYD3fOIYfurtd+Hw5bvU4tMiBBmp6/TxEiBGmDma8EHl+vvegwj49x/8y782/f/uGw7gzTddgbW1NVy5b0995qGxgyUVkapMAWpIyMw4eeI0fuuTD+BLj51YAQCr46Ufd1z1LuxYOxibt5GZnNe7+8gzM0tLzlDOdGQNqOAnJpqt7nWA5Bpte+jRZCGzo7RTaOKT0hiTM8Sx+B5xcC+xOanSoT3VOs6CWKltcdoA1ddZbNASAyXn8h60dT63DY5OijjNGE1sNDKq1YLHx0xN6i74KDbmek0h6wuq1tgv/mxugJd2qoRwfUIygHqvutdqM7ybQkfiibwPAnFDL62vo9IC529QtP3RXbr8N2lUni9+FQBgkYkkS3lQii8FgAzB3dp0bYYYZwd0IPhPGKWVwv0hbJxYkFoR6qP7lsUG5mo6FqMPLRHAF4bynp9/5NexsXV6tUCujov+WJvswTdc8+MOtBxHzKaUNNlG9zLRnqYUnj8IQCBAH1MDAESQNfiJOFM8XWOdcWuqbtF++RadNel03LGZOEbQ2d8lF7sL929o1nEKr+ej8Gwvsn3IMuQR1uvWm2W8ny8cjV8mxin6MqiXgGN4OfMzhsmi0K6D3t9Ezo+Wx9raZ/BGsw7QX2oUKeavzX6uqS4EkvrBT9UbtmG5ogvb25x+GMHUjJq9rF7fnPV11QmCsvos+ZrM++d4poelGPDSgQiNzIG/1n4er1Iify9lVw/WoYGkYzYynBc3n70kIwCv2rsDP/yf3YQj+y9D1/WhoSRK6ASIrywAIrK/Y2BrsYVhPmBzXiSpcuTM6k/0vs8ew2e+/NQr9pku27GGn37bXWjHUUTAwECfCgAw6zvMZhOkrtTaMlUvjbN5AMgUfjEMWptIYyvXS6bglAhra+vIzOiTxZMzA10FTzJnZSMUJWW5n8+dO4dnTr2I9372Yfzgm2/BVXt3lXOR93GO/rKW6zNdum+XDEORFVx//h/92gewsbV42df0uv278P1vug7T6QxX7t1TQBI2SQgB1XyQkJJ5IhRfqvL5Tpw4jXsfP45PffkZPHL8+RUAsDr+6uOWQ9+Ny7dfD5MAQDVg5cGQAibBx7aB2bmNe7fjv6KhDC7AFDTf7dSTXK6wZLGDbHoqzVurLzfzJzMEKmi7pxdScEwH+4SCHOhKioLDRcKpRtPrQLNOQNAg5YzWoK0FABDpmmjo/ksifsL1XtYchul5Q0FtXfydUV5A+J1eNn6XPKZUEhqaKFwUUGsUZN8vNBc6jT55jHeihq5u18d7AESvA0D8ArKY+6XeTZugDXNyLs3tPdAmTJgbuKU6jGELjjFc3nSrTr9GetF48zTAiitWR999a9DoPsOywR+g2bVeNy0g1Zs6kS4AACAASURBVMcf+hcrA8DV8doBsq/+W8XQVhswgNDb+tr4lqh+OdDrPcjrEnACpZ4q8JdLs5Oczt81ZeH3OI+ecwJUB2t7E/slDQjPORq2UWpAZr8/2NrhTQW9dCHq5mFSIdDy/YVtvwi69WWJCU6OwEuBaNe0ckwBsHG47edxP8qh8RbDwLETjqe4L3PRuVCd4ffzMdMves2MTf8ESFCTYmoB7Vqul8DzsJ/7iD9oTeLSZNw+aNefEVyJ/Z5A7X5OwTyX6f/Pfu5YMC6JwFg2OcgJnjlzL778zKUnKfu2Ww/j++++Ganr6yTXQP2cGak2dV1KYfpfmvzyvc/nc2xtDZgvsprVMSyR6oP3PoIP3/foK/aZLt+xhp95210gAhbMwSa1mBgSZqnD+owwmczQVQPAVJv/5ExFJeJwMQwgZqSOkLNM3B3NHkDfd5jOZu6ZgavRHEhA7P7bIjeHYcDGxgbm8wHPbSxw/cE9AWCUc0wpKcAiYA20bgOGodSNk87AiczApx58DP/hw/e+7Ot59b6d+P43Xo/1tRmu2LsbDMKkTwaOpKR1XJeS7h/iA5FAGLhc1xMnTuM/feFhfPLY0ysAYHX81ceh3W/Atfu+tXmoUmzyIS6zuTqbG8LOyzqL0WbstslqqGd7GTWZzY7WHfTvNuUlahJ9daoKlS7IA6N0K53AmllTebgX1e3dOehzEw/EFGMI3EQhyhbM+diojMkaNLSd2LLIO59HnxukvzUmisXHuMhpWQnj1tnTCJvAedVtip6e0TIDsPx9w3n7URc1p+GIrF5770ETChl/DcjUABrB4MqZu6ROrzFcM+5THzxW4l2f2flACN1Mc5BrUS4mNkolVQM/T+115mK1ASmIfix8bfC/TOcPV7zzkuIYsdFpIjDtq3ZMkza2CoRT576Ko0+9b7U4ro7XzHH7kR/G7vUjoSksazEH3TwjytyscW5BRyAYqmoEqTe5Q3jO2TWIUMPR8t8Zzscm5wC8lv2Q4/rMDhhon3P/vg2AEXLdYSBujKfzn82b9Xno2YMRIQjPwRIIPiPaODowIWbNU4C3R/GF7T7iAFHx0KHAgPOJAd7ILmnqw/KYuya614HfFufXSNx8agC1EojYOHvmiCSv+I1GjNKWxi22/gLS5CtDoHyW5PdKD2AFrIHajTN8ViQKPg0vbz+3/Zlzrp/TpqVx4EF46JkP4Nnn77+k1qQDu7fhF7//bkwm0zj0SFVUI475lWlo3xk0dQhgnN/cNACA2wBPxkfuffQVBwB+7m9+Q23mPQu3nPekS5ikhK4jbNu2Zg11KnVLR4SBaxIK4Oj/2QEbzfgqEWaTKZAIXer0XLKPhaZa9bnBXWaRF2QFyDY3N7FYLLB9x47AQigGhalKG1IZeTWSBT9XKq9fmAfgjH/6ex/H4ydeeFnXcs+2Gf72t78O08kUB6skocQQFlCIVAuUAhAAD6+yZ38Bv/uxL+HP7330onkOVgDARXxsm+7FnVf/2CgJgBuknt2UgOoD2NKWw4bK5thrD02MkIsu52b6kV2sjmhrOLsYM1+gMDfZug6Fl6KBKBQ86j5fJ7BiKCiZ7vHfbYEWuYA0YDlnjeYZTWbaBr5NTfDbbDU+MrMpV5i2lEvf6PmYxSXAwtiIMC/J+PX0P08VNP8GSSoof+6WgAmxePFMkuVsfraJBKKzaTlHv3o42m6basAxPxqab++KNooFi8/5FtBHkebMGl2kqHLmJZGPaKYypM9AcbB1kU3iQ8CuyCRhDnAbvjc2DB9ZBVKIMbxQdNVo5pZzoLQVH4DkJpZW7D5+8tN49MTHV4vj6njNHDcefCsO7rk9sq18JF9yUbQNAIlAnW814jlKn4J0x5vXDU2Eml97oW7/NHLPT5G27wFDpaI3z3kWani7/qJZK52Gu1aKbVNrk1ornsfAqwMjmySXyBzzQDu7KFTv04LGjHW8n48o9hx5Bz6pSJhjUVqQRowB28P8eSyJvfNpEU3SSoz7i5HCoREXUzxKjdyAY957RHWXRg+G9ZzFDb00j1llKOTkCvV6kfNiUvDBgwsiQ0mNtHA8XFi+n7t9lbPVTxCz5bqfVwDmvifei1OXWATgG687gHe/5Y4m/tEBYQR0qauNndPHw/CljIxz5zaxmBfq+UKaWpcs9aF7H8FHXlEAYB0/911vdN0du1uGMek60/9Ppkpnd7hlmWAPWen3wzAUkz2h8jsWMqNECcp1TClpoz4yaIbJLmW9G4Zs9X9lHM03t7C2bd2kwi5qUJgamU2uys4TLSV7ciUJ4IOffwi//ckHX9Z1XJt0+JnvvB191+HQZTuBlNCnFJ7nruuKJ0JNI0gp6SPYkYEn2RXaf/q5h/C+Tz940TwHKwDgIj/uvPrd2Da9XDdj8qsVRaQ+Bw3zWPPvG6zxlNFT6dJIT+hp1EZncxtmMLah0HgyU6PZEQqRZa1brn2yXPv6WtG13psVwRkauulso6Wz6Yd9bPXP0elzCnOWcfHTyil8pJ+fzpADXDhQ+IJZ0ijxIGr/467kpzTx2kRAqAUwPPDBX2MRoGauIIUFxwkO+abeO+dTo30kp7v1RVar87Qow1bKAURX/aLz7xTJ9npUDzYRokdGZgdOcVaPCYncM42qREuOC9tlzv4sxjNosro9cCTOzQGajk2MTmnqhMEidXwRbo7h9z7+uziz8fhqYVwdr5njysu+Adfu/5YRsBnWH+c+ndwUqX3Oya90jiZk3gEeAOgroOZjOBu5lG9gNQIr65TPTAndc549t66uTdR6Azid6BJQlJfYQgejtxrfFmRDLkbPqnbE1xqxhiIOwUH335q3+n9q96LGJ6b1zAk7o2inq7M+GimB+y51zyO/1/BS3qL+CzVJAZ4J6ExgqTXj9ftuK49sZHxlPfaRtnbPEDho9E2qyEEyYvs5mrrNABlLMspWzzgGgzrLX3A/XyLj4HH0rve4oQbc+eKjv4UXz19aEYA/+/a7cNPhvXqt2j2668r33nedA/a5GuYx5oty7bY2N7G5tcB8YCxydjV0eY4+fN+j+Mj9j72iAMDfe8c3OgZI+Za7Kr3tAEwnhL4vBoBCXSfiqrkv3k25DiI4ZwxZBnZwd3+5XJPJtEol3HNKVCblrmmXmknMMIecMeSsiQkSKZjzUK5/36HrenX7XwzZGe6xYzvZ/S/ShFxfUwCEf/1Hn8T9T5x8WdfxW193Jd543UHs37W9eCUQFWyXzO0/13tn2nfo+om+P4GVRZE1yaCc7UfvfRTv+eiXVgDA6nhpx+uv+iHsWr+yadNcw+ko8GKGQQ4FtykD/RU3wPLYsxDho+60pjFLNXtX+W0hR118CEyHr07oTCUiWR/aHE5Rztuapew28mVxURidu9U4ywqd2IzHiJ2xLpE40jp5SQNthne8BFi4wFQlvEbSRnlcArFJGJAboGXs9RCLrRSmX14/OY51zCNgIuYS+7goCoVmZOu7QpFFG5ebooXD4M8PVALwQs37NJreoH0UfasSPEROkkOB6idFVKUCJZu6Mkx4aJ4SCuWUZ5REo8Ex92LZnWLVu20OIAfiOKmM3Z+MTzz0L1f6/9XxmjoO7L4VNx582xJw0u5zr8kfrevOzKl9zpvWKqytMR6vZQiY6V1sXTGapLPIkhyw6+VbIy8Qbtf5xhuex2Bt3IfkPVpS/5JtrvlPat43dPUqF/RTfL9XUU1HaK8kh9e1xtY1sq4cD+fQGBKOpYROL/81zHFHDLOlu7D5ChCSNgIesA1xrkvBdtJXysgVjKru5+RldzwCScygVqaEaVx3+NuaPEPRa/a/1n6OAMCwMB/lPmEBsZObAGcHTLRXN+GeY79ySe0pt1xxGX72Hd9ojSTF3Vkc7DXtAyUBQJzfc2ZlqWxubmK+NWBjkbEYFoiR3IyPHn0cH73/lQPs9+5cx99/x5tGQx35/y4Bk56wPpsh9V1dymrCAbMO1sT9Pw9DAQJcQ630+i5hNp3Az34Gsc+oQ0GVUtQGX/qAYSi6/+TINaV/QQUcgOl0qoxmidzL9WeKJ4NLI6D4/eUKkH7+2KP4vz9038u6hjdfsQfvuOsa7F7fjum0Q9eZ90hfgSE4xkM/6dClXj+npDn5yMSh9jmfPfYkfu3PPr8CAFbHSzuu2fctuGLPXUqT83m9BV3rqqledsxqsvxXpBhXFzYhcptI0ofIihSM6G8xV9fRm4mbwoNCAyZNu0gJxEDDxy+hpYg3BaNEAupm5VIAgBgRhZGWNGtxY8VJ52LtKLrBizkdDzULNWlmwPIGr3UmhmpN/ZSBvsZ33XIClsUABSYGUJtWCtOGmAdtjtjtJEAn9Q2Vso3Aa2OJ5Hpa+oMZ1nHwiCB1z+alH97ACdWBkfsdoXnW+zuehLg7w92HEvVnZoD6PKgBTQsiodGodi7hITYO1VnMFXVoAJD42mbaCSebgfpsaNFMzmjqAs85IV3ScU2r47V7bJuJlM1FpZH5jxRj2Gh85yeXkabbeLNIU+6BNA8OMEZ7Ukz3aJ9zo657chGIw3Tax3sSTOqmwAIQdf2BKg59zmWfumz3gEMH54VyXPeh7dsGXHf1UIvisj6szxg33zgoBZdSmUYlYuRivY9B3btJLW6GgUGp5mkPpTDtarb2I48lvHi2U+27yASYodPn1IKv9aqdOJnw7PEOMq2W70hM0kQbG3xjqnzr/Hng4UfWXXwvXFLKEEx8bS+BgsntnkfUgVxMrbiQS11BjTlwrteP3ATRpIpLZIHMKlFof9cbAXo3eYU8XFIFt/IIZ5Cs+zldYD/3McICrHt5hDLhYPuJ+mw0vgoAzm2ewF989TcuqfXoJ/7z23HHtYfQlsW+kRWz6lQlgaka6OXM6FK5v3NmLBZznNvYwsYia3PqX/Keo4/jY0dfWQDg57/7bp08+0rfWA2EyaTHZNLrQEeMT+WezXlAzmVSr481GHngGn+XkLqkZsXRlFVUUqRgitynCYRhyMrqyrnIAHIe6npTwIFUx1zr6+uY9H1dt4byuRI0sYVZHPjHx8mTp/Hezz6Ev/jK8Zd8/danPX72O2/HbLaGHbNJlTyUf0udgM/FA6DvCzjR9z0YCZO+1LyZzRsmu70JAD597An8uxUAsDpe6rFn+zW47fA74TVbcMh92ATr4p9EU8dlU5R4IW5M6WT67k2SYmRRBABGG7k2+RU19DnLcAtD6Pl4RIHWgo7GWkRFD9tIIS0enXxATOU8vFHPN/NQwJLGMZ41Yz5mO6sJVAUA2rxiLYEu4PIeaf/LCXvLZx4xASBOAFLrj6yNuMM/m4I3LxkY5dFrhWnVKJc4xkXZa3l3eho7TqurcTMNaozypMBmof+yaTg1GqsW20kBH7ZosTy4YopHBZnF9wnF2GIo1fySWb9rBZWc6F9NvNqYKidSi3IWbr6J6KKt0WINCFBQ7mHpc/7sC/fh4Wf/fLUoro7X3HHXNT+ObdPLnYbc7StC+ffPHBk9nxpvmiC3af0CtPGGpb5wLlVjA0R7t34ZRSlTLXUAG51U/WyqnCChM2NaMPqecPONmyAi3HLDAtNpea1Dh7Zw2R4xvC1vt3/fgP17F3VCVHKjGcDWPGPSk+lynVZ/MZSJ3KQv1XiZoJVz6zub2sefTdoTys+WQrpcx0lXgIVhYPS9aZ2HgdX1fMiMxZBrccsorN3y80D52a5rKPm1ARgWWV9X879rUzBflLVuIu+L8jNdRzViraz700kCN340mQsF+8sPr4Hrd5RzOaehUrO7PmkWd/k8CX1HmM8HpC7h8ScmeOFsKvndNUZWdN4PPdzj/HnCkBOOHpu4fcpJPRqXWu8gL/uPuZxDhybcGBbDMWCIluzn5PSKgaHXsmlSMM61aEVndhj8KsoPnj77KO594vcvmXVo/651/Lc/9E2mWQ8SCyho1XWd3pdJwSSbNOc6sDh/fgMb5wds5kEp9GV9KL/7agAA/+B77i53A5kBKurn6LuElBiTyQT9ZKKu/zJJt8aaHUXfDSh0zsXo+6myXfz0W5dyWPMb2E71eg/DwtH+y+sPeShJA7muBwnYuXO7DlJKZGEFYKS5To30kwjPnzmDD/zlI/jQ/U+8rOv3nbcfwZ3XHsC26ayAHAn1mlk/JGyQvu9AidAliZBs/BGcH4SAMUcffw7/8o8+vQIAVsdLOybdOu6+/qeAMH1oJsajDFo/3TQDvTCdGHkG89hFPtCdodrDUeY8OQdeh8B7LbXPz43Ov56eB9Ni+alLfd2itexCCoL3hQ/56cyjKbplP5v5UpwCtxnNdRrL5Jox1gQBar8NP+XBsuvdamCpoWw63aJr0rkJULLXrg0whvD70U2al0hHcnivdtJQGuslpkhtnFbT7JtxVYdlWkt4O5QAnJirrl5zx8iAm9R57a+cJ7PpJ73rg7FhqoYtOYECc2O+RGbchIYhELTDSbPBEe6jhhkTdLHuXtBscYsBNPTcirfM3CR0EI49/Sd47oUHV4vi6njNHW+4+kewc/1QQ1tvolODVtv9Xergc+7jJJ5GMYLGLqAGkPXgKirziSzD2wHYRdpWznLSM266aQsJCTdct4XJJOPwlRn7Ls/YuWOBqw4PIAI2t4YaiZVCwEoxHnVaVYkLY9R1zz5r3xsbix2QsViUtbMOnbBYVG1vqeCRa9MutOZCV63gwYLV3Z4ZSk2dTlKd8rFOunKGNvyJSoTVMBTggWDgwnRS1sj5UNa8rqv54LXRLw04h+ngMJQGu0slkzwPBTiR9X8xlLisEklWiv2uQ52qldcWcGRw55CzTW3lOk16UjBDJrkplfPvUvlvogIIKAWaqOp1y2vKz+TMOH0m4bHHO1BKeOaZDs+dLEDvV77a4/wmYbEgPHBsWpd+iT6Le5/uV06imMJk/q+zn9PS/RxhV4++SH5jeer0F/Dwsx+6ZNahH7z7RnzzbddosyosF2ks5UpxNQvuHEvVg/RCkd/cPI9z5xcYcsbWkJFRDOBk2fnYqwAA/ML3/I3CUqgNsjwzUhtPesJsNqka+4SBs7rxp2oYOeQcuKbFrM9K3MVigbW19ZGyOHNJEsghttVJuqjcxYshY1gMlUlRGE3lv1HBB654bzmHnbu2o++6usZBJTlWkhpAc+rUaXzovsfwwfteXvO/bdrjp9/2BuycTouZYWWXFh+I0o/IOtlPpgCA6aQvDACJM8xAqjKe3DA9AeDBJ0/gX7zvkysAYHW89OOOI+/CjrVDY5NkRmyaAReN5ozjvKFy82D6UiyaAIbHOmzk4fahiEBbg+cmNcFsKCu9qo0zkobcsoSd0V2bP6wZvN7zoG2wfXSTc4VeavS3zMiOnSY1OWZEY+rUxOGBYqwclujGo2FSS/Ef/3m5gZanriPqR5HCNfA0d67FiG+wW6dmnzzRmi7Zpxn02nizLjkPaoGLJvNZqZ3erd8BWN5xG/A037GHAvNYm1pMvqBmTl6rqxTJMLERNYsHh5y+tcZHZWApr8MDY+SeKZOckIFdbvfyEwhycoz2Of/cI7+Bja1TqwVxdbzmjtuv+mHs3nYVxgax5hPjJ2y23n9tzxUBuaVAs/XCGn+Jyx0BnSB0XcZNN2zVyf2AfpJx8OAc+/cCe3YNuOrwUJpIGNNN4qUqLqjr2CC0dzIqOFGZmssa47dDcgk5KVVtMUnBzRIo4NZWWTZ4RF2W6bX8rE2BXXNTJ/FDjoZ/aLctlia5GnNxaagTVUbAImMy6bBYRMdz//n6LmkWtpm21glenfJr7rgABBWIkBVazt03auSKmaLHFQDAmBJy/vKzwlBgAItFaRyEwcDCHuhSiXFjIHUUWIjiWzRkk1GU3wP6rhoBVrSn6xJOnyF85ZEOfZfwzLMdnjuRsMgZX31khs3NhEUGjj7Q1/ophX3S7+cpdZpcA5XPxIYq15hKNYYkxwR0+3kA0p1/5rGnP4Bnn7/vkliDdqxN8N//6Lej61K9r3lEIBLXf6JU7n8uJnmZqwGgDp4KeLexsYHNecb5YQBnRl9BMyHEfvT+VxYA2LdzHb/0zjdrLZJcEEYBvxK6HphOprWh7sqkH3DrQ3beKYDJLW3teOLZk9i/ezu2bduua7EAWuzuQ7m+whQo0ptc2TkZi/kCOedC76/P7pDLIkskrIACZu7Zs7sydeq/5cjyTJRw8uQpHH/hHD7z8DP41EPPvKxr962vO4y3vO5IWTukD6rnLwPKyaQYHKaaEDGZTJSBkOs5A0XzT3XYI2AiM/Dw0yfxv7/3EysAYHW89OOWK78X+3bcsPSLYp0mZKUUk98sGvM3iSqySB2fUdyFlIBRbJIDFshNQksjmGrzIjTrFFPyqDG70TzgwZq16oQrUTiZB6TUu9i/4gFg+nCPrnk6uisZmVyUX/VLEECAvHSi2QmYRlPgZcZ8wUXG5rXh3z0LgIIOFfDGf9ZsiiFd1wACNAJasDRRgEZOvwjNsWd7wK4ju/dpZAAgMYkxB+6o9+cmjYDG50fUNOnQpl4SLNS/Qn6eUqXdsn5/FqeFRtMvnzgjaTwmFPAIekk1vLFUAPOWiO8xktwQje+FRpYwsuVii+hE09IUT4Bk/hjLFgEGPv7Qr6wMAFfHa/K44eBbcWj37Wj19tbVQh3cdZ2+0L0e2EbR3E/ZSPW4/totzKYDbrx+jm3rCVccWmD3rgV278q49kih7eYaMTrpEoacMV8w+g5K6zQT9owhl2nYdNrVBow141oab532c/SzH6Q57UgNtdBC0XXi7ieTk77sPcPAteE06j6F4roacQ2laJ70pVGU9+0rLV6K+JSEHSBsgbIHbM0zukSliWeuk/qkoGbOxjYoU3uqEgFg7hpsATTEd0Cm9ql6DwxD+bM2HoNQ/qsEgIBJJ+AwAgAyXxSWgpqDVVDGn19gUNU/LeokUwAACtNLKfbHYjphIVBlKBjtWVgV0GsqYId89szA1nzAdJLUHX0+z0iJcPZcwtEHZvjS0QnuOzrFw4/0S2OJowEuO0kij/ZzlZblbM9IGu/nYMZ9T/z+JRMBePcNB/G3vuX1+t16c2F51rpUtO0yfpLmX7052BiHQx5wfmMT5+cZ82HQpziz3Xf3HH0c97yiAMA2/NI7/0Zg5cjDI671qQMmfV+aV421kzUqW4XKfqhD+rlPnTqD0xvncfn27dizZ6dGMsc13UCUxZCLZr7rqolirvKiwjyYz+cY8oDNzawxnRI7KJguGOh7wp7LdhnTM8P5chFOnjyNEy9uICXgT77wKB546qUPS3atT/Ezb7sT27pOS1+qUZxDBTH7lDCdluZ/MulLBDkZUODnkyJb1qjqelm+/PQp/B8rBsDqeDnHoT134rp93zbaFGJNZAY3tsBnNTAJZjitaztXV/mqrzfafuc02KTvwUGLn21a7SL5UuoClZHUHTWrEEByiAkolEu3QflJtUX9FZAi0PrVJCg3pkFOZ4eq71YAwPsnRBq4j3HyunbyDspkCLutFDQGAJbq9RDfMzACvAxhPPGnpY7Qf9W/+ym8dwJu76B4LfznoQutHMv/AHO399VQIyMh83Awba37vGxGTu09J5RdSW7wkzSu7v3GYomwRHBsXhK3yMzoqNeNHjKJ0QjBBO88nuX6uGdGnylCASK8mZ+aQTV2kozG+Tw+56fPfhX3PfHe1WK4Ol6Tx5WXfQOuP/AW1fG3njb6XBPCviPFd5z+otEzE3ZuH3Dkqjluu2WBw1cscPjKATddPweoNFuZgWlt+rbm5X2EQr5YcNV1loJ3MZSJt6wauZpXERXt+WLImE071ciLNr+dUgsg0DmCWM4cejB1jV6SIDKfZ3Qd1SbXTcjdZ+p7KhFfMBbTYiiNuTTX4hcwmSQ9Z6A4gpsW37wFfHO9yAUAKFr9eO6Zy+93ibT5HobC6Oh7ayxEOiDnJICAXkcHAAiQsLUQYKFclUV1Xk/1WvhzzFy+w64349eUoP82DMICKOv1sKi+BZU9IP82qP0ENUI9AwA4sC7ra2Zje02nXWBCiJZ5yIUdQE66Ip/FA0GbW4T7jk5w/4NTPHhsDfc92F+gRKdGHnDh/ZzdXtr+3OcfeQ9ePP/MJbEG/dzfvAs3H94Xvq/gt5GoRuKZPIPJou3EvJJR5CjMA85tbGG+yNgcaqxdYwp8z9EnXlEGwOU71vHf/MCbR9WhnFPfJ3Sp1DR936ksQK6B1oBc7q2cc63hy/9sbp7HUyefBzNj+9oaDu7dHRNF6/8kVQBVI8BkBtYyvEtUWFOL+QKLYYHFYsB8a6HAYXYE20VNF3jg6RM4P1SAyz04GxubOLdVmFxffOQ5nN2cv6zr9pbbrsK33HxVqH6Tw6lTKoBK3/fo+q4YE3YdulS9RhC5xeIT4ZlERIRjT57Ar/zhygNgdbyMY9v0ctx1zbtHzZY3MKNqdBdM8sJS1MS9jabcuZkuV0Oz4JIM1xBXzb9G0iVnqOKaNQUlyvZLktmrPLTsHG3FDVe0csPS5tRP/TVFQGMJ06gJNtMof+1y+LPX2AGIHgfsSd8ZrQuDNYUcnH713X3GMLXvkcbTYnimhJdCNNPzRlpgk3j/77liFmksu9DXSiMxSCs98JCRxkdh7P0QWRjufnWNeVh2iBrDPWOzBKdtZQOw8wgwD4DW2R9u8xF6WpA1KFrrPSnq/STSAbQa//EzQg2zojBbxswLNNc1+F7UezmYm8W8KDxx8jN49MTHV4vh6nhNHpdtvwavv+qHRs+5N7L1Jjbi3RETAsrv3njdAocObuHwFQvc+v+x9+bRl2VXedh3zrn3varqqXqeR6nVEpolJAECiUiAxCAMJgbEaGJDwJjENiEsjL2IcZyVAA5ZcQAbAjbLmMkOCQgJWSDELAEWSNDdUre6JfWgoeehurt+7917zskfZ39773Pfr7FaamF18e5avbqqfsN77w7n7P3tb7gu48rLJ5xxejGju2gRsGyAS210bTZjzQ1bw+VWpwAAIABJREFUYL8CpaXPuU2lYoBShdlQBmlcmxlca+Da7642FZYmPKWgk/w2oS+qXddcbEBN7/z0GNowF6Wy0zdAjKiV6j6O0bnRtH+bM9kDBo5yQm6FucV25VwwCNCwfN1cjFKvU3AAKbXGugjtPTp5gZcPRAEHaNzXgAfT8ScprCk1wALQjWpAZrdI8wiwzwdArym/hw1+bgTDJhcgsDIXNeUqsg5rwwE0oERuoCb/8GbBpjfW/UUZFc1hHc7ThbIC+hvwdYJndsy1A1V4vsehyRLeff2A9968wntuWuE9Nw+Y5uBSYpZPmtujHLOR0bY+FvmxzX3409t+9q/E+vO8K87HN7zq+ZpUUZ0BsUaRBiClpGwADs+4DugZFsr8NE/YHEzY5oKDOXcxwPzuv2wTwPWY8E9f/4q+xqt0XwoYYsCQBqSUgOga82q+Q5z0e7y1SMT47R+9B3OeUSswpAFXXHSurDnVMV5KB2qlGBBT6kAAz6ctuWCz3SKXjO1mFuYKlNlDlg0rqjf96a141233PGnn7MyjK3zba16AiIjUkxgcUNTW8fVqxDiOzVR0GNRgWmVBNEoUpsNSAf2Bux7YAwD744kdKY74jKd9G5bEb9IfWwPlsuMXWv0QFtRwusnqJCbvAALdtKVzjLfJuzaJwRmrdXnJDqsOSRosUq6jRhfa0NhpyCuAUA4BAKC6f3ufEo/TTeKtxT4sL7k6yr23z63dfJfnIwNdC1z7ZnknVm75iPnJdE8RPywlwCQAg3uvxUkC/OfhNDx12nwFF5amjB1bYMnmsCJbnW7RJzOYNmopF6h9bGDtUxA0jSDY9fQRSKSMVdE0LhkQet/A3yepexp4njvfhuruMW2+TdNVOtbM4v6DgQiNdVAVZCrVNfx8T/qYLZfVsAM1eY1uO2ft8/TsFXtqb/jQ/4uHTt65Xwz3x1PyODIex6df842LVa70z27pk15OOz3j8ksnPPtZGZdelHHRRTOue/qMIE1cUY04qd/lkL3TQL+UgtK1S2lNb5TJNd2t57l0jSlN5Tjhbg1DcXpgdLp/gg6e9skmgwUip9xSU+vXUzT6eRZ6/W7kbO2almFonL5ZHLMD2vTcmwKXhWGA18eTlTAkm5hPk62ZdDbvyUkNPMkZqs8dUmy7SXFGYeKdwPO8ncoOABCCXSP2WBwkeF8DO7fB46J6fgmscFIH+Vz0B+CUHwQABAxpoJG9fqQ/gLAMguTBM22Wf57mtm+sxmDNSTXpgUkZWyzjNBUcEdnIpEaKSXPS+d62U7vf1qOlMmzndm2HFDDNwM23JNx0yxrvuWmN99w04pHHYsdC88MY7yNTFrXCiYOP4t23/8JfgQHagH/0Nz4L4zDqc2TrgqVPJEmQCs7EbojBLBiV3t2Armk74WAz4bEpq5GeG7sAAN7+lwwAAMB3fdnLcNHZp+sa4933YwCGcQBCwpgaazeLo36iR5EAbJD1Lcb2XH/knvvx2GbjluyAKy44V9YJq319mkB7zlIDUoYkficNUJnFaDBUYJpn5JwxzzO224JcK3xod1LpLjAD+D/e9J9wcjs/Kefrc599GT7r2sv6daV2YbIYYhD9f5NOjOMgKQHmX1WEpZRrY5JSns2FNoSA9+8BgP3x8RzPufwrcNbRS3cMkPrJcx/x16Lv4q7eEnB5uN78jVN7NtOm6dd83NBHrGmzVvvfRY2/DVFDxzSIoof2poQtCpATIWsq21S/WJRf2M39LGVqzVkclE6qIIXSRd2Soox75/TuFsquUK2W1+yp2qU7h0vdPnrIpIvUO8RAcPFIVm34CQj45AVPWl9q+uV7q3fmN/lD3zD787Kraa+PGwsYHfjgr3Wv6fVRhkGpiIzXyWLY1UAKTvpqZ8xDiqVpg012Ar3nOmd/VJjfg+jrAVRNhyjwZNvghFtFgLCAYXdh1PMYzRyGsWQSFwnAxVJ6cGohzXHIfNRpUe0impbP+R+//yexnR/dL4T74yl7vOiqr8Wx9blYpmwAAU+/ZsYlF21x8UUznvtpGVdcNuPYsSxu9lEbWTZ52ymLzt1o7gCkybdp82oIna9GkCar1Ir1aDF5ZN9wUj2k1lz3EXrWPBJM8NOiaS5IybluK55qOtBZYvOUKusm0QQSihjMxUMAgaTU9qr09SqTdzrsT3MVyUPbrw+2jYo6iut/UTq6aXw9K2GaSgMWhAEwzUUAkagMhxiAOUPZAjTk85uTyhRSUHCBTvu5NK+B1Ri7Jp/HZmrr54rXtxi7I7uYQzMIhL5fMiMMALEVlSCPXcOqEotZpAJkL7T3lxSwcFsb5rmIQ3hQKrNesxidwa19v/odMGpRfjYccs6aBMX8Bdo5bH9e+h988PYB77l5xA3vGXHjzSMefHCEUf89t49Dj1Z73XviJrz3w792yq87L3nahXj9K57XniOt2SyasjFrmuN/LmbW2+5pSnT6UU0pFdvtFgcHM7Y0savVjzoQAfzee+/AH7z3Q3+pn/fvv+5luOSc0/vBUgBSiDqJT8ky64MMLbL4GND3gCwiAHjg/gdx7yOP7WRXX3zOWS7hxBC5ouV1wcBmeUi6znjzPjJocp6x3U7YTjNQJMKzVh008okuqPjDWz+Kt/75J+5dcebRFf7Oa16IJHVqkevm+bcBLa50GCJiGjCOqTEo0NY1XXc4XEJVUIXrBgGn933kfvzLN//JHgDYH0/suPK8l+PSc17YPTxKW68ubqI6dL9mQdGlKSlFM2F9ZFLVxie5v4sbOnzEXnQT57CY5ERp1J3mDGbMBuq5y2zgQujjnzi9jXEAdlznRWpQg+rGqZ02OUCLb/KSAAMAihae6JrG0rXd1p2FRfDiMiYQOzGDO1T8WnG4Xr+PV+xseXfmxqFzr99NAVhMyyuAQ7TtS2aEgTc45P1gcf69USGg8URh0WzX2uXd93GQxoDg9eC1UoNH+ZrXpVmj0F6HYFB3JjQP1vwgam3Is2eitPu4oFShbLmJVpvQZZlADe7auYDImp3koWq6AL0soJ+hLhr9og7DCqbJv7X3XNSzIIS6403w2OZevOu2n9svgvvjKX08/8qvwsXnnYcrLy945rVbXHThjCsuK7j2aU2vOc9FdeHMq+cUWKn4bLhy0aZ3NfSLJ7XpAa0RhDPlahnzRcEB/+90/d5sZ21aq0zRGP+0nds+Q/8A71PYwAEYOAAze0sybeZ0mk2sbyq95pTfay74VXTxUH29rSWtEaePwTTTcK/9PKfKNBCcxUwwhoBJGA5RZAvFNfykoM/ScLIRL8XMCLcKtERum7pbbmTivxpjt5vQp2CSppgyCG+qt50bEKw+DblKc90AAMb5qSkfGFPY3zNch6NM7xmX2FIX7BxGJztgg0d5w5ii+htU5/vLc8/zwiNGM+jzkDtjGXNBF/m69FXQ3xPCThPnPRw868QPZe66e8CN7x1ww80j3nvziLvuTj1zQtKQPvzAu075CMDzzjiC7/jCF+K0Y6d1jESTBUo1I5N+NnSUalZG97rzzPM/bbd49GDGXEtrnquXeLTXf+M7b8X1t9/zSf+cMQScc8ZRAMDrX/FcPO2iszHPc6e3T8k0/zEYuOHlEMXT/+XGu/+BB3H/I491gwseZx87iqNHV7IWFn02LPmkmQ6uxgEpDTbgcOe4iNi/5IJpmpoXgIC0hwdbtuPf/f6NuO2ehz+h8/a5n3YZXn7dZeb/gf76AcAYA8ZVQIpDS06QOMIYUycnoR9I28sm2bOq9jkhBNx61wP48be8ew8A7I8ndpxz2tV41qVf0jWiwcXT9Y7J1gi2Rs1RwRcGgL17OxaNpqffUffm4gWxdENf+u7yxgd2IuyqLT42QacTfNN2k4nQO/3HPrJOI+gWdHWP4VWIRECaUbfrGp28w3eBGt1k10/5dzN5zWCu6ObauVR3IEFPCO8jq+Ac5i22cBlp2H+9WjIhYM3pIoQu7JBJ5WvBR2nVxXf7aL6gsYbBOxAH53zvTRG7SEQDAFTOEWp3y/nz670VrJcm5T845kHotfp6ilS55WIxjWpfKjrmBlAX1yd2z9gS6NLECpcsUQTY8iyNztZRNf9B709lCDgDy8PEIHc9eCNuueut+0Vwfzyljx/5x6/EX//ii3Rir2CxGKKRTt8mpcGKwO75lWlyMWbaIA13F6NXfPxd1ax4NpMAMCRrtmO09zDPGTEErMaoE3Bq7ae5mX0NOim2PcwaMzNdp0leCH3TWkrf9NF3YBzoGm/AdAgGbMTQGkmmAEQncYiOWu/PhTUJvT8CXfxb02ogBSeZnFrRxTvExjYgEwOueR2cAR9fd5pb074aokzB7bWoGx6SsSlIxw9O80vN/SzmglGvL6MYCdS0fYrRhF5mUWTKP6SI7Vz0NYuyKiyJgPdaSgFzhgIlRdIZCOAwBrA19sa+i/ROyPL3FJDn4qIUg8UN0ldibk2XZ2hAItyaRMBdM9GhREdh57YP5w2xWiVUuXcfeijhfbccwQ03r3Dje0fccecAhICbP/wW3PXQqR0B+KrnXIEvecl14s5vZtRklLAOCLpWBL02uvt771Fh6tRacfLgAAebgm1pZnlZ6p/EWEgAv/bO9+P6O558AODMo2tccf6ZuPrC4zh+2hG88JqLNcKwDRrazcEYyebH0Z7hRl03xk7JNO5uNxGTMmIAHnzgIdzz8KPdwMWXrOtxxPHTjwib0f69CgO0AW4RwxAwjAPWq1Fkn3BAABQEmKZJQICi8iuufUt76gLgB37lDzvw7Qn1VKcfwTd/3vNdtWu/O7k1N6UGhg7jgHEYRVIUHcOzao2ac8E0Z2QHACBAQcYP3vMwfvzX9wDA/niCx7HVuXjBVV+DpS497lCO+7z0IDTrKg7L6NpddJFKy9vBpre+hfVme3VH621gQltkGOvhaZ+kewfGtun7zcJgsCZR893FMFCbwJrVe4COpTQuBJZZ8NbYdpFRflKtmnHfyC4AAN/W1bpw1Dddu02ceu29sS6WEoa6A6BoskIXA9hT4C3qrnQsje4378RBLqUg4rwttED6B4RFzJAZG0WbJojTvRkS+dSDBYNDjfwOMXiUXcUYIcXPi8zMqProSPMAoFmYJgwgKwCgE3iVr2R1GXdvro+4lPdo5y9aVCGAEJN5FVS458s8JQwVdv4VMvHXe0M/W1WDw7Cg09Wacctdv4m7H7pxvwjuj6f08d3/zfPxP3zbs3TFm6TJpcaewMAoU18CAKsx6YSddMyK5uZPAIBNf5LJrjejq655C7EBC+33WDY8HfUD897BbPhGBR+HpqueZArcDLSDfoYkTTmn4/QWyHNR6vycmRZQdR/yuvQ2LW8NCP9O8z5Opeluz1i9pTY9yoSZDbNnQHGazpPOpjYEa0atKbbXpM4/pWjMixAk47r9/tZwm3RBAYBg12uSqX4a2iQ+l9qlKczZzBmz2EMEuS/muYhx3sJAUJ3+K4YxooiJ4ZCifu8sATMphg4AYHQZp36UkRAwaCZw6FgBo9Pm+wQE80juncBDaI3KNBWMQ/vedn3IIqmaFMAIxFlMKwkIeT+aOZcGenD/lr2GGulJ2B4r9wyl1PsinHgk4ub3rfBt3/cfcdtHP3rKrjeXnXs6vuXVz8PRo0e1wc+ln3AH6XSp5yZjNYojZ1SGX1WZDmqjeB8cbJvcBhXbOevEOgDIQll/0ztvfVIAgDOPrvDiay7EuWccwQVnnoZLzz1DJtEJSZr+KAaGKUYVX7Kp55qWCA5w3XReHMXV+TlXPPjgQ7j/xKM2U+yiLSkFSjjn9GMCiInZapTnqbR6N0UgDk0/f2S1ajWOSCdp8plLEWZXxnaakOfcfF4EcCwVO3lZBcAfvO9D+O0b7vi4zunnPOtSvOwZl6OiYgyh48kqEIDmxzGuWuxfSgnjwDhDaBQ6H9J5zs3PYJ5RctaRGllBt91zAj/1tuv3AMD+eOLHc6/4SpyxvlCbEWvSq4tXdjhWtZz26k3/fNOohm2ljzCDo3P7R2KRQ+tvItsApVkNrtqQ5mxJe29uuxLzJxTroNTt4swGKQGQGMBQu/jBXLK4dSZ9D51zfmXWenVsg9SBKUFAieKaZjUA7GFgs17oHPubbKIuzkmfWx0Nrtfev/dvgGND9J4ATudfjYJIIMJPn72xoU3hd6+ryUdS/zq+yQdc5FDotO1Nm9+nE5h0wVBeAweixvVVT5mHgQDU7fe+DEXZHblmKXx3r1/n1h9CN2XURlxjx8zAcgmqdecmRGHs50b7qv4+j05CUHWhL84wsU8qsKa/W4iXUZIV+pzfcMcv4aGTH9ovgPvjKX28+tMvw8/+6MuVuuyj78IhdGeN7xMaPzPmxyFqk5ySucxzatWaY9PA51Ixz9JgwUzuqLMmZX4comr5mwYewgBojV9yGvNBdPzbrYEQbHKHBJUYzQIAtMmaUedtUla1MUU1UEKZcbClIsuUbEhBKPFmOOfjCAkA0EhudpR5+g8EzQaXqEKHDRTnir6MBVQDO/FWIFAxDrG50RSbTm+nIgaBQWn9jC1k2sCRVdL4Qb7HcQgiAQh6jTZTc+4f3b1AWcJc2nle02RvsvukyTbM0G07ZaQUO1PA4tbaWlxSQ7AIxi6ZwCUxDCkaA0GMz6qwG43C3+4hSiGK/Ow4kC0g99QQ1Yug3ctBwRSfdpAiYwvbhJXAFj97rQ1YqbXd9/Rz4M8zneHSz/pFBT1Oueb/nNPxVZ95HS4677jUGX6NCN2Qyyb/1Zm6HSLYrK1epeHodrvBZqrYloKSszbQnun5y390M2768P0fX3MWAp55yTn4zKdfjEvPOV1ALGv205AwpNSeXzH0a7KVJKkkztI6oKOkp2T1eRH9etT6Cbj//gdx78OPIFdjLSluKcwX3ptnHTmm0h8OyXIxom0AMKaA9XrEIA76lDdVNBAxCTiDUiUScMY8VRxMs5gAGivINx6lAj/zu9fjzvseeULn9uhqwLd/4YtcalgvkuXpW8l6tF6tgBixHgc1sm6eEaX1YlJjbucJ8zwjz1NjVzmGTgoR77/7Ifyb3/7UGebsAYCn0HHdJV+Mc0+7Whvm5QXs8kqd/qy3JPaLlFGQlVIefA67p72HLu6tnxBbo8tmHTU6OrYkDISeecBsUYv6kQYs+sYuuui8YlNfjYoLyoCwn60WIVXdWXJu9p2DvTNBtNf1TvnBpAgubWGHKk5+lHeCX0gNdpcaAwB2GukQ5dSZTKHCT9oPo/V7QhPfW28QeBjzYDeeEAtWgXeWdtcZvbli6ECM6hrk0rNKJIFAdw75GWvasaDF+0bdUgF81nEMprHXiEyXNKHTdo0PhE7f2xRqXiyLxmQpPuPXgWYxJAUZOtBikUSATmrhGCoh6r3awAN338jP/sFN/2Jx3fbH/njqHZeedzr+6Fe+qNPBB+e6XnXKHXao0Wz4GQPH53kYkv4sfx91ujZxbY3QOLRGabstCyoro+1swk0NfC4F24nNZXtPgFDeXbNJtoDG8zlwoQELFVNuz/VAvbxM4ZMwC7jycLI/DD34TposdfAek2bMnI8m9D4GvtHz8XxsIvla/Hx0zi9OAhFEAlFlysivQ66J1xOThcGpPQGBFAPSEJElbYFNu7IwhD0xze3zUX9PoCG4LbaxMgwAGKSxz+qyH/Ua8D2SGbEaYwcWkZmAah4JbKxozlhd5F8udj1S9JK4oCaL4rOmMX/tPhbpQMWh8Ye+pqLMglIWM3AM3XW3BtV+Ts9DrZ1EJqWIIQXcctsJfOZ//cZTcp15+kXH8Q2f8yycdvrpymD0zAwZQ8jAwYZGcPUkYz2D63xJ9W7ASsZms8V2yjiZi4viNl+OUive+ucfxLs+cPcTm/YfW+MVz7oMz77svNb0u/uebJ8YE9arlkXfJFRRvLEgkpagjTh9DRCALJN09glet84b6f77H8S9Jx45rEQ1PwRX5qzWK6xT0tow1+Lq58aEGMVUdbVaYRgGeb9+aGOGgKXkxgTYTpimgnmRrqDVIP1SUPB/vfGdOJjyx3yOP/95V+L511y8M/Fn818qMMj0fyXT/3EchCUSlFnRGGNFWEozSsnYbiZspixrRdB41xCAD9zzMH76d/YAwP74OI6Ljz8fV5//it388mrNl9c8d5PaxUQVdTfPvqpuH4c2iiHEHdFZ97u9BruSOmXu6H4KW2tAiEneR4FpaVoj7F9fm02REviFODgTNnoN2NeB6CbbdeFDEHYm4wsKebDC1OfndrR6r7ev6nffNeFwWnPfAJoJo6eeo5MgoGNrpENev1iT76b2UIDGJAydaNM54u+kAPi0gFp3crgDlkkS0WLw6NxfGekV9Rx3Ki5vQOjkFNwQ2iYqDXLNTUZSFz4SIB2zqJHkLiBi/g+VwEM1SUoIToJSy+MAMwtABOjlIIdsIrUWmcp09lcOvHM+B9Trds9nO58PPPIB3PihN+wXv/3xlD/OP/MY/vhXvxjDAJcOAp1QMtpPqdPVvo5g1H3S+kvtNfJsOL3DNw29GFPFqT6N4syslVKCZjBIkMFPTPtiyeL4/FSxyRla0T3NRafaw0CWkEUKwhXf1L+nBJ3c+ml8j+XXTnPrP7sBpKbrZ/OHRaO4GpMyAAbZvicBXZZgwjg2FhQbcervOVVsnzFKI+/fczDzO5fUUOR3kRHBHsQo/tgx5bPzCJULRO9DIBN2DwAUAY5iCDphz7lgHJOuzOoJob4BBFkgZoHVARwEEuS8De0f57lqsgClDupDIPeJSVWcnABktgRldigQojpk+zNZMJriwKomGEBgAFNVsIbXnufxVAQALjjrGF71aZfhJc+8Uvdrmjtmojxuaw/i/E9DR1tPQlfv+ZqC+vhaMjYHEw6mjG3ODWQrWetKRsC94+YP4/c/xhSAp114HM+/8gJce8nZYAaXfo5qgGBFxZgShnGUSX6QqX9U5goErKL0gZ8gujUihuZVUHNFDcC73/9RPHTiEZx3xgpjSlYCotf998wZIKWE01YrVyMtPafaGjyOAcOQcGS9RhIDPXouhGB1Yy0V26lN0qc5q9/JDJ+a0tP1f//mO/G7N35scYsXnnUMX/+5z10YYy68VtCiB8cUsFolDMOI1TjIOYwugrad57mURvsvGZvN3O4TT1mQ+/B9dz2IX3zHTXsAYH888ePY6hy88Kqv67g1fgIe4BHkvqHjohTFdVwnkNVp24MY34kr+66e2dPLD4uys4fYAIGe+t0DCG0h1UWTNG/XrHrqew2WAuCTD9pDm7VZa5gINdZwTWDqFimVRIg/QkRyhopuKt7Z/S8ZEfIeqzf78yEitTNLPKyJ9xT2wxrv6hz0dwCCHUmGp7z3k+ad3+1/1hv4dfR/W8D7SEcyMnr3Z4Q+4otygBbh6JrpYM01J/Oc+nfgjAMx7D4RMCXQA2CW05E0dqubnDE+Ei7isqJD9QOCAy0kSULuzY4BERZpCw5EsvfkQCHPPqgWEVVq1nvIzDD9NWrv7877/gi33fv2/eK3P57yx3lnHMUf/vKX4OjRoE2KFiHS0PsGxjMAOEEO0qhxUl6dIVrnsl9Ir5eGTc3hgjbXnEwTEDAzurJgJbQloJkAZlS05AFlHURbt5phnrnQe524T5ApbqoY4TW14oI/WVY9bWkIL7OZJ42WdHrq8gkAjAOd8Y0R0fkWDDbl5PSScgI2rzmbPKLFKxYFD7wjPc87GQTMEmdjG+QzkvrOybzR4ityBlKiMZ7F/lVA3ft78z4B0KVBj0LrJwCwXkU1VNRUA0gaUjD6ffM4iOqDwOQG7jfTnKW58pP7dj1Wg8k7mMLAtAZ6VxTRR9NXYZqr6vSZ2sD7sXkRAONgzX8HSJE1I7GLRc5NM4Zk+o13ajcAIBfzjbj+5gfxBd/4llOkLh7wyk+7HK9+4dM6Vg01/azh/GBIwUExxuuMmWtFTMbSaeBV0cShioJpythsJmxylueraE3Hxjgg4IY778Wb//QDj9+AhYAXXHUBnnnZubji3DNbZOhiCBfQ5iUp0gS1sQCYR9+c9qO6+5vTP5zRcMuy5+8V8kpbh6Te/f6fexu++EVX4YwjKx+UZedsEQHoP8OZ6yM7jeTy70MIWB8ZsF6vxJAwar0eJNmFg81SSwMBpoztVDCVos5O4XEa119/9/vxJx8D2+KLXnQ1nnPFhd3PL4HWMQSsY8AwNgboSt5zdAMqq0MDSi7YzhO22wklFwFOfbJA+8vv3fRh/PZ77viUeXb2AMBT6EhxxMue9q2uQcOO1ttPATxFnhOLSK2bxO2Fii66rwMQFr/L1kevqbaJd4xJtc+k++dik+AA33RJE18lQjDGLhe6N4QLXdOmDXRoMSPt02WhQqUupoTfu/Q4YGPXTavRa8q73UKXTkflprZ/EQ932HTfFsteZmDEpqWDfF1EDAKHpSx43b0lJRgGu+tkb0yEiro75Q7W8Jue/pBJ9oKWb/9bmjC6zaz2Hg3eUC+IrspyCw5hewS39Neq0gyeS2V4iN+FGlXyLItxX2cCKEV+7DwRov626rhmxrTol1C9p5y8YOnrUKvEBMXkIhIPYWXoztmev5s/8mbc8/BN+8Vvf5wSx6/++OfjZS8810XKwU2B26Rn8PnuC005ZLJKDXR0U2C6xrMhXnVZ8FUNBjVSMKCTHfD75rnaBNaz6SRur1R0AEB0AMB2LurUr79L3u8sRlxewsA92YpQdFNoX0m3ieZisCRT4faeLKovl4rRnVfPPJjngjRYPCIbTJoMZtdsk+XAQn35WmWxdG2d2R0jAsdkTcg8F53UV5X/9e+RTXKM5h/ADxucX4DR+KEghPeOWDsJAJtmTWrQGEBpTgaLAiRo065hfz62UzEmQAhicFjVfI9a8xSjxhbShDIKYEEmRFyYMqfUmn/bj6qCKGzmlI2wcP0fUlTDNEoAlBkioNk8F8gAG2/6rTvx337vHzzl15PPeMal+KrPfrYgtdutAAAgAElEQVTq+23ibE70+qyLvxNqo8lrvRygEs/QTaU94yNLrWexdSceOcCUpTkVXYcygpyJ5r/7vffg7oce6973uWccxaddfh5e9oyLERAR0YwD02LyH1ylF/mcxXb/rsY1YooY0iBgYVQPIoIBtqa0z5mCxZmyDsmS8nHDbR/FKizr1f7Pzu9OZ0WlAKvViJXIAIKrEAts7RhjxHoVm3xhvVIjQJb26h9Sm8/TPGXMecJ2UzHXirlk8y5ZlEtFgNs3vvN9uOnDDzzu/fLcy8/FF7746Vj6PCyb4iEErFJ7v8O40gQF88CyniCLbKHMGZvtFtttwVRLs/BWEnD7mTf8ya34s7+EWMg9AHCKHs+5/Ctw/OilC4TQ0ZIdfdty2dE3kAsdf2dE5xqSGkJHMedkXfX2PoFgEX0WOqOnKuZpu9PzRsmGa/grQkxitlIXza0PUePE3ycGWBMd3GeufpLtzpw3QGzfmeTzNlCio+fL99dugi6NbvXmfuiykFpz6ppslWXkx8FKD2vy/ff0ev++Efeyibizcvc+BP6IDrDICyCpHPLefNBddGyKbqTn5AXoTPDCIi+K0/A+/hEu8aHofdIKJzvX7Xp4PX0RWr8ZI1Ga0ZgpQv9XI24vRSg7Z9hP/300Ywj2fFUmVIhsYYd5UX28ojMBVElD2YFWWBb+yW0/g5PbB/YL3/44JY5f+KFX41WvPL+jm7Nh3GyzRETZVHlwNOpZJrNDatr1PFdnJmUxgHSup6s6nDdJcBN/NuCBDTskRq4UDCkhhKIN2SCTZzaQbEw5eR+GKFTVok72Rcz4OE0n1Ry1GQNS/52cG7dvDL1hX/V7+iLfz0/pO2AhuumTNJWeDcBIuu2U1XyPXgvRpTLwHMNds2FozUXpwIIqJohsfqjVb69Tch8DyM/o/QKapUMQJkVQqnuVBTsG+7xBTfrgrnfVifp6jGqISBbGlO36scEvtTVGCMA0tXuQ/gmQSDd+fo1nlCabkpTDIiv5fWowF4L77ME1rejjD7vf0z49nwNP9ycDZndQFCQtImIzZb0/ef0A4JfefDu+45+84ym7jjz/qgvxgqsvxAuuvkgd+hUMxCGYejWfKNZLMdq83TfONPNVbXotWstyjcnzjMdONg+ALUqLehQnez8uiiHg1rsexC//8a0Yh4irLziOl117MS446zR5/ao1A0LTnfM9xiUrQcrH9lZbrN5qNYo7Pc0M2/+jcAk4jGqGdQYqlNqm1FHSMfjZ7rj7fmy3m8e3q1oMHmkKOAwDjo0jBb5ddcgwvzEljClgHAeM46igxTIcmzLmOc+YNhNyqdhsMybHsFhWvRwwzfOEn/mdG3HviYOdt338tDW+6XOfjTSMHXt6ySgIoPlfxJH1qGkLy/tEJQu1YppmTNPU7oe5qPcB0EtH/+3v3oA77juxBwD2x8d3XHXey3HpOS92jZ9vdHvtHRZKemgSQN2d5TKmTU38/DS3ugmrz2n3dPa+8WGjVjq9c+in07UssopD91la4ebcRzuWgjm0s0raKY5qa24BPL75XQekJMc6qIK5lsWst9eB2ngi9lDF4zn0BwMlTALgvie4RbDT9dfeWLAz28NCrlGdQSGcH4E15+iAIbuGXXRhqH2KwM5GUPp/D7tLSXe9BGgg3ZRGKporbYSp5tlQ4Fxae5DD6/bJHqhyj6sXhJ4fJ+lgrJ9kWmuh1YE9wW1wzUjQZCOSSlEyEJ2nA+89J9tohcTQPmMpiCFanCTPXXV+EAvGx2Ob+/Cu239uv+jtj1Pm+D+/6+X46q+8XKnps07QbVIfxW2/NWpR5QFV8t05rVZ9fYqYS8uNjtGo+2yEarVV21MzOTHm3pRz0dx4GvdRQz4kAoFGwwWaOz3gs+7b3kHwYSP0c7rxR6ewyrkqa4HU5cOKs+Cnb24n5tpVXJqA+s04RoTS9N37gHtdxoDZxLwofZqmefz5ZdPJ6TT9ArodJwR9neASFHyTTPBGwV1p1Odcum3ON7dBHd17JkXzGgg69dbUh9l8CjT/neCBA5yKa74JYvB6R7Ehb6Z7Qf0jopgs8N6jjh+AShJCaOkDlhhg7IclAyVngEaPek9WA5zYnIZgdUbhM+ROFmUMhTKYxWv9m/9wC777B975lFo7Lj/vTLzgmotw9fln4ZqLzlb3ek7p9X6uS/+o6qSFrA3aA2J57gaskIHRwMSi96cZChbMU8bBQZMAbHNLAfBM2WVu/UceeBSXnHO6rEtRG98QWlXE2MAEtUeW8UdwTABhS0nduxoHDMNgaQBSrxC40nqMcZqwZ7QKE8L7pxC8uP2u+7DdbHa7YpgHgGdM8Rk5dmSt0/+y6E4qKhIC1ilivU4YhgZeVGcCnWJEkZhLMjXynLGd2lR9W5pxKM9PhDOMDlbLHxxs8FNvuwGPbqbu/vn8512B5155odwrUWn5kTJqqeLHGBoDYBURU3ufnlERg+uc5B4pueBgu8XmYG7rnFzH6O6/iooffuM7cTDNewBgf3x8xzmnXY1nXfo62eDNJZ9P59IB3Ro6N333Lb1mp5duohucS3/ttAZsEj2wULtJc2dGJI8WNdhsPK+8bMIZpxdr/sLuYq1eAnK0nxHH57ZbNyojzERJZQm1dgtyBfDQg0nogjaFPTiZ8PAJFh9mAnTPfcK1qkpiwkMPB2y2u2jl4z9Ku/9GpsAyaaCbxEMkDSHBvBB6U8dnPmOrhlG+GLPCKnbu9H4aUUorVoJDTpVfIG76XYSeAEPnn5dx4flZN0SLouwLPo3Jk2JFHYxraeYvUlib2U77/oOTER+8faWoKt9LRcWHPhLx8ENjJ2cJYWk0E/vmWgkvRVkNmg5hOY67YEpA506rd2b1sZRVZCdRv5fXyPwEHAiyAF2qAALcjLvPI69718M34ta7f3O/6O2PU+b4vr/5Unzrt17dxea1ghJd8e2N7DTCSjKlOfX1BRyL7uDN0mCxeqVY1B1p0226vICGmSk/RMTQpqyN1h61gaQTewxtIlyqyRKU8eYm5lE08PPcQOsheVd/W7fNrG7360GL7aq0W29ORzf4USbzNO/ro+Ts56ivR2iT+bLwDIjSNJItoWyDYpRzEtr0/RWLOvSmibqfL4ALXl9O7ckAACzlgN+b/bmgFt/Ft7GBofs90Gj9S50/AY3o4gR4LozhYZP64owll8wLMglSiuqrEGPEnLO+Bifv24mSlCC0a5OGTLl2lHOCAwSpK4wlUjrjSajpoDE6amf6WKp5UJRKV3jgB3/8Bvzzn7zhKdP0X3n+WbjmwrPlvmrXaS5F6eUpmgTCEnmCymB9vRpCL0tsSQ/QGrS5wFfkWq2HrrVj4ZQ549HHtngs50b/zlmBxsp1QGcnQSs7eg6wFog6KFLvPlCAqPbVIjcZQgOVUooYh4SUBgwpif4/apIQ6fQpBV2PUohNMgUaGVZdQ730hvXerXd+xJciCIexAZz3da3A0aNrq2kc+BFhazRCwNFVauDFOCDI4pRiVANYOPlrLgXb7RbzXJrhYinqM54dK5blFuvGnGf8xFuvx8lta7afe8V5ePVzrkAakj7fbPxN/99efy1A3jBErMYWXQiYgWqIoTM6LCVjs50wbSds5yJR4rVjQwQEPPDIAX7sN971KfV87QGAp9hx2vo8vPDKr5WHTBZAyEMvuuoOFAA6KlOIXvcO1eb7vx87WnDNVbM+5MfPyrjkEpq4Aeefn3H8rK0a0Vx80QZnndk2lgozFWrFVvs1NBEqDkGcS0POV2NqkwpubGzgXXEBma4Q6Z6F/pm8RhA9fY4bocU69Y7DLLJYSLFomcV1tBnrGGWQDwt1n1EipbjJxhRQPeVQo3hsEkOzIRa+w2jFgzdHqrVitUqdqRHdsLfbNk2IKWAW7SENnmjClJLoDUnZlOlOcb9L+uLOwZp6UE50WmEl148TimBaW+oLSb1zONCOu7FS9ESnSZSdekWL22rvo01RotDrqpqB8X2zEfizG8UIh4WcbAInTiTccWfqimw2CXfcOeLhR5zLrrBV7rhzxMMPB8uaIvWUzwiNDINjvnTeDxZ7qD8udMLgtIk+1tFiOJMKXICAWz76G7jr4Rv3i97+OGWOb/+iF+C7/+G1WK/iwkQuasScuqcXm9LX2tZ/TmM7aruTiGmjKkHUQ7Q4LDXZ073Ein3Kxoqs/cE3b9vc1jg2UXNFSpBJdfv+NFhBaf47bQ1MBACySR5aEwhttM2tHjtU/Bh23ciLB0hg1G7uyU3jy33BafUP+dki53YQAGBy1OAlE9iv6R50MW2+28/ZTAcvUUS3n1NesJ3an3XS3fPWdNJHxkKMzYixUendhNLt58p4KO29jYNMQKs13y22T+QSAZimqjFwybEg/H5epUlkXUFvgMYAMFO/1ehp98G8K4rtwYGfXWIV57mo5KRJNopjEwTZF0MzcHyc/Tw513feU5bo0L7nO//ZH+Pnf/UDn/JN/1UXHG/PCKImefTx1MCOnALGJrFxTbXoaQFqQmBDHzozUR0gMSqYg5RqPh3bzRaPnZyxqY36X8ss17lqVCRQEVJCksFElHpGxYBMINCpubEAZpmYA8AgqQ8xAjG1aX+ITUtP1kuMSd5/EC+iaBzWUjQJQUFTZT46U2c5TffcfwInTj5mjv+eiuSWoS7tGsB6NWBII3CokWFQbvCRIWK9ajKA1pBD119UdMBfrU1usZ2mpq0vDUSdcnHQbQMACGw24K4g54wfecuf4eKzT8NXvOzpGAdr5H3KQ1vXm0liCq0KW69a/N8wrDoZD8EKoKJd7vY607xtRoBTxdZFuvrj+jvuwRveeeseANgfn9jxvCu+EmccudBNyyNIm24LZMKlF2ccPytrs3L1lROOHa3qxH/t0zaIqRUMQ6p42jUbbcaWTTEbZRZARaNqzAGXDaxOJoQaRzreODbjNU5fjPpX1VF4ms1pFU6zqUY63HCHiHky+YB3lGZhwSKl1lYMNaooNEKIDTw/GxF5ajGnmVOf3fNPHeBqFZGz5SQn2WA2U9aJUYGZm2ykceckhRMCAgCkLG62uctPnp0hUqkVm22bJuim7ooJmhENvnB2U5ntZAVBccU3F+t5rh3llAskJ3aMP2r6ShcLGLCTqerprZupOWsP0XSnjc5r1DtO2trnKhphw6ztcYid9tdPTWx6aBYNQe/b6PKw6QBtedVtGkgEPNgELwRMU8Ztd444OJlEJ9cm97feNuLgoLFsaBDznvcOMmEyWcCN712rU3WAlxzQYCiqR0XUlIqGslx/+y/hoZMf2i94++OUOb7+lc/B9/+TZ+HoUZuot6JKDNaksculKsh72HOeYrBMdJliG63bAIDk1vjiothoEEYOwDS3JqwFolQFLFNarKGB/gNFI+mKi9tizjvla6T9q+Zf1upaq6zFrZkj84AMB+5BPDcEl9v+bhNjMv5m2UM0QSGL9jf1IDfPD/9elS1gNOq2nzcghnsjmQZdpB4srtB7l9h+XnfcaQ7bz4chKiDOKEQvXFMQXlILtvIeGlASBBCAo9E3KUcDkuxccs/sWYomieB+3pIKogIAup8nu05DijjYzhilgZnFSO0wAIBmiKRvZ9nPxyEgl1ZPNE+CiLm0BlKNI7O7b+VE/uf2cx8DyPPqL0IIwN/7p3+EX3zTBz9l1oWrzz8Tz77qQlx1wXFcfcFx6zdds8rGuTNIriYbKjr596a+9MJoAALBfoIAbBZDNKNpYwEKk6JjZ7SYuoPtFicPZmxrRckttz7nLKwEk72kNGhjH0xvJABEUC+g6BrSBKAEYC2MllZ/JUA0823yH6WprvKcJxv8aPpV+2ylFEzTbKaGrPcKdpgt87zF7Xc/0OXsHeanwHfrk4vbdH/dUeqXwtshtgZ7NQSMqxHDMMq6FO01RMbhwZc8z5imGfNccVCyrucmCa3K4CQDtdVrWc5L0pqOfleNCRuUFRJDwCq2GvXIOiGmJrGgHIeHNy7NuWCaZ8zThM2GDIXDAZC33XA73v6+D+8BgP3xiR1/68tfjc9+8WW49JKs0SDnnDPj3HOmhg5HnxscOm86LqbaJA+kvpF6hu5ntTFy04MskUpKpZMnd4iWccufURq4IHN5MXUu1ZpXsMCrftbRUzcbmBC1aOF7bhm/jHzqnYqpw2x60No1fZyaH5aj3BpWaDwVm1U1AoK5SA9JYoakuW3AilFGOS1hU++LSn6u1dhiijabrIUfwQL+/lkABy0gFoZI3kiK126pgeS1XSLmvB4+X1mBgMBM6bbRUvNaUdXcia9HsykWLqUGud+MtsnP5JkGSxYE/967MjdDGMt1ls8gMV251M54K+faaHPyeTdT1vPjPpy5JueioEhAKzY5lazOqIvvneeWYJNmkbtNz7/UnAPed+uqJRLINnFyA9z6/lFNC2sFHnsM+Ec/8q8PNXnaH/vjqXp8+cuegR/8n5+HM48PAghzjW9/TtoY1S72z8BIKK1bn/MAFDdNh3tuW159A6MbYABdF+w5r/r9Q4rdc9z2Hk9R99p4OId+HAKc7rq0V7efkWlAvb2XFjDJIDgQg14lUcHLKvRla8QHNu2ldi77NELkOqdFufxst+7D9MbM4Pb7uZnviSZ+wSKzPc6meH4/H5KTR0gNQrNFTmLZfNMPoNS2PwaRXZDuT1bAcj8vTlJlsYhRBhyMywuqzw/ObIhRf6vlfq4MAuh+rgNMBPWkUA+CVQMgDh5nP1+NEdMsRpLc38oT38/9NNNL6mLwU3N0Njpf9w9+F7/1hx/9L74eXHbO6XjJMy7DK559paunyqJGMbacyVcsGtOLeGIIHRjg2QExGFgHw1P03lV/Hr1ZbfLv7/9aK7ai9z6oBfM8S51XUEpuDIDQms5Ap3t+ngCN6rPiKzhdeYugiyFgTMC4GqTpT/KsB33mqzxjXEOic9QfRe4yTS2bvgGikgIQ233JgZ7O3ADceff92E7T4Q3/oRGA0EFKAHDkyBE16yyLtJIk/zbGiPUQMAwJa/ENaGtXUhZPVPascCRzxna7xTQXzLlgW5pEo5bipMpo5uGO1ZCFpcl6rzEvoLnV6vERY0tgCAFHV7F5K6TUZAoulSyKVKEWkxdvtxOmacLBtmAuxdjUDgRIIeBnfvdG3H7vw3sAYH98Ysff/qpr8b9854s6/XytjVY9DEE1TfrwOU3KEI1eiCBxRtXQ+qYl6+N9vDNtcKhrv0DbIknqJmOTohg1cXNTJ+fSNldODHwhxWXdJvNVaIJR0XDmRNv0tupEoJTSdFIxYDNl2TBj56hPIygWQNykWQAmaiRL3SmavN7QGwv1ztJRaZ+cpI8SgcSfY4ETQvsaZCLDYqbKxJ+apOwjrgSM8OZYZARwSuZAZ5UEsHDaYQBUo7/6Zp6fnu+Z4EhSsMVAhegKWt8MLwGjoo7+1lTz9UzzSx1q0d9DA6hBXG/9IlaFCjbnokwLUih5j3kaLu+EJomrRvFUjWsrDrtpjjQlzOj2LtnMslbX61I7MMGvutOUxYAIMjGEukpXAL/+ex/G1/7939kvdvvjlDo++5mX4Ud/4KU47/xRNc5+gmfrtGlT/VpUNIpr9zkPwWjW9pybAH6aczctLSLJqtLg11qxXiXVsgedBFaTIyBYpOBgf+6fc1vPzFE/dABALyezNZImgcXt5zGEHQNAk04E3fvJkqpVKLL1CeznqF0GSb+fGz2a0olun3Trn2ndfevGz1Q7Wcd2a0A2dNpNgMBRgJ3vwJCCGi9yb7JGzvZzGx70+3kfXWivsZTsBY3do4GsxQj6/Xwle/bsWBRNRhe7z5Ui0yravUZZXZMnCPMtBAOihsYo5ADhsP2cYMdyPx8otyxCb0dV0Inn7PO+/i3485v+y6XLPOPis/HS6y7Hi592sV47Tt9r7b2LyBipC1CHHka8nsk9ZzRSbLKIxvjTmkM8eijNVFNAtmydR4Xc//L+Ctp5LfOMR09OOFlmlJwbACfx2mpQDOik3/tI0GtK5TH0i0AbVEQBhxqAEBEFSCC4gUXSQfTceff05nkWenrR2lLBMmEtes+txx7b4O6HHu5G9qVCPUR8gR6DGfB5ecBqXKkhof2Id8S3iL3VKmEYEoZxRBIPg1IKEJ1TWWHtmZvL/tzO9VwKcm3/Z4x0dRKN1vy3ZqQ//waaNDAgKEiTAKxSxJF1wjg0939IalQMLpocTEgpYgDYJAqbqWLKRQ0d+Xlp7PhDv/xHO0avewBgfzzh4xUvvRC/9KOv2tHnFaXWy9SZkSYwLVmIfeTQkNrDPEkTTDOZ2TnL5twXG4rCyiKnm6toLRsC2R6YRmcHxiEpaukbatPnc/LS6FhLIyg/zUVtubvoGs7a5ZQSGPCbKjdQPoM29bUYJS3MSu1cknmusjNMonYoz0UXGNI2x6EtsFmmESxgPFhRCvTzsCBRYyd3TTfbViBwAj7NVYusSdgLa/oFuIirYYg7MSdN6xm7Yi76CKLQ6KQsPFnEesOidi5iBxjwGsXo6WRFp06zy2Iute4UK42qyEipBnTkXDCuksZ/xQh1W+a92e7H4uh8fSRWlkJ4JRIUSjJS7PMfqrglz7ndn/z+puGNugmSrkmAi+eGRfacq+ZeKzAi5yULckw6MKUGnbxOrsMP/9SN+F//5Z/vF7v9cUodL3/mpfjn//gluOrpRxqAVmhYZVIn/jvNAZcO5mzedc0OnOg7bXr3nPeNBVlXOds6MZGhRHNCYY2NgyUODGr019YV08EbzTMEa1g713mNnDKaMpt8T833YHpZNOn+69xntDFXGR7XafFNWezn/LPu56B8wor6fIgJIMHJrQANBF5qaPsfYMAu9fnNkd2czr1jO+ntfqrN82ITWbNhITsiRe7nrXmLNB5yAOrcmRqaJCR5lpawvhjFyP28eU2I0VeAeuoQYJ+z27tkP2/7bkEpnmFRdT9P2mS0PPkWlRhVAjDnqmxF3c/H5O6lQ/Zz54vh72HvfUDgYJ6NWcJ75YWvewPuuvfkX/rzf/UFZ+HVz78Gz7nyAgXT2FgVTa+wkbs2/+7v+sxV19QvYhSjGkRC91k+px7Q0ihfTpAdBUZBOTX1tWs7TxMeeXSLg1qQ54xc2+S/lqoJ10F0iIGsXG3+W+NJvTlC0/0PKWAcm5Z/GJpBnsoV5NmMIaCG0CdkqH7fhjUlZ8w5Y56zJGS4mXToYb4kXgS333W/UuaXDb83iu68l0G5ZZBkp4T1aiVrcN9aRifrGWPEeoxYrUasV6uO/eMZB3pP1IpcMmrO2E4N1NhKs10EBOAbnYtbQ0sWL5TBDBUBEVnKZ5dUhnUMWA8J4ypiGFbKtIAkAPjhX5G1bJq2qKViu51xMDePgrBgSwHA3Q89ip9+26dePbcHAJ6Cx/nnHMH1b/4y1epZ7J7pljxKjSAmGdU2Dza1/WTcmtxcDot0W5phmL4yRK9jqh0V0/+8d4f3Rk6eHrd0840LrWgppTN18otG0wJG3biJ2k9zxjAkjAl9AVShOjotarpNtmI7t+bQ6J+euilTjRi6TZiaeX6dBQxRZerCsVhUaUjkAQFq40nJpHSgFSiWeW15rvZ6eZHTzEbcn2udpDudrcoyfNMrgAc3pCx+ECmF/vo5YyoFDhwAwIKMxn70LvDMAy9RKI5hwQm90TCrFoPDEG1ClQwA8K7P2WX1ltrc+FMyiYoBYVFjmNQgUgAto60uM7WrmiT63PEdbgsL+7BIaAB0ovjt3/eH+P9+/fb9Yrc/TqnjRddciO//jhfjJS8/Y8dbqtT2TDRAumjxBbhse7c3RPGDqbIOeQo7vWRijAICVtW4c00rVdYf0HME6tuydTKjUnrWVRHzWrhmFQsAD90E09XprrHI3cTb5AKWG9/LAwjgx1C7OMNwCIuq38/hqL79muPXoxR7BluM6LwGeN6Wcbu2nnlw3TyA/nP7eScNdOA/v5frMBvxmey5FDE6o95+PyezIHSa7loqpmySslqDshQbYFNQa+xlCjGo/0DLnA/qsq4aczET5CDC1wYKjgcC+EUBgDkbi8IzA7mfZ0HlCWDwvuc95fdzMhe6ezIElCz7sCZkVFzx8l88tMb7ZB0vuOo8XH3B2Xjl867Rh56u70pFrwaaqCldt4cGS7ZQ0MBAsSJdqpn0Mh0g69TWpzpUPyQj2OJqvyA1WmWB4aKHc854+JENDvKM4lz1Idc4yrlndnwQ/X6Upj+gsXGZpjGk0CbOkOY/hG5yrWthNe8CP/TiYlpEL9+eqSIAlD2n9AqozgwQCLjvocfw6MHJQ6M3dyaNbnkzgJXrS8DRI0dczpj3hjLGwSrFBgKsE8ZxVFCETAe+D8ppuB7M89yYAFOLX5xlqFKKpTBkafLJFqulIKQGptCfQe0jY0tQGGLA0SE2L680YL0eNVnBalD+uShjpOSMadriYJOxKeZDUBY+Z+/90H341f90yx4A2B9PzvEb//YLcN01Z+Ewx03vvEsqOSeySrdyD3Gn00m2sVRfTNTamfc09Ds2CkyVBADG1IiGJ8WoFOqwKDgGKbxY6GkxuDC/Y1yTufnbAkgtXUpRC5NBadXmYM+Ngz4AbEZXEpnUphoGovgNO5fa6fBo7LQ0MhzHiCifRyckzlWa593vub2etG+i+XVOHFiE1GJf947OnpHhM5Y1BmiI6hi8XNfts4VD6YakwyY32V7qRXlv8Fy24sambbzXBqE6Ujpg+a3oCkJfeHIT2MmETqbJJJOABk7U0RZXXHGKSABqmi2uiZutNw/z8VN+erI0ziEYUxzIFlPLtPVNTLt+tZMcAKEHOOSzvuL1v4ZbbzuxX+j2xyl1XHfJOfiH3/hifMFfO1eL5uCBZD/5BRbSnOb/wok8WVCzN0IVYyz6koQQuug3FtTcC/mc+0bCP+ek61Y1EDSZme66h2jcdV13jSnBRJtgch1rH5r7HfXoXlrlnc3Z/NHw9XH38wK6g4UAACAASURBVOD8cxaGfEszPkqqeC5S3AWvgxiy9t4C0LUtKHCzACEYLzhbU08Tr+QmtV7a5Q0QuZ8X68OUts/vDaHRpn2koO7nycnHqLFH6CIU9TNJQ0hKPvdzZZQV8RACFnZ0RkHnvqIDkopuPycLojH6HLjzOPt5N3msZpxIud+OvmzZwAIdqzCXiss+6xfwyWYjpxjwnMvPxeXnnoHrLj0Xl5x/TrsnJTZXA5YFDFdNv7v3S60YRVozlyoa9t2IRh+JyQGRxYUWTbCqfmguzXyUST2bZrj7q0rufNDmm9dwxoMnNpjyrNfPmKhRG102/oMkCXHgMiRgGAYgRHnfsdXUMSHXoqaBjGNuNS8cUOKe+UCnfyDnqUlv56zgUzPltqg9xwXQe+uuB04g5/y43WFd1F9mrhi6ezCGgHG1som5dCULESRibHF76zEhDRHDOGr8NEFTplqYJKRdn2nKmLYTcq44yE13j1osMSMI84hJDvLAhiHpdU+gGWJATBHrGLEaWk+zXq/bEDMmOWfFDT/t/ZRakOcZB5sJJ6ei8hADeW0d/u3rb8cf3fKRPQCwP56c4xf+xSvxypdeqA+dodWGXi/zjZfZu9Qx+mg7FkpzJu0sdJpBuuDG1MxMWtxGT92EovdNAx8ZG6Roq2nxGFOj+i1Hiy50bOd0XSbRvtkkBVQn5yGgyGdhIULjN06xPfLNwoIGPMFNxNlEEnggs8I3rqR4cmLsJQAQOj0XXboq22YBBSR4XrzRUHJTCBYUMYmOfzC/AL+R++ZcX8M1wN7Zry42As2/pe8CC4bsinA2vFjQX6XA2GyzXUuXQ10EuCAAwGI4xDah6DWmcWda5amuQ7J7gjugv1b0iGjFqkUjUXNMii4XdTj3YH6WtAB/fIEW6dewYCe0c2VUVBZzdCmnyeM0FfWo6M6hXKMP3vEIXv6Vb9ovcvvjlDsuPvt0fO/rX4Yv/7pz1Y0abjrNZ9/A3rAzZW6eLdCvb6diqTVe418XE+rFWMvHnfJ7i1A47TlvadyU7NBIqj331pSxWM18zskmKuZToI1esHx2bYgdIBB1UmsSqoU7mQMz2/pexZxX41qL+QnEYBT75X5OgDqRLl9rF3NLxhWBCE31GSJ9tPQz0UsoBKgMSkEHTlzdWu6ZZVX/Lt4y+v5DZ8BrxqzQ7/W6WtvPo37GGING17am2U/obWzCOEYC+B6IoAcM/YKYXuTTaqrbhzjUYDyf38/nbO8rRU73vW4f7nyXnf3cey70scduT2Mj5AEcuW/ec8tDeOXrf+2T+pyvh4Rv+bzntD+PK1x6wdn9FDgYA9Ti5Nx+WRozlYAP1wNSzZW6v2DWxRAw5YwxpdagFas3/T0c3cS8Sw8KWPgNWM1H2CeiST7uP3ESpZYOsIkwrf9cK1ZizLcaYptCx4hxSG6AEJ3fkwGOTPRrenX5nNXGfCYLknjC0swI5zk3EKMuUhCiAQBqlCj3/F0PnMBmO7XEk7Lb7B/GAOjMTj1bs1asxhEhJrc2hF1PgBCQQqPdD6uE1TiK7BJKsY8hGks2AFkcY1uNOmO7nbGdCjaSxMBEB+t5SmP08BlqTQug4GE7MUOMOCImn6vVaEwM56XGe0jvJ9krttOEeZ5xcipdNKFfz0MI+PnfuxF33vepN9DZAwBP0eOHv/cl+Nove1pn1qOuuskmya2Z6zPfq2MDrMSwjPQ8FgnUb3PiMk1Njw1Y1q7Rsi12j5o1pZlnUqpbNjDRVObX8wFJMajpHhvVEHogoxCpd278bJprZ9zTFmtGi5gT87IEtAbOo6Le14B6U7ISLMO3/W5G9q2YXa1u06ZN9XnBikDL70nU701FjYG62CLRbCo9VUCT0Rkt+U9FDSGBEaP0y4brmmYCGB7w6DwGFtFBahSZgr6qZy9UaXQ74EKKJxaHbc1t0y5Lb9hNYGDRx0gbShiafjJ0poaepuWnSDmXhczBgUuyESqVOPLfoha8vFe7vXDBWlj+fZaIqAB0mn9jwdj92Ix5eslJqcAN73sQ/9XXvHm/yO2PU+644Kxj+O6//jK8/psvQByCRWzJwhvFrKtN8CyLfnbPOad6Q0pqxMnGlEB0DLGjvdM/ZuBEx+8BpCIHLEyagupr6TPC15/nrGtq9mu50vLNWHCU9a+6ry3BCb4Hz+XbTpY/z2istr7adCw6cLzt59GMCYObPLMxdxGL42jSvzyXLhbX9pvaydLYAFP/btTcunDVDhhi6CCLsGANEFzwPgDe3Z/1Sqm9z8x8yD6EgO69k/7t9/lO8+/YbH4/J4NtuZ9rLB8baiera68LZSuSKRHlfM+l3b+MIZxdooTu54Nzil+YSB62n3PAsDR0pNeD7eehY8VV2V8+92s+eQBACAHf/gXPa83/asQl551tgL2yT6Ky8TyY7/2blgwFekgYS0j+XpfQmAcE7DljUxaisRibe71nHDpMshp7QpkACGr09+CJk0gQU8/kpJSa8RtkjYoIMck1lvvKnQvWMpyaIzSABK7BX07hCYDMEj9YS5aGtCpgqY734kEQovNKEJbwPQ8/hs1msxMVibBo9N2/++b/8BsgYrVaCSAifiwORCQ7YggBa5oBjs11P/D8Oc8D/xxSDjDnSWIBCzZzxVyLSMGKJQeUKqwGY/wMadBzn1JETBFHY0IKwLgesBpXwgC1epnXn6yf1BoQzHPGZrPBdpqxmQuyADGlOl6QvP9/9ZZ34ZGD7R4A2B9PzvH9f+8F+JbXX2e0v+rca933ldLo9nluyxeLCSLfPqouaNSbaW+S0tZq55Srxn+ueWzrWKNWx9RcbKc5d5IBmrKRrpW1GUrquLs05/NTEU5tWPQkxwjIrvlkwdN5FriIJQ8W6NRgCPKeSxdvRG06EWsWTwQANMvZTYE8vdBPp7wEwEf7eIpmcUwNghD+a3CIJBdVT9evjvbPTOtxCMqO4LUdFkZ5aTBjO5oecUIU1C3XmBR8PSLqZFLweug0yBkIEuSZpj7qh4DGPBe7FxO1n+3PnMb4iUg7v6UrLinHoBP4kBw1MwaMyQr57Uz/B25qzjTMbUBeVuHLjKoNRi+R4AvQTCrPdg9y4mP049r93j+94X689pt+fb/I7Y9T7jj3jKP4rr/2Unzl3zof67VMuxL9UEKnZ+e6Fp0ZGmm7gLGumAYzjr25aXKxmltxSx9i6JhFrG0jC/slQtzEwl0SSnTxc1BPG2Mn6FRfQEw20kaFrQbCV9vTlDFUexp0dAwjSh0YdTc4Y16uzSZ/Cx3N/2Pez5Xea00o3yMjc7m/5LnfzzmAG2SwwGkbwuPv5wbyGCvDu/NX1N39XBpoyvT6/RzdPjVpzK8U/jFaogMac2IlYIiPGOS+7fdzTtSjmB4Xp8n2cgMCIjaxdvu5y1H/i/bzEGx/I+2/uP2cXkcEj4YhOGBFPBxgxr9JfHvefeMnb3+JIeDbXyPN/zji4vPOFrZO6OL2IC7qPEek4NsO7Iz5gk8HgntOxdODwIEzmWyUeAIjoQPr2SDq68C021WlQMGBDlWac4vMq1j4F6B5NfhrJ/om+buxGqvWMC66Ud5nlNjuFrdcxMOg7LRtpRbMU3P5n8VPKeeWRJBrbclfkOc0Jp1ip2QA3b0Pn8R22rgewhgDfg00hsYCAOi8B7x3VTP3Ux8Grl3owdUIkQGsIsZxwDCOTT4sv6ixSsMiFrIo6LXZbhsIMLVIwI1M+9mEV4nkKyIdSUNq10qkBmNK7b8QsFpHjOOotP/g2cqxN3SGANABwMF2g81mxpQrplrVS8ZPLh8+ucFP/MaffUrux3sA4Cl6vP51V+OHvufTdWNi087Ni5Eapbhs4Mw8c3FDr7AGU5xCg1KpBe2S6cHSSI4bMF8nOhvzLJqgIVoMXoiwWJva0/FJQSxCxfSRa2zoIK9LLbxq62vFMCb9Ot1yvaGSosGiuzPfgdBPCGLonHejKxZ9xBDpm6XuGiiRJeBzfP1EhUgzZVNkL5BevzRpiouCGAs01ZBuKdAcwBJdNMogTvazc1tOjMCanGxBCr4UQxfnR+OU6uP8VKuKLurPM1CWzIoU7byQzVEKkJjA4CZOnOLzHjZ6aoC5LNskzN/j7f7JGg0GtCYgoGrixCwMAU6zcqHjrGk8R6YBTEYFzQUORDGXcE1AqAbi+OipJWsgitGWN8cKAXjDb96Jb/6eP9gvcvvjlDy+80tfim/9jitwxplDt+ZmifUzZpYZZfI557o7zwVrYaRtttlARDXqxKHPOde0KsUa6b+Npl876VvO1kjzOWcmvDERzIT0sOfc7x05e2Cj6rrPhjnn2pl+MT7O8u4ZXWjypNUQezmAA4yH+LHv59Wt/35ySpCXa2x2viox9kCEedagm7Yv93N6N2wniwFkgkpjLNhaDwdaGIsgOAAj6n4eXUbecj9f7peDi2AtXWJD6N4D4GV1XrNflSLMvS2GgJhk/S943P18GUPov873R2d2TW8Ktp9XmULGSH+eoEZyGvHsAP5pyh2484a33oFv+d4nf39h898kIAMuFs0/qsU0ajyeNNTkIpoQw9nNo3f2N6YcwYEqNWVxPhJFJ+fG5qtap1Kfz7qEIE51OfIF9MCQuMBCLw1Oo4vWNAT4UWEGe7BhWJGIuiDvpTrQy5saEiDwkcZBkzMc7Vzp/hPmnEXv3ybfk6GSCLU53TeqfZOOEgwZUsADjx1gu93q/b0gTxw6/e/IAcExmhxgQBnDajV2bv5Oeerq0wYADAkYxgHr1XrHZJxu+7GzU67S21RM04RpytjOBdtSxKCxCPtSAAGZyDNVIco+EGPCKkYckTSCZr7IWOygAK+xV9r9UJ2BuhoA8jWrSQ54H9553yP4xbfftAcA9seTdzz72uN46898QRd/wsaVZjitqEKHDHPj03gfN3lQw6BsjXSbaNPpFuqy26jdqeVxZqNfLp2RvU4xCgo4z9U1mDbZae6aoWv4SaHkpIcu/yxEvJayo9o7qlx2Rny2wQY3fS+HOuIOznyQkygWfZyQVwdMaBNaqoIj3qwmLhZKXTAlCtDHAjY2Q1TNo08pULdbTrjcBISfZTVGeOA4Jvteje4TNsicLZe4ugman+SvZUJCLWl0zsN8bzpxH0L3GUOweL1xbJOI4iihlA2QcjU7ZsdyM+qysYHOZK/kKp4Tco84vWpBxVbkGjRonMQbwheO7Z61nOlx1cAl3vPDELXA8sXslL0e2ApO6jX1PMxlx2lXi0e5P376/7kF/+P/9s79Irc/Tk0A4HUvxTf+7ctw3gVjM4t17BeN05SJPRlpNpC3pjPIGqLPuex7rbGM2pRrZN5CUqaJNOL2HwNaxrzQ0mcni2PSB6fhxfmDeI8RSgC4FtZanGu3gXzAQkrExhsOHCAwP5gEoOn8g9L8SQXXfTY83n4OWTfbGp5S2NnPR5EP0PSVunnvccL1Ky2YXpRzlY6pIXR7rpHTQk+/iCbk3urN8wiecD9vAGyra/x19BG7BOmXB2sBDyYxeng1JgW5zdOo38+ZK+8ZhabBN502/51ACKMWKSPYyvnyvkdPdD/nZyXjAd3nkeshjLQ599HK//5NH8Tf/Z/e8Ulp/msFjh89guNnn4ml7IMxmfSaQAgdYEVn/5kSTjj/pznrM12dV4aP9ywefYPX8dMIUECHWl0zL+bWpZjWGw1UKDqgqDsgDGsVle2IfqAlatHUOrhEgagTffWP4hAqVAREl3wQuuhm7z4/zTOmaUZAVbBtKrkZ3lWTM3TNncRwxtSMBh88eYDNZttJbLwEwtemS+Nl3oOsVTis8a+JAIzDqqs5OdUvpajuIYWIUQyjjx5ZYRgSmL8YnMEIfS14HUo1X5JaCg42B5ingm2umGpbv6dcmhygFADt2lc5BymEJjcIAcdSxGqdENKAISb1pWpSMZOKqnyzWFpFlgSAzSbjoFQBZKpdf7nN7rzvBP7922/eAwD748k7rr7sdLzjl754ZyqcMzpjPzVTSs0FPsSelhZg9MFxCLpB0fXfu3Fq9myu2vRlZsGjR3lDZFNbHdkKpsWWosiSCXwm7OPfmGzcWQR6tFDNcRRIrso6oDTC50mrbttFBpreFN0km1Ry0gSpkfcxguMQJbbHJlVFEhEidr1U2OwOUiAxTpHFEj/PVibylhWNLivaaxg1mk5+p6cZep2gL4CW0YWkDNJdlwCAShoqVCPpTQ+LK3qC02SSpmlaxOD0ucK+GCwGiZRBFlKqn124/fp/B8xvwk9avNTBF+2q73MGldOUO1kE/RkIRi3jDv2kqLqk7+1sYIFOfOR8K6NBcnktv9ucsH/wx6/HD/3fN+wXuf1xSh5/9wtfhK/66stxzTOO6LpGinyVNbCWfhrePec+5paRTtVkWZ5q3hn6OYCTE31bO40xF4L5dpRizbSn76LCPef9ekTWVinAONie2daLsDAV802KY6WJzMFr9Yuj6pM5ZBF0veHozn4OKOPoL9rPPQCg8XnW33SGidzPl/r84hzrP9b9nL+3LkxsGcsYHHDPSb2ndnuX+2Xk7Lzj5G+vXUWONg5B90M26NzTuPeXCjUQjF1j1DTbWeIhuffmYnHHkwJaof1+8UhYZquXcvh+TqDZ6/45/LHPG5zXTlA5yCzMGg5+/vV/uAXf84NPHsBMzX8IwHlnHMOx004zr51iwx4ybDjIQPDRmDbtXgIG7ZoVhwJWkVvac9cafCzo7LWb9scQVCbAf4+w+MTGHjDqP4EAyH0e3TPK35xkqlyElUFggyaGauCH1lRWB/ZEAQUsWYlUe+cEonHHLXowz3NjreSKbanigF8R5IMP0e5vXf/cs/bodsI0T7tT/fAXMwCW9+my9vLNfzNPXZnXShfrYr8oxIARAashYDUOIhuwGECIxMKYuMb8oHfMPDcPhM1mi2luAMBcWvNfCTjU3M5pjAixmf41CUDEkSFgGEeM44AYkzMoN2YGY/+8YXRbj9vrHmwzNiI9yLk4/b/dxz/2lnfjYJr3AMD+eHKO044NeN9vfoUudH4x9lnD1enDOIn2kTpE2j2Kvtnmzj3d566bYy66eL6VouuGdEMMAr1PAZzhXz9tdtr5GLQh5u/zhkF+GhFdTBBdpaep7OSvBzF68xnM/F059+87axSenxShm3iQXkjdJ5v12enp82yFGDdzTmL4upqSMNh0wScN0LOAGkArSqteOw9oEFFnbFNw719d8NX4zq4Bi5PiPt9SH9quUT+BYLFIV2g/zYcrvmfX2CvqLxOinIvpeZ2hpBoPHuLivYw7tKioitUqIYlJZHVsDd8UBEmHSKltBDReXI9RjZms6GrggLISBPRJKUphWDWdABIFmdRh3CURpCBpCK0gY1GZnXFTLsA3fOfv4jd+/8P7RW5/nJLH33nNi/BFr70YL/yM0zWxY/4Yn3M4QGAcGgV8s8k6WQ5ubfHZ9UMKnYnqemxrEuMENfI1F5UfAc3MrU2ExGh3yiILMuA0RbKJglJITdIQXAxgA+Dhot+o6ScQWhb7OdBHtHI9Tcmanb9oP48Rsg5aIgALeH9+Saf3+/lcmokpY/y8b4G/PqkDj2u/Jy/2c7IH/H6uxsS5OpOyPt0odA0I9/Ogjgrcz9teA2MwHgKSe2dvoGr6gJkaM8bY/CWaREO8BRZg9SCRx20Pybaf16D6dC8j4H76ePu5fw64VxKQN0Df7XkFeo8W8aOJ4ncxl9IxLkup+MGfuB7/+08+OQCzd/u/6OwzcOTIEZuwOzG0aui12bcOyWrM6ibP0mQX+xk4s77qdP8t2z0iixS11W8OhHKWn4Sj2HDrYCEXRPGoIisgqmxAGlDXIBefLoQoxn3JNcT9wMZCI0OXOmHsAWN+tM+SFViY5xnzNCur5GAuUJO7WhCqpQKEACT0tToBjPVqxHZu6N96aNLGba4ItWCuBZucUXMDGhorpSyGLz1wGLoKuwd0hmHoWVcdRUCyFKQXODZEpCFiNa4xyPvyaEOpbZBnY3WoNwDvke00Ic8Zm7lik7P6ABRpzJuWP4ocooEAqxAxrgJW6yPCCmjvyfuUpJiQS6P3R89eQcU8Z0zThEc3GVMpmkTA812dPPb3b/oQ/vjWu/7CZ2kcIi466zQcXY84bT0uGnVhRqhXhIAoAKacce/DJ/HoZov7TpzcAwB/VY7f/rnX4hlXn2UPu9NapeimtWN0RUXfnOlGLlOO1hgVRyGznZeL9HZq+kvSmIpIC7SZE01+dYuSd/Nkg0Q9k05RKzrHZBYQKZnOejiEekhtos8q9pOf6qYf3jSKjbj+7iGoeRy1n8silA+Nb+Lp0kvdourrmdcarBCwrwedvjDer+TauRibEVBxTvYGSigQIl8PAWr8R1dqAgDUl6q5kiu8GMnHDZPxU3w1T8fPLse4uuIlOvMbTwkz92XIOY9KkfVGkF7jz/fN1wsBnVwkOndpygU0SzwbOEPNKX+3b/5LrU0rHHu5Cjdt04nKZLBaoZuLFf+j1wrHoKkYpBX7e4JAFicyNB6ccq8Tfs3ffAv+7L0P7Be4/XFKHt/y+S/Aa151MT77846DqiiTWbWpW0XzjGEzOM8WTcc1vE10KzZboZav0k7z3Myiyk6GtY+PSy5qkFFu3D+nWZ7VzhPAvWdAk3L0OU+tec657XPUuNPVn2BkgO0dpC/7LHSC+0vWGyf7fsKu+3ntPyNQsZ0J0u6m4HA/VxDE7eeHAQCedcA1kxN5/371PYh8we/n9DDgfq6+DnkR/ZdMdsFGnx4A3PeDGzJQGkaPlsGB8sVF5NVD4iGT5KTP2SR+y7VbGyDHbmTevMoBnW9Di0RG17haDN3Htp9TVuEHFNUB75qeIUBURXMnNxrz7n7+D/7ZH+Pnf/X9n/BzfMFZx/CVn3EtQgAuPH46jh45oo0xqdxs/Isz5PMPIoc2yyhcjfkTXbVFSvoxdbs/o/h3+CSrzuivNgZsday/KtN+X9sRUAkuYlHvRwUSTFoQAintze2/MVFSZ2wYAAwpSU0XrGHv2B8CNLiEghhaPDJd/ktp8p+ptjVgLgVxcc7ouB8ADAL2IABH1iscOTLK/VlQiw3X5gqEWkRrXxU8AWQtKFmM9Rh/WYwdUJbJBL6ZHcxvBT2rQ9k/qQ1qVjFgtUpYrUbxaAhiQmrnUMETucHMJNXWvIODk9hsWyLALAkA6gVQocbLY0oYY8KQoOaD2qPIGhGDRVnrdSnV3VcBtWY8+ugBTs4NiClynZYG0bznfvHtN+G+Ewe47NwzcPy0Nc44usZZx9Y44+gKZxxd4/SjKwGzoH4PXnISU0KIEQFBAIuAIUSkZMjK/Y+cxH2PPIo77n4Q//Hdt+0BgFP5+K2ffS2efe1xnZQSPfZ6RUYDddN25ikrtT2iumgkP33ugM+FDptoZqkVg3PbHcdklHbHSAihLYCkb5n2ywqeQYo65sbT7TY7XwJumL4o7HV7RRaJVkQyU9h5tHUUp1J6h3cWPpRStAm/1yp6fwSjti9dffVcRpMAeE8Ez7oi84DNcEfhWgA1LD6NSVG7rFVOJ3qdoE1jsrsPuvMhC62P2lNDPkc3bBKAIMVGUZCgLNy7eX58pA/Nb9RZOvWZMmQqLNFlbs76++W8sHj1uxB/ejvlLkc8xtg5STM2k/dMcfTdNlFM3VQCgBldVYspY9E4OFaEUmrF86Ldx6bpXI9mGNSKRru/XvSlv4KP3H1yv8Dtj1Py+PpXPgev/ZxL8Hlfem63JrN59Jpg0pZbs7hrfAoYFd83w2xS1RPAOeLTP6C4Z9oaBxbtZAiYg/qcC+bc6OItVcS01mROce+dS2uk2XTr/psEZC5VFxVOz5eRq6Qf8/UIAKyGsOPVosw1B5DylYub/n88+7nfC/j++JqUffWTdQdCpNBJB/T8+H1Uzrt326ccLgUziCOoQcNV824xpgRp+rrXON8VOv03xlvU9ZjTN3rV+Ng97jk6pdbGFhLDJulK0bn4o/e9GRaRvWama+81L6IF42I/N4YZ1EjZDz9oOtxNfmtFFXYNmTa1AP/99/8hfuGNH/iEnuFrLzqO177gSgDA+WeehvV6LXVA7CfcBFwCmya77ygF4H5pgJawDoPFIvo6jWZ91LfTlM17RbBOyDL9hbIJzNzYgBcshgvVDTCKmhbSGyiJ+aOP7mXjGBT0aKzzFGJz9ad0RKYjVeQFyTXJ/vdN04xpmiD9NqYCTJJs0MARk/DGRR1ZFQSIOP2MNVIaGj29FITaXnc7FwO00CQG2zlrw7pI/utAw0arp8EeGkCxSA9Ioqf35n+eQtGAtCa9WseII6uIYRgwrlbq7UIvgCKmhjRQ7OTLTko1TRM2mwklA9ucmxSgOpaE0P+HFMX5f8B6tTL5FigJFSfPEDtAuYi/AA0bt9stDjYTtlliCHNBLlnNpLuEtMB1QwCiEJUBwk9QKpCCeVtoXyB9TBqSxjcmuY8jLD69ARht7bjrwUfwY2/+Ezy6mfYAwKl6/PK/ehU+60UXyKbgdcli9pPNNZjmMIMzJaPDLKl/PRptzSpvxpRIExTdknO4H+jGC3QGeHR5jaEtiHkuzeyDX4uWFTptc4twC5zC0zCo2gQ5mb8BJ6neST0NsUWgOBCjmUKJRssVjxX9VEgLGhaG0TZn76rPv5vhERy1rUqedRDTvKIGScCubtM3u8ZMcGCCGLjk0uscd30BTJDFqb83xyPVNISg/gK2+bjFQK+RARw5m6fAJLKG9WiNPCn7s5MLUAawFV19kMmMb+aD5HUrU8I12jZlsXuyVJ94sHC+NkcovUdbYWbXJkuxxuejVOfMXFqUzJgitlNuZpRD72XgEwb8HILxht6hnBTM7GKbaKhZq5lELn/XXIAXve6X9wDA/jhlj6/4zOvw2s+4HF/0N84VfXvVQpdAHBsIHxEI9PpzFu6kkhol2jWbOgljMwmdzG+mJnVbj1ErIbrrjzSwCmbbsf/PlQAAIABJREFU3oBkWV9q26+SMHnm7OLZfIObejEa/0CQmVRlgrVwAC+TUjwAwDQDTsCSi8U1MNb2c2PTVpOYuf3cM6v8ftbv5+jYYz4qLGcvnTOwmOugTeVNbmHxv+Z90hpvacydzj0JNV+BnQBsJycdEFrwsmF281qLJnQArb4O7wehf1tsm0W5WRxh0P2c+8Cc27kle87v0TQ29DWNGsCVnulGdgjvAwLWVRzMi/t7KWTWQQY9xqzY2c/l83kPgK/+734bb3vHRz7u5/f0IyO+6ZWfBgTgvDOOYn3kiBn8BaP+R/z/7L151K5ZVR+4zznP+373Vt2qogaQEglQSIHNJPMgCi1TgRSIIM2gkHaI0RjHtLQh0ZjEtURtO8vVWbZDG9Ldjph2DDiBQYVIHBhlEESIKCBQUKJV93uf55zdf5z92/t3nvcrINZdGr56n6wVqap7v+8dnufsvX/7N5h/w5AEECvNMHdrZtrbjGrfB5qSQu4QRn3JXeB5TeDvW3sdLx5bjOcghYSUtv46bKU1wEeRQb/vZo+0cQaI1sy8s7vL94YDxn/Rn42yGAAUeOCWWu3zUlnmWeYlov0W7caIMAcVVakdU5FCsd9Z4r5NInLu3FnJJRtdvrqeHwxXSF2Tao8VbNWM70JuBZaTELtgzSLCDwY4wS75J4EIDgBYHN+ZUuRo230DNptpMD8sObuEJ1GMpGqj5YydpUmkLovsdrMc7/rwf2wsALFkjZKSHE1ZzhxNstlszbg8aPWllEihERFNakwRTrTq/erxbpbzN89yU2vSlmo+DU1WqIcxVJKdjcX62+w17pYGcPSoGcDEVHpCRcqyKSZpkNGDRZJKyd3g8Dtf+lufUBJwAAA+ha/ve9FD5LlPvTvpn8O1t9DwsY6DKyXy3lHsOScXf4cHL9yQrFvDs980tiCZmAPIaYcOu9lDKqTxYifkZY6tsNJrB5WaqedOcy8U/YO8etOioxnqNE4JVoRG/B4OIzafwz+Pw1k4+UPzP7rch+6UpQSxrRi1mYm0/QAwKjERODYql1EXC2NAGM1xPB4MkVBo3DDItv9t8B0II791LjSbAGKDBh1ko/cQwEvyiEG4PONnTyu5A7wI8PqW2mS7DVGrEnrK0ol1AeFtFLszi1AON7mM70ynO00dheeCBvrmdlPcDChRFrZv38jgCU0jgI3ClFVKRsD32pvd3vBMFlGGbGk4y/7Rn9woj37OLx8Ot8N1aq+nPOgz5bqH3kWe+rwr5cyZ8kk+5xGnKTJG7GEgLVb8duZhA1NAgNRoyvqmPrtzOLxgeg2qq011DCcxSIoDqTBf6+BnCxlbi3MXtQMsNmYl+XZZQu4ktM1HdB8AY8jn2DEfNTBez1jP+eeu63kMnAF09vefKb42elqkwCCZoA1Ru2zoRgwFqueQUbVhsB7j+PB9x7CkFJeYnaHGnjtjPQ+fI9TXHl08Gsut6zm09AFQqMXIBqgzGOhSHOG6noPBGBKDAMBzCVYkXocnMWxy6PpTgCCQ6UV0nG3/m+xJztCLcG8xbYqb2D3uS3/lVknMzp3ZyAse/Vlyh0svlqMzR06Rhrm00OCWKUECevdm5ohNKS7NQAFlLWuM90OsGvT4iWIRE5lfOhiTYsHQWhvi3LDRZYko+2mRYnagrbPG2/tg+z3oOZJtZgEI9N/T+4pkvywRC8RlT01ltyzdvb52ee3cWmfNkkcENv5seliIPbDJSS4+d9ad9/uf6T+/kvfIUlWqimTp1P6lVqn00a+BpJOGfwAAajofli6BpTH0WTK+/pyL5JzlbElydLTpRoAUsYhUBpjE9lg+Y30oy3ODtTEvsyzzIvPcP7+bl9o36znJJiW56ExnGpRcHGAq6NGJaYRIQxhMIna6aQcXlt1sCQD22XVkjoCkDjqI0fannARNZclZGo3hSWQPaFH7XiGHyyWJpCJTMgPRlDs4kAEuiHko9JvhB17+e/LO991wAABO6/Uvvv6z5aufdy83ooMeJ6fQOC61bzMWzjTe9C15pQ10s7QAFHk0VKo9Gold75elO6Rn6YfUQgW5GhoHih42xG6IJuHMDtf2seFLA1IPHDfZViGbzl2E9N+gMi7NadtsBNUBijFCqpCTPLQ9iG0rKclc2+CUyg0nAA80ldoCofStBaHvoKexaZAXC6eki2sZB+o+GefhZ4H2t85uZh08ZzUr/TuVoEemLFKX0K+jKUaTCYDgeFfJtE7dCJALRJl6Q9wdYGlTYVswNEQdHCBdp22yjo4m0jTuyyjW0gj/fGjIVy7I9jsATnTjvmr5yWgcdfjn8fuI1wDNLus0sb2YSt/qY3sVVNygke7m/gx4/vXStxfFTQCDRfHGt90gj3/+rx4Ot8N1aq/P/aw7yxc+4jPlGc+/Si66uAzPedf2l+HPo6aUss/CwvMkxDzbzd1AK+JudXiOT3rOk4HFJ50DeDZh4Inhy88Xa8B8OF4bwpbeF7rBqQ/P/azj9JUO9iZKxxnlDPPSDfrm2uN3c5Ih/SCRZrl7KKjMixgDLuo52BEfv553cLIP5gY8z20AWDnCFOd9bOn0xHo+Rsgmj40dDAStfnQwRUeGoiT/rrtpG9fz0Afjd+fcTVyT3ROe+67hXYSf5/pvquejTKE5cABTwEL1h6PVsKmfpqiHME2E5w+20ujftgRawUcI9x0z/uAvwD4WiJmF5GO7LaYjD9NBFZH7Xvdz8oEP/c0ZZufObOR/uf7BbvjXZ34N2WXONudkclTPQV+3gblpk0HFPvj7gCEjruNvGABTbNTHXg8JVy1YAwCpVmNOkiSaIjoT7CPQ/b2noghf7p9CgkTeBjbYTy6DCGo2y2M66GCMBu9VFlnq0t+z9Uo3Lc0Bj/UADtZsls4CwDB8dlvk0kvPDcaS/fU2AzHVWYi12RLEABJEHzYJoJWBqvXV4od3EIYAGnwvvpQkEMF77SyScpGcOgBw5sxGSpnMU4GjQvs5luz/hcS3AxeNGLkwCmytyW63k92udYd++77OTlnOnj2y35scyMNCiGsFJ4OrsS2UIhvneZbj87Oc124I2AHgJrUunQ2VuuQjl9zjXXMHPPq9mwjgToPJaVr11iFLK25kOOUkVZJsc5ZpApiZQwaXRP7vV75RXv8n7z8AAKf1es71d5N/888fFoW6RXQfHrTeMMAYp3kMm28ZRJyih/kqHtD+UDEA0Fo40EKbVltQ8tYxNj2rFOZH2TcgKJK7uZLZmm1KN+Hm79uGlGSxf95szNyG3Ht5c+F5qhpDPxsZsQQABcwNBumzAc0xzAYDrectN1xvc+oNFOhvKSHrdTRNYk8AnqSbUWFZy6fDhoUMRlT2jIFc12kD/9C88KZ70SF+C0yLzdRRyZ0N/AAijnfVTaIGKquEAdN2k+WYthhCm3NsV8LAqrsTl4wNunoOc7PX7k2vhMYPYMaolQuH74h8sq3TyrkX91MmeQqeB+h7M20asf1J2CpKGGoOWdIi7iQNoAY6Um7MYVrWYzbDlGupvXmassgvvuJP5cu/9TWHw+1wndrrQXe/ozzrkfeSp3/JVXK7K6a95xzALD+LMOMrWYdYPQZL0fv0QZwi9SR09Jy8wsPghuRRYsBerw1paMrAaHJ5lFPym0fEgWYMthmec4DhON/nGsCFyOgRUN23RQbGwG5ucrQpbjKIQR7nDG/A8XuaD12yB+izjGpdz9F8qtHNkwMASvruSJSpBnJ4vv3Hqef8WcPTAMkqyXTdTQMA4K39slDdIwkAQAX0ApAfwHQW0Y4AGtb13B3iRQdpGBrlbFttriFNU3y2El5HqlHP8f2GKXI4mjsLzOQCYMLpamvqgH9JQ6INM+sixQfmk1k0JTk+Xryeq4hc/dCfjDjcv8F16dmt/LMv/pxhmK40ZKFOZ0lg84va0BRShEaeF2G6BwAlG7iTcopNL4quDbRR3nWg8rtxYEphuEea/tDiB8MgwInk3gFJEjGP1Gnh7iHgrvA9Z941336f9IQhWcMPdpj0Hrh1un9d+tnUVGaLboR9XvSrKpxpgK0xnutzZzZyySXn/K6ptuTAdn4xerqqOKhURSQ1ldmc81VE6glDopyw/ecBUs0REBBJM7AhorcbSR77u8BMUEqRjSQ5Ospy9syRiGTvvd18UVfbcQN5xGUGSkaqxppZqtx8fF7O7zoT4KhkOXfRkZTumucmopmeVzZ6dL8GnyVIHiEdADh/fukMgKV2pkatBvSKJw9kYwBIgjdCHhITGCBasy0gnykld8M/YxDgzO0AQzddbBq+GyIiL3nF6w8AwGm+Pv8RV8v/832fN1D8UXxxs1a7GRlJSifECrFmXwmhE0ObOxUx+xYaB+VCG+5CLiDZM4bR5GQfcjEcu+5/WySpGojRUwTWxnVi9MxkVDdQmPC7oCXrJjTqKG4yUzvo5WR1wwMlBa0Q0olaw/0YdEzoFY/nNhgjeXZxHjfHHDfITdoQpUII4BqcaDT47hmxENOCT40sYXzEm5HQNPaNGQZ+XUlBkIt8UpM7UCdTNE8YpOEIzVIRj3BCU4qfYwkQoDSyc3TQyuL3lTw2+kB8oVHDtoRZLk6xTch3bm7Ox3GWGMKX2mSLyEDTjeFZmm2Lj3tg7ckwV/EtWZPu2Mvu4GhGxe5HPF/Y5kC685Kfeae88Lt//3C4Ha5Te93z06+QFzzmPvIFz7pSrrrDZtga8/C4fs6zZUcLP+dTGqn0/pxHNF1sWvrwh5g7JAxETFQH+pIDAPacl86YE2MbQE7WFAafXSIQhnmIZzImEPnW9BKZXLYFqrLQ1o3rObbrqDVr8EIkAGau51wr1vUcgK9vzQigrmSollO0h5lYdkLMs0YJMF3334fzTLI4drLPg2dB5Nezh1Em9kUxuRbTyGeK3V1PJxj0kOqDJQYb9VbjLoOJcX5XPYZWKYaPjW1BaV/MH8frRou0BW/oreFvA8vAmHNJBsPAPTab/7fkQIv4vRS9QEQ6plus5xj41/X8To/8adFb0fVfdtGRvOiZj/RnEB4enRGptvkPGrcA3KM0qP7Z6eByjr4N1HyB74+EQSi+nwbWgfIgs+4H9h3qdZAXqG9jebSGJwEkCm5m7aOmRTOWoP33Pxuxwf4awCjw9x7yhGZO9bvd7PfHzqj6eP5DMhTmkBiC3fVfRS4/dyQXX3xxSCnItb8zKZovhTqoZwkpTSVZVF7TJstqEAXbQFeb/3WeCCQNzXwcmupgQiqi0iqR3nMy2USWlLMc5SxHU5KzF53xgRg+ETllqQaydBDI2LKiA4NLfNWV/D5QVbnp5pvlplnlkqMsR9ujyDKUYKZkez3qaQgGLpthY/HePrw+5t0su+NFbqo9AWBuHQDgz6mUPrTjXOjvvezF3Sb3zTDWBFhOdlfmAk+c7AyaMhU7pybzNyNPMhV5ySteJ6971wEAOLXXfa69XH75JY+P/NulDUOaGPIN9LeRjjGlMadyoKLbAQgmJgo1CiI3DVzUE3daEjS7XhD7wzMvvcFCYefXyvorIN5rTT4o/9iY4OFkyhbT8NAMlBxRcng/PHA69cf0iihu2HygecNAvH7Ng87NXic2QGzQE9p8HTSCI6UyGkI0ECWPR25d0SIBFEAzCToqP+Cg5i9LuNTLikILkGKagravBBLhvU5F3BRJV03g+JkERY69A1CMq1Ef8VoquS4DIOB4w0h7CJ0lf+6IcCrZwAlVy+22WC5z9G4UJ6O0icFBCoSmknQC35M3qjlMnML8atQV4z7FPQH0PbmDcxuewe/9kT+8YBnNh+tw/fd4XX35OfnHT3qgPOHpV8id7nw0PH/TpgzPORy0/cx1Lax6lOZuxsA2so7Y5BRnUl05yMN9G2e1b3Ht/FGjLydyJM9EUcfGXkWDfZTDNLSYSa1Ts7lEmnyME1OUhm+cG9yiVR88It71luo5fgdo685EMK+ddT1HPeR6rqv2cBhSlVgN5Inj23hRZ6udWM9BA077krd1PefYxqWOAEXU85E5F146LdyzyU8B9RxsrxPruW15c4n4YNRzgP8wneWoO6afZzeko3pexjSLpcYGE1eXp8GfhkwJUc9J8//J1vO3vPOj8vnPu3UeM5dddCTf+oxHDAwADNb92clePz0S2eot7sXwKmpDvjyGsAa3SUnUR4bvBHQBuppGk6RhuaI6Lnu4T/P0JNUhHtKZrkPIRAc2GpgFgrSP5oyF2EWLOcmnYeCFoSN6iGWeZZ4tsk5FqjbqZ5ACkoYhke9zMACuvPSsnDlzdmD7xLGhMs8LmRl3l/rFWFKtGrDXOoW92ffYPs7mf92vRu/V7MyU8AOQYF4osQBEVHIxV/ucZJunDgCc3cpUpmDwUkxM3BMBdCqZPzcJL4CCxCWTQu12O9kebX2T7xIxDXM//NmI6Ez0eXamR2NGmDY5f34nN+2qzLUzAATfmQHKySNLiyVQ5BVbqPeQxVlvACdj0SYpW4RhllyKbKbJDRQ7iL3PVEsi8n/92h/I6/74fQcA4LRe19z5Enn1S58cpnItNp7QP0Lbj4LEecsw1sh2w3Y0tsnxDEp45BezZjARPStZXqm4CUsaBvte9GF6oU4D5AzejdHeoPNuTceIozQOTeyEm5JYlFzc0a3qXq49zId01VhEfnPaO+QK0ZAQhwe2ACijrj9Cbq1EjvK6ECcyR/TPgJoWFEc0QJzSkFb0L8TosVyAqfG7ufog3AyBRwHFUM8NAyiEksafpfb9dwmADC7cQFpHZH/cVGBTjkZrO6WhtPT8VI5hUvcKcOnCSgbBxpEzpQy4vMFAIgAAYYYTYErV5qaFzNqItIYWPhW0WQObI/S+wYqZpuysjw1HP6E5J9bK1n6Px3FaY//1/+q18hO/+CeHw+1wndrrDpddJN/4lAfLo598O/nMay8KM6/VsxoDP8z4krOjUB+6Z00bhjZskTmeTyhKDgyh5s9dDGDxnPf9Wpd/rUxZTYZQm7jhKw/K+8+5+tkG2VYztKFSfa6e2hNnoYj6uexsopLdERypK0IaZcDt6J2P4c0yyV49x0IU0jQhABcD+cg+W9PNVyA0zOhQB6dMNVb26jmSU4JJty/14qQB/M6ThuhEUkge4APctabeBsexnufBO4GHw9bE6zknuKSUVrGH6izIHpFbT/RAYPd/sDeOd9WBhXU9V0nkwyPu1F5Yyol6niJRAO+PP4s3v/2j8pjnvvxWAwD/9BmPHD7fYenjjudjjnqnQavLTmJGRcKB0cgT9SvMkMAWmJ34wUAg9oz4CB09WdCsIw4wUXITAwcuIaUh2/tAVZnMNwgL7eiljdpubMTY/mMIjPSO3fFOlkXluDXJIrJoc0ZQly52RoGkPtyBNi66OudE5E53uCJYVPb/5RWjp9lmuhnIkPwZ74BAq+rSxYq4gJQ6W4Y+X743HSTA8G1nmi9VHEwwPwfbPvrnbfT4krNMpciZkuTsma1Mm8n76cFs0RgejvpARkMYqUsDJJZ49q33rX7O4d1AZoPNaJhjKlX01xWvx9ILOguhys03H8vNuyq7WoekgOworJlB2n2b/GxOsjVvgGzf8TRhLskRG2hxiuJRo7nPOwIGFAwEx4QKFZUf/bXXyevedQAATvX1qp94ktzr7pe57pvpezBPmkqiGDUhU5px8B1z4EfTPB/IVEYnYwyXKYzSEPOHA8h1LiKu+QcDAI7v1WJPttty4vtkjWd36zVmgoTJG28Swnk/3s9e7j1rIFMUgIhTJI0dOfGfN008GoAkgd5BdoEYpVI4qk88gs/BFH6PK/M7pubLKohkpqg5bgSBas6z+T2sAQJqRMBK2C2jjp4Bklojvik7qJT8/qhtpN82MyMEktlowxF62DQYwowaVGRdZwcj2CG8b/TzoOeFP4HSdgv3RyadfgBB2X9v5ACb8dKUpC69+GFj1uMMmxkl9vc519ATsnO1Ev1fTkDRZ3z2OZqy0ApnefbXv0pe+Z/fdzjYDtepva665Kz8k6c9VD738ZfJtfe+eBwe1s+5IM2m9Tg1e6rmpQPQJYdHS886T5ZaAmo5DQcwqrNI1MXZR3zmBi1dVWW2xhh0X9Q+gI2T156xQXbGWjaNsDOSwsOmtaBOMwhR7IyBqzleHwD9YEu1IRp3Tec/ybdgWdRYUhHPJyIft55z7WPgWelc5Ag66Lc5iWF9Ftahnpsbf1V3zGczq1bDALL7QbCkSgbQB969xbdjo8mqqkXqlnDePp7DG4m9dLwfMNAl6jnam2QmZSFBYx5gI037cG+tzGwTgfAbkjc6bb+xB4YM9TOAohHwKlkcfOF6/ro/vEGe8IJbZzJ72UVH8r8+/eHDgM4DYil5YJMODYhETLEP/dwHODtEYqtuA3teb4OpV1GSS9Rb0OoPQzJ1VDAulBXQlaknq81MNbHJN6lCyZn66JURIjEm8UvrUmWeZ6lV5Lh1eWRnABj4YYOk+6JoeFVAroDUgHneSclF7vYZdwz/J+pla4uoUI/KsyEZAzXuD21NWquyLBVG9r2XtVhFjO7ub6FjulgS8l5AZKv9ft/cm0QAFPqci5swT7nImSnLZjvJdrt1bwOcEwCSHGggrT4G/6biyQNgd07OVID8NPvngP4NjIWU8Rnj2c3Rx0oYxWIBmlOSm26+Wf76uMrS2sjUgL9AjpoF935PBpkCSOzGmeaTRsADnhsVey2eZGJAAu5bj7VUM0pUeckrXyevP0gATvf1iv/3iXLvay83TXXQ7IRiUVAucJihWI8HJQ19LWhrQQHvN9vizdC47dhuCm21R0qipI6adtO2KtPGaNhE/WRTuyieaYhp60732almtanMSzUUMVGkUJhJAXkveTTXayvDKUZXGx2cIp1+h4YyDN+Sb224yGOA3UyB+LE53zwHG6FSw7Y2/whDu/2opmGbQAhpIcofRz6ysz4ADVAGm4QpINNtEREFycNm6ikA86IU+2hgC0VPhQ5WhgNxLddo1FyKhOYXTeREGk9skJja2SMJdY8SC339xv57Kf4N9CardFR+N1eZpiRTzr61ON4tcnQ0WTGMRi0JIgTxvQptBvvPWzymSVxqkGgQAIBfW1D5uKkGVfLxz791EU2H63B9KlzfdP1D5Pqn3VH+h/tdPGx5PuFznmKoDXf+AHz7cx4A9rwHbho7yupVreo0dH7OJ/OS6Wdlp4An7cZ9k8fuVZMXCSW0RD8WwGY/A7DlLVP2yNuIFRNnJBWSi2HDPEgEcqLkmgBf9+o5s7ASLwEing3AMZspQi8f2/Wx7iAhKDT/lM5gm2mP+Stpr+FksJvBiqWNLLiSu4lcozMUQ/dEvjpRT4g9kGTwRqgEnHBcX//nSNph7wlRlcVivSezWocxGNKFFkpi6PU6D/KJsZ6ry9k4i57reaZIRbxf70dK7oC/yGB0vI5Lnpf9eGHU89/63b+QZ/6j37hgDAAW2iPizecWpGzAg4oGZYDv/c/F0CKutQ9PKgBs8FkCzTylbsK4HmHgg4Rte9++cpxzHobHtR+Dx80JJRIoxTKaTLADGOHLgfcpKUlJ3U/JEwVEpbUq867H0y2mt28mTRRpvj3PJF0KWYRJDpPIPC9Sl0UkiUzTJNd8xtX+DK3mQWMnRP+MdximhuqeKrVWmwPgaq8ORGILXlWkmuO/A4aI+zMQo5851Y08xaMbdRjWO629SClJplRkYwyA7XbT7x0b3DHAQ48PA8hk3yX+2YEI24cX83JKGuyLyn4zBDKuDaORKMK+ah5RKcnP1ptuvln+etf8rN4YQCM5mWmfycTMyyxLcu2+qki2z0DoecmZ/GDspkpkFNj7fmIJuJSVlqVZ5CW//voDA+C0Xz//Q4+VRz7gDlEIYciSI7Jvu8myLGpOuEQzs4LZVPdo84kOM7jAx7Afg1GlbGI8ZNgoxNaiyTSVMLUrIcDHdr7rIcdtPxohVUS0pMGpnwd5VfUIJVCZ8OCCSr+luCQ5gQXAWdEMCnDurlAhYw0UaI+QOGywwW6yFzcImiReJ2jpjX4vCqYQOMCxOOv4xDikosnbGNBSKaZwIRPHvjGTAADIuGkwvDNKe7aIyLpijqBprauYpzBFMoqn9J/Z6PXArT+nSDNQM4pcd43I6XbKv/QoSLhKw5QrNm/jdmuhZn9e+kZRKFccUgdoOpdlbEjc2MZQ202JQgEWBYA3jn4C3TdnEUl5zG02qiyei/s/+efl/R+8+XCwHa5TDwA85Sl3lPs+6NyJ/x06fn7Oi9PtZYjgY912Kcko0DFYbWjTUmt33YYhnEBrb885n+nYqWynvp3RFptakQAJUT/R7MaAjtqQBr0+Yt9CN9//zrICkzEoQ68O8HYz9WEzhvc4b2FCekv1HAA2zvaPV89jgIuGmo396iqJwdN0phQD3S3Uc3VzraDmn1jPk7EDNXoKxClCZgXvBY6GU5VV1GOA0vjcop7LYIKMJBsliQMSXNQHTpjO9i3whKQlW5Dg/B+iGVssWdAPSNrfoHv/lLvpmVr0GSR9kIyt6zmkJGDEnFTPf/EV75Wv+NZX36pn95KzW/m2Zz3KqfSeWkDGSpVik+GAjk1wc8wAW/9smvcYfmPwVh9iYYrIPheh34/3qSZnaatlFPenGPqKDeiL6dPTsHzi9CU1nXgzGnl/3UM8MIFO+GLxPdZaZZ4XOT5e5NikCHDph16+kl8EL0+yiKQCU+VF1CS3IiKXnjkrV3/aleH8RsABI2FpxbIanPuxpad4vc7GXOL+UpW5NpfqNBWZ7XPJnvihthRq9j3r4Nmi/vqab92611iWIlmOpuweAOHbEh4lLIIF2wD9Mhgc+J1+z5kmH0BUmP5l+28yGPR5fGgO41aP2NaQ5OA1zLudfOy49pQnSbLZJE8163T94lKraSoBUtp34+esnUv994apIhrflBPVk+LnZRaxpI2eKBFmnCL/7tcPDIBTf33fix4iX/qFdx+o61wNlLF+AAAgAElEQVQ857nJ0QZ6dIs1oy8dBbXaFj8lkeO5GgLfbxHkBqMxY811rer0NM7fxfB5bPFpXjbJdAU0xpKzD5Cck5sI3cdWGxRuRh9Bi+Gjc16qTFPpKQBEP8ewX8rKMIi0+Gg+ISFQMiYCXXuiWCnW0y+0wfBNlYQ2H82QpyJQlN8CQMCM6sJz1prZHlTq2/eT6J4nDdH8HurgnJ+GxhN+Afw5oiCCVgYGQMmRmNCMIeAu+1MevjdnJpj7togMfgas7wWIlVmTJ+zmSzFMRuNKOZMnQBua2WReFjllOZ4rURYNyacNRiV2C8sqSunPkes9U3YtKMs1YE6Ic3ttZoX7y/0DrFHGe3r7u/5SPu/ZLzscaofr1F9f+6QHylOedCd50CPP7emIRSI2iuNaOS3Fdf/Dc94b892iw3N+kuM63PVVZRjU57l5nYE5XMlKhp5oJNX9cFxLr214zndzeMCkNKa6wP+l6TiscSzU0kJTiyG/x/pmYpoRQGwNIVJs4KsStH1jQJiHDddzXKjnY4RgMhZFp8uv02uGz1ZHzwTUc5YR9BoU285NIQBgFZsL4GJG32GgDmSJqOehnU+DRBFnM85qgNfY0s9LMPYc1Ced/1IjEUDoO82rer6Zig9XE/xsnPUGc9kA9/E+1Exr15G/Y7Rv8nv2E9ZzA5cYcOF6/qMvfYd8y4t/71Y9u+fObOTbn/W5PpTF9j+5gV/okoWGeEqUkNB1M7jetfUtnq0U9RHwTE72d1rzDTto5YjvY2YCJyANw082w2eSAap7QBCQZMuRdRxlMj14v096xEPBoEhDXn+uLDLO+lgxXTwo8Tz0JTZcpkltWVr/RAk0uuzsWbn6jleN6QYeT4ieOQ8SWpwT+Eh66kCzWPDwTYBsoNlmDjr+qs3Yjf35weeXVGU2cAC6fz+Z1Jgb9DobUTA2KcnZTZGLLzojuQRDA0svyA/AVlhfzLYJJm+TXLIzxILdISQ/0vA/E/SEo5H5cM+QbwS+E7WkmG7OF4ziTEyTPuRHRHvKHKudKNUjvF+yAU7OFhCR0t23HQHzWNGho+7v5Qdf9l/kLe/98AEAOM3Xv/6mB8pXPvvaiEQz2mTXL4V2DBt0NAxCTUOr4VzukUs5YoMQkZc8aQAFUQeKeE6dsgfqChxqMfAuZJbGTQvocMjCZd1gNHlNlipB5yR3Z4+X44c2BQ0PTdumrDwARKjpCBrj4lTK0XSOAQI0TQtrInXfnK8aHaeQRr1MyTfz3KgtBCaEhktkymgQxRrKMDsqoMWuoumGuEU3MiLafk7D30OjelIjwtFSs32WMPODbnW7yYMjNH93HBHFwAtnNIO9MboC0xafnLEB4HA6xBALaNsO3LceYUV5yfNSvfHL5puwmHYfTTRvt3a7fu8ebbPMph3eThE15I0lmX1t6T5Wb1BkzGmGrk1E3vTWj8jjnv8rh0PtcJ3662uue6Bc9/ir5SGfc254zgvVmU/uOc9OS0ewzFxNV5/huYG6p7bhDpPR6gNkf13Hu2CLLdasb0oIwgEKJDMIdN8adqIi89SIZ9OB9o7345TPNp7DQz0vQbk/tsg6MAz26rnJEfDZjfU8JG0e8btK11loIF4PbX7+i/rnzgCHahpkbAv5AKRVE93B7mSAfvxdALFez9M+uL2Qlp7/m9N2Jc5iUOSx5VOJes4/j0F49jQYdPsWD8ayi+4PhP4m6mwGaKxhMNg9mcSXC/z5ARTpzBS1PgTRsj1m0rXd2geqqfSf2aotfBRO+/hOZfDhERH5rv/zTfK/XYCUma96wgPkmjtc1ungkgi0ia2l56pTMlOk3nD3J/6/oftGfwAw0P0CiOWYU4AOYPdgsmPgYNiANyVNfjphwEt7YBa0/pwWoNrEIUn7Oxxl7OkCOYm2JuePd3J+7gP20ka3/EiQkNUQFwDQSUBmSiIXbc/Ina6+/TDI8XDLA6sOAz5ALEu2kDAyVGJFMughxhpw9Ymq1LrI0vrmuZ81kTS2GNBRNdgc7vsllhpAC52LpiIXXXRm8FNIA7V/NPyLwddYnbU6YMxu/4uluQBgShw1KWPyhANFSP+w75+TF0aPBkrISjBVTST9CjAn27afN1r4fuGBAgBKEjOlWveCsIM4pezMgfjiw3iwtiY33HCj/Phvv0Xe8f6PHgCA03x9+9d9tnz1l9zTtdvrgwhacB7G0+pb56GPD0SnxVB8B2cu458bijwNMyXl8RATpjPGiQyqYiCwcPUP9NV/Tw2aP7JndaU1jOF21OSvdZSg9LP7slNONbSouEBVHIzmuIibGdRCQ2aTMVR1bdbnD7y9DhxcTOPH4Qi0Gr/rpEzoTOg0RyquY5HYbCmyqOGAv+/sjL/Lh1bO+w7EqhyfGJrKyLQd/Se44BaKRmwrB+DxtQQ4wHS9dZY2aLiZ9K2d2ZFpELD0A3o+ppKlA7e9meP7Cod4rRFdCKSZ7yumK2Zr3Dn+qqmMGwr7Ll7z+38hT//qVx4OtcN16q+veNz95PGPvloe+fmXntiAc4Z30NjjOcemFykc44CLga7/78VqDAZr14AXmGPJ4GnDZrLhUyLOAED/1myDhzOk1pAteFwsl1oNw7jd3KghFRuMenPOEazig1CYan0y9TyGJj3hs90/351Vpwws7AMAXM9rW7EgeOigel5KaFQ5Aae7cieicI/1HGkBcJQX6R4Diy01hnpuNZ9ZadNEaTN1/B66FDJHPaefJyKDRMK9dJTd0KP+oZfooHxzxoOGMbpvrPF9Zoo13G6K1Nrsvuw1+JOt5zmbr8yqnp8kYxAR+ebv/F35qf9461Nmnnj/u8pj7nvXoRdsTYchFHW/IL1Dx/rY72niEWjcXegdJJjt3kQlXmWLRJ8l3C+KG7tBYhiLjaDBC5kI4ntdM1A8jYlBAFFiZ4i/x6VrHV3mmlKS8zefl3lWOdZmAzLeb/PtOy9dhJhBAiq5yUHaCRvpqy65WK644vI4t3SMgA51gPqHCf+PPCzBOjDTcOY2Bi3F+8+RXVP7+wDVvzZZWu2yxqSizUAfMLdUJZtMoLlsQ2zRleSyi8/4uRWJDX2e0IHVZc9T8h26Axv8fnUd8ZlUcir+fWMxF7dayAeGA8/uIXEggkCt4YxKfh4lMoQUY2WH6odkCTmb94kM93Uw44gt5lLr/vcy9bl4jx++4Ua54a/+Wn759e85AACn/XrO9dfI93/bw+LANf1fogH4aFMkJZXdHDR6bAdgNtMLLdGZE1xkm9QqZnbWK/tsuutoipoPQ4ubIRmKBeoaBsZVZBM3BuwNsBfzJ+LeBk5vcjQXbsrQYMMhOjTsgxadNjGcBYwhrSkhxVSMsSHniEJsTPB5AKTIbKBoMYVsRuQNJMXXwFiE/QKYrhiyjUgbQAMFYAGfJ5uXNN5mJxl08k49le5KCi0rmhq8xpxYjBBbEDcctA0KJA/s1M+NpW/etH9PMLZZAzagxwsdysra1hyUTDdAEnFzrZL7f4McBUN6QQygAQBsJLbU0HM26DntfzNNObPrP92HfC9j49+bShmyviPPd2QH/NIrb70+83Adrk+F60sffR/5gsfeSf7H6y4fY1EJgMXzk1LyaDOYmi7kPj8v/Zzdboo32JA31aZ+DhSS9iQCUvHnaw2t/egsru7nwc/8+jnHZpoN/TINJDDYKiU7iNwHV3W2HvxkEgH4eL1ez7fFk0n+W+p5IZC2gAFmA/BmEzF7iN0DQwBZ9z6ch3UKxfft13OO6eteKDGoAqyFGWEjhyu8fiGgBc0uUlYgtzK5cYDCWbyGldWfYdCaY4FnA4Z5Q420Gvgv9CY9Pl+x+GOu56okQbDPu/cPyajU6vJAvK9EcomIdEwW3xz+BbW1E+s5ZHnMHEQ9h4Em1/Ov/fbfkZe+/N23+vm94twZeeHTHz7qlYmOoRp6+L5IStJa9ZED72MxAzx+TvJqyw85oxLCNSbQjywHzFCZvQEshjCSnkJixGkN7sNEYvqMQY812UlWUZNpkKOGz0OVj920k0VD84/BtLU2DPVDcoGo5FKk5DL4RkhSk+y2QRJyh8vOyVVXXuFsRFkPwmQoCiYE/hCiAXuKZPbtPEybG23t+eoAjf0uDTlIa83SH8wDQ8ysO/WEJZXmfWFrKrM2WWxOuPLSs2TyOPabStIBMH7YLDCtKPG6lsmSPwi+V8h8ivXoDjzJCnxLDHyGSaiYgz9qAaIfw6AvG+DYmQj458qRoaoel45nHSaH688BDAb/2QnU/z4HfeSGG+VDH/trURX5yde8XT70sfMHAOA0X/e59nbyyh+7btAeCqhLVty3E1HKW+j/Gjt5ttB576yR2ZSI3dlusht71BoDLyQErJEXkZ6zTLTNlOMJhhZvMSO2wYCHNruVGrshnk6IXiahA5XUUcSlwqAprWieRNvJ5LRMMXQB+oUuDJpJZjLgUB6zmWXITebteNDgu3wAtPNW181VkpT6dgSbKtBTGSxYqpj0wowPjTqE7xkmdwWxLaLD//asUkFOtOxpERNRKCOSqL82aCpZx9gbVHU0dB23OC8qRxt8Fsm2JaPcw2mjU97TBqck5H0Qrv/s8j3TYHB+Vx2MYHfriK/pgBLkMsvSZLPt2Y+1jrIIbvhFsuRkJkz2/eMZUxkBJtx/rcXn2xs/HT8jEfnRn3mHvPDFv3841A7Xqb+e8Yh7yjMed1d5/FOvMMbN2JWss8U/3nOOnHtQogFI93MzydJ6+nv/uz3tA6k1C+pVyU6HhQloeL/0s6M2isNtoeUNphwkXckHaUTy+iYHciQDkcVozOJeNSG3Y+CgmDP0zjx9xBkIslcfhM4rxNxh4I0aFHW2S+vizGbfFniqlClMetlpnCPHYBa7bizDt8E201MyY7tRssays1ojjrH/7NDWN/KdUYkIXmxOnUEwDIdxPjPg4Vv83EdMyOXcE0DDh2AB8wvMQVVZ7GchgrDHOGZfYuC7rM48Ea+Vt1zPI00Bny3MFcuKerxXr6XLWJBMMEgAksgzv+Y/yX967YWJmf2SR99b7nPn298iy2QcXDKlVdQYdEzaUDW27EJGyC7zdAp39mcierjRewP9QfL7AfdZDIbev2kY5+Ukg2GkgwMSG/O2+lkhe8ihb6eFxo0fu1mOnd2jFI24MsjToOb3ZUwxf4EwUQyJQHITwVar/7crL7lYLr/88mAwkDu/PyPaDQ/Zh6QnEKzuqyRORQegxOBGNdpJMld+fMe19u80eSx0i8G6Nhtug0XlYKoZ9rGkggdwgDj4s4mo+QyEyGpgDgNHGQy1wwwwDYweJYaErmK5m20g894yKAUrJIkkNdmLsXm6z5Y4kCRpTP5ylhJkISSjYWAM/wUJAPASwP3+kY/04f8N7/mg/M47PiC7pX7CZ/gAAHyKX3e78yXy2z/9ZP8yPTbO3HMZ+UbxXlP4hoYhyaBz68P0GCvjXgKI2Kkw6EkWy5ecpoiHGMMub4p5I9yIjhW0vRgumwYS3ESlLs0KbWzM8wlNTmTXRzPRmho9TvZi/AJBVjIUVG+Y1hr5Rjp+0NGgh4rIjmhcWd8IRBmFPjSB4gBAz0gVH67F3OebvXZQjfBzMwMAlG08uuXG9r8DHLa1t+SCmZz1hRpCB2aauHET50h77OFqu42fEaZ6kU+8se61WVHocgwz4zMmRaONIG8/goqfvKDBAblMfcvmAIBp/DMYJRrfBZgqtapMdj96msMm77lyoxkF4FVrk6Ntdpi6VkPwnVHSv5+jTYmGpIx5PSkl+e4ffJN8zw+/+XCoHa5Tf33Bg+4uz3riNfK4p1zume7VTUNzxMF9gud8mors5g70be35wsY7k+ymN/zYvAWAjecckgHeILYWbuVLVXvOzYGZQMKU1LeA3eh0BRqKsdLMTR+MBlmxupSozkpO53HGa1CDMeTkZEs4vcV6Dh8gbMcrecewB0JOo6mrswfI0ybOQfG+ALWrNnVwwoc0OjsXOxe9nvuiAkB4uPLj9XcwxXT6Nmi3oZ7LYKRXydCW21w2kl3IUBAO+4VMeTsAwIOWsbys2c7285MxAFEbLb7emR3zHAwzeMwAiPF6boDIx63n2tOFNlP2+wlO99pGyYSoyPld37b2e9Vii+0Ze8xzXi5v+qMLEzP7uPvdVR5737sM0wTqfyLPDAwtALH61tsbhEFjjWGyG+rBuyqGwXBuJxnFHni4pvNHqQ1dPTnmCzNadIiLxmZbbdBMK18CMESdnUFgyPH58/JXsz3PoPrbswOH+5zgexRb+67xjsWILwpSRCNLCkZDa03qUmWui1x5ycVy+6uu8M/egRP0pmAiGdgFDwW1hzYGWhvuk/qQDSCGTbExsAIwzXmUyqjp/HPK0lo1VkdImpQkBstSCVSJM8SgUzv3dDA55D8DV332MEjJZCYJEg6WoUTyVzJAKuIcV3x83zoxw0QG8DeM/ZSYLwEu4K9jSdl750T3m4HOKZN31wiugYmbKDkliciHP3Sj3Hj+ZvnlN7xb3vn+Gz/pZ/gAAJyC67d++slyj7tcGrQcGlbWVy8q6oW20kMIXSQGpd6IRdMBSQDM0jDYiYgPaztzYOJBy9say71sVW3T2wfAlAP1Z/ojexo4NZyi1sIvwNz3RTzfmV1Paz9xI1+VhmGmxzF63WmXPWIpdI3rw22MHAoTp0zyAB3QPtbiN3IkxvfVamgXod1bMw9yHimFY3SNDM0n/32XN6xew0JRRdhYTyV51BOSDRhM6LSn0GCyGRO7DzMQwlm6cLrtgE3kAOPQ20w5/B50jDGE+Zc6XbUDXstMxn65N9nwWChTdkMb0PvBOHEPBnLxhrTjyBgBPBh0SQwXoM546YBb/3dsALjUcIeGjAFbIgwnOYs87xt+U37t1X9+ONAO16m/HnWvz5AXPOVe8uQvuiJiPN3/I/tzjueIQUlE4G2mHtl5vKvOtMoU/3WSlAoygDC16z9ruynCO0QfJo2d4DnPFsGHs227CaAb5p+bTbGzqXnNhHwg0e8FxZv/vWoAAJ+onju7DK9RZWiqkf3OoCgMf3MOMKVSzRlMAW149GQeo77vxVNVDYNf0svXal4Cbq5r9WFVz13Lr1E74CUzraj4sRgwSQMtDrieF2dRhHQsreru2vModOGh/e41CrWub+ly6ES8FnagajTBBZAxEbA+bhQ/cT3HFvq/pZ5XkqQhNq/kXn/u/YSflb+44fwFeYavvOSsfNP1D7GlUhqkekJeCcl6K2yLMWxiOITOO1GCAxvpsUQINgFK0kSwS9UH19h0b0o+8bmptN3NiXwCaMLjqo/vIufs303cOxEL6UOlbe13xzu56bh2A0j76Ug/AGiEGEDceBgAmang2nIyMBzODUlmXlzlqkvPykVnz5EXB8sUmw/xyr/XGQ3ZPxfci+5PRZ4g0Mtni7puZIrocXTGroTHgLYmKcXn1BMbbPR1FoRaZLT6+TKqPbRv2IXM+Ii1wX5TfTEVPhMAlfAZemQgxTYyiwVGh5S15/eFe8NoB/emnBwgdGo/AThpSD9LnqwAAGiNY7GJ+ChtMXPvDIB2lvd/+C/lDe/5gLz6be+T409i638AAE7Z9eqf/gK5190v8wbEDdgoE3O2YdQp0Izmr8wDmRKOxqaQE30fEMU3udgQN6OHr6ndHCOHeD/VccjHhQFfW5ivsAkUhrVqZisweWktBnlG6NQojklG7biblrSg8qRh+6NDNMctPSSBUIrUZYwqbDJunfGeMMAGZSm2LzAVwpYl6GwUL1dGbT4bCPo2u4WxUyCd/c9A+76xgXRZwgMA/z2bdp7ptx3UoG3cisIOJsG0GRMZIBVoJBVArN6RyTuclYKGdJX2ACR/iCwcmB4hednYP5/fVQcZUCQ6UCWmDa6erRzSEDNCnPtgcOZoMrRcKEtYSBtsnzm9B+RsRx54cnlK1c5eAdCFfUcWkcd+6a/IG9/2kcOBdrhO/fXgu99RvvoZ95frv/gKNwaNZ6jr9jOZqQEAwHCwo+f8mDatvP3OqSe6YOM7OS01ovd2cwAA2QeqRrrR5I2g0tAHgBbxeGs/FyS4bABYW5+dBwmADENdLLLi53s9H6jfXZbWWusMupQIo4ytEeRLTgknCVJO4+be34dvosVN8PQEfTUGgzUQWtvI4mNfHd9y0oDL/gU85NY2AvMxGFo9T2GmxxUa9byU8JBpMtZZkdHPhqP5KrnELw5+ZNlMQePHMgT6+nWNgbyrGSNkDPQNQ10lNttQz0tyZqPLDE+o5ywnQfIN7ht4AOA77AyZLJ/20J88MUbtb3r9wyc8QO5y+0uHQZ09cbAJTUSjxveP77z3lsk8eGIbOwxjad2XZfpZPDA1Zw5gSF5HS3rfpuo0bde4c8zbUNuT0/2LgQDNBlp+ndqaz4rZ9PvLMss8L7KbmywYUN2IUIc4RF1JWyMS0F5F5n4F7ID4O9XuoYs3Wa643WWdlt9asCzsdzeim/ugK/AkyT4gpyFW02LsUvgiNWNzxKDfnzhs27GBD9kD3rMMDAg3A0TsoDKjg1QBSiATzmKlTbw2yQSeLK1JFiSASMgekhDANsYtjskisWVn1kpm3T8Bl6rJE6tkiHlNQ4JB0zjnlc6mRnMJgDX2t4AMponKDR+6UX7nXe+TN7zng59Q638AAE7x9aqffJLc+x6XD0ZJPJyOebcRi4YK4vFzVtRgOtS3L32rvzEPAP45TktsnZ6nRnMTG+z8kF/TGYmeB5kCUFY2PAGi7ttp2lL73286aK5GI6Pkr4k1f3vgh+sw478rmcGcLBEQ3xSr2vAs4sP0LVEodzBYLHkNJcjS+vDOWxBoJhPlW29R2D0mCIdKbA8gAWBKFAop6Kdbk0Es5KKtst9sL/az+uuP5iKtUFdujpjxgAMtIpE6kOTUzVVUUfX4mWgioMVVKo6QW0BLW2kzmHOSYwMAcK+y8za8Bgo1sfBcWEcy4sAOw6/YnoEqByooUgLQoIFlk6mIoyhwSkJKIg+4/hflAx+6+XCgHa5Tf93zTlfIC5/7YLnuiy6nZwlDPAmwoGOlRI5l9ZzzecYDEPvecF1c3LMmUkfwnDPoDAo9b4ixiXbHeKsNPfNdRqaZnetl9Zz7Vos2/TA3jJhvtVoRxoeqEe26W5ozENhxP0kHPdTiC/uA37W1220OMMVSe0BF3UyIRTRmwZQGB/mjTXYD3HU9Z4khpyQ4gJKCRRHDa4p+gO6LiOxDknxE+QKQdj8AfC8nDPBerz0SjaK8aOvrvQhF6CmZ+nb2RHItf9Tz/nOOyYQ2rUxrIqq3vxCwClED4ZeEGlibOkAtBg5jONvNHezJq3qec5Lj4771225zAPgUZQgJQMlJrnrwT4hewI7/Kx9/f7nb7S8bHOJY/pFS8vs9fJOa11O8P/RhJQcjED0s/r7Xy1XmOdOl8WgNBmtsUrlaTHBktNCg3wfJbrLWIyp99Stqcp8uX00efzeY+2ros0vJMi+LzLtZlqWfOVXUYvLEs+0TgQAD8zyH/EBZYsmadknSaKhLIjKJyKXnzsjRmSM6VwyESZGUsNQmKjCli/Qm3H+TLfrQ+4zRguJug62FWR7emgM5BIxGooXac6kDw8NZCxS72AykBFDRDIHIFPXnZ7OLexjI4fkh2WcAvxIzg/Idezx3+MxRE9wQkOQAHPMXw32WnDsvI5aRI4QKeU8slPgVMCOMmAEWd/iKN7xL3vreD8t7b/irW/X8HgCAU3D9/A99vjz8s28v8xIDDEfopJwdzYZBGzc2ndLIWZTiSOfgKioRMbSOFNpuCrm6Ivs3GqNMB7DTCYetR1DmsIn2QgKa/xKabTylzRqczabEANmUBmmY1gnR6U52ZectS206xHGwqRCzBMYs5OT00DD6GQGGBQkF5Cpb7ACdl17sTMXQB36FaVJkEm8Z2Tf6ePKDB43bGHHXTPcJUKIDCfHPiVyLoUUUCYo/qK6dTSG+lcJ7hBkk0hyUNjpplXnch+DYlkHTCG8EABhcuF3/tIpIaSvfiNhWxUZuM2VJOXKZhRDvQk0+YhVzTqt4QxnyavUWmCC4hzodVAYt7LAlIFADvyelJHd51E/753S4Dtdpvj798nPyL7/sEfLEL7p8qEUM8OreMC17zznAPDznOSfbnLdBsgUjVn7OE3uK5ORRfOvnfPR8CS3/NIWbP8e2ssQM5xY/5xNTxJ2GOm6uGVDleo4UHNRVMPOYCltr6HEBdJJ02AFJ3syvmXE499DAA0Sd5zaAtfv1PNFQFoA2D4YAuD2WNfG2WzxVxqm6NWL9+mtiBtqqnrdI98ks6YMbvg0xfO5HX8MyvuT3UvK6FbFqkVqjXjs9NtLACx/EzT9ot/S+BKbG8KoAM4M/j/V9hOVOl5RoSAskAP0jYux1KYINYbX3fW9/143yec9++QV9jr/wofeQh93j6r0a5xTxXMh1Pfl4o7TpDaO2EYxh8z6wOPh55xx4BfPCnp1GkX9df948oaFQTDQ3k6pNKtVmyHZ4MPM+Uck82yUhAjP2yIUnPXlTlXnedQBz6ZF4zXuE5mdCsmldKSo5UaQwzicM3uxesiLEdLZmEjl30ZGcPXvW+rvmQzaYtGv2hm/DU+pb7dTlAUlENEUkXjegboP3k7qso38nMBisrdIG3HwP7LsXliQkSnCgz7iDMmno33AmV9QDjivVeA++6DO9VGLAhIAB8fuQpKv2PvMqslREZSpTfy8aPSqMDNc1BLdaWrEaApCMdAoGt3Bu1lbltW/9U3n7+z8ib3nvDRfk+T0AAKfg+r4XPUSe/ZS7DZE0HJO2mbINVCP6jkIH6n5ZZSFD94gYoEKReY6c2cDNAEDOWUoxCs7SH3LQwqvpn9cxm2Lu9HVRokdrIJc2XOO9ecNAWrmgEYk3R3qCy/HaEI8pOLra8SulHqQTGABuFkeoPlzsYfoHfwQUAdDS2IEaenqxuCp3HVbeYkDrJ1EsiNCr9UQAACAASURBVDGR6M9hS5NhokXbdm6YsdUY74X9gXU7xPr115AkDa790F4BAACQME3JkW8YNzUyDwRFiqNVqgEl7u/AKD1tz9knguOU2PUV2xxnyJgfQI9/iSxYbFkAirHXAJoqTgVgHWAiY67eGIpHbblxDiQ12FhuI1rqne/5S3nUs152OMwO123iusNlF8mLv+pz5IlPv8LPc9+i0bOLGLe20rU7/Zq6pHFr2/1gkK++mWKztZubbLfFN+AqnaqPIQznWY9MHRsyrLdS4toSWu0180xV5Wib/SxfD8Mw4eNBH0N8JZM9sLN2c5PJNvvsc4PGdzzbkrvAg0nhEWOr+LlEzTP6CNSvfu7JwKLCNh7MjKjno/u++/qkMSIQtRPgOmILWTfLcXEevyfJHfFz2o+PdAAi77P2mMXhPcgqf93BcWNWBAifRY1lVojiW7XTnXGfwTMATunwBOjMDHEfGnzO8DnA8iDn/XrO93qx757rNfoxBi1QE9lI7A//6KPyhBf8ygV9jj/nXneSpzzo7r5NjsEx70kAdDChE3eyB2sGtH7Xfp/43TUfxBrJBWO50zzyD9R/7mUY5AJ4FQN6kzBWW30PKkN0Gw9ovXdtJBOIZIlM8YNiz9NSq9RaLQawJwml1On7CEpsRIn3jhPoEw2s+BwpDE5GX/t4jVMWOXfxWdluNtaTNJecci/THFzNPmh3hlRyyYJ/B+YYzpR5Nx60iG74byCNAIM+/AiQqsJxj/AmUB3fTCKmgNKZ5mckUfzZDNB7fzKqdukUDmANINNZKCm2/5g3cop7ZBjq7ftHIgkMWhvdb0nCa0Ij59LfHy8xwRpelir/5e1/Kq9665/Jhz52YRmiBwDgFFzf8Q2fLV/9vHsN8T0YBOelyZmjyRuSXJKUZMXIaIJjoU7uDooDaKnNc5XbSo+JhmqzyeY0aqi/HRAYNt0llQ6p1bPtEXX+uwloQORatu2LO+6udOjY/EJbJqY/z0kHc45ErstKDRDTdCK6b0wBGDbby+ifgG36Zsqur9wQJR45w+z6zAkL3Iyx9t1lYgyaWEzSXj4rbXW64ZKaO3X2w4UBD95EQEePZgLyEd74B6UpyW6J7UNtY5O7kPwB+smjTfhKQEqiOh5+a/RzIUfkPbkA6X0dZbfYRk9hSIk2LNEsuLdBijgsNH7wtnBAwAygjszgC4hvIqSYvRoqPQNIsECsDhrfyQAZEZE3vu0GeeyX/MrhMDtct4nrykvOynd/1aPk+mddFXpzyqfvz3aA0ksVKUWGIdWBXWtUQbXHeQX50/Hchud6jLUVd8GH8Z8DuKoBPLiBrJCJLm2VJWRCxZLMlkWHxhRFyhlFA/g8AsuD3EDiPc9LTyJoBLCWLIOMTzXSFFhQwZrxiWJWIQnIIu5WD68gTgnAuS20EWc5AG//h3rOOeYyxuq5V0NdgfBE629kKKgCh/y0Bwr3jzSo/ZmaDPi3NJMWTquaPJVyAlMtWHcAXeB/g13hUM/t1eBng1HijuCr+GBd1XN4KvDQqhS9XEpfFuxmS1CC7LBiABIHiXJOQ4xzyUne8JYb5In/869e0Of4gdd8mjzj4de6m7zQEBhGdSEnTAzqmBY9c6SbLX6SBkMnYqJhzBysRnXwIAVzU8IYcHTXTJ7qgVi/kQ2baLuvxPaxgTFnH+J7Pc9STSoAsIV7MO9PLSue8+lrrR6DCM8TNSbLIiJz0x7dLMyy1IF2zl5eLI1kAID/d7b/O00i26MzJEMdjZrzKoYP5zPi87q+3wb/FXtAV/09mz4j7QDvo2m14R8MCHs2ahPFQm94dgME1sHoLz5XDO7+jGHgJqNzXbnyB5M1zjJOBgBTtANYYIhkv08c+LGkAfgK+HcNHwCSVwTLTN3/SwfQJsmyLPKqN71bfvddH7jgg/8BADhF13Ofeo38m3/+0L1/D4r60bYMFO2S++BWjQoJZJZpfmVKritCrjJu3GrmQ9Dpq4pskZ/OcWoWRQi6WsrdqR0xSigUhbVFKbRFbFbDo2EhOp4SAi7GVIii3lkLs+szR8pPNHE6Op7qWJzZS4EL9joSEI0G4vfWjSgzAAJl5M29ENUxGlwM0KA+rn/3aFoSoIXr7VtHYfGd8Z/9eDGALAPg5gxNUqJDs4MH0OTH+4FpDMCNrUU5wQMAsY216jD45zwCDo00e3XQiYqbRiaie+WS3JWfN4FJEOGnQ8oCg0ibTXZWTGTOysoxWgd/AcRHKeUMYzAAyu7U1xqFDM3Nf/yN98pXfOurD4fZ4bpNXEdTkR/4xs+XJz/zyiF2y6PzrLZwOovT4JO4K3sp9jxpxKnBFA1+AvOie7np2LziecSziHQagAr439iA19pcFuX1aHBsxrAYG+Fshy03tAz0pgQDvnFDHj5kOkjOcI6H2WF/j2A+4bVtzKclAFxxo9lCiTi1jT8TAAjXDpyZ0PiXDDr2qM9QOtcSObQzvT4Yxmmo5xhAmPHFfji9nkeCgJu2kWP5up4Xqy+yquejlnm/nrPkA2kT89w/x8kYC31AbfRncW9GtOxSG7Ejg4ni3jqbQuwMHRgwYJqgnncwuvcF3f8hmT7949RzAvBf9TsfkC/+x6+8oM/xNZ92O/nyx943hsxBa598GMe2tb/OXlsVjo0Sz3xTA8olNsayAkSiR1RjF/SzopJkj/tGDJ+ZMtP7YioGME7kGP2fsg+RQhtkp6Zq4nS4wVXeDT5Top7AZJbNTOBUZV6Wvkm3AXNZ3G5A1J5BSaO7fRKRIiKLqEfrnTj8G7Ngom8Fr3U7JTl75qhT+5MMzxR+UqHvpTNb0sAQzcb2gFQIPQ/YOJ4UYPGPeGbEUlLcXB+yDabf6yrf0Rd89vvZbETCYFLsc8N2P5G8qQM+eZgD1I1fCaQh3T/PSLHx7/9uKj39SXJ2PwL3CICpI/nB1JXhOl6rgxaqUmuV33rTe+T1//WD8me3UuN/AABuA9e973E7+Y0fv27QoHPMDwaUTr9PjtbCiRN69w2ZKGUyZFmqenwgCjk2L7NFr22Rn07xaY3M3LAaXRYddG5oOED/LHRoesZ8Gg//IZLPBlQ0WZm2xtguQIvn0VAUm8Nme57b3jhWRFd6nfjcEZGYqIBgcB0SADKZiIgMr3Ewp7FfNGWRmeKaEF2Fxq1QbCAeY0eciUkwTXmIsEqrJg0xe7u55wYzAJBXlHpQUWuLbT2G+9C+EsCCaB5raBEnCCmBD+NGvY1M7eSSkyThL4DhH38PPhHOerFDtNbI9e7yjA4ANMtSzinJZNu/88d1Tzqw1nmBecCJDew9sFlFmKmZAoFBsZYpVNeJ5gEQ+rGf+2P5lhf/3uEwO1y3iSuJyL974RPkyc+8KmQy9JzPKwO8VoN1hUG8b2q7vE1S9zRpppeOAV9lXmJDivrF5zhMAn3TRdsbnLAdiO3xhPyc5zSa56L2gv4tBHRj0GcjVrCIeKuJrZsYgD5u4lb1fNDCRxwhgEwRkj7l5P4q47nXXA4Gk791Pd9SgoBYnVFFVGLEr6GeNx0bXc5IX28YA5DXPUCm/5401CAAPKDawvn9pHoOCQlv3vF7vd5gC4dIW9KrByXfhjYfaDkqrVdX9Blek1sAUQvVUQaCSxYymqV6TkAX5B6QZegt1fMMs1uq5xL9z0t/6d3ytf/yP1/Q5/ien36FvOAx9xm2wEKO5p3uLL4B7TNZG8zedACQ1JEvp2hT/Npa9sH/G7ryQqkDvoU1ACCTwV9OSZZWA4oi8Kdpc+d4Nwml19A0UgY8P5623sUN+5JLEsBOTbQNhtQRMZCtVmn2mrQ1W5SIVGk9VWIwNdQVAyeWJVNKzsgVAwsKQFYnsPf7cbPJstlsvblVjV7YWUq559OrCw7yID8FqwIfAj/vvI03vYRFczYb1HXUwA/vp7nRYmZjR2mSpferDCwm2TfbW8dTYsOPBaca6FRKlmpAREmZ+kAkSBngw7GAEueArNgYo/xDfamUhJhA6mICqbXKR278K/mFP3iXvPXPbvhbq8MHAOBT/LrbZ5yT1/7sU4ZiP5XBWckz0TtVP4Jpcgq3Wt+IDM71SY7nKjn1pqBxBBOMk5ptVSklIOKJdC9vl91yccjv5s5j25A/APTl+L0nbeHx57DhQAMF+igADB7I2FH6JAkAXNpl9buG3F2Ko8Ln7c62oKfX5jQzUBZ5q4UmEc0U8nqTgTBDfGJGY5cGrSs2Md4wmLyj1nDux2aHX3+C9hCNC5IJVlpNOG5D1wh/he00ZqeylADmRHzI1BYeAK2Ja3zh01A1gI5Gvw+eCthQscQC246J5Cm7uUYMI0W0iKonGGzN0fr88WKMBHgyaGeyiLjZ1dG29NKhwVJZWqfr4R5iGurOoruOKJ4LDJTNlDymKiim/d79nh9+s3zPD735cJgdrtvM9R1f9gj5mq+5Jlha9Jzv5urUa5HOWCslyXTic25mV9a0HkOnPolLAHoiSkgHPDLNnvPtpvj5g0Gkm8liQBvbpHlpstQmR+bMDmlceM/01moibwEGcxcytkMDCCkexwPy8M4bvI9Xzxdysl/Xc98Qm5ksGBPY+ANYAI2dAYD1xQN9WtVLfBZbSt+ZzWx4uwFFNu05+YuIxzaGJK8PPsWGdUi8OqC6Glgkal1sLykuLXHEWk/OUQlGxEw1ggEdACttpduf52q1PZs0IQ+MPvgwIIYZxpW9nsvgUQOqfnbqewed5tqGeg6PiJPquRCA4sCCDT7/9t+/Tb7j/3jdBX2GIQFgCh309wXGFtiGqxBIEA74w7xGVA0eIgPoSIOhGg/dojKYCWootR3UWVp1ynb8nHVKQAy/YPLVWgOASMGMdNd5YrVAguJxfuQFIGaKh0EW9xcvUSANqK0ZWKLSKgZdJCU1qbSQwM9z534b/l1eQsGXTbopdTFdgGpnJhxtixTTQuW8ipyk7PpgB0SEYi6jZApxdb3PrXsxpXD/V1qDe/zfygQQ399iWhfe0SvF6uU0gkoDe5fOqP5+8rB4S74szd77Z6L585CvbvII8CL78q7f7tmZLGGuit9NACn12TfccKN8bDfLL/7+n8i7P/iXf6tA/AEA+BS/Lr5okvf81hfv5SUL0c4jKinyjit08qubIUx3QgMuEhTxbkQUWexoGNxtt1ns3mrw9xqhoylLp7XpXqPBDQZvFEJX03G9eYlNOX4Phn40HqzD5wub59Bx6qDtxpaFgQf2WgAtMFyBG+UCj/+MZgs00T3afu2eDH3wDVkGN519+M6D1m9LOnpE7HXNfxoyouEADROlktIQ4eeDNL8u08webTLlRu8DACIUcTgFUssRW2gAYfwkA4hD1F/yK+D33AufDlRD5GlPJbtGFlRRbBvgyIrtlm/GdtWjEtm7AuwYpEfAEdjvS9FRf0qFElTcrXkF4K6ptYMLAKBwb4J18NxveJX82m//+eEwO1y3metFX/JQ+fqvu7vkkoaB0YcEia0PzlmwaPafc6MDi8i8VPMXwQa8ylQ6jb/7o4R7/lJBzbZzgPLHof+MjVSg0LX2sx3ncyJ50mbKFi8Y2vm60n0GcN671kS1Go0sQIVi7AM26XLAZFv6pu+Tqeel/56o55Euw1IzBsi9np8AAAzeO+O+wYAVcc+XqOfJ+w9J4c/ivjoAPUosIPy/l/jvABZYz8v1HDW76dj8j/U8OUgcQI1SJK66CWRE5vafv3GgCmBKCRAmB0MDQDbAgy19HnMlg0EJUAvgNra8i30n6A2Geu6eDeE6Drkb13MRkRd91+vkh3/mbRf0Gf4Hj7+/3O0Ot4thjbb1MNhLGUwN3u7H5rjZWjy7a7x4PN+aITAskfhepCSNZgy7tecEvHgCYGAjNwyBa3YlNORNUs7Cgkt2vY++cTQPzPg7mT0r0M8qAQYiTOKHz0DvoaqxG6sDPPgs4XmBOLmSImq4iojtPqTQeeCgQEL6Xdf1TyWJZJGpTCGBou8RrzlMJ/MgmVEdPxecDqrNf2drKtqayUXVwQ+wVDObETprg88xjXvHhmnxIT3bQA5Gccg22GcKHmKxXMuj5EPVY0iDLdKBk+KxgOrxi0E9EE+X4c4Q/WTJY2w2vv8/++ANstQqL/2dd8j7P3rT3zoT7wAAnILrN3/qyXLtXS+1uLegHrMzJx7alLtmeh2n4mYU6229BPUtmjPOnxfPxV2AdOcsm2nl1iw6JBGEsUg0ScVi5BjdFWV9ZfZNCag8tTYa2tNweKBxgxkeXgPrNkVk0GqGORShh6L+Xlmrx7pzPvh46M15BQCQQY+SEai7V9tmppET6EnDMDTsnYYeLIJGZnxKFAZ3yjUpCKhVnH0NemIp8V1Dd5ppwD0yVgaQ15ySaw+nTbjdN4rlU9KVpRSpt5AEMFuEvx+AUUp+ETiklyXyYD3uxQYHv79tyxL03zRIO7hxmkoe/mwYDFq8Fh2c8AqIRIoRPNNV54LtDt4rP2Nf9A9fKa99wwcPB9nhus1c/+hp95cX/pN79jSMFTWbZV+lJNee59V5m9Ioq8kF0bCh4/cIVA0tfbF0kkpu+tnOvlZ12B6WKYk2bJbVgV1IhBjoQ+Qgmr51NOCoNY+5uZhcazE5w1TitRVye0/DMG3v2WjuYz3fz91e13OcUTgTucZNDADQhhnePEzTZZ813esLkrv3n1jPbXEAw8SUxojYpjJ8fpHzju3/KBNsK5O0MNKLQsiMhaYR7YhhY13PkRKRUvb63ZN4koEVWTbFYn3tPoTJLO4zHep5LAt46cGLFq/n0us1knc4tQjU8WppNjlnl9rpSuaYc5Iv++ZXyy/95n+9YM/vI679dHnqQ+5B23ZZZaNHdJwkULDtu1Adtq++tbctc2SxByNnPWAz+KSkFeDYQL7v+TlNcGnHf5NRct5UJWGjnoIVwPGB8B5Q7o919d5zMCCgC4cZQoJMBD1NU/9OMXy77Mc25LWacaAtZ3pCitHkq8qiKknsdZMkIFPfssAU1N57SVk2mxJ+VfZ9wRtAyGwPA3H0Wvj3mC/MC4zMppIGG0NNpoENeW2NPDjwOk1WwcADsW6rNgIbgj2AiD+RkMlwDCNLANQ4AImSR5IxGSDpSP7zQmKaSX4LCUFiBFI4ynV8XtasBkki826WP//wR+WHXvFmOZ7r33oNPgAAp+T6jR+/Tu55t8v6Q2gDjGvSc1CReWhFEY6hNgq5b/xXKGvEFtnDJ0nmpTqyjZg4tVimWsXpYDxU58QmKXJi/Bwuj5hrOjQag0O+GIqvOugAAX5MBQd20CP7gEvNRQ73eh+YXW83as5OQqRTjlQAfHajxotNAgPJLSV33T/R/oVG5umEBgF6IqHPgTWajnauaIIn5fVWSgyolGXskglyOV5HOYnsyyPWBbdQfm3JEWmFrXpKY/Gtbf/zhTwhp8i5xn0BymMho8qUwhnb9bD2i7BtBOqL7RoSG2AwJik2gnwvgmXhLsGJ0e4YOFhSEqCTDgkB+L1f8OW/Lm9820cOB9nhus1cz3nMZ8l3fOt95NxlxduQ2MokP6u7BCwGKmjX1895Tl3PisFisfOUgT6cL5CEQffNm3+Yk+Yc0jmACawLxXNe/JxUMpqKcxUmV4jInRyYVR8MNyRxEoltPOINvU7lkLrBu+eW6/kIQo6yQBt0Vh4vqJ1gNuA7QF8RJoDjsmBdz/Fz8Nmtz1CleDqv5wSQ+OtN/TWyQRlAFnbTH+o5Aa6g6aMPYtA9rTPFyZAM8X1dcpaH1xya5hT1PAfDDJLAdT0HUF3Kfj2Hvw2DMwAJPlE9T0TBYBaj30P2iVz3pb8ub3zHhy/Is5tTkn/93M/dWy7EIK8+WNuS2ZrI5Ft/ttJ0V3VVHwQhzxQMasQcXRsoi6wTKMg+kwdYN6vLQ81mI0hRGrzdMG6MFXRGDvkDhVkg7nn63i3mkM8SBwLcGyqR11ByZ3zcUzhDEpT8rcsRsyEl3US6yVzVWUEqLRzx0sot3w00s2w3ySKoO3hZSjGK/xo4ibg7mBZGPzk+/9jQJ/ouI4JRPdYx2SwBI2efQSwRIGX2LdNhCZMzAFsZI/lWzJEw18TvzPBwHEEZo/NnMq6UpJJTCaNE9nBo6gsivPfwKhgTPtSZLQ4hyct/9+3ym2/7M9kt9e+kBh8AgFNy/cIPPVYe/oDb++HsQ7uMMUI4TJGBLOSGH/TL5nTK9YMUWu5ehJeqsptr10qn/a0nkP0YWjuVL9NGgF8fU/1wGIdTfBj7oS4i+kYHDVBoeyAH2Jp8YdiOAyG1TMFCNH6OV6pNjGI3GsAxGJBXem9H/as6o8GHaxjL2XAddNQwRBGinG5WAMDWKKb4+pLIYGCFjc5mggu9sSsK0OVw2ofpH/S0/h24WZF6DGL/2WyaFS78brBIqHA2QGSzyd4cgRKqI7IkTZN7GPB3i9e+nUJbubQOBnUAgD4z6fRfZDGjIY/4x/jeYF6JpAjIZI62ZUBqoUHFzz0iYy3+jEZWiQSYgIjBRfe0nr7laSoPfOovyPs/ePPhIDtct5nraQ/7TPmOF95P7nyXM15X+DlnX4C1B8zg9J+S66/XACR7mJTcaZy7XXPvD7cds46zew8kOdr033S8az48ok5ikOaY15w05FUUIccAAG+VMYwiUlBVXIcaA4CxmSjqVolNt6dRX9qQQ44hns1zZbXpxLnc6eK9BrlZKx/R+Nxn8mCRMVp1Xc+Re59ZQkd0+3mupvVPrm/u9bwPagUMPmpWPa4VngWDz4tJ9OCHY73OQjIxyOM2xmiTIVa2b459ANcA5ScynUV8K+r5VLKxVPrfhmcEA1OsMd+r58Yk66aAMBCL2oB6ju+E7zM2+PVo4tpHX0QR9+WJyH2v+zn58I3nL8iz+zn3/HS5/iHXDjV8fYOxVWHyrTKlYAwsknBazxh+lVmnjRZDyV3bseRCz+Ib/KakFac+hbbzvO3PBOyNhtOZhlqj19vWflwQhRcBZAUwGhQzmPNB2eU+bZBo+mvU8MRQSXvxx05pB0DgXgEiIkgp6VT7WsUH1KU1NzusGvF1peQeD57B/uw9UJmKZ9ZXo+4PiUkJ8geYcsbguzZThgygtc6sCM29eHpSktH4j00BsYxhBg2fTPj+HfAFE4TYFg5iDJIF8U0/O/f7dh+ggp0HmQwm+Xb395oiOQAMI15EKrGrXvnGd8sv/d47/k5r8AEAOCXX//7PHirPe9o1joJjwIOhDnJ3W2umT464GAwx2MzyTaFu10p0ywaEOZoe17atioBHwcnoAhzb6hjQQBtC07QeFDttKJoLDImthd8nN2qg9M9mFIdGA7GEHiPY9hkAnbZvgEeNDQMfNiKcEhB+CSmJO/aCAVBAv2/hBq2rh9CpqLRBYr04wIWjTV41n6umDkZzBCwA4GkUtYPie+wa2TS8Dhx0u7m5B0B/TSlisRppKJUNGZP7FOC/NQ1t/9oRel56UTAm7MAq4Dg+/F1t4ZyNIR+ft+cCW5GFTisKVcR5Jaeh9s83tKXAaMXjsADM1CX8NJoNGZLCeBNxjtnkLImepU6di3jEJCJv/eOPyqOe9bLDIXa4blPXQ+5xtbz4mx8q93vwRTbEqz8XOGcDrB1rx2BsJ7IX88c/A895mbJo60DfdhvmedCNShJizmXT6Xf/GCVHfo429ec877dS+L1Mr19q1/9vtsXq6KreouYOplljPUdCymIDKMz8dmZ+WAysLSSzGn62CBnVctpMsnq+PgfXXi0yUIDxHfjnTEAoAIq1TwC+m5Ijy14SmAXNteMc74ffsyyWZkTpKxtPKSDAI0vE8dpWPgyPM31PTUopPjCO/kc6eNZ4zTCwHO0RAGcMeCzzKBT9BqBYzRdGpAP1iE/emKmkklQNUgewGFH7XYa3YnAcG6C/mcJTZ3esct8n/Zx85GO3HgD4jCvOyfMeca1cdtk56hHHLzj5sBWDb4I2e03JXn3uesKzX8CipGUPDNgQLcd58dldnGSVwhGsRlm715tbe9/Uj41wEjPPS2mPCRRJEpmM/bI9++ExlMlZvr8JsV4q088iIMDkKk2D8YDFkA+rYCMZzb+15g77OC9rqy797J8D5EmQ6HSfAvQqKWcRe91Tb/TsWWsyz8totKhtWICpfeclJ+/nYymn3pe7JIfOOTUzwGRb+h61KUMc6ngaEcRESWJIBigpWByQAZXEbJKQDQWLFgaQ2j8HQ3UiqUNOOMuSmx4CyKh2/rLUSCQWdn9x403y4v/vNX/nNfgAAJyS61994wPkK599T//nTJp8pnIni0VblubGawPdT2SkGIqc6OI/xr+NlEmRbk6EGBOADDDAA1UbCPrGnJKW2rU3uSRvXpYlNEK50PDWdNjAQ5OFzFdHNtN+3rvqvjfCEONBOdFLjaFdTI/qWx2RMf6JhtR1VB/QVQzIYVA06jqZ5ldpm7TeGPTXJebkf8LfbR0AQNM2RDm5gWK/jtl8aDWs4v2d1BCmlGSusY3Hd4jPaFk0Mp2tCPRmR4aYpWqpBdAsttVmCzrUk+7Fk747+FxUa95w/y+1b5XAZkBjyDGUkFwsZH6Fxpgprz12Svx72DtYk9DPS3socJjfiLzx7TfIE57/q4dD7HDdpq573elK+ZbnPkge/9Qr5MzZvPecj1u//ee8uJt66J2x0cZzx7FyHE/Xz/eu6Y7nHKaAjXT0SXKGnGA8G4eNkkD7qcNzjvehA/V5jGFtrYUuWiPCF0NQPydPrucwlJ2N6ZBMBoH4V96MsTzspDOU6yOb14mYYaDJMPBe3W2ezksRCYCCznSc5ZBf4WfAE6WtZF+NIlnR/oM5hzrIzAgHCtYStyS+Ve5xjY08D4TqeQyedQDirZ6X+PnB9kpDPVfbJlKSOQ0WSAmIARKMDfecMXPedAu9AKQCM6Qx02igCDf7NQCgIvIHb/qIPOHvv/yCPLdPuN/fk0d91p0H81vOumfvhCSQPHDeejijMwCXU5KqzbX+YgsalHoBZgAAIABJREFUoZ/PFP6UwnegURRgSVmqNq/THAMJmr0PiyoO7CO2cP18sP/AKLnQYYOfU/KNdS65gx9JPEEoFlvExJUYnEVi+w8GLnrPGLqDacFLtWBd2A5b4+yorZqHSeQCRBRjGgGOnGTKRXIpJjmCN0DIK5dlsbN5ZGb0c86ikw1UcKq/NhF6D8CMAGxwNCuzAOL8NLp/CyNU/HfIB5jh6UkTZvoKk8VE33OOqIdgVtH9i4VhT/bYZ5+4p0gO2YcbQsqIEoR/Te/Nf/V1fyy/9oY/OQAAh+vCXM996jXy/d/2sL2tMjcMiKSbNj0jvev087CdRvFk2V5HvWPwWhB34w9DGvLnMTzTudSbCdMPbkBlqxjKgi4Dt/4wvwk9aM4d1YfzZ16bEmKoYiZBCvf5HsMWSDtvmTLc36sOngLJHJ9zHiOE1kN5wbTNsTYS1KPIiZeBQpqTDJTR/t/F6fZptRnqtNeg4q91k3wVMnli6lHT0Uxr7QGA9+i0/8o6VPtspmjy8PNwTVPQ5AGMYDvDrwEN2JpVgcF82OS37pSL7wcNdF2Zgy1m5Af5Acy9RLopYR7yrwPY6MaScVCzvhN0VZhENXLjwlYpthJkZmm/i++XnRm9sP74Zb/xXvkHL3rN4RA7XLep6463OycvfObD5EnPuEJuf4ftwD7CuYTnyMHpnGhra9F+vj1GvaIMdSR/YGNschwMqtBYd4la84GXgcE+xIobgxZKK0H+ei59UsPAiroAimtbGcc6y8oypfv5J6M8SyP4jwFn/nxQa7tcQu3sC3AxFgLReLuBrgQdeyqjTh/6VgCzviRYeazgs+uMBGLe2Z/dbotLIDhxByBwpujFdT1neRV00IjPRdQwvHA2E29E4+/WoWbZQLFimjBFfLHvrdewMK4bgajsPjRN1Ux4k1Pv3bNnDmaYf3dUzzFADGbJpGlfg915MC7UW6zniz8bUc9f89oPyjO+7tcvyHP71AfeVR5yjzt5z8GeRb6IkTSYw2XfppLzPQ2I67i0UnIYuQko5BpmeQbY8HJByVW/f0/dgaBpkyn3JVM1aYH/PmNmZOkGdipKwyUNuBpbeR2iCxH/Zv4Cdk+XXLCu7+7xRqt3bX/ihCYbjME8GuIBbRttNwCYC2CRDD0mySbQiyyIi8QhCRBSOQ+gD8S1VXv92bf42V53U5PU+Bk6y7xUXzaGlCbbd8wJLSLa2opVLDQ/hAwAIAozmGLR2PZSreKMxr2YA9wZgBCKH4dXCcAWY1MA2MHr60CfeSKkzgLzaFHrR8OYMg1gMD6n9ZIP13f9h9fIB//ypr/zGnwAAE7J9dhHXi0/+f2PiRxh0gJyLi2Gfo73wc2azbRjXvqmO2hv4QmADOajTRHoEMEAiAi07A/T6MbfB6nNpgz6ZzQs0IszasbZwKBw8X9zUxzT7eCAgakK526OGwMZwQNCpXEAl5UZ30nXbqWJbE3dXfaWwAXfJtifLR73I573G1r+sfDjjcNQpJC5EZo1UPVdX2kNE+cE84DfmRnJXe0RsXVSGgG/xpzCbReJDErGV7yJ2C2RL51TsE2g5ayN9PlL85hC3hTkNH7e+LMAL6DjhykTmuBSEjXd0QgjTqoPGH1LN5XQwU5Tlo3ljGN7A9B4t0Q+t0dD5iRqngpofGVgTIic38HHweQVi8q//w/vlH/6vb9/OMQO123u+uanPUye//fvLHe+y9EnfM67RIhiAKfs/6ySSPKEM0idGo8Uk16v+kBfq3pELM4PeHUANEcyS8TENad79/hA2jxbnF9KKsdzP6w3NAzCh2VTkpsabihONZluHAAA/Gm4BpxYz4sxsUxiNSwBcL6X/tnhZ3DUoMfqsUeObeZhmFjyqEP2em4stU7rTS4va6JSqZ6nVT2fbakwnVDPWdLhjACK7VpLPrh+Nx1jfXs9H1MPOMKVM739PkuI1rW+KCffUkKTDSkY/BMwmLgcxMCHxWrlGtj25YPEVhp/v3vSJNexA4wJMCx+LwMLufShCvUcCQvz0uRlv/o++Ypve9UFeWaf+fB7yP3/3u1d59485i2MFHMuA/0ZOnTWaWOr61IODbmouk68SdK0N6Qox/PFTt17v02hBQ/pwbFc8uESqRB2k4aR4crHAP+eAJpmjvvMaCiWFoHnpLlhZR6iEnHvAlxwFqhoRAdKABCNzAP5/sHrTpSGlVeGhZKCSQH5gRuGNiW/LXUaewdUJ4rDU1/IYA5YlkXmZXYvgKR2b6e4dz3hIXUQAJ8pvn8lNkBs9pWYukhIaD3OUgOAZF8UUU5AGb0msv2FnhQwpjEkN/IzyZFkN6FsJAEtpbhcICRj5PxvElQlk0A2F08iMhvY/Hvv/HP5qd9+y38X9fcAAJyS6z7XXi6v/LHrolBAK19B0dLBAR//u5jTLpBVoIYoRDGkZ3f9BzXd6XuqsilmmNNUjrZl3I4X1s/LgL5jYGfNFxvswSGVt7dgJbAWE1sbXItp73FY+YJexsxheAIUM5NCrA6GSv47KYXxSZhM6fC6xg3CKv5pGOrT0BBhCEZTyZv3vDJvgtERBnFHJb3oWGO7AbsjNgbQ5UMTqSJyvDMJgFFHj+fmGzPIB6ZVBrdT461rxyA8z80ZHjyczwY4Ibt7OQGUyKa1BOMkB6nCvzM0aKCkQo6ChIedvXbo+vm7YgCstSbz0u/VZFsA5HaziR80qTpsZ2QAM/qWQfcM/5xu6MZR6pKY7Sa2N9/7w2+WF//gmw6H2OG67QEAT32Y/E/PuZNcc+2Z4TnfGeMGz7mkbhyLcxJD63D2UZpHrwfiEoDO9FEfarcT+ahssmTfbienFmNrDSkZVKhd49kHXFC2MYjB8BWJO5sNttJpALvxs3FW4myfKcINrDo03kIAASfaQDaFgYrPKZY6DU7U0qUNqDPbTacr82KAZVAAqDvozPF6vU9gcnNKMmjz8e95aPe6yaDEqp6z/M1Bndw3+Phv6j1FGn4v+ogGI16TiwSjTMjnhvT2VRxo6ga5NVgOoARTvPACIKNkHxkBVHQ5CX1+C5kPrus5efoUi03EYBJgU3Z2Wo+sTe7ldGI9NzDoeNfk3/7I2+U7f+QPLsgz+4yH3UPud5fbDwMmPKIwMDq9270JKJZRIimKzSNpOStKG3df3OYwBxTaBDfe+NpSBSy9JNjG655+fs2grNpkAm1fIhEiBsu+bXbAScdo7KpNigEf2fLikQs/mNDRgM/9YTNQA0zGAhCLNOmFok3H9yOD3t57QbvRp5xladWHbZyV65hS1aDei8t1o0fFIrDaz9/tZlmWxbfcTUNyqa1JmYobBSKQwA2j3QQ1Eg86k6I6WIQvorU2gAJuhCghJ2X2avg+dGACrIAw2IY0RU2eJXsMAMgeYOCY7d7gP5O9/wxgi0GktGKppCTyA7/8B/LO991wAAAO14W7rrnzJfLan71+DzmfSQKAQ62Recn6RtATNfFCGCs0PhF5BkOaasYdKL5wWmd0HsMb/zsUXhHZkw7EIR+DdqMhPVt8HrSIGM7mpXo0EecRYwjDdqZTRDX+7KCtzN6c7CGv1IT9/+y9ebxlVXUu+s251t6ngKIKioKilU5AWkGDIEYjgh0xptHEaG6SX0zyiyY3fXOT3Jfcm3dj+uSlN+29uabRqCHRG03EDhX7FvCqRCxskRKooufsvdac8/0xxzfGmOsU5iaPwnrUXv/AqXPOPnuvZs4xvvE1jAwiAFAKGolBmBjYNS7PoZUJVAOmTl+LQAwLgloYAUOypr5q58zYL7kpvr9OPnPZgxaLZVKXYbIazHAICq6wwKIDceyCyjT6Pqq+0xsSccKhVFORnIxOi6n3HOCimjYaRgbHfGBR7O+XWuwmzPpOiyGaX2pebzCtZC5F3cCzK5R10jYBr2hq1SC7zj/I9GloIop8MePNiLjw/uafXo9f/9OPrhax1XHAHT/ydRfiec87Hieftql5zuH0tnt7zin18ca1WV3TrUjnc15p6kWf8+kUrdP1gkaxZiqmdFvnN0NTqeBG7VZE+yg2t2Z1lgwTxFvAu8OHUo39AkpjbuhFRIM42nsJgo+Fs5YSG+ivVuy7gl72DFLmKXOYz6J+7WUXTv3UxPW1NHCLw23386BrYck+orjdz8lQ0yjdbH4CZC1wAFEco82nzah8rLReCbWJtz2kvhfofk69eCff0/2cEgM2+XIR/BS5MXFzID3ZYMtlTT3wbLrwZfbzXs0D3X4uST7/lv38/vURP/uLH8HLXn/DgwYAPPrE7c094MWRkfJQWLMJFKsFnVO+sjDcPWq/B6WWe784Nlwpm668SCMXo38tY0n691qcl4dvMj3bRM0BRY9Oanl0w6kudvJ33Qto8l90nx1aF9WaLzaNahMHWLwhaFEWZC5mJgkXL4eJBHQqG/HrAin21qhHZQrsHQyocYDFNbIFreF0ZZiO1RzQxQXSfC/G+nylDbGN1lf4Grmuv9m972IeCc5IMFjH7mrF9rpblCI2GP15NpHtAVEp+zEEFx9bZRkEPxTk8vuUNxZUcMmzjOoFu+7TX8LL3nrdfrP/rgCAh9Hx9lc8E6efslUXDU7CabqXnXGMv/gpWYMbnE6J6PNyqBob77SrCwWdiZ1xEbh4uwWJhQUb9caQL1hTz03MjGXMjI6bNBoEvwIAykgYzTCki9UMJicaCKIxHPGpAA3zgOfHIfQNRSk8QBwVLLqKAACbYk632cWycOHCZUCDFD7BZA8zR+Uj2KD+CDJx4mfgFC1PXLFroRb1e51G2O3dVIkTf68yK/L5uLhZZFHQqZ3fSYl+V0pj/TzzWYfosru7PjpaV5hM3iy5oUhcorIZekYiZb0fp/ngnhnATYCU2UqxzNpc8P6kYzf/Dl2cfQxQmkQO8b1zEtEWHWGvcVp+Y/jOn3g73njNzasFbHUccMeLnnEBvveFp+DkR25qvEp8WotfE6bPuc+eJ8OHHi4zkboliY/iPkiTP8/usbhQi/9sgG9PR5cClWuqNg2uMs7Fm9TaNIgbGGni3hSQU7eocahOH138fm5mh/NZ1Lhcms/5fWW6ThWR8DH2ldN1+5xQgNcAV+1ZGrCa+3nXubi+B9zPQ7OfmwdC0Axz7udjqmu9ej8UM+tjw8shRHB7su7nBPwn4ls3g218xL0kYHSAPlls6k0kQ43qim6DDp5/v4+G0O7nPK/GXsOG/Tw4E9wH2s8Zh7a3/ZzAkH8fuRSMA/DjP/9BvPrqGx9UAGCDBwAZpZqJHs3N3qc1ubz54jTS3tHdM0miA0K6YGyBLHIbP8bKzmSwj60MwKSTJhfSOoCu/fo6RbXlNG6zNCuZkqOaFkYESyJA/WxRTbSKTbNtFXBO8qEZaKgUxLECgrxmlim5VyIoWCJxfXq+xAurrnlCZg9mgheEUUXKv5rxiWfA9MFpkhvcNeK9PgwDlsOgP0e2RhZWlclYzWNBhyIu8tPkIUXZALoOh9C4/U+ByADvDQEHgppxoCVCFW3kfbQiGRZwnhp17YnKdiKNobI12gFPKbbO69+V9xUBvOKdH8P7P7n/1HorAOBhdLzlr5+BM089rNG6UcPnAYDgbm7SjfjQ0g20iJTAdNXUWVeEedZHjcLxzZqP5uACbmAERPftaX9BpxjLZUIncXSYLHDJRQ7Bva6BA8Utuj7bF43GqDhDpemUxE9l9b/ZqOvc1FlcMZO4iBEQne+9oZ03ivLsAk9175z5XVJfBptsdH1AydDCdd5H0FKl5NZAz3sbeLmHeTOEDQXRUkAKGj0piwPGPPCTcdJm/dS7i0FjJTmZiMGKv5aVAAVCWlaFaexTE/uU9ZzQEbkTQEdjmqJp6iuaiw2FrxXGoYkM9K7VLIpLcaAQjSVRr9VyqKyRSh0ODX2V57PS/KNu+qo/JJjRB0WKL//2f8b1N+xZLWCr44A7vvPSc/FjP3gGjj9p7QGfcxrINs/5RBLmG0s2WgHFNQqMZi3q12HgXZkwtGqhtxCjXD7HyXkLIAR9zknxLm49bCVtJlnzE0g/1fZ7MsFuTr589BjXRTZ+a0Ld9wSFpPG6od2zZP9eLlMjD1tqDGw9V17G5a3CwmT6N6aNbLfo2F/ePwFotf6NVn+6n2eoKzys3p40Pa3kAM1+LvTlvbhvmW+CbziKNFht6kEXg8oaGTnrtfje8NWDUvy80/08SYYd5Wn/p/s59d172889aE/wZbqf33tvwbd9/9txzUe/8KA8s8+9+DScc8KRiJOLwik3pCEmYOQTGXzmepqk/fh6zSb0NJErQoX3BooGSmUxtfMmbP5e9ekEfHb6GF0SlMVRDylJzdeZsZ4DHvrYMlpJszdJQLB7T5gAXNNiYyZpgEjDvC0Eb7KCVX4wFybZoWHCPuDZoUwh87OJG3+N/OtaA8Viw4tpfVzr6tDE/9nk3p7f++67b2Lu5yVHlTGRHHganHEfAKQi1H+YjEEBOkGKkia0ZOTS1rwKBsqiYGCKMZ+ii4Q0gJAgkPg3SMJBFOlIjRSNCrIoQBOm8abeO2Kj8V9AwH/+67fi/uW4AgBWx4N/vPFlT8fZpx/exNFxgwpCxUEwSjansFygzDW/uE2SIAK0CCI92jvDx06oMin7aM/GNKjG5iRzW81Gk7SoNWMp1Oilolo3Yym4RIGe1HvL6/WMAbiirJS9P5gtaNFSJb120bMS4HRIxUX9sZjjxjwMWQ0VaTxHFsT0vTAVYT7rzHRIrgPEXA7SWHqaPN+X/i3Ncy7qlDyMWb0ZvhwAQPMnOi6zQCQroWiOsp13AFibxya6kBsei0Cva2Met3dr5j1HTS/fD69zQFFnY58TzKl9DKUpHvuOyRYm/SCdNQYr4GOsplyqSYvtosjrvhwyQozoY9W9WtFsUTHE96n99PICjYBCNY/q+qo7HlPBeVf8A750+/pqAVsdB9zxTRc/Cv/lJ8/BjhPmjfbdzDWzgpBeksM1yhuhqfN7EgaY6LKXy2Q/65o2snpsuuqo686orzZ4bOKjmOUW95x3MrHPGMeiU/lxzBuiaBX4jW6tdEW7jzG0QrJs3M9dkoCfjHvwnRFZYyqqr+Z+PuvNZJDAbJ0+Q/ZcAyTa5txJJpwUQw23ZIrdidM/fQB4LW3Nn+znqb7z3nn8POB+XgyMaH102ui/6X7N87lhP4dvIFrGXBMfJ8aGXRc0/aWC9PYZo8tnT8I2WRMJwEgAoDNTQN3PZdjgG1VfOyS516rU0vaXve7nY9GhRBcDbr9txNO//Sp86pYHB2R+zkWn4dEnHTlpbeozl7LFQBIIYJ49nEzC9lea45n5pB/K8Jp1nJa7ulHn0S5Fgs+lT5Agg4bNWhNpHZk2EHSoQ1d8yGSck+Fav9i94BMBWN8GhMY4r06Us03+Q00bqHWyZ2maBwI/B+9p1hAqPUEbIe2lE2xwmexVxNMkUdqi0sXo/g418pikTlgNSINAP6WPIeDq62/C15xzEkIIuOeee9oov2ISJVbZxbE3i09sIJuCsotSxGcAZgKo19lYHaW0o0JPwc8K7GUHRhmA6Jv5ei9IZKNjBvF5jjEqgBrFC6FkSXiIJtvR65lbwDcX4FNf3I0/esOH9qv9dwUAPIyOv/+jy/CExx7VoPCcjgdSW4ptoinlDTeDnxjUhy1qE0otFg3PuDHpRh5rLFveC6Wb7AGP2MHpEzl9SLmIS7LRxP3UenrTEgDgNKaTwqXq2KNSz1i4GDrqNU0W9UNPAU75ea6AtoBSt94M3dR84WFmfFaosnCN0Rp+TyMcOVnmxEAM+PwEikVko8WXYnnpzPxo5lQN78xwyqIaoQWfeQuY7j84sxZlD8SAJFMN74/gwQ+jX1oj7KmapNyPEs3o6fd+Wq8uzmj9APremBSmqUcTzcVihAWsaVhb6QALX6VxNb9Xf4a60QowtSaUQMFs1tUc7wwnJWF05EbfBFKUed8OY8EjnvDK5vOvjtVxoBwXnnYM/uxXn4Adx8/tOZf1Mmdrcq25NDYPac9+zWDjxKl0cWswTfUAoyqTys6GdxiMlh2CmI7CjENp5ldZA/U591Gm1cy0aOHsTU5pEMfilOwvfgYCvDRjNcNatPu5c0rn3pOFIQbXEHgq+vTonXFg9mkyjSTBQPjpHuwL+6mpnV4/NZ+tE+5xLBtc+L32GZikPsA8BOwa2ut6WV79Xpvhzv2cPjYPtJ+bR5A1jU22fbShSfWJiQ9gXghlQpZQ9/MCB6bnjfs536PfI1hrcVgwn7WGjMlFH2p8oNQ+KRm7gnvbzZ9bx1e/4B9x132LB+WZveLRJ+HiM45VQ0L+l6PyzvItjZXp3O6Li7PXFIGCSdSiyWdskJMnvhsW/TdltTa0T53WR3V+L5PoaMYUZpdVn6Uu9G79Bghs1NsHoYTzfQDVe2gYR/Rd1zAUCt3oixtAyTnIcNe0aTyNeRLFEJAJDDFETVgI7iR6k2nWNca6CMJsab1MgHoe/DXxTA6+44CAq6/fic/ddhe+/dLz8S+f/jyO3b61HaApM0OAEPVXqIBZLz4EBEOiRpLnxj+KMo1aa7VeG9Mpe3aJAMGvt06rXxv+oL4DlFcQLIqxjf0MTi7Q0TtBGS3WE03vY12PAnDdp3fhf77luv1q/10BAA+j4y9/80m44tITmsYpTTJvazKqOc57czyfk6wu5tJY1ql0XajGBMw6iP6/PpwzEVUtl7V7XJtZg8hFb2SjGc3Zmfofr91kJDHp9ZX2ZrTsKHQ66rlZMHhTIX6GKeXdu9bz4TTjD6irLk2FGhqZmxC0sUPt5JoTE05eQrDmWicpMu1nU8vi0xdbLJZoyOTNfkoznQo65e9idcAfnQP/1IF5yUJzon1nBJ7f1LiQr611et+QTeALRE7u/IaRJmZFftLkm3rG4wVpqBmPZVm2LA7r/9fUCRZgUBkJr53KSpyGn/4FnXhDLIckk67YFOREd1V/q0649Cyoek2qzfxkLobW/NCHSPI+5+ZEzVtKBcdd8rcoq1V4dRyAx6OOOwJX/vFTcPSxa7o/zLpgHiHR0cKjX6MprbIyRllXo8XzqVyn78TEzgOWlL8FfS2lcc+ixrz5iTrBU4SALK/nzUt9oeqbsJSK6vtTcgCAMABi2JhQo4C5i8VS0Bje2MuSEQge133eUkg6ifLzKS4h2D4yd7IzTo95nkspWJvHpsn3gLR35Le9MbRxuj5hgAB1caZ39HGhQV6y/ZwAgDcbREATW0javebBBx/ZWszDSPW6LkLYmdPRx6Xu52SbZQWD2CT4/bw2pybp6EU+MQVPHmg/n7JNagJDrlNbYRcMY2mYMdybeL8bawVKk2Y081uu3oVv+09vftCe2aee9whcctoxmM16J52B7rU8wf5eCK55pdBfI9eYxABGekIHMl4Hb9n1YmDn8ux1Ug2b6PI55fnQxtQ9/61UtAgbAE3KQAwuvUJYLJ5ly3ukE6Qu54Sckng4cQBltTfvXzKSBtbhvGElNYHfJ2DJ81HNK6Pq8aNQ1HkfxxAQOhoYOvmF090XUBIVXGNcmkSH4lgAZEqVJlITuPr6m/Cqaz6K5z7+UTh6yxqOPWKr1lQ+ctvLBTxAF4SFYTGG5r1SPDgi98uQRgVoSi6Iwj7S9Ad5ODoFFoxV4t8/E8IYz6jAFELz+QiUFIj5uQAXIRRJl2hrP35OZScIgBgQcM3HP4sr3/2JFQCwOvbN8ds/dxH+wzecqhsSG1TSDKnX792EIfpRvG8OHb2sFlQVPVXdX28TbXNZrpstizi/wJKa1UT/yIPLCB1qstU1vtAlV3KOm1ih0kwi8iRezwqlifGaZx4A+nfVsdlNH2Z9bPJ5teEvXnMu2rwOk2QD6Pnp3Cbvp9sEW2aSwTyOpu3zrAZei0optUkN4/wIVAxDbsAE06C3UoOFXONN86jXl9fUskxt810uM9bmUU2ZLFarIXLohAqw6BRDm+398XWy00fW3Gyh/aci90/dCL1p4zBm8ZGITUwkz6eCDJQKTO4/AgB8HZodjqkyAjbNqzZuIYaGaxMQaCrFgEwBa7SYFauxC5rKwOnNfFYLMlJwuxjw8U/dia/+ltevFq/VcUAex247FG/+y2dgxzFr/+bnvJOYwKzyHrhmsT7ni2WqrzOzRtzLobjfzUXH7/eJ5jlH9XthA1vUa8AkWvR/mfXQ51x12jr5quvk/YsRs75Tnx16Foyp1cdykyKozLUjSIOdk8mxct6YT83PoJR+OXeUmTWmtQVGW591CKHousy1zdPlKaHqHRhbmnz6LOa7La2fjamvI9ioxGAeRJ4Fxul6wxyY7O0BdfKeJuC3xd7GhmqubADnF1BNe4PWTE0xT8BZJHw55wlbre5rnYDXFQDYyGqYzcxQsFL8o0yKCQDUpmM5eullew29texiqK7/awIsDKmo1CDlgr//h5vxfS+5+kF7Zp923iNw5nFH4Mith7g0o9AY23lX966LkkNvBrlBGvgQTP9PV39S0mnKqc7wgIJlmmoVbOgzNT4Oek8QQGgj2bTp9w1ynf3rz2c19A1IOUk0XFatuNWUWSLxzPST/1sKkBww4YGAwP8ni4KAUQA61AEc2NTLMGHe+UhBq5frcKizplZALE37iEGlAX3X63Ci9Rsw1kZ97SjnIbt1zOqqt11/E155TU0wuvTs43HJqUdj86GHKDA6ZQ0UZZt2jc+J9xzogoGYSZwjuU6SoZOTmHE643GeUEppKoOzAlL1d7MDNKwunTJ+jP4fG9NKBQOKsUwKU1RidNGLRaUSnk3w8nf87/3KAHAFADzMjpf8+GPwvd96RjP1Hd3GMWiz2kZl+CgeUlnms04LE06T6/+LK6fj8XND7TpxyeUG6rRSwaP6OomuUX1eI9hJblIQTU0AHC2Imcxu4i+U9ZSzFFtmIKW+BlMQgMyIziQLfpLOrGW679MUjzR97zBvExNziveT4GEs6Bw4kCaFDQ0W1VSIVHGEX6EwAAAgAElEQVRXnLZsCjTpDAQAvHHeqF4C7dTGG+V5aUUM02lGPTcB5vngp+zFTb7DRFvpkV2f8uCprtHfi72LchKHZPo5+Li84IqdWpSbT4KnuGY5B30fG5qq3gPFjC+DTPd9nOVMYpq0gO8dhVEocqm5P1rNJa9h15sRECdBLARHmeb0XcB1N+zBk5//T6vFa3UckMf2LQfj7S//Whx9zNq/+px7ffb0OfdGaN7PhWt5dCZelWoNNW2157w0+8Q4ZoQYMBMnbYLbc4m8TbK2E8AmANDLa9WGDsKwM3o5kwhmfVRHfyvks+qBfQwiXO58L2kyo4tdJeWYrALucdwT1NwUpdkbmZoz3R8ZIZsmgH92k9lxArIPo8X36X7eG1CcJ/tXztD9PLkoMM8U0P08t7GFgE/mMamE+QZFadLbyTzX796txfy7lAvYfm5pSNyfh9FADaYOkMrOmmbWBzNIzsJ4dMDxA+3n1S8nYD6rjQavdd2Lsg0/Jvv54KKMfbwhAIxDwcte9ln89Evf+aA9s6cdfRiecf6JOHTe46CDDzbduhQCNX2puGl8HYPGYP5EfH+cotIfiO1g0ex5RsGxNo0aj8cED8/2gGPgKTNRQJzOmUR7+Uh2ccQEfKKbBvvBTdboTQPkUIDlcoG7l7nN2ARcKpZjgbg3EJgPV6qe3HTn9n2WHl1owdDI2g2WIsDPVGvK6NiZUe7xTgGGClb2+v506KOT86i/56Uxug4g4K3X7cSrBACYdRE/8PTzceRhh0wYsjaQ7Cb+BgR4+EyVAonADI1pcwji+UTWVZimY9CgMSpQAK8EkdotO+lJ9ZOAW2ONoVDffhT2RVRmi7JayBAIJpMOytVy8a3BWMZ//sYP4xNfuH0FAKyOfXP83z96AV78bWeqfo/0IjZuuVi8jqebT7VMROL5wOdMhLcoHTq5lAD+XMmtKZ1tckE1h/QKKLk0EXrFRdkp3WrMjV5f9d3MwjXGUtN4tznymOiy0CC7ebKZTnODp1GFXJQ8+yDAabqTSytAO/H3mz4bRRZwU1o8CwJOxf0GxY2FKQHU0bOo84WfGRaiMeqBQ6SD29AaE8BYTaI8xYkFV995zaSLYITFHtF7oKVhoXHgrgVwaf6+12iqLlXOI3WufRf1/dVrUJHrYUy6ifpNd6onBEzvXwrvtSDUwNJkxcJNykw3agh3bnSAFisUXTHC7/VdcEBbwHWf2I2nfecbVovX6jhgj9f+4dPx+IuOqNIa95zX56V9zr2hKNewKIt8yeY87XPFuBZnaciy80BRmq9QZhlzqrp218RwL+PzrXp2FnnOLM8/59713hfTFjFmjXt0UrTsDLKCAwAoVeA6TJA+b5BulWaN900MMfwqSciq5fZ7ttcPwxmeaZQqZRkxaKO9t/2cIK5S6CmhcIaCebKf63Q02iTWJFqOdv5l9nNeK67rGxIjikUg87U5W/dRvJQeksoeIp3K7Z6okpDSRP6WiTndcsgKcm/cz9kEixljaWUKSRpkizSz/dHvsbqfy4kYlgX/z2/fiN941fsf1Gf2q07ZgcefcQyO2bZFXdyLy2coLjc96+Q+qO7aN4dm1FdcI8VnI6shnwc/6ucsjYRjaugZ2ZAFe5jZ4JMB2ysbNRtlu3lmfBa0MzF0aGVAwGK5xJ33LcWnoLhELCsAPLuyNIbDZpLtPQKio+3rOuDOJ7/VV5MKhGyZHRGVet4FF4snctOu62VIFxFCFNaAGeiVUJxxpgF8wUXd8R9/57Xvxidvtqb22MMPwYufdr4asKK0bJ3i/tHXU6TgB3PpUzDXd6g+rcAbcANtY++NJIOThCRZDyJMthUjozVNIsHzhQI9P/wcBEX8a7OGVtmVAJIRQf0U/uD1H8BNu+5YAQCrY98cL/62R+EXfuQxzcajTS2pN739Gw9m7fbSuFXzGV90iKEeN9BctMEZU9aGMeuEI08ejqBu9GaU5hs7WVw3aMZb52fVDfZRCsLSUPk8skqjFv1/5wo7Ou2i0RKjosF8T56e6YsqNtseYWShNaQpywKI0WnFkxkG0gTIf12vUdTCxLsg52JsDmoIgzPzY1PLyUbn4hQ1WikSSAmY9dagDtQjxuCK1dZIj5M4LwHwurtBNG/ThAOdEA1Gu2fRGIJleMMVPMHdvwQWeolDzJk0SxchKEUZo5e87nJ6zJ1J4nxeXcWSmjDF5rmBoNPLJaOBKqWxMlBaiqJm2Wav/ayGNzGY7syMxyKu+eAufNOL3rxavFbHgQsAvPRpuOSiI3WiTW8SToHDv/KcTwFs77vCmpgsLLKjpgaCbEIIAGgOfTY3a1KTo6Oepjw1OUUTbepd8rkXtkal9vfNRNXAZU7otZGEaZUBmJyvWIBtct45NMT1mmVNY3Hmhd6wlAa6BArKBLxgE0sD3A0Z5rGNrqOUbkxQAB+ANsweLOmmeenOjNYaeJckgNaLIDkmGZkB/Pk6fc4aa8bzVfeeonuS9xLivks2INB63YyjmDKG+nk0NSBGNVl+oP3cx0SWCWtx6j0xjlnrItYR0RlbEniBTx+KAffdk/DTP38t/uZtH3tQn9lZF/Giy8/Fpr7HtsM3T0ziihohVqZ21UtrhJ1UBa3ppNWbTc8NuGmui6ibUNEVjEdGKXW/7ZhxL4tAYYMdqM+mGZ15DLCRC8Ui+ghucEI9je3LJSONCXfeu8CQM0rJAsrYuuH9BwBrzLVkFfPEIsZyNAAsqMyAiNZfSAcowdz0NaI+RPRCT4fEHZpEIFr0cYziydQrvZ1rXozTRjE4kMe+/qE/eV1LwQdw5rHb8O1PPrvxV9Bz6Bpi70lANCAEICKCuQm5GixUyUjJiMrayPDRhHEyjFRRjmvQKfWlf4SXjESPqBQDszqREBiLAmpeGNUMMOjf1eSuyfvJBfjt174Xn7/9rhUAsDr2zfG8Z52C3/35i9WojJPwzqUC0HHW6+U1tiIYpcybBo3JdJCMsrPoo6KUSk6PW62f6CjnnerUY4S60+uEnI3ThG7fz2pcWm7eYxHvAShFu00LqJMeAgB5QssfXcRQSq0ZnTfRqZRAAyH4sPD8Wf6sLyRNVuGbfR9JyPfBCYr/mhN/b/rDz1B1kNgAJlhkVhsLZYVtBQCoa8wTZFQnS0KJZ9MNmP+AZzAQTOBmxN+jRwEZHiG0coDBaUa9b8A0G3dMRsvloqrAkBSOvB5ZXrd3cUlV49omJ/R9VMlE19VPtFiOeh8zsrBq88VTQdwHZ7Ooes65FNUL1ZVa+oDKJGDRiWw6vPfFIOZi8z7itW/6LL7rP71jtXitjgP2+OvfeAquuPzYJrmEz65vkJZ8zgXEVDNSBGX+dF01+LSIwPqcU9qTC7BYjti01tfysVgcWzVbq88m9dRLiWLru6g/Wxvr+p4WSz7ntm+yGbHnPDTANKMNvZkpmx1Gsvr1te9s4m/7edCGMru1Fo7+3MleSRmanbeinghs+Kf7OU1Ym/1czGV5rqYxt5iug0Ld5/40jln9bpQhIHv/UjwBVHLlK1TYz9r02yK9fL1Bw1hNpUH1BFB2XDbWyHRPVkq/TqPJYuiahB+625P9xm7RdMW1LSFIw/vK7wEmWwhuH66/2YtprXc716l1MbNKyivIcPMpCIzf3X1rwg/+zPvwxmtvetCf2x1bD8a3PP407DhsM2b9TCnsbdqSz2NnfJoYZaI4s7vJpN1FLKuiQYZEBkqpnbtcm6JAhM3fgzr/8/WbAUcDGk6muQ1TwbNHzIOBzd8wjrj33gXWcxan+oyCLFIGG8B1XXRacyjzhAwATrArUEGTRKvBeM5qo2z6+YjQeAsoZ0JuzyjAW4ydJl5UpmZU74CoTa09Q/7ctOct4Obdd+GXXvn2DffF6cccju988tnN9Wx5PRXA7MSE0N/ftZ7tyPeYgDHAmFKjspDHTc29/eDTM0Y8A7b4GAoYohSCNfTeiyxI4kKM0Z0LDrKik6JA4y953/iI0h//H1dtAEtWAMDqeNCOy59wLP729y5tGjsWUTmbJiYlmxZwYebiVCcEdXFVh32hruViFMhaMFSdfnIFQ27iVaBTYRYtNA7qZOrvY9rYeLIAXIqRHafjKVk6gRoayibojV045dCoPm/4Ulo6JJ//LMWnIrQTN+LORfd5CjyLVt/Adi7n1wMTnkKVN8QNtfp5026Fxr1UNW7evfbLPMze/X/6M0q/3EskpI8znNG1OLX5vDXBIOrGNNJ9W65zQ610G55qrtw10QXagTIzp6Wl8VIppWopdeO0XGtOFLwJmJ8iLEWTy4mcfR2QcsBySJjPO4fO24ZHfe/avNPfpbN01WtSG9qaOcZQ85+90zfPTd9FXPmGz+DFP/eu1eK1Og7Y4w//6xPxrV9/oj7nOjEezZOGTZP3S6F/ijcIhCSBVKCgrsMLMVujrpQu+LUxLQ2V34z8zC+FTuxAwEh2QKiA4TAmrM0rmKCRqJ29v9qkR4mMtUZzOSRNMAlNnWyApWZ7w4PARaMQPaDtVm4tOv0+ujdw1xtveWBllMjYCC9pLi147tz5gzDHVC7nJG9+P7d0F/OAmTmQl1G1G/fzur52nXOS173DgAAv2SKjgMU4gRkm5Rir0Fzh+fmzM46hDw33c92j/f6TsqN3730/5/uLTgrnKf7cj1t5WbtvWmY6HnA/t1jden4//ckFfvgX3o33ffKL++TZ/ZqzjsNjTj4ax2zbYpN0x3nnJFeN5YJN5aMg77GLCAgYHbuG5m+qyYYH0Yp+P8bQNHIx2oSX7wdO24/GvwoT9oHVcPw72QELvqGET5pAQEoJd999P9ZzEQAgCciTKkAFM/eLMarUxDNAAyLgmsiCgNjJv5dqTRiDSSQgE3UQGADQu2Y3oDb/OdAvIApYWf8On6eu6yvIBaDre3XJ95r/1ka6Hu+54XP4q7de2/zbFRechNOO2YajDjtEwMjcyCr8s0vqffUl4GS903XPJEFZzAizuvzHUJt+SnE82GSpYxVo6njtEdoYwmKSYiZSUMTiJRlREyNEpuUGf2QFkNWlcdTiHcK+6+bd9+A3/+Hd+93euwIAHkbHOacfjre94orm36aZmQVQ4ztPu8qlTumZ8w5YkztI1B+jdqj1i84fwHr4+ghRBkCatEfiombfErHDhmkt6ZN07SQI0Ln4nXHcaLDSLtzBLeamufTOoZ6ySFo9C4YYWAC2Jkjt9NyoTdODBUPXWTxJmJjD0HmfkUCkw1tEkkUesmgZR6NOMou6vpb5PlT3Xchk3/TwKWWln4fQMgGqwYq9rtd40tDQ6w4pnYACE/b5luo+TbNEAw0gdCyLyMqWxdwFZwCEhhpqlNX2+wV793AITktrpoXmGUG2SS/sBfV+UE8FGkNmff+MS6SWWD/faGBBccyGaSzgVOLwF3/3SfzUr7x/tXitjgP2eMmPXojvecFpukYTAMjZ9hRqff1zbq7VJifzQKw5t8taKqavXP/IhoOslZycEjTte/NT6YXZlMaiE6vSNG57f86B0kiVWPSStkvaOtcwvic6oHsplY+Y9Tv6uJf9nE72BHdL4dQ/YLFMjVY/edA+l2ZyxZjFdspcmv2zk3Ppc+1rDWBTz8qmSPIZ+RqeAl+Qc1DAxO/nBH+8IRr3iw37OSMdpejnuszBwXKsN9J81tnkcQK8k/LL79PxexhrrVMB4/o6ZiJre0NBMDac7uewyEPnDs40AErcgngJtCyLpHvROE7iEYdkqQWT/XwYMq79wD34oZe8c5+Zj3Ux4Pufdh6O3LoZa/NZg0bQXK8xwNMxqSQERGPvTH0R6j2VnbMAwfh6vip4Vo0aIa7tWWQGTCAo8PeymShq0xgDvM2wN1OEAzOCYwBo4oGLz0spVSPARUEuuUaE5lyBmJwaKni9lp3l3jt5QWkkJi3g5U3zgNoAkwkAN/mHAw3hzh5NU2tjG9FLvTjre4ROmAHyvpTWDjMF9LU4APzFVR/A+z91i9R5ERefdgwuO/sEHHTQJue7VBMESm4jBrOkOnSdsZaiTOA7AYTUtBnCAJZYWMo37Do64z1JPvA+DFGaff59A6Nkbcu5gisuipHvh6wyA4mj/h4ZWb1+v5WT+X3oxi/uxh+8fv+r81YAwMPoOP3kLXjH336tGumx+LGFGE0DOaX5cdKrE9fOnG27GDGfkeIvyJoUL8zv1EWKCzmM4sbIHBY+Mxfv5B1Z+XVy+kmvqWx9DVrzJo/0e9q1uS63TqnTDQeuOeQCOmpT3FLVk2cuPMAT5F1+m4cumFngbG8U8rI3Clrr+ptykagmbJim0PixixvNhIYxN5nISZ1yjXrPKRsXZi7kdbIe0XdALs4R1VEpCajQn0AjkBLjpKJOmTqntRzJ7pAsYPpChMl156Ll3WULfSFEk+s1wNjAiPAskaIshlwKsqRQTO+34M45IwaV1sj7bcwGVDnHWxqYGZjQgla/9sfX41f/+LrV4rU6DtjjZ77vfPzki875dzzndZLDqDRbX0NjEMXIQEa35VyaNBo6yHPfqAkqXZM+E6P3OWkTYBTInJjaQSZpuj9JEz4KCBtpjuv2kCwTxE6iBfNk4l4n5bmZHA6Dma/GYPK4Wefd5af7edDI1exMCJN+DX3/nordGqsagMI0l+Di4BQweACPlQ1DiGw6/2ECxI/JzPXojcCIRbLAKkU369+cZsNXQCArk8Rc4WVyyGxwx4xQl3bd86GAgGf2LcXBn1HCTCyizCQ7qVuWi90FsuVS3c/nG6MZmVQRQtFmcLqfhxAw781IkXXE+qLg7VftwY/99jX7VHt82tGH4VmPPRVHbzvUPX/t1N6D8wS3coFopdEY3bH5LwVC+TdXz3ovZgXYk7IMg5NpBNXmU0/P5lBZBa5RHkueOOw7w2AXQceLTZ8r/RxC+V9fX2Ax1vi/lBPSmISpUCPoOA2OIaKrSJGa/UU1BozskhFCBIKYLE/YJFavlubfOnjbvsoAgEs0IAMgxChrGtDPZuLpFZQBgNAyOYwZW5+Z23fvxh++4SPYded9OG7bZrz46eej73uN77RhXK4Nec4ouWpH/QrfeDU56UZAFNlGcQBb0RhGDhkJivB547pi/X5RM0gCDLkYGyqKZwIBghiippHV3qWNAqzXPSAVW1OySCzIROsm0YQhBFz36V34H2/+yAoAWB377jj5hEPxrlc/y1GToQ2RIarm6j6fVWMWRqnNNb5HYuCKxaxFMdZZCJ2w7w0lTClPpp38m9Zgs0gbU0ZKpvtXrV6pTWPvQAnVIsrCPToGQEptU6z0y8hYuSwbsOkEfaHIRcJHJoYpVYLvNxtFsqBtdlkA+Amznffi4pfQAB50seaiUVwCggdC8kSf7+OdSGPle+TnZYE7NTFk4eyNFX3jTbDD4gOLFt4ssroYGipp7xyNCSzRrdhPg9Tp2tH2dUIknhVdH3XSQmpvUzy4JoDngZUq2RKZlFhKGKJN4muOt/kDLIZ6jQikjDRwJGgxJBczFlTv2ne1iKdJmde+1olObuLJLBrT4qw4ffvll16H3/izj64Wr9VxwB7f/IxT8Ce/fIkyZ8iW6pybPNfd5jkfs8ZVhVAcu8gMPkspWCzFh0bo5d5ThOtY7JiRbbT1LloqQPVCCQp+c/JeTXVrlc3nfNZHDKlmvvfiN7K+NF+CXAoWyyRgohVgWcz9DHwtSt8nmMn9nOayfj8nm4zpKxo7mooW+/ROqOZflQ3QiR6YDRbXeR+pxokbP7++n1IwDrLXPuB+bp4Nc2lq/X4eHUPMf05+TenBbGbah+R8YDipLdJcFpFSRDbvjlbNwQI9DxAItNBb3VgFNiW0tACN4kNtMOl0P0hsZf09aRQ6i6DT5sYBMtzv/L7JKX9lvUU9lwbot4bCBPg7N0jgM7JYZrz3bXfjO/7rVbjzvsU+fYafcs7xeMo5J2E2m034KXDsUDN09HpGb3qoEgkUhEKPKqPWZJEJMNINcglLqfdUDEAUA0vWV+b34DTt4pgXXN2acjbqt3TPAZYqUuSaGDvJv6+EYTFgMSTcn6opYC5ZgDKZgDsvgijxh16GWhvz4BpwgldRM+ejmyoHByZFcbb3oADgffwlrWrWqZa974PIRnp0fS8JXdEGeS5WUU1BS8HuPXfghptvw2vevxNPPvsRePK5J1WwRaQQcLGMOWeVFFTmRm3IQ/TeXdDUJQT6A3RNzVwTXqL2K9EV236ok4vJBRSABew6olQqv9SxZCb4VBcfLVlUBhCbgRfZK2OTUmFeZlPlxCc+fzv++A0fXAEAq2PfHYcc3GPn1d9SJ8uT3F6PaCc3ueBEIAh6TTpi8ONqWMyfoWGtQ60Z0pgpDbVonLKyIUoZLiqm3oacRFBvz81M3ZwzVFfN5o+LmC7qwfT8TXapNMPB3eqaMRpb7Z7fudhYQ5DTWhBaE+2H/0Tl1ReAWk5SBAs2MB6mrIPeTX1YkLJg4XvwU+7odIveE4AbHs8FXZd5fUan96fGkRMtX3Tx2s1nUSOT/FTLZ1k3Bo7i+Fwmcgkirj6n2KYzMJqlQ1HLhDnBIoEyCb5+78zCLB7KYgeLm65xurcc6mY1l8gnH41JwIS0ueQinvz9FiZmiEWor/1EqlImiy6L9R/8hffg5a/duVq8VscBezzpwmPwyj+4tPk3pmbQKX7jc25pLN4cj079XC+9sR7z14fUZn+bS7yXV0VNzyHwqpNw3bNo+kdndujfZlta99ja8FP6xhhD9p+c8nNdqQyrujEMVf9VwYoCpTgTNK6u/26vEdCAzWoFCExKV9z5tfdKB3kW7cZ8QrD9PCUztqJWH8Fo6T7idW/7OdfWCnpEXScRqlEfmQS2vpo0TR23pcju+6gu7nADAUYEkx7Ohor1BJvG2aw6oA9DVvaA9YhCme5iIzPjXkmJxaTGbwD9KpmMWg9wrx6FwcEajfuYsjBicLWCTV0pDcnZZBlsUEaiJ6iNDMGblAquftuX8C0/ftU+f4ZPPPJQPOdxp2PHti0ar5edhlyNg2GDlya2knFspTXY4xBEf1bu/5xSdbyHSRBpljchHjT/UEr1qwgu+q0t+4Ia1AGefWlRhBo9mTPoJ5dLwbBc4P5Fwn1jAopJALw2qDhZTAwRGZXe3gfg9nsWOglfCKAUQsDmg+Y4YvNBcFkG2uhbk2+xh97YsKNZNer/V5aoxP7J6Vqb9+i6Xp6r3smr0Kx9IQB7dt+BO+5f4J7FiFOP3qYNcRFKfxLPLMgzoDT+EFwEoMkAQogKOE4ZHGSJ0G+hFBphChgg55+GkMFN+qOaFhpAO+asjbuyaYJ5hJQSHGNAGDuyjkTHhEJA4/xPYYbWqAUooTgJShAJwAdWAMDq2LfHO175LJxxylZ1F+bEEc7siOhxLV5qMVIXbaj5kjaHXdhLpBojfZzBIMwMhxqqgpa2tLebzWuyNRHAfSNG5rvnxviIr9i7DGFMXqeiwUIrL0ULLS4u3IT8pCI740TVMYa6eE4n+U08EmoR43XqngGQJ1oyXzhM2QFlUlQMMhGYzzrdEDnhyZPz5jWoNGEkmMD3MQzVjVm1boIs06mZhbalQZg+ja89nehMXZ2Hhg3QmkMSMG38Fyaf2cccesdrT9sNdNgPLioyGwLrwRmfOVyvPc+dRYkxLsh/HSROqCYbZMkoL65AM9dh34xgUhQymorTLP7dF/zwW/GWd39xtXCtjgP2OP2krbjmVV+rzznXbL8umnmbMdv29pyXDXtA0OfcCk9vVGtrufqZ6B6XMU0RZemdlbKfm72RRmyc9JKmSlp/7yjidX0pzsvGAZ3yPi3pBfq5fTEa1IhOgIkC0BOwj7XJr+uoraEEcP0ErvrIFOdX03oa5JJ1/YzOqM4cvh0DLgQXBQxtxJXlFmtSgzeopVzAN9ilFG0SyPCojZPt09V0t5MGkAZxaDxuGIkbu1gTAXQgAHGQz67pEKM2zzIIwSX0RGUcIAQn7wuuGWiTCjAZqCyXSffzKGCQB3408rCUZj8HvImyDXhoakk9eYBJCd/z4VvxzBf+80PyHD/+9KPx7K86Hf2st6YOAUPKMmhx1PqJz0J0YByaxtN7bRRhRGaV63WaJtB67gQZIKhu3XVnbPS6QIaFAHMIrSyFjvtuD+d7KMJQIJCQU8ZiucT6ImE918jgkpN5GARz6i/OYjgg4Mr3fhJf2HPPl3WI37xpjlkfsWPrIVibddh+6EHYtvkg9H3EWt/hyK0H14bd+RZ0DVBQa8DqZWIAQAzAbNYjxk5kvZ36XkTxUbh5z10Yxoxbb9+D2+5ex5PPO0XWvmT1fDF5hkWdFpNYuSk741zLNAUD7aCI60IXI1JOlbEhD1MudV3rAvSe1/McDEjyDF8OdTR6MBgYUNmkUL+A6JgQnQCrIEAQjBUSQ5QI6NAmhDlGcC7AzltWAMDqeAiOt7/ia3H6KVvdjZ0VWa7T7Kzu6Jy+JjH+6ULrLEytHB+mGAy5SznUfHtYpI024A7JhyCTGUWd9n1OvGr+XVPr1Ee6kdWGsmhMkNIa6brpIvA8I4EZybm0+cy5FMxFA5kyhHIOjSpU06DBmmAWklMfAR9rpJnQMqGJrtja6wM4oTGFsJFZkCWOaj7vLN4FFhvFaD2+DjeZko3Oye/nAnW7D2hNIllIkgWwlKmMpSBYo0s37S625kOl2HRbp/ulOrJ2MVoiQKgxj5zmTA0e95Z0wOn7kOoPzPogAJe9L0Zv8X0F94JDw3CgK6w18szHJuOBxoz8u2Mq6GXyNUrRxUJYgjMsOWM0E8Qx+RzqVtJxxQvfgPd+5NbVwrU6DujjPVc+G2ecvLV5zkdHu06c/rrnnIZvpD9zTRxUHuZm8c6kiU30XLLiB5dMU5gi0AehZ2dJkikqHygloOuKMpZo5lej3rin5uqQjzpNpE9OlBxyJqpQEkAaP/PjQ6jT3nFKuXfSNlKW/X4O2X+zpBWQ1q/RqjNLF+hc85CowkAAACAASURBVM791K9lcE0Z5XMsjoucG21WHXARg/kczHpHaXa0/KVMOCnHasHmYAaK0cAN1gtwPjHU76aU1bQxlyBgeWU/pFRBma6LWCxS/f8YUGSKyPdUUGojFIp63FTwt06OjaXHaLmo/+WZJAuF952aKLpGPmUoeO7jhKMYNDI1otnPi/cSwIb9XAEAjQuqr/uO992Cr/++Nz4kz/DB8x4/9IwLcMThh5rpXbYayTdfncSnEYgzUM7uPbJk6D/BeMuSDYzi66lZXgBKxgYvkaJMiohUpK7x2e9CEaceH45mDzmv1L977blFQ2csl0ssFyPWc8GQMnJKCoTtrdkqKPjzt3wU96wP/5/P/WGHrOHQTXMcvDbDWt9hy8FrOGjWoe86G2qAoKjo3zuCcxVIufO+Be6+f4k77l3HPetLfOH2u1AAHH3YZpxzwhE45xFH4vgjD1dKfhLafy5Z17fi0hcKgCBrjZeGGvphYJCvF/35qf0DJUGlWZMiRFqQRu4M+vre9Np/ZkY8wq0lCFbfVpC0Uz+GQr2VG/YwRYA9gN4XJev/NyljBdh5yx787j++dwUArI59e7zt5VfgUadubaYfRC+JRja5qzKtHhN1j6Gh2E+dZ7PsSNTfcWrsHW+HsTarcGhfJ0VRKcE5rxo2nlGQRov1y4r8Fp26wumWqMPiBFm1kn1sGmjShjxKzulR1wWl0896Yzl4t3vVSzZeAZwsZDchaBvpLI0eF12NeglBf9fr3qYxNKQNesDCywcU7CD10cUJ+Sm6GeK1kzMFKjZMq41qy2n6hmk2sCGn2KciUMvoF3ONg+yibkjeNHAYi7pgq7+DO7e1qYcWq5zG+AgYRXhhVFSdcsUW3EilAiS1eK0b1mLITqcLS0tAfT4oefCTQ97DjHwksLIcavEyn0WNDGQjkAQE60LApd/2elz78d2rhWt1HNDHu/7u63DGyVt1Xa5rhjzns6gTJk6vvbGtlxgFB77Nerrgm5lcKQXror+v0XZFsuprMTyMScxnuZ7lZk1n40o2z3JIKulZXybdg2oUqO05JVSdOGUABIxns05MxNA00zS2Uvq4mN1m34CLPGA265oJVxE2Hj9jLYTdnqeT86gyq74LDbuMoHIDkMs6GLsoRXlW2VcrjYrSeBfdr4vUGUEmgeOY1Oiu3c+DMrsC2npAr0MxAJZMrroXC/MO9DcqMqyArr/LIYmRbVCmAov5lGw/LyWIBtzuLJ+oE8gwlCnymIrqmIPIV1jldCJZ42drInHdjdsk/jRSgNBMwx9oPyfw5I/XveVz+O6ffsdD9hxfeOoOPPcJZ9neX1wzV9rUhagTeAMGWI5kiXjT6W7JFuGGmgevsYEhuobfGdBxWktfB6EeVpAHGLNJSnTC7wYOnRveZHWY90zHIgwHifwbRyyXA9aHjLEUjGnUGtgzHIm7/dlbP4q771/ut2vy4Zs34fJzT8KpR21FCcAx2w/TZ5zO/gR2eH1ysdi/Kj0y1/0K6PCcG/Bit4mtjQTfCjLSaHuCyr3E5JGR2jHQcLMgaz1ogYjVHDSIXxMHWxVY7oVVVAG9yXPqkk94bxFsipEGhAIEhIBOhlk16tGYKTft2oPf+V8rAGB17OPjLX9zBc49/fCGIkaaHfN/GdHim0SPmpXGNyBP4pWCNl/c+DhtmInDO5txdecNkEKnqMFSEDg8jdlkCWpgE9T8Tt8XpySRXgWcwBuLgdTuqZuxfx9BG1/oa1pW/cZHgZOZrvebAUQvuncAgAVXykYn89rDahqUHb2ybDi/nJZEp4WfSg+mKQHT78Vo9MIQvhwLwdxX+btT6uPeNjE/aa/nyvJd/XsgAMDP1Dm9Pr0G7D2G5n0VR92fsiV8asL085knhQE6BBX08zipCAREct5Eel/EaBMrZdZk+74lbZjkwZsT0mOjdR2vU6jznnklvnjr/auFa3Uc8PvWWY88bMNzzli46XPOtYHGcFl8R2wKbS7hSkENNjENsMI8K4WzSGNa87apo+a6lUuxiRKBCJmCdX2lduu6HIL+rILquTQNAL0Gcs6ql1bj2pKVXTDru8pyIFPPNb3FmahZ9JZ5wVjjWBwg6hoROZc0XR2G2sz0fcSsI2MJmmNOllRlbWVlbhEgZ/FLXXsXzYOFgA4/s5nKBvVeoGkbNdY0KxzFjDF2BuKzqde4WDmPlcpcp/s+TYfvnxGPNBXjUKIFAFpQfBwtuSFEmzauyaBjGEvT9Os+1HW63/RdROxi06jWaaN3smfMMiTPPmvUYmU0lEZLPWW4+P08l4KXXXkjfupX3veQPceHrM3w41c8BodsPliaaPPk0WuhjL3YXB+TqVrUZGUyigeAk6Dy91JKqnGnVETTBxxNm3puzaQPU++GaIlGLgJPJ79e0up+MRdbP4ZhwH33LzGMCeu5VB+AlI3F6ICJT37xDvzjh/Zf75+D5j2+5ylnS806x/FHHY6+67TZr/LY5ECorIuapSmgGfZM5TCa0lHcc5yL83kqzXUqypSCMg+ysEN8LGmjIYYlF+gwKWd9hs1cG40MiMaF9Frhs+01/yEw8pweIkXBJvvM9eudt6wAgNXxEBz//BdPx+POO7Jxq5/SYaipZLQdo49qU88NMCv9qTZGRZv47OLtahRNalyIh7E0VQZNg7LoxgOA+bxrNtVeqInRRe6QldALddpPFIZkk/sACF3djJ+8Nr6a4eXG6VOppJQldBsb6CKNem0og5oLBi0mS5NNDbReBx7saCQCodXE1/NiiQecLM3Fnd5LHLzWiP+vuv2+NeNjYWQId/3a6IdhkkxQN1Y7h9Bz4QF9L5WIEidVm3yoTGPMVfKhMYDi2O0TBtrIR0ta8FT9IMACUw+mLt6cSvmYPbI2SAldDlnPHQs8AjTKCGDaASpYVaf4SaeMflLG+75MJjRkThgow+zp1sQx54KuDygZOPeZV+KWFQCwOg7w43V//jRcfMFRk2mzydBQCsZcSzPG1zEmlrns/jnX9BFh3NQmvqjDujqn52zgXmc/z+fcgwCUv3lKvoKvMOOu+SwqAN33ZmAbYOshvWe4LyZJvMmOvj/I55nPOnP3z5Y7XZtxqEdOLyyBJG79ngHgiz1LFqiAPRs16tEZ0ao59GPR4p6N12xWAQCuvbM+umFARNdZXB7BYe7nsy6qN4EC4iLpqNfefFZmM5M7FI3vClr4U6IG0WXXwYClIJGuzQn5QkCa6tMw9Zyw/byd1AszYvTpLpJZHi2GjE08z2HfB8y6iILKPNi01utEmrVA33cg/ZysBI2n7YIyI7xRr09bGEamGmzcV8dU8Kt/dC1+/U+vf0if5ceechSe/6RzXeydASp8pni+/FEcVd28M4rqynPKyCgYpennz0VNZzL5KGPbgotDJqCCEDd4LUU2hDEq07Wp7RxrQwdnMGCwmpVmrN+/jvVFxhJi9lgMhKLuvaDgQzt34W0f+/x+ux4//vRjcOGpR2HTfA3HHXWEAYmAPnclZ4wCAlSQpsYp+nWx0EwEbaqGxfS1gy/4AQxaCUZ17C8qmSkqcxJ2MapXl3GLg8Y6sm6EA1+ttjVQj/dMFImKJBdK3HNoDMNZP8apD4ozHuW6u3PXHSsJwOrY98dr/uSpeOKFO7RZGwej59eGtHNoLDQejZuI6RxNQzlmMzdis+nNehbLsTaC3MCkGAkhuAIJWkyQGs0iyGvYdYJeqlkd43qSK5I4febXALCQ6e1sIgHg4XX9xS0AjJKyeKl24af5YN8bAkgdKVF3b8DnQOOqvRzzhlx5/j4nytnppvreYgy9ZIGNvEoc3NR/dLnBBAayi83zLH4WCDxv3hTSrnt9H3X/Kg0zxE/fckGTRkB5CGP6FPCINRqvAj9RI6B8HN5AsARtPBRg96fXORant8+6mENouhWRZ0Tf+jIpdT8ocs+GIWBtxnNePyPBkVF9JaAgTc2eFk0ooNTNcaznYy73J4MWusiEi6yxTwrQADjqwr9RpsvqWB0H6vFXv/VkPPPSE5Tazem999UwQNKeX21UC7AYku5ZQSqwJLT9+lzXAnw5ZEkDscQSCMA9plz3io5JN2IWKn+3JoXURAFOrFgEkuVk6x8aoKCumWYmyok/p9sV2ID+f3ImpAQACCpzGtZPomMJlCTdz4s25mzovdGrX4cJvDfnVdZjMxXOziRVfA4C1JtnGIto2BvHXmFe1P28eqFUAGA+i7pX2n4eFHTYmwQACMq+Y5IRG5RxrH/XwOJsZl+S/ML9nM7updi9xv2cIK+/l3juGJdGCjQNcpWNkXIDlFAOOJO/WQEACADghi5yH1XWXf3dus91ddr5ZfZz1ls+wWZMGT/6396Dv37NjQ/ps3zI2gy/8Pwnufseem51ECFAURQqN2s2mrDRu0LgFYmPriBeAZDHxI0ZRZ6R6itQVPJHiYHJLYI6D7dDYrHjk/ejNY78SPB1w2QaTONggk33r69jWGasp1wd/nNWAAPORf6zt96NV7/nhv12Pb7igpNwziOOwnFHHdFIUHQyLg3/OCYZYmVdP7y5H6+ltuRqEG43sTfVIzjQxThx9xc2sivuldkUxJCRDEuV0FRAgvU1mqGosQLq+tepFKg4k1eV6ILeKHb9sYHREFXqQm8P/t2bdt2B3/3H9+1313kFADzMjv/5G0/CM7/meG0UuZl77V80rhiS5JlzCqAO7nSdl6+z6Hl4u/fMHE7mQksjpFysofZNZnHvx5ulcXrrs965mMxnXbOhUfvmI/4qNc7y1VkwePOZ5cBYHis2ejFxy8mkBXtz1R/V3T/sxeEd2kCzAAgTuqpvWknLpMO9b+j9RLxq4qFGc56V0OrP0SQkVKDGpkrFLWIetCDY4ItH9SUQgIAgC+UcjA9sNLfBXHItMqfV33uvAqWajqaRL6UyMTiV47kx9oYxExixyDgpNf9BC8xw+lX1WZDiyyYvOZcKGoWATfMo5l9y37vC179nGjT1sWp601ic/MFACU9pZcSgv2f59z9+4x144vNet1q0VscBf/z6T1+E7/rm0x/wOfceKf45jwLQUXPfd3X9YdRaLgXrixGlFGyaV709WV9rs6jso1IKNq31qvOvE9i6wHMSH5xjO+NPKeWaOz8SNi98zr3BKfdWmhdy3eXnHF3Unpr1SaP4iU/dhcVyxL3rCRHAbXsWGMaC+9ZH7L5jQM4ZX9h1P3IGbt29jt13LnHr7ev/puswTWOZHrfuWaBkYPu2NedX8K8XlSWXL/sTm9Y6HLltDdsPX8PBB/Xouohjj9qErgvYfHCPw7fOsXXzDAcf1GHTpl73tLNO21oBZTFurPcGRNdrAECkD5FM8plGkFJWXwnv0cM6hFp/T2HmFL80QFNQw0c2KpoVnrLu52Rz2FlgDFkUanpAEhCDUpbZrJdG0ujzUUH+yX7uWI7jmPHs770K7/zgrof8ef7WJzwKjz312DZG2oyZNHs9MO0BGV3oVNZJgEkjpUtBTlkkAbkZ4gRIQ0cmHozBQSZQ10WVyURp9D2wQ0CiAJo0oSkATqIQ5f0WcfX3IEIpBfcvFlisj1jmjKFADAsdlUTe9a477sNfvf1/77fr8ddf+Eg85fzTGt+v2OjuZX3KyUl4xReAnzIY8JPJ7lXtf9HTwqETo0L9ChEn8dw0/Ayq569TKJN2ZqPxO4B21llilhrCCuDUCeujvq9oAIUshhWMcBGMwZkcKqhE88losl1nSFhNAFcAwOrYx8dv/eeL8Pxnn6JNGA0vSEsEgH7Wobg8WlLqugg1CwRM917NA0OLusFyzxkv1Em8DwApxKK59YegTsSkerNxIijB75PCOYw24aAkwDeXHsHTz9a3GnpsaOJt2q0GTW4jaTOloSBK31uxptGCuY1v8oZ53Hz4HryjtWqdgmnYPaDAaQnP0yiN/KxrNeR8h0tppj29neZYw5hVnpGLlwQYcOGj/gahH3YxuGQG6kPNtb+dagR9z7GJjixNXB/RXMv7RUMzpbux3SdtxvNM/+7efQ28hEPdrune7CZJ/LmU6r1B2umSRn59bKQt83nVaS6HjFnfaZ4x2Sxd13oCMIkiOzaBUtCkoE+54KP/sgdPfv7rV4vW6jjgj295xin4g5dcos8512hrvNrWNKUk66kZc9WovTqdSpSwwfTbZLh5AKCuNVXHP593ewUA6A1CLTpk4hqF2ZRJVXeGYSz86DVCj5qAgH+56S7cdc+A2+5YYM+dS9y6e4Fdt64j5YLb9ixw+x0L3Lp7oZXZrXsWdbK/YgptOLhPb9+2hhgCNq1FHHnEJhy5bQ1bDpnh6CM3IYaALZtnOOmEzThoU4eDN3U45/SttV4hGIDQXDdP8Q2653rfHRer6PPLAc2XByp12AYQQWQX0OQIBAOlaUA2jDR+ZDMhccYhSKRhVCCBho0KUE2iex/11Ffji1+67yG/Lsdt24wfefbjGi19gGO1iDEmSmjzkNHSxUfZpK0pEw23mwrb8CFqc1eHPdHFSDoUQiQA3vsouGjLKGkBcDF6NHMj7Z91CeMLk5jALYeaBHD/mEWjjskUvP7f/YsBf/jPH95vn6sXPvUCnH/y0Y3fUnGfRQ3/aI6XC7KAAfR10sk4zRQZv0eZRqkmj56V6/X+pO8DxjjOznjQokihzEo4s22XH+XSSov2O4D5Q5QQJvGm9R4NAhry+vOG9sIqpkdQTpRz6xMRQ8DOXXvweysAYHXs6+MlP/FYfO/zztCJOp3oa9NmFDduHNUNtWrkp/R6jVcK8tyQTugmnbkAibQ4VKp2LtBii87q0Rn3eQDAH0pVFHrl4DJvmTs/m1X39NbIqGA5sPEzJNG77HpvEEY/dXHj+yhNGulGAEA3XPmsCAEyxJfm2YoSv6AtxQDJKOJOAlAw8VVo6ebDWJoC1oMFdaIEmeZDJ9ldZJSfeSX4pAC+Lmnreg2cIza163N3Pfi1gRRR8ovbqX4GhFkh52Ys6gUBLVzMR4K+CnRbJmU1hCoHyamosd9ycC7fLKbkZ5fLrE29B4B4vdioq2/BkDETmclCqMGb1noEr0OT87ZYZpMAwIyd7Hoa6yU5gMQDAD594fpP7MGTX7ACAFbH6nj8eTvwmj+/vDHCWzo3fwJq3EvWFzVii34BWQzf6tqSVYJDbfRymWxfEUbbmjDcsityUypYLJM0a5XWOSaj7PskEe5Z1HtD1ouPfepO3HX3gN13LnH7ngU++i934NNfuBef/sK9dWo/5NUF/wofO7ZvwsEH9Tjr1C3YcugcZ5x8KE4WgODwLXOceerWup85E0e4/VzmHE18MIt9+hXU+yRqJOTaXNznEzQi0RvEUY5ZhwdFnoMKUsz6qOkSCLHuQy5doA4KoHUCANyw805c9I2v+Yqd4++67NE464TtSoVW2nyxvZINY26SD3JrpoTSmFlOvZrrc5lFSmKeHPRkYNxcCFE9PDi8zyXs1ZwOML8J/2/01IiUG4iuvMigY1gusRgGrA8VhExCP48QCjks5vTl7/gYPn/73fsnAHD5BTjnxKN0YBMck4Oyh+KSurIYHqpvA6flbMGdlxIjN3MuzoMhOmDBgJXGjE8lIe3verAguAEcTUNpOsqJPaf79GUIghro0DAYM4E1ug1GscG4MopvAJy3hx9KoQA7d60YAKvjITj+2489Fj/w7WdqM1g1eTZhZ8yad7cfNcu4Q4zFuQ9HMQ6MrqmtzIHOmQnSdIcutSmTis9IoqIT6OWQ0MUoXxs9khpKnczHoIZpRAfZFG5s2tHkCvtpK2CTee8PoE1hI1kwIyBdjLIlBdB4h2g9o+10okxDw75NU+D5Js3To522YELd6HNDYzdghF4JXmPuzQR14qXZp9CIEgVD3KmzIsUvB2ho976IJtjAjVsp/xKTyPitXgzuyNjoutBoRXXiH83ZOqoMxIEhbjIzpgoMqd7eFTpZI7Ac5au3KYheh2xTtLVZ3dxTzuqqTSnFfBaUDshNgYV+TZow+qgHNFjwMdKSbAkCI7w/aJb5jvffgm/4vjevFq3VccAfxx95CK7+m6/DlsN7baqGIashXqWdZo3tq9I1M7JtYm1F10/aP/+Nz2CNNyWY12ZQD2OWdYyysPqc97KvfPSGO3DnPQPuunuJW/cs8NEb7sAtt61j9x1LfGn3+qrBf5gcXQzYvq3KEc565FZs2TzD6ScdikeeuBlrax22bJ7j9JO36H5OyjEBKO7nMUaVzllyEhkDRY2XmdBkjU6RmMaMXOhW3jURZvQwqA2Ixd2R7fbJT9+Fi77xtV+xc/i080/G084/VZuzKDr8LNN80vVZK7GW0AlvNvp/baSyemm0YIK5wn9o5y7suWcdd0m83u571rH1kDU87wlnim9PRh87bc6aZCFnEOflILOuawwAWSuREu/lSOOYcP/6AikBS12vjP1jQ6aAN157Ez5806798v5/4eUX4LyTd4gnRWnOiXe8GmtEiBbilXEhzbAkpPjhWnHFbwxWC8NZhmhUpGOC0L+vixEjM1MF+GXdSFYokwSCmoOabKZ5s8JIUClK41XQ1slFRD9ZvULoIRIcIFAaprR5Z1UPgN973QoAWB37+HjxCx6FX/yJx9aNKJsbcIzWNDI2CQ2t36hv6pxL93pBZ/uu5maKGl70kUnp2rEL0jgaJSblNpovCQLLCWxytEYfcRMnizM3Pk7JfdSGz6S3+ENDWrPX/biprkXuiONuLo6y1T4k0UU5+ZgdAgN8/52bFKn7q6OfZWdg4lFCehAEcDLv83INZFBdaZ56EViywfR73FincoMmvq6L6KNpEvk3fJSiNxCs4E9R00E68AM1gi8JsOLdiwkm0PTPRyROIw75mWYCUBkw1EoC2vumfa06pav3Oa9HdsZaGhkm19bi+gyIAVoTLn8uvFdEdhnNUQ1s0NxzacLyeNeHvoTnvHgFAKyO1QEAf/Kzl+Kyy47EoVt6BDr25yxrc1bT0ZyzyIDMu4XP3JiKNmRs4oOusVzXfPSf7X8EAq+/YQ++sOs+7LptHTfsvAufWU3vV8dejqO3b8JBDiA49RGH4lGnbMHjH7Nd42K7WL1jfAMVnYli7+Qu3POK08GXnFVm6RvQmnITOVfXoQD3pL6LeNeHduEbX/SWr9j5OeyQNfzsc79awTXPlPA+STXGr2rEGdFXpKMzcL8IsyIj7CWWuqDgle+64QEb6oPmPZ501iNw2XknVrM3b9zu5IT0kmJ8XRe7xmcILr5Yme3BPC5KKVhfrGNYFiwYYShNMZtd1qUfuWkX3vCRm/bLe/u7n/oYPPrkHc53Rab6wYwSay2WTbtfbLRWcjVBDOKXwGa+ArHGAuCU39braAkQChAVqSWNJUDwJyjrsmzwqOpiNc8MMgiDmDd3caNsJ4QqRwjF3X9oEx8myZv63Hm0INg3LUEgAjtvuQO/97r3rwCA1bFvj+c96xT87s9fjEiKokbXiAlgrJT15Kgq45g1hk2NcVQ3Tgf6mntJwE8beNFMYoKQdtFpgRoTDzakRq2rDTOc67GZ99EgcHTsAD7Q1NwA0Ig+utF7d2NjPNh5YpazxTVFa4zpgdBBzXt6kTuoCzNqwoLmPAMaxRSdjIKxhUGlFu3f8lOrGOx3p6ZD/lDE2U24p278XL7IoKjnrWiR0EV6I9CsTtyVU1a9Ie8NoE4VqIVdm9f3b1RG09fzXBaXpsBzAwTMhQnCqCmeVw8AEBzonfeASiAak8rovAkC5rM6qef3DfQoWkRNc8YJNtXPlxzdzYouTnl8bnWRz6AyGuqK54xutFxamlUOAjAQbHrtmz6L7/mZa1aL1upYHQB+9BvOwxXPOBFnnnMQ+hnUrZ8RrbX5rs99ndQXbezpgG/UzaBFvM9Ir3IyaJY1n9UPXLcbn7n5XrzmTZ/HNR/40upirI5/PzBw5EG4+NFH4EmP24HnPevExgiSgDIbC/rj2CQz6JS7jQKcmOl29NKpe5VGCIqB4Nqsw1+95lP40V/8yk4df/hZF+LYbYeqFJCmf6nUyLaO03WgmTZb45VRMif9bRSld3b/2Oduw1++7V831bv4tKPx2JN34KBZjx3bD1N6Og03Q/CMoiCTanGMV7NIB2aw+efag4LFYok0FCxLxpCSfpbkou9KKfji7nvwN+/YP40AX/jUC3DuiTsa4MYAHPOsqLT32uyjFKkxyYbIXtQviSpZ1+pM7adM1rtgEXyMS6ScoIvVn6UEMWvMRT0gaO7s515M/fAxgzXBgXeh/V3S9D2YxOtfnLF1EUCHRpJMDWDcJX9f700HMH36S3fi91+/AgBWxz4+Ln/Csfjb33+KJKLWZrbr7EY1rbXdAbVBNuf+IZluPJh7h8QQmcmKYGZumls0Dm3WR4RY/QFUEuCo6/y6atggjV8R7aVFw8VorupjytpgMZaNOrpULAkWqPrR2mBCGveiOvnW46A0ZoNssOtD3+rpvbcAm+NO3YYty57vp0ofjKaeUmt81xideBMhFH2/BDcoU6AWqRSbpo+SXR0l/sgj7DyHdD0tTs5Ac0TGIPqcaW+YyAKbJn+9Y28QXPDOsAR4PLq6HOtntJin7O4jmwpkAVZ6ofsDUAbAmkRGUee/Rn3vSFr/RjNC04JVdgpNKIO4tip7JVre9XzWaTZ1LsB83lUTLgF/qLdcDsnpOksDUoyNN4OlDnQx6HV7xet24sX/1ztXi9bqWB0ALj37eHzdJSfgqy7ejkeeuQnDmJBLfe5LKeoJQPf+pQCwXJsJ0FWAtAIDdV2rQDTXBAKEb7rmi3jf9bfj6vfcghs/c8/qAqyOB/2Y9RGPOfswPPHCHbjo/O24+PztdXgBCK0/qr8FZWlLiYX08YrsJnjPB5qZ5YIQI+Z9J7Vc/cn5LOK53/8WvOMDt35FP/93XHoezj3xSPOfCsG5qRsYwhrJ3OZp9pbF6d2MFU2HbhP4V77zE/jQzlv+9evRRbzoqeeimCNUcgAAIABJREFUFODwQ9awZcuhTV47HPhQo+HkvURGFKIxswvBDO5oUpdTwv3rAxYpIYmnQWMQ7f7Wr/3De/ZPAOCyC3DuyUcJ2zcgO319FAYFB3Rwslm68lcGbnGR0aUBT1KuvghBmvcQigE9brquqU0T5q67UNV3TJ6n6IY3fJ2ixn11+BlC3MDypREswQJr/KNKVvj+c86Tezc0jv96H6s3APDuGz6PV73z4ysAYHXs2+PcM7bhHa98li40OcmUvJh+O7sYpc47ls87hGLNjKc306GdE5bo0DJmN3NRWIjhUhfqtCXl6qweApRmPROndWo8gWrC5gEAmu914ozrm0ACAFE0b3S3J/OAzvi12a4AByn2bNbXZqJHF3d73yR2DngI7rPTM4DNacfm1zXpXkrgo/vKJGrIZ9ITOWRcn3f6987/0emh5rMqyRgGc8WfzaKCINSid65A5jX3vgXTRc97MJQCZyhpjTrPIwGAKNFb/ve4IM764Ewao74XlUxENXJVRgMZGv5822ZSX3uTMBEWA40ug/oAeHZBFodeJknU9AeLpdxEl/+xXq/5LGixlcVpPMYoKQBBAB8oAMWmIzmfguVobIgI+1t9J/c+gD97xQ34qV9532rRWh2rA8BFjzwajzt1Bx5x7EF4/JOPwNEnzNB1AWuzoPsD16ckoGc1IQ1uLwlqVOufzWEs+ORNd2Hn5+7G666+Gf/0ti/UaenqWB0P4fGIYw7GV3/VUXjaE4/F11x0VFMfrDlzXd3PBUDmhHp0+zkN86qZWXSGugG33XYXvuFF78Rnb7n3K/p5Lz7tWDznkrOEKm21I9mLjZSz0U0XbcyKaMmTICdl0iSmXPBzL3/7XqWPezuO2LwJz3/CGYgx4tjtW2tjLw1kElPFPppRXZUABpdtX2srawCLNZoAxnHEYrHEchQfAInHK5PmvwD4i7dch1vvum+/u09f+NQLcMHJxygbZW+dYvWoKA0Y5VkbZAmwgY6OLcCBIU0BeUYsAtXqR55zT/uvwyWRqRYDJzoxePT9fWNIWNqrQOU+2cp9F1Ua4IENZYtBhqriuxGc9j+GiVTH0U2v+shOXPWRnSsAYHXs2+P0k7fivX//bDVRYTPkadbA3vTMZWJy8gB5vsW0TlwAQ4BqsxnPQYOl0UXuQR4e7/yqU2KX3exp1UHimJLzFtAJfDKvgjxxWNWIPrfBMhueOlGjDrmpeLG/03UuOrGzRjznouBALxNtnZ73YlyHYosg0BSsBBqixi7KtZCGP0lkIM18NO6ns+/TQZ/GiV0M6pKviLpzoicrge+5k2KhsjfqJF4XN3mdMNmwzNPAGBoFcLIMn8da9Pox37puGqExGNywIDkgwmJ6JklBMK2jv5endLXojCu7EI1Z0VUtmDrDqt4/KCshSZoFUDDrO3uWGOWUKpjQd0HlER5c8Q0Jz52+L5lE/vqfXo9feem1q0VrdawOAJtmHb7nKecAAI4/ehMue9aROPyIHl3H9aydIhZnHgqdTolsTQDf9117Oz52453469fchE/svGt1klfHfnNs2TzD2adtwfO+9mQ85xknNIOO6Mz8WG9ROjcFtipATZA/4Pbb7sKrX38zfulPv/L08i5G/Np3XqbNWxEGaIjtxk5vBPMICMglIScaBmYbDrifK6Xgljvuxe+87gP/pvd11vHbcNnZJ2DTrMeRR2zR6e60Waw1RNSGt2lMUV3kzV+qghQ5JywXSwxDwf0CYERXk3ovhDd8eCeu/cz+Jzn6jiefi8c88rimJrPI7crG0EhE2FAmwIY/FUCpTAAvt6SPFqfqem1hNXyQE2V/t+0Zau2eWwmHvJa/LrQTjN7ZX3oXGjgG9R4omg4RnATUS02yk5BWRkJUEABqcpldv1Tf339/87X4+OdvWwEAq2PfHiefcCjec+Wzm6ZNjc1gpn61WYuqGc+5nQzXpjeqftsb0NG4g9KClDJm89ohk03AptOinCrVjU2Qp5iHEBC7oAZLbKK9J8AoDVelZxc1hCJ7gNo4vu5imTQxwCLZYqPXVrdpl3rgGQF9F7VxE2ARcPuWShRiQEaNmvLO0sUBHH5C7H+XWdJ072VD6z9LSq6RF98Cfr/mUFtUn1Le5YJXOry9tqf0E8zoXToC3EJfJk3sSPmG0/WbJl5yWNHeZ2RkZMcuoGyhMWApbIyhPhNBvqbfA+83vR9DcNfHov3G0Wcjm/yDDuLqqRBqCkHsQhNzuDbvKqsCkKhIaJpF14VG8rEm8oAKhgSNByMtjKDN3q7Fr7z0WvzqH1+3WrRWx+qQ44KTjsQTzzwWAHDGaQfhiZcfhUO3RjPeUjlWER+RaM+5SLD+6eqb8d5rb8er//kzuPPuYXVSV8d+f8z6iPPPOgznn7UNT7pwBy69eIea9hIQCCFgIXsIByqjGwakXPClL92Nz39+xHf/3Ltx+12L/eKzff8zvwqnHH2YxeyhbaoQzKiz7usmkaSTfClZB0TTpvT9N34Rr3rXv51efeGpO3DxaUfj2O2HoQvR3oujt9Msu3osVKZjEE8fjZCT6olDtpwylssllsuMZc5IyCr/bJqvAHz4pl24aj80Avyuyy7AeScd1ZzvOkTKKt/QxjtXoz84CSjPYZmAAv57BAkquyMhigcAp/wEeatcVYtEYwTAdPpBEhnggKHYeG2IV4MzhdVehj5RpNYCrvEPSuf3g9L6PsV/pgCQ7/cxNmkHHDD9zj++b7+MfFwBAA+z45CDe3z2mudrY8y4tbpJ2L9pDq00lJUS32khVWn7QWj70sSL9hKCiXLSOQxJ9fWVGl21+kDBMBQBBKI1bPr70lSWSr2hBtvr5nOGGuEsB/EAAMx0BKbbb7Lk2biSOsdMdqBx2KdMQgEA8QRAqEY7vsFkl8xJuP+bWX5Pc+JL+3eG0ZgEdeOG0tapWWc8HI35otNLcbrOvwvYtKu+bnBmirn5Xf7srDcwxAM9zGjl/jpNT2g3XNnC1b+hpewpUpqLGSQWy4Kd9RUpp0njrK/I6yDFOwEpRViZekA/BWnUS6lmhKRMer3kmFsUeRwzuj5Io26a/wrMVJ3h2rzDYpnFQCkqM8Rn4A4iSYmiJxvH3EQ1jkmuo4AxmMQ9Dqner7wHfuC/vAt/9Q83rhat1bE65Jj3HV701HPqJCUXXHLJobj4idsxW4sKoHGdHgWQ+/iNd+HaT+zBa974Obz32ts1jnR1rI7/vx4nHnswzj/zcDzlkmPwdZcdr8wXZT3GgFlnsjYg4Lbb7sHNNw942cs/hyvfvf/QjZ9+/kl4+mNOU6Df0/iNbh0adqfXWtfmLOuEliACG8mrPnIT3nTdv6+JvvTs43HhyTtwxOFbmjqHBQhj78jOjLEzA+amkeLXddNfDgsMy5pWsixFfJsk0UDq3wLgM1+6E6981/6nDd+8aY5f/A9Paf7N6+B9eoIx3YuyAxCqLNZOUNFpuIIG2Av9X5ptuCm7T2TykoBSLC2guDzB2oAH6YGiq3OtLve1b5EEAWOXhSZaVs0BaRwrdakxphv3CHi5QK2FgV/+u3fizvsW+911XgEAD8Pj3Vc+G2eeclijHQcbZtlEqmEZDcxo1Gduy5XG34nLab1TOuaeJmtGs2jQOc2ui4TPxK3xLcxs981iKUEmu4xhqxPl2azTRptFHqfmbN44zS0SK8iml1p9Tsn52Qf6FADmPjpZDLwnAM2lLArPKEVEJX3sHQRIiNG8F7Izl8llo9aeUUE0UZzNLBJoY+MtDXx6YN0+3BTbR9VxYeuddnY6PfeZrH4q72N7DCxwPgXBtGCcmFfAIylVy/wBoroBj87Jn94KmlaRvYmMeEWkjJm7X+v9KKaAkk7QdZK7LAaDjPcrxZIk6pQw6j3FAqpzGbFqvkhAJNb/r/4BXTWsITuCAMBoNjmdfE4yLBQUYTxhX++9b/6BN+PN77p5tWCtjtXhjjOP22YFSgB27Jhh2/Y1XctNYllw3SfuwA03raj9q+Phe2w9dIYzT92iE01rjGx/HseE5bLg3nsS7r034eY99+437/+ko7biP15x4Yb4XGqvK/MvauMWRATOSTMbxuQmvL4pfeU7P44P3PjFf9d7W5t1+L7LzsVx2w9DdBR/39jWGjpq86lReG5azJ9jPZlSwjgMuH+ZMeSiRoC++QeAe+5f4qVv+NB+ed9d8qgT8NwnnKl0+OoHFXW6rtGALk1FU6nk38ngYPyfb95rTWQJLpXpm5u63csmegFfTHog8eAhiOm5nP9cXHSjRDFK7UrFPmWjZW9DLgBF3qeCUmQKoDJUspvuW3IEmlrPewL80t+9awUArI6H5njPlc/GGadsVZd2NnWzmTXASv0uNmEukwbdo1/RPeBZ9PSMkhuE2t8szC4GjbnrdAOlkzw9A9ioqXmbNNQEIpj/ae7808WhRetsMl50+upjANmTsVlNSejeXY0X0ffYWXzdbGYSBpqO6MMfnUFdhsukL81kP6WsrvfeZHGaNABUE0O6/o+pIIZ6zseUkYtRzZeMwOuZflA0prFem/raXovOz16lEBbp2CwMwdgCnraukYbJZBV02jYfCfNZ8IkBZowo518/n3guRCAV85JgJEzOWT0bKENhOgTPQecAG8pBDLm1e9HfPwQJvKMw0Vvzpqjf4FTR31/exKiUB15GmXXMJ4yb17O+5yq858OryLHVsTpWx+pYHQ/PI4aAX3rBk9DPZ/VrWPNM+j8z2jVezk2AqxFgaWqz7KjmL/2nD2Hnrj3/7vd32tGH4TkXPhLbtm1pnOp9/Vr/Vmx8iaC+QwHFCgipAzOGYcBikbAQ+YKvEXz04e//0wdxz/pyv7tupx1zOF58xYV6vmsN37I0Uk4Swe1BE2+g54ZfKMriqKbMWVMVOq3zLMqVk3al+Duj7xijggWMKGczn7MZ/dH0rzRkA41t0OtYclb3B9b3Xawm2x5MiJIgECJl1dFin4PFC3ppwq477sVv/a/90+x5BQA8TAGAM089TKnvcMZ2bPrp7M/pa3TNMHM+6ebOm53TZzaBpv0uDZ0+Tyg3Xt++V717qJvC0hnSceGg2WCdzCd0fWz8DLjosFHtOqN6a0QU4DwOKv2efgLeE4AsBfUTkOk8AJlO10dmOSQx6Ck+6lPjDjFx7GWOvJnoAUOqH4BNa4ymh2eKASnx/nebzUMQU2pfg+QAF0DlDikDIZiOH+KmG0NoTB+9oSLZETxvXHT9Oa/Ue5vyd7EFEbxsQa8zrOH2rzkkAylKqRT+YRAPB3H4JkOguGQCei0sh2QAAI0OO4JGxtjgtZ3PooJOIQQnI8nOyV8YAbK4E0zrXETiMKQ6DeicrwBMGkGvA3pRECzjdX3St74OH/nY7asFa3WsjtWxOlbHw/b4psedhq8+5+SmfvF6e8Ac3Gkcpz46rNvGpNTx4sCFn/yLNz+gqfD/6XH5uY/A5eefusEI21PBuy46Xbk0/66OKG6anUvBcrHAcshYpIwx1zQAhhl6I8A/e9NHsPue9f3ump24fQte/IzzsbZ2kEttcEOV2i27aGwOHN3gzfk2sOeIIcrkHur5AHAIOTF5dI2qNqzBu/jb8DCE4nwIivY5rGvTJGGAqRL8RyYLlAAE1KJdmQOR90GtjfveIgCVIeAiBr0R4hduvxu/9/oPrgCA/7e9c42x67rq+H/vc+6dO3feM3c8fjt2HIf4kYQ8mpKgNg/aQKqmCIRA+cBDpBSoBBIPgUQ/gFAlhJD4ABJClFLUD0VVVCIBipImzVtp2pB37DYPx7HjOvHEr/F4Zu69Z+/Nh7XW3vuMU6pQJ0xm1u9DFNvzOHPuuWfO+q+1/n/lg+Hxr38ae3ZNZGojRfOZZfv1UpjJeLy1Bt2e48KY3lRpzzlE11lrACtVLdJ4vMtc30XFi2pZVmTJjRWgN2X8f75ZiNlbACCealKkl5kAkH46w/vZNnofLPV8jHQjx3peJeAbr/zMeYSb5Ug6n5vsVZmwwKZx4icgN0TZRxXRoChMdImPrvBS9BaZg350q7dx9CitLDg0yiIWzKkjXjcBlCLTWhvNEYXCvnvig6zS5UZ5YoR43g2CJxjACmxuglKxsU3BI+2SZkB+Dj5Oisj1VhbnrxrE46k5v6Z1j8Ki5qgvooQYNPoY7VdE/4C0TkC3uMr5eE11exUKa6OzuIkdCMvXsCezHxEoTG6caGu3yygemNTlj8kHhYhFdA002V+j15frwGL3J+/CseMLesNSFEVRVi0Xz4zhd37uWnrWyYu6uEteb0hYW39WARur5bFswh9++b4fu4jpjLTwuZv3YXx8lJ9T67HSeQKSmFaDJxbEkyrfcTcGZATY7aPraA1AOt5m2c/4799+GS8fO7niXrOtnRH8/LU7sXFqFAMDrbj7LwV6oAqbagmprLl5JD5JdWO+lABGLz1PhXKxXlgyGYQHghGTbxunQJI5tXw/blp6DxMCgmFDwWzaIjYyayJC+r6hZlQY4npHbuItngSBH1SliWey6yGmh2WeWHI9HDp+ZsWueagAsAq5919vxTX7OiLQwXsfDcrEsI7GqNNuc65c5uPiniP8jJEdagdwJqqNYzd0UxYnd8pj93Cevp9EBCIrOvNik4rntGcjhnQ2jvaY2nqCmEBFJZITAyDReSZ17nPDKCmKrTWcyS476VmGaUjybNmwcOL0X9hlneD0OSU72+dGfWKkmGf4yveXXTEgTTssjzSkIlf29kPNy0FGn0o5pmx1ouJYwHeLNRTlenmsXi4ULFdcZZoAkIQHxEmKEABbpNhDV3kYztDtx4+tJwIUy8xzHE+MyPqDrHXk3gUybp+bBDqfR0qGTKVNwpB8TRntkl19ZKkYaUIhqfKyl1ZKkkXmcSErM3IdGWuieiwTMoW1/B5AnJgpSwsRnOV1u+JTd+Ot2UW9YSmKoiirmjtv3IfdF2+IzxciniMAHiGaAUpEmxiuRfM872OzIJ/o++N/ue+CFDG37N2CW6+6hAf/8s5+iAWgsRbNsozPqFyH1sQLKkIdnHPodvvoV5wG4H3dW4AP+p6nX8OLh2dXpABw+9U7YIzBps44WoOt+FAoj8nO+SzBwccmidQeVEf4ZNCXxTxak/y46GuE+GwrtYTUIfkEqogNVNznAhEJBZ5jBRH4GbQwsRinmEbA2iyS0qTVAWNtnIINPkUQwqTnvLiywD9LWfBEA08D2NyYEMBrx07iSw+szLQnFQBWIV/6qxvwqRu3xEgNcJEINtCQVzzlK4dYNEu3uFFSh9U5SgOQ/6+yLi+Zv7lY/PpAWmja96cCMC/IpVD1MglgLXo9lwrEgn4JVJVPRTcXw1Ko5SZtnpXB3B9AjA6p8CpYAJDIPi48PQsYQBz9EeWvX3neo2dzQVYh83F/MSU0xqAZXeOToV5y30c8HtmZJ6NFF89zfvwyEid78WVpksMsCwm9vqcsYPYsEHGjUdLEgg8BAw36upLgIMcoqwUlG970Kx+L4LTDj5jo4JyPecQ+FuX1lAMRPJKgEaKRn0S1OO9RFEVcJckVVnHhz00lfRahKOaIchxys81FG5mOEM8E75PfQj0qJsSbfVHYOMmR7oYBztPHlxyT2as8j3jZ+HXKwtTWCJynEUURx/IHAooqo1WGsiBxYP8rZ3DjHffozUpRFEVZ9Vx78Xr8ysf3oizK82LhwrLEnIAQi6lo1BZS40TGs+cWuviLf3v4ghzf+vEh/NYt+zA01I7JSD5bIUwFXxELYPkBCu4UO2nuBDL+6/V6WFxy6Hkfnz2WF12PHjiCJ75/dEUKAJ+5Zkd8ONrUGUer1YrPSgYGwXvq2sPEicv8p5OxfolyjIlQPMlqTX2aI3DRnptcFtac5zGWfMN8+sCQTBglaUwmjkWggKHaI710Jk43gycAYsRfZvIotYhhrwpjUnpFVEWMiFcpncx7h++8chTfeHJlpj2pALAK+cLv7sbnf+1ygAtfUVGLIr3RnKvOc4r3mSImo9eSoU4RH1Qwyg41GWIk4w4pvAaaZRa5Bo5iC7A27fMjG9Hp9WlCodUseIKIxngkM77bc5zjjtjZ9iF14pFFwTUa9DlSJJdFAec8+lXa2/eBBIBGgTiS5EO6Uci0QlmSCshv75RCIAUwn8vSJqHCFoYNTtJNSMaQ+jWn+2wVwtRTGgLnyktRb4xFxTcoceBvxOK2vufu2CyH1jY4YYCPqfIeVUVu+mUWzyfXh6QPLI+2k46/43g9OceSBiHJCeIOSx+fJjTohhmiaiqeBTLtkF9T8nqDBRibTSfI9EAI9cmK3FNA4vkkG3n56kNVBVaaA60NFMm2RfYNJbqSIidJjDGWjGt6VYiRi/mumrF0DiqXoiphLI+U0dft9uncNhoWz+4/hU/86r16s1IURVFWPWPtJn79xr3Yun4S1paZCzv9e1HkXddkKBcz5ePzETeqALx87CT+4Z6nLtgxfvrqHfj4vu3ZLnvdp8ByWhDFApp4fIaLP+lgi1t9b6mLbp+60l3n0kMj0rPXoweO4PEVKAAAwORwC3u3TOHyrR0EAJunJzA42KoVuDL1KOvANG1cN8M2SCsA0gyhFKk4gJ8K0swIUNIWvHNp/YI/P3jP+/o8HeJpkiQ9GQcUxqLyLnX4EWKSQ5wyMWmDQVz+c38CE48h8OqH+KIlnygT0iSIpB4E73Hs1Bkcnp3D3d89uCJfXxUAViG/dOsW/Pnv7UFneiwWZj6k/X8RAKTj6kOAp5oLjdJy9B64c07xgNZSES/FmiiiKRs+CQDNZkmdaY5jE7f33EGeVgtMLFIlCs/yhEC/n97wckMhJS45wedd4Yr3tKWIlMxo2jkLscMvqwqVQ828LhcAqDYPfJ5S7m6fTQrl4+jzkvFLPloeO/o1tZLjZLJfaMgcVaWI9T7E1AL5efKvF2rqJeJYutzIpBsuqxFSwMt+/PKJBjFzdDxR0SgtF9Zp5YJWOugzZLTeezLMCwB6sWgv4k0/iMEjv26y4y+vjRg0VhV9HXkd+xWZ+jWbRSz+5bWOXggmnVOXvfbegzvtiBMdyaOCFOHCIgoAEskn8TwA0O37tHJQmBhZKGsAce8viwIkExt6HRqlSQkTPk1XyLUy0CzwwGOHcMcfPKk3K0VRFGVN8NM/sRHX79qMDesmU5GP85N0ZKUvTlZyrSWrehLn9uzBt/CVB569YMe3rTOC37hpD4ba7fSs7ANKyx5QPINecIMlFoD83CgToNL57vf66PUqdCsPhwB4z4Vv8l966KUjeOx7b67o161ZFtg2PYKLpsewc+MkRoeHsGlyBN55foTliPB8kjUEWg+N67o+rX2IwSM/K8pEQX1NQL5ugPcuM1rOJ1b5a3mfpmRNvoMPTtpy8WKTwj1PBsud++naI4HAGhtjAcExldYApxe6tefwtB5AAoDzDrNnzsI74NS5Jfzn06+rAKB8MPzk7gn8/ReuRrttMDk1mieuxAzWqnJxhycg7duIs7zN9qGjCR6Wj73LjjMVYJVDHL2WvXsxuRMK3p3y3tfG9fPxc5PlZ6abaVb0IsVuFDZ3ATW18XTyI0jmbibzFKBR7bRj7pyPQkUuAIhXgrEsSsgvKGuXqcL1yBjZbZKOeog7QbmiHGALyzcMOo9lWbCamf98qcCX0Xya6OAkgux1EimTHHVNTHgQEaLXd9SlZyUzP34x1Is7/jxaVRZpp1/28F1mLAhQ95tSF6gY7js+pza9BhKRGMf/geifIL9o5TxZY6Ibf7/ynGYgDwfJ28Gz63+UM0we2YLs79LrKTtfoiYnIyKwqJXeS3LeJI3Cyiggv9i5N4NEyMjnkSNs8jKQscH5+Xn85d8dwNf+67DerBRFUZQ1wdbOCH7xul3YtmE6r+VqVYh03gs2+o2eb5k4EPi557H9b+Cux/df0GO87art+Pjei2pFkngfxb8z9ExLqVTpGSY+T8jzVFXBVX0sdAM8PGzgn86kBKyHXzqMRw4c+dC9lttnxnHl9vXojLYx1GpgS2c0dr9zz6naK8td9tLaFO8I1LzELKibLmefJghCvFRijDc/r0khb2JyBNUXATwBnT2Xy/VljY3r0NJES1OgKSUqAHhnbgmHT8zhyDtncXJ+CW/MnolCx4cdFQBWKX/62ctw28c2YmjYYrozGosS6V52e1U057DWUJcXgKs8G8Ol7HYyPEPs1gYej07u7IhKLRX2NEJTcVe/KExtTF3MOoBkiCbRg/TmTcYfUuilAtRG4UIKWSps0wSBdFvFRM+7UBvNEidP8SeoXEBVOepC8wqAdOMrVjgLa3mfXiYpaDdcjlE60UVJpnjyffJx9VRQsqsp6nvrjsfH5fil2BUne1GXK7aclWI7/1jPX7vMBYCCjPm8D+j2HY2hlynyMC9Qq8qxV4KJHgCN0pKCCkSDu/zGLuaI9HkpMULWR+T1zHe9AFpvsMZgiacHogAENlPkSQURAIqkI6WJgqzopl+6JJCIAJD2tNJ4WrwOeF9f/lxm3yAJKiYa3dA1zysBCDxGFmoCmff126vP3l8GwJm5ORw/XuG2zz2M+YVKb1SKoijKmuFnr9yGa3dswPTUBIJkw2fPQrmRb+ywx0IQNUPlr9z/NP77tbcu6PHt2TyFX75+F1qDg9zVz591UmfaWouyKKJXQJE9P4i3kXMOvV4P3V5A1wdYUFc8mnGHwALAh78ZYK3BxNAgJoZauGTjBKZG2hgebKLdLLFpajSa8okRMngsH7UmX1q7iGu07NGFsOx5z5CRn0wb0ASpeJDRg5hb1tEJCPUkApM1bkLd2f/h/Ufw/OFZvH169SY1qQCwSrn5ozP44u/vg/PA8LBBpzNG7pUm7e7ImymNMafIMzGyc45d4A0V/5ImQA75YvxGI9QFd9Olldrjkflmw+LgkXO8k2Mwv1hxvKDB3l3jcRxeijHnU0xfWaQOv/e0fw5Qx1mc2vOdf3Fq7/U9SjasY9+MAAAJfUlEQVTK807yRdModgh1AaBfuWicJ2JFWVAsYsGmed2+A0Iy7utVWWHIZnxSPFc+JStIzJ90kaXQlpum7I45H9BsFNHMJDeSk65zvhtHRbqvm9hJccvu9yK6SGxer++4iE/CSozCA4kHMjkhUYbWJgFDYgHFAyCgnujQaJDRH7LkA+foxpsMEElkavIKSFdeu5pJH51nue6cJ2NDANHYUNIJJK6y0bB4+dBZ9PuBX1tgZKgBGIPNM4PJHJJjD2WSRa77spCHDTKBoV8OAd0+KdDNZhGVatK4UkKAXIfp3+hrkN8BXcfz8/N4+3gfX/nGQfzTXQf1JqUoiqKsKbZ1RvCZa3dgcqiNycnxLH0JteD3mPTOHf+sBoQxwMK5BXz5W8/hlWOnL/gx/sJ1O/HRS7fGfPvofM/Pl2QEXNCfM5HCZgkG5MHlEHyFhSWHygdYmUBkfcNa4IEXDuGh/at7GtAag23TYxgbamHb9CjGh1vYu2U6+Ttkhb40scRnjKaA68bQIrBIxLOsXEgzEYGSGPJEhxh9LhOyNUhAOPj2GbxweBYHjp7CQm/1N2hUAFjF/PUfXYHrLu+g0TBotYBOZyzudwcWACrno7nda4fnyXwuBJw9V0UF7sxcL0bAnT1X4dRcDwgBR99ajG+q4yeWsLDosNR1OH5yCQAwe7Ib1TdxiV9OPlb149KZHKh1cQeaFtNTrXiJd8YH0B4sagpgWRhsWDcIaRQPtxuYHGvGonZkqIHWgKWoDxfQbNp4zNxMpkjAkH47GXa6l0LVZO+yJLRkN7TMBddm40gmK+plT722BZV9LPI3ciampMxVHnECYtG7/EYgN0fDx2mMwVK3ou8dAk7P9VkwoI9dWHI4eboHMogM+MHxxSRG8A8we7KLc4tV/B5LXR+vD7lGwo8YpzLv4RL5UdcZXSP0/81GgZlOCwHA1HgTw+0yfuzGmTYKazA8VGJstIngPSbGBtBsFCgKi+G2hWHXgEsvHn3XY44GMqCx/9nZCgHAb/7Zk3jtyLzeoBRFUZQ1x8cu24QrtnUwMTSIyYnxOBkZsocfw2Zrsraad20XFxZxz9Ov4sGX3p/R+Su3TeP2a7ZjaGgkiv213+9iAmht3OeXqQB58JKCdGFxKXoTSdc77pob4P4XDuGhl95Yc9fA1Mggdm/p4JINk9i1cYombbmbz8uyaW3XBzg5Z5kAIKuozlNzMSBw1F/gBKrATS0bPydNkBRxzP/FQ2/jiVffxpsn19ZzmQoAq5zc+T8v9N5L8aQoyv/yHovxlT9EVVn2thJhSFEURVHWGsYAn//kFQgBmBwexNTkePZvJvoAxA4uCwPWGiwuLOLBFw/hnmfeP2O19kADd960B5umJ+KeP9f1MbkpBE59smUqpMTcj03xgqcowH6fTPBo9TMm1wPgCYA1KADkTA63cPmWDi5aP449W9eRLxab8NGaK5+3QE7/Eo5d86LiyQGKBpdkKxefvwIosSuaEsLg3PwSvv7dV3Fodm5tvg9VAFAURVEURVEU5YPgsk0T+Jl9W6kAHBrExMR4rEpk51+Moj2bPC8uLuLI8VN4/vAsHjnw/kbn/dSu9fjIzo3Ytn4q60jTAUqPmvyxyMjZ89/ZmBAVAHhUvT56fUrIIm8oKWCp+Prmc6/jwTUuAOSMtJq46qJ12LFxApdtnqZtisxcKfeIiKbLJqVnGf5751yc3vCyksuTmfPzSzhXOdz73Bt45a3Ta/ZcqwCgKIqiKIqiKMoHwrbOCG6/egcAwIWA6ZE2JicnuLQLvFOfVi27S0t4c/YUEALufuogjpw4+74eX6Ow+O1P7MNwcwDTnTEYY2NSEBkM074/7ZObtKYQo6IBVzlUFXleVRWZBBlr4lpjCMA3nzuoAsAPYWiggV3rx3HFjvXYvblDaxUACmPhvCNhiE0YSQSg1WbyDPPRbNEYxFjqxYU+zlUO3371GJ567fiaPr8qACiKoiiKoiiK8oExNdzCVTvWoVFQlN5Iq4mR4eFY6Mm+d6/Xw4m5cwgh4KU3T+DwO2c/kOO74dINuGr7OmycGkO73eadcUmRIuMoH8iI2XBqEQzFzCEE9KsKlavgXeC4OhPFAc9m0/c//zoeeOGQXgw/glajwMxYG1unx3HZ5ilsnxljvwhKA6A1kRC9FshcklOf+FpaWOhhoXJ44cg7eGj/0TV/TlUAUBRFURRFURRFyYrOz96yF9YW2DozibJsABwBLOsAtJ9OxskhUEllDSU0Vc7BOYfALvYI5B1gWAUwBvjn+5/D939wQk/2e2RbZxT7tnZww+7NEPN/zwU/AiiBgbv/BsD8uR4WnYMB8NVHv4fTC10VAFQAUBRFURRFURRFSVyzYx0+eskGtJtNbJiZgkFKJUiFPPkCWIkFBNjxn6LqnOsDwURzOgBxGuBv/+M7ePPEWT3R/0fG2wPYuX4chQHKRhkFAJkIAIB+RTGMAcCZhS5ePz6nJ04FAEVRFEVRFEVRlPO5bud6XHvxDKZHyadA9sqtsSm+MCvqucdPBVbwqKqKcumBmHnvPZnVffGuxzGn3WhFBQBFURRFURRFUZT/f8QQ0BhgangIk5Pj2QSAGAOauGsu/7HGcOEf0O9X8N6fV3X9yVe/Be+1DFNUAFAURVEURVEURVkRTI20cMf1lwIG6AzTJEAQx3+YejVlkiDgnQcQqOPvfZwEMMbgrdPn8Dd3P6EnV1EBQFEURVEURVEUZSXxkZ0zuG7nepoEGBnCFMcWkhmgDP4DxgIIJAo4x3F1ALz3CCHABw9rDF4+egL/eN8zemIVFQAURVEURVEURVFWGjft2Yy9m6cAAJ3RYUxOjSN4RO8/awzECzCEtALgnE+TAT6g2+vhoRcP4Z5nXteTqqgAoCiKoiiKoiiKstIYbJa48+Y97OgPTA4PodOZIGM/dp03oBF/wMB7mgAIIbAzPUXUvXn8JJ55/W08ckDz6BUVABRFURRFURRFUVYkF8+MYfPUMMbaAxhslpgabmNsbBQbJkcQQkBhJRoQqCrKo0cI9HfB441j78A5h/tfPIIDR0/qCVVUAFAURVEURVEURfkwMTbUwmCzfNd/o+GAgH7l4t/NL/XRy/6sKCoAKIqiKIqiKIqiKIqiAoCiKIqiKIqiKIqiKCoAKIqiKIqiKIqiKIqiAoCiKIqiKIqiKIqiqACgKIqiKIqiKIqiKIoKAIqiKIqiKIqiKIqiqACgKIqiKIqiKIqiKMqK5H8Aa/Te3uZuzxsAAAAASUVORK5CYIIAADAuBCeiBgAATy8FJ5wGAABPL0MmCQcAADAuwCUpBwAAEi0EJ3AGAAASLXgoEQcAABItkCUVBwAAMC5JKCkHAAASLeQobggAAE8vjyVtCAAAEi0kJXcIAABRMAgmSgcAALIxiiVtCAAATy97KG0IAAASLVcowgkAAE8vxicJBwAAUTAXJ9EGAACyMQ8mNQcAAP80JSZtCAAAUTAmKEoHAACyMR8ntAYAAP80hSZpBwAA2ze/Jm0IAACyMUUoNQcAAP80Vif9BgAA2zf6JqkHAABMOMwmbQgAAEw4BCenBwAA2zeGJ1cHAABMOI4nVQcAAP80MihpBwAA2zcTKKkHAABMOBcopwcAALIxyyhtCAAA/zSTKG0IAADbN08obQgAAEw4UChtCAAATy8NKHUJAAASLQQnTwoAALIxTSilCQAATy8FJ+MJAAASLbElxwkAAP80NihxCQAATy/8JXUJAAASLSQldwgAAE8vjyVtCAAAsjGKJW0IAACyMR8nJgoAALIxByalCQAA/zSBJnEJAAD/NCUmbQgAAP80VifdCQAA2zcUKDEJAABMOBcoMwkAANs3hieDCQAATDiOJ4UJAADbN/omMQkAAEw4BCczCQAA2ze/Jm0IAABMOMwmbQgAAHwqqCgTCgAAtSyVKAEKAAC3LDspbwgAAJAqVyluCAAA7iwrKW8IAAD9J9UoMQoAACMogyltCAAAmCb5KEUKAAC+JqspbQgAAAEl0yltCAAAEi1XKMIJAAASLeQobggAAO4siSj1CQAAEi0EJ08KAADbJA8pUAoAACEjHiptCAAAdyJlKVgKAADuLAQnlgoAABItsSXHCQAAtCwEJ6cKAADuLH8l+gkAABItJCV3CAAA7izeJHoIAAC3LM0kewgAALUscyUHCgAAkCqvJIUIAACBKl4lIAoAACMogySMCAAAcyoDJ8IKAAAHKBglSgoAAC4nXySRCAAA7CcAJ+8KAACUJtgkyQoAAH4m7CZFCwAAnyTTJiEMAADmJa8hGgsAAIsmwCHqCAAAbSRyJAINAAAzIrYmwQwAAIsllR5HCwAAOiatHjYJAAAuJJshUA0AABEiKCTWDQAAACCnJlANAAAAIMMoGQwAAIgdZSlYCgAAgCUTG0ELAAA8JjcbSQkAAPEjeh5iDQAAAiKTIRAOAACdJXAYHgsAAFsmshgqCQAAzSPpGjYNAADkIW8eIg4AAAAgFCQuDgAAACCPIWMOAADeIdga9Q0AANAjLxgJDQAAACBqHmQOAADvIRYYxg0AAAAg0RpJDgAAACALGBQOAAAhHtga9Q0AABsebx4iDgAA/R2TIRAOAAAQHhYYxg0AAAAgvxcKDgAA8CHKF74NAAAAIJIX2w0AAM8j4xcBDQAA3yGcF5INAACuI7QX3gwAAJ0lJhgZCwAAbSX1FwkLAABcJmsYJgkAACUmNxgnCQAADx7KF74NAAAgHpwXkg0AAC8cLxgJDQAAMBzjFwENAABRHLQX3gwAADIc6Ro2DQAAYhpwGB4LAABiGiYYGQsAAJIa9RcJCwAAoxlrGCYJAADaGTcYJwkAAKQZshgqCQAAwxk3G0kJAAB/GhMbQQsAAMUZrR42CQAADhx6HmINAAB0GpUeRwsAAHQZwCHqCAAA0RubIVANAAAZGq8hGgsAANEYXySRCAAA7h0oJNYNAACSG3IkAg0AAMwdtibBDAAAaxnYJMkKAABgG9MmIQwAACQbDylQCgAA3hweKm0IAAD+GtMpbQgAAGcZ+ShFCgAAQRmrKW0IAADcF4MpbQgAAIEZ7CZFCwAAAhjVKDEKAABvFVcpbggAABMYACfvCgAAgxWoKBMKAABIEzspbwgAAPgXGCVKCgAA3BeDJIwIAACMFQMnwgoAAH4VXiUgCgAAbxWvJIUIAABKE5UoAQoAABETKylvCAAASxMEJ6cKAABKE3MlBwoAAEgTzSR7CAAAEROJKPUJAADtElcowgkAAO0S5ChuCAAA7RIEJ08KAAAREwQnlgoAAO0SsSXHCQAAERN/JfoJAADtEiQldwgAABET3iR6CAAAtyw7KW8IAADuLCspbwgAAO4srijgBgAAEi3kKG4IAAASLXgoEQcAALUsuijUBgAAkCpXKW4IAADuLAQnJwYAABItBCdwBgAAfCq/KMQGAAAjKIMpbQgAALQsBCcXBgAA7ixZJeQGAAASLZAlFQcAAO4s3iR6CAAAEi0kJXcIAAC1LE4l2QYAALcszSR7CAAAcyoDJwoGAAD9J/coqQYAAL4mqyltCAAAgSpMJc0GAACQKq8khQgAAOwnAifsBQAAiiYjKZQGAAAHKD4lsgYAACMogySMCAAAeSYCJ6sFAAC2JHopiAYAAAEl0yltCAAAISMeKm0IAABXImgqlAYAAJQmKSVJBgAALidfJJEIAACLJsAh6ggAAOYl0SEnBwAAOiatHjYJAABKJBYlBgUAAO8j2SH1BQAAiyXDHpMHAAA8JjcbSQkAALIjzh6ZBgAAgyQnJ0IFAAB/JVoboQcAAFsmshgqCQAAqiNrG6UGAABWIkgn+AQAAC4iCSWmBAAAACBVJ8cEAAAAIIQq9wUAAKgdaCqUBgAAACAFJYoEAACpHUgn+AQAAEkbeimIBgAA3hweKm0IAAD+GtMpbQgAAEEZqyltCAAAACDcIYMFAADRHQklpgQAAHwbJydCBQAAdRkjKZQGAAACGPcoqQYAANwXgyltCAAAhhkCJ6sFAAC1GxYlBgUAAAge3CGGBQAAgxW/KMQGAABvFVcpbggAABMYAifsBQAAjBUDJwoGAABKE7oo1AYAAEgTOylvCAAASxMEJxcGAAB+FUwlzQYAABETrijgBgAAERMrKW8IAADtEuQobggAAO0SeCgRBwAAERMEJycGAADtEgQncAYAABETWSXkBgAA7RKQJRUHAAARE94keggAAO0SJCV3CAAAShNOJdkGAABIE80kewgAAG8VrySFCAAA+Bc+JbIGAADcF4MkjAgAAGsZKSVJBgAA0RhfJJEIAAB0GcAh6ggAABAc2SH1BQAAGRrRIScHAADFGa0eNgkAAHQawx6TBwAAwxk3G0kJAABNHM4emQYAACYe0h5BBgAAACDSHjUGAACAGloboQcAAKQZshgqCQAAVRxrG6UGAAAqHnEbUwYAAAAgcBtZBgAAVRrtGHQHAACjGWsYJgkAACocDxl0BgAAUxqnGG4HAADaGTcYJwkAAIEacxh6BwAAJhzKGG4GAABCHJUYgQYAAAseGhkbBgAABx7WGBUGAAAUHqEYKgYAAAAgGhkiBgAAACDVGBsGAAAAIKAYMAYAAOshoRgqBgAA+CHWGBUGAAC9I5UYgQYAANUhcRtTBgAA2SPKGG4GAAB+JXMYegcAAPQhGhkbBgAArCWnGG4HAAAlJjcYJwkAAFwmaxgmCQAA1SMPGXQGAACqJe0YdAcAANkh0h5BBgAA9yHcIYYFAADfIZwXkg0AAOYh+RVaDQAAuCNLFr4MAACuI7QX3gwAAAAgkhfbDQAAdSWyFv8KAABtJfUXCQsAADUm9RYUCQAAJSY3GCcJAABMJq4VCgkAAIAlZRUECwAAaCZHFBYJAADJI9cUrAwAAJsl+BMMCwAAiSaTEioJAACwJU0SDQsAALcmJxAvCQAA1yM/E5QMAADkIUUUDQ0AAAAg6RWZDQAA4SFmElEMAAAZHvkVWg0AACAenBeSDQAAACAlFCcNAAAbHkUUDQ0AAEccSxa+DAAAURy0F94MAAA2HNcUrAwAAB4eZhJRDAAAihqyFv8KAACSGvUXCQsAAMoZ9RYUCQAA2hk3GCcJAACzGa4VCgkAAH8aZRUECwAAlxlHFBYJAABkGvgTDAsAAHYZkxIqCQAAKBw/E5QMAABPGk0SDQsAAEgZJxAvCQAAHxysEWoMAAA2Gu8P8AoAADoZlw0hCQAAFh71EB0MAAASHHUPEwwAACcadQ3WCgAABR7oDrwLAAA0GkgNxAoAAE4ZaA0cCQAAdBo5DXkKAACqGVUNCQkAAA4cGQ04CwAACxwiDaQLAAClHfkM4goAAAscSg3BCwAA4R38DEQLAACPHuMMfAkAAPAdHg1gCwAA7R7lDKgJAABlHtoM0gcAALwe3Ay9BwAAAx8FDbsJAADTHvsMvwcAAOoeYA4KCAAAGB+ADiIKAAD+HkoQXggAAB4fcRCECgAAEh+YEY0IAAAbH8gRtgoAAAAg3hHPCgAAACCtEY8IAADtIJgRjQgAAAAgeBJjDAAA5CDIEbYKAADhIHEQhAoAAAEhShBeCAAA6SH1EB0MAADgI6wRagwAAOcggA4iCgAAFSFgDgoIAAD6IegOvAsAAO0jdQ8TDAAAySXvD/AKAADFJpcNIQkAANgldQ3WCgAA9CNKDcELAADLJUgNxAoAALEmaA0cCQAAiyU5DXkKAABVJlUNCQkAAPEjGQ04CwAA9CMiDaQLAABaIvkM4goAAB4i/AxECwAAcCHjDHwJAAAPIh4NYAsAABIh5QyoCQAAmiHaDNIHAABDIdwMvQcAAPwgBQ27CQAALCH7DL8HAAB+JXMYegcAAJwlBhczBwAA9CPbFhsGAAAlJjcYJwkAADUm9RYUCQAAvSOVGIEGAADOJX0VFAcAAEwmrhUKCQAAUCT2FPwFAAAiIq8WogUAAOshoRgqBgAAACCgGDAGAAB2IpMUgwUAAAAgqRaoBQAA3R2vFqIFAAAUHqEYKgYAAEIclRiBBgAACxzbFhsGAACBGnMYegcAAIkdkxSDBQAAACCBFI0FAADXIlIS7gUAAGMaBhczBwAA2hk3GCcJAADKGfUWFAkAAK8b9hT8BQAAMRp9FRQHAACzGa4VCgkAACgdUhLuBQAAWhv7Ek4GAAAEGsUTQQcAAJcZRxQWCQAAACBdEvcFAADbGScSXQcAAHYZkxIqCQAALRt9EW8GAADwHO0Q/wUAAOkaWQ9fBgAAoRncD2gHAABIGScQLwkAAKcc5g7lBQAArxpSDUIGAAB2GYANZAcAADoZlw0hCQAAThloDRwJAACFGVQNbAcAAKoZVQ0JCQAA2RlDDZEHAAC0GioNUAYAAOAaHg2XBgAAZRwxDcUFAABdHA0N1gUAAFEcBQ0rBgAAyB0ZDUoGAAC2HfcMVgYAAIAd8gybBgAAvB7cDL0HAABlHtoM0gcAANMe+wy/BwAA+B2YDnMGAADqHmAOCggAADEejhCnBgAA/h5KEF4IAABfHuARvwYAABIfmBGNCAAAACCtEY8IAAAAIOYRyAYAAKAh4BG/BgAA7SCYEY0IAAABIUoQXggAAM4hjhCnBgAAFSFgDgoIAAAHIpgOcwYAACwh+wy/BwAADyPtEP8FAAClJPsSTgYAAPslxRNBBwAAaCZHFBYJAADSJH0RbwYAACQmJxJdBwAAiSaTEioJAABYI+YO5QUAABYlWQ9fBgAAXibcD2gHAAC3JicQLwkAADciGQ1KBgAAmiMxDcUFAABQJVINQgYAAIkmgA1kBwAAxSaXDSEJAACxJmgNHAkAAHomVA1sBwAAVSZVDQkJAAAmJkMNkQcAAEslKg1QBgAAHyUeDZcGAACiIw0N1gUAAK4jBQ0rBgAASSL3DFYGAAB/IvIMmwYAAEMh3Ay9BwAAmiHaDNIHAACNIncE8wYAACEjfQQnBgAARSO9AlgGAAAVJN8CFAYAABEkgQTZBQAAxCKrAgsHAAD1IoEG6wUAAAskiQaRBQAASSJ0BtUGAACOInEE8AcAAMQisgLmBwAASSJmBvwHAADLIlkI3wUAAAMkYwh6BQAACiJHCOcGAAAKIjMIMQgAANIieAqBBgAA9iOMCiEGAACuIwUNKwYAAH8i8gybBgAAGCJhCn4HAACaIdoM0gcAAP8hTgrDCAAAcCHjDHwJAACoImwLJQoAAFoi+QziCgAACiNUCuwJAAD0I4ULfwoAAPEjGQ04CwAA9yNOCk0KAADKIkcJkAkAAEElpgv1CQAAiyU5DXkKAADjJFQK7AkAAPIlggqxCAAAVSZVDQkJAAD+I0EJ9AkAADElRwmQCQAAzCImCDsJAAAEJCQIoAkAAOUiXgbxCAAAPSUvCDsJAAAMJF4GTwkAAAEjbgS/CAAAFiPSApcIAAARJG0EDgkAABUk5QLaCAAAMyVmBvEIAAAhJXEEvwgAABMl0gKXCAAA/SVBCDEIAADPJXMG/AcAAJQldwTwBwAAZSWyAuYHAADVJZIKfgcAACYmQw2RBwAA/SVUCOcGAAAaJZUKggYAAB8lHg2XBgAA9iOMCiEGAACuIwUNKwYAADslYgjfBQAAAyRjCHoFAADOJYAG1QYAACIliAbrBQAACySJBpEFAACUJX0E8wYAAGUlqwILBwAAACWABCcGAAARJIEE2QUAAOUkvQJYBgAAFSTfAhQGAAA0JWEA9gUAANAlYQDlBgAA0SUAAOwGAADnJQAA7AcAADUlAAAABgAA5SVhAOAHAAAVJGEAngUAAMIlAADcCAAAFSQAAKQFAAC9JWEAzAgAAPUiYQD2BQAAxCVhANUJAAD1IgAAAAYAAMMlAADnCQAAWSJhAOUGAADFJWEADwsAAFgiAADsBgAAwyUAACALAABDIgAA7AcAAHMlAAADDAAARCJhAOAHAAByJWEACgwAAIAiYQDMCAAAFSQAAJEMAAB/IgAA3AgAABUkYQCUDAAAmCJhANUJAACoImEAGgwAAJ0iAADnCQAApyIAABMMAAB9IgAAIAsAAHkiYQAPCwAAICQAABkLAAB9IgAAIAsAAJ0iAADnCQAApyIAABMMAAAVJAAAkQwAAHMlAAADDAAAwyUAACALAAAvJAAA5AkAAH8iAADcCAAAwyUAAOcJAAAgJAAA3AgAAEMiAADsBwAAwiUAANwIAAAVJAAA7wcAAFgiAADsBgAA5yUAAOwHAAAVJAAA8gYAAPUiAAAABgAA0SUAAOwGAAAVJAAApAUAADUlAAAABgAAcCWlAc0JAAAVJNUBFQoAABUkbwE+CwAAxCI6AfMKAAAFIxUBxgsAAOAipQHNCQAAFSRKATQMAAAVJIMC7QgAAFklWwKmCAAA0SJbAqYIAADBIqcABgwAAIoiuAD5CgAAqCL3AMUJAACoImEAGgwAAHkiYQAPCwAAmCJhANUJAAAVJMYAeQwAABUkYQCUDAAAliIzAbYIAACAImEAzAgAAEQiYQDgBwAAXSJDAdgHAABZImEA5QYAAKEiRgLbBwAAFiPSApcIAADEIrIC5gcAAG0iQQHnBgAA9SJhAPYFAAChIkEC+gYAAMQiqwILBwAABSNFAe8FAAAVJGEAngUAABUkSAGfBQAALyNRAikGAAAVJFsC4gUAAEUjvQJYBgAAFSTfAhQGAAB0JToB8woAABclFQG3CwAAWSWnAPYLAAByJWEACgwAAMUlYQAPCwAAsSW4APkKAADEJWEA1QkAAK4l9wDFCQAAvSVhAMwIAACfJTMBtggAAMwlQwHYBwAA5SVhAOAHAACJJUYC2wcAAGUlsgLmBwAAEyXSApcIAABlJasCCwcAAIklQQL6BgAA5SS9AlgGAAC8JUEB5wYAANAlYQDlBgAA+yRRAikGAAAVJN8CFAYAABUkWwLiBQAAJCVFAe8FAAA0JWEA9gUAABUkSAGfBQAAFSRhAJ4FAADRIlsCpggAABUkgwLtCAAAFSQvA+cJAABZJVsCpggAAG0l9AKvCQAAvCL0Aq8JAAAjJTsDZAkAAFklWwKmCAAAEyXSApcIAAAVJGIDnwkAABUk5QLaCAAABiM7A2QJAAAWI9IClwgAANEiWwKmCAAAXTvvJ1YKAADdOyEoTgoAAOo7hCgyCgAALjwsKEoKAABJO3UoNwoAAJ86oydhCgAAWTpdKD0KAACYOp8ncwoAADk8mShaCQAAOTyAKDMKAAAKPYEoMQoAAAA9MihACgAANj00KD4KAAB9PJIobgkAAEA9gSgwCgAAbT02KDsKAABJPZEofAkAAII8KChuCQAAPTwcKFoJAABMPS4ofQkAAIY8JihPCQAAfT2RKIAJAACAPTAoggkAAHY9gSgvCgAAsT2RKIQJAAC0PTIohgkAABE+gSguCgAACD46KDQKAAA/PjwoMgoAAEc+kCiPCQAAST43KJEJAABIPoEoLQoAAHc+PigvCgAAfD6QKJIJAAB+PjkolQkAAH8+gSgtCgAAsT6QKJYJAACzPjsomgkAAE8/gigqCgAASD9EKCYKAAB8P48opQkAAHw/QSipCQAAZTt6JyQKAACKO1cnYwkAADo8nydaCQAAnToSJw4KAACfOqMnYQoAAF077ydWCgAA6zu/JzMKAADdOyEoTgoAADs82Cc0CgAALjwsKEoKAACAPL0nbgkAAPw85ycvCgAAAD0yKEAKAAA7Pc4nfgkAAII8KChuCQAATD0uKH0JAACAPTAoggkAAD08HChaCQAAcD3TJ4MJAAC0PTIohgkAADM96ycuCgAANj00KD4KAACkPdcniAkAACk+4yeTCQAAST43KJEJAABqPe8nLQoAAG09Nig7CgAAfj45KJUJAADyPfonKgoAAAg+Oig0CgAAXz7oJ5gJAACzPjsomgkAACs+/icpCgAAPz48KDIKAACWPu0nnQkAAE8//ietCQAAfD9BKKkJAABIP0QoJgoAACM/ESgjCgAAdz4+KC8KAABjPgMoJwoAAJQ7GSezBwAAazqrJscHAAByOtEmKAcAAKY5fiYPCAAAmjs7J4kIAACCOxknJQcAAG46xSaeCAAAYzyJJ3oIAACiOYAmmwgAAIM66iZxCQAAqjmfJi0JAAAfOXkmnQgAADY5qSbSCQAALDmtJkgHAABwOkcnygYAAFA5RifiBgAAeTt8J+EGAACoONMmogcAAKg4dSdEBwAATDiOJ1UHAABMOAQnpwcAAKg4pCaaCAAATDjMJm0IAACoOOgmmQkAAEw4BCczCQAAqDiEJ8sJAABMOI4nhQkAAOg4gCc3CgAA4zjsJgsKAAALOXsnZwoAABc58SZCCgAARzlwJ7MKAACDObsmFwoAAGU59yaUCgAAkjoYJzwKAACYOp8ncwoAAOw50SZ4CgAAijocJ4EKAACWOpUnmQoAAKY6hCfVCgAAmToYJ74KAAAyOtomwwoAAK45+SbeCgAAizleJ/8KAAB1OssmOwsAAMM6BScbCwAA0jpkJy4LAADtOlQnWwsAAB064yZ2CwAACzo4J54LAADeOvsmSgsAAA47RieECwAAlTrFJmgLAABCOtwmoAsAADI6LifGCwAA/zryJnQLAAC6Or8mkAsAAG061SbECwAAXTojJ+kLAAAmO7Em8AsAAFs73ibUCwAAaTsmJ+QLAABuOw0nGgwAAGU73yYPDAAARDvEJiEMAADyOsEmJAwAACQ7zSZADAAA5joCJ0cMAAAcO/YmVwwAAKI7kyhSCQAAWjx9KHoIAACBPJMoTwkAAHU9mChRCQAAeD0sKE8JAACsPS4oUAkAAKk9mShSCQAA4D0vKFAJAACNPX8onAgAAKA8eiiLCAAAkj0WKJ0IAACpPA8oiwgAAGM8Ayh6CAAAwD2AKJ8IAADGPRgooQgAAK08CyhrCAAA3T2aKFIJAADzPYIoowgAAPk9GSilCAAArj4fKLMIAACkPHQoawgAAKs+hiiwCAAAnD6eKFQJAACdPjQoUAkAANI+NihRCQAAfz0QKGQIAADQPp8oVAkAAAc/NyhRCQAA3z6HKLMIAADiPiEotwgAAAU/oChVCQAA+D+lKFcJAAD4Pz4oUQkAABQ/iCi3CAAAFz8iKLsIAAD/PykozQgAAP8/jijHCAAAeT10KGUIAACzPRIoYggAAK09dChjCAAA5z0TKGAIAAB0PUQovAcAAOE9dChiCAAAhD4XKFoIAACoPUUovgcAAHk98Se9BwAArT3zJ78HAACkPEEotQcAAKw86Se1BwAAXTzcJ6cHAADcPUUovwcAAOE99CfBBwAAeT76J8cHAABWPEIopwcAAJw84ieZBwAAdj5HKMQHAACsPkgoxgcAAK4+/CfJBwAAgT50KF0IAAC5PhkoWAgAALY+dChbCAAA7z4aKFYIAADsPnQoWQgAAMA/IChOCAAA4j5JKMgHAADkPv4nywcAALA/BSjSBwAAsD9LKM8HAADAP3QoUwgAALo7hihvCAAAwDqJKEUJAADLOpMoXQgAAK07RSiaBwAAEDwWKN4GAAAvOTUoIwoAALU5cSgeCQAAyjmIKEYIAACxOkooiAcAAJU8OCiZBwAAHj02KJIHAAAjPegnkgcAAFc96ieQBwAAWjwTKOQGAABSPTYokAcAAIs97CeOBwAA6zwVKO4GAACGPTUojgcAACo8oCfwBgAAcTywJ/QGAAD+PLon/wYAAHk7fCfhBgAAIT0VKPIGAAAzPb0nAwcAAG07ACjWBgAAcDpHJ8oGAABXPRYo9gYAAGk9wScHBwAAwD3HJw4HAAB5Ot8nywYAAFA5RifiBgAAjDnzJ/YGAACoOHUnRAcAALk5PSiFBwAAqDgNKHsHAABMOBcopwcAAEw4jidVBwAATDhQKG0IAACoOGsoTwgAADc5RSi/BwAALjl7KEgIAABMOBcoMwkAACs5YCjfCAAAqDg8KHUJAABMOI4nhQkAAKg4hCfLCQAA6DiAJzcKAABNOQ4oXgoAAAs5eydnCgAARzosKG4KAACWOpUnmQoAAD067Se2CgAAgznaJ7cKAABHOXAnswoAAIs5Xif/CgAAxTm9JwgLAABaOs0n9woAAKY6hCfVCgAAOjqLJ5cLAAALOjgnngsAADI6LifGCwAAnzqgJ2QLAADSOmQnLgsAAGA6fSe/CwAAXTojJ+kLAAC+Oo4njgsAAO06VCdbCwAAijpuJ+ILAAALO0MnQQwAAOY6AidHDAAA4Tp9J7ULAAAOO0YnhAsAABw79iZXDAAARTtTJxUMAABpOyYn5AsAADQ7HydSDAAAVzspJzcMAABuOw0nGgwAAEQ7xCYhDAAAZTvfJg8MAAAkO80mQAwAABc/Iii7CAAA/z8pKM0IAADRP/kn0AgAAMo/CyhOCQAA+D8+KFEJAAAHPzcoUQkAAPo+4ie+CAAA6T71J04JAADSPjYoUQkAALI+8CdOCQAAnT40KFAJAADEPt0nuQgAAOI+ISi3CAAAfD7qJ04JAADgPS8oUAkAAI4+1ye1CAAArj4fKLMIAAD5PRkopQgAANA92SdOCQAArD0uKFAJAADrPcYnpwgAAJs91CdOCQAAeD0sKE8JAAC3PcEnoggAAMY9GCihCAAAZz3PJ04JAACGPCYoTwkAAIQ9vCeeCAAAkj0WKJ0IAACpPA8oiwgAAIQ8uCdPCQAAqzylJ4sIAABjPAMoeggAAK48oidrCAAArTwLKGsIAAB/PRAoZAgAAKo8gSe1BwAAcD2xJ2MIAABbPGMnpwcAAGc9kie+BwAArDzpJ7UHAAB5PfEnvQcAAK098ye/BwAAXTzcJ6cHAACcPZcnwAcAAOE99CfBBwAApD21J2AIAACzPRIoYggAAJw8fSeZBwAAnDziJ5kHAAAjPegnkgcAANg9uideCAAA5z0TKGAIAADQPZwnwwcAAFY+qCfJBwAAeT76J8cHAACEPhcoWggAAK4+/CfJBwAAYz7FJ1gIAACNPq0nzAcAAOQ+/ifLBwAAmT7JJ1UIAAC5PhkoWAgAAMQ+sifOBwAA0D7NJ1MIAADvPhooVggAAMA/IChOCAAAjz/dJ0oIAACwPwUo0gcAAH4/wyfXBwAAzT75J38HAAC3PtgnIQcAAK4+GSgOBwAAHT4XKAQHAAAqPs4nFgcAAM0+MSh/BwAARj7zJ4UHAAD1PcsnEgcAAEM+MiiFBwAA5z0XKAAHAAAPPjMohwcAABI+8SeHBwAAsj0WKPwGAADbPTQoigcAAN497yeKBwAAsT7DJ38HAAChPrYnNwcAALc+2CchBwAAzT75J38HAAAqPs4nFgcAADQ+syeFBwAARj7zJ4UHAAASPvEnhwcAACE+oycyBwAA/z2sJ4cHAADePe8nigcAAOs9nCcwBwAA9T3LJxIHAADKPaUnigcAALU9lCcuBwAAwD3HJw4HAACCPZsnjQcAAIs97CeOBwAAaT3BJwcHAABXPeonkAcAAGo9iScsBwAATT2UJ5AHAAA1PYInKgcAADM9vScDBwAAGT2OJ5MHAAAAPXonKAcAAP48uif/BgAAcTywJ/QGAAB/PGgnJAcAADg8SicjBwAAKjygJ/AGAAASI2QwBQIAAAAgYzB9AQAAACCBMrYAAADgItwuBwMAAAAg4C52AgAAQiOJMjQBAAAAIJo1CwAAABQmnzLVAgAAYCOKNY4AAABXI7A4ewAAAAAg5TgAAAAANyOmO6kBAAAAICg8MgEAAAAgQD5IBAAAaiOjPYsEAAAAIA0/RwgAAJYlkTqUAgAATSZ3OAICAABDJmY1KAIAAPknAzUsBgAACignOFwFAACEJvg7sAQAAK4jXT5DCAAA+SZCPE0IAABqI9g98QsAAAAghD4zDAAAhCbkO9YLAACOKAY4rwgAAIMojzX8CAAACigDOBEMAACVJX46OA4AADYj0TsADwAAACBsPGcPAACMKFU0MAkAABIorjOXCgAAJCjHMzoIAAD2JwM1IgwAAN8nVDIfCwAAvCeEMg8GAADmJ5Ay6AcAAHMnWzDyBgAAuCfxMH4IAADAJV0wtgMAALgndS8eCgAA/yeBMPcJAACmJnAueQcAACsnMy5hCgAAcidLMKcMAAC7J/4w/woAAGQlvy7CBAAAPiTSLV8GAACAJQktLggAAKciny3bBAAAACB+LUoEAACnIl0seAcAAAAgKCweBwAApyJ9K/QKAAAAIFor9woAANkldSzeCgAAfiVMLHgNAACnIiorfw4AAAAg/SrFDgAApyK/K6IQAAAAII4rCxEAAKQmBy4RDQAARCQ6LK8PAAAHJZ8tXxAAANEiWy1+EQAAyyWzMKQQAAAQIyYxDRIAAAAgOS3jEQAALh1bLX4RAABYHb8rohAAAAAg/SrFDgAA7xwmMQ0SAAAAIHExZhIAACwjdzInEQAA0xx3MicRAAD4Gp8tXxAAADQaszCkEAAAuxs6LK8PAABbGQcuEQ0AAIEaTCx4DQAAWB0qK38OAAAAIFor9woAAFgdfSv0CgAAACAoLB4HAADUGDMuYQoAAFgdXSx4BwAAACB+LUoEAAAmGnUs3goAAH8aCS0uCAAAWB2fLdsEAAAAIOAudgIAAMEb0i1fBgAAHx3cLgcDAAAAIGMwfQEAAJsavy7CBAAAWRlwLnkHAAA/Gl0wtgMAAO0cZDAFAgAAACCBMrYAAACMGFsw8gYAAOsZnzLVAgAAvRyJMjQBAAAAIJo1CwAAAJ8cijWOAAAAqBywOHsAAAAAIOU4AAAAALwZZjUoAgAAyBymO6kBAAAAICg8MgEAAAAgQD5IBAAAshl3OAICAABpGpE6lAIAAJUcoz2LBAAAACANP0cIAAAGGAM1LAYAAPUXJzhcBQAAexn4O7AEAABRHF0+QwgAAJUc2D3xCwAAACCEPjMMAAAGGUI8TQgAAHEXBjivCAAAexnkO9YLAAB8F481/AgAAPUXAzgRDAAAahp+OjgOAADJHNE7AA8AAHMXVTQwCQAA7ReuM5cKAADbF8czOggAAAkYAzUiDAAAIBhUMh8LAABDGIQyDwYAABkYkDLoBwAARxjxMH4IAABHGHUvHgoAAAAYgTD3CQAAjRhLMKcMAABEGP4w/woAAEMYMDJeDAAA7hk8MnIPAAC9GYE1LA8AAMYZdTjwDgAAvxzyNdwQAACtHP44mxAAAAAgqzKGEQAAACAhNjARAAAAIEw54RAAAFIj/jibEAAAQCPyNdwQAAA5JnU48A4AAEImgTUsDwAAESY8MnIPAAC8JzAyXgwAACQoxzM6CAAAjChVNDAJAADsKRk1wggAAAQpSDRwCgAAEiiuM5cKAAAbKkc0MwcAAOYnkDLoBwAAdSntMy0KAADdKbEy1QYAALgn8TB+CAAAMCqVNNUIAABPKvczqAcAAEspyTDvBwAA/yeBMPcJAAAiKsgyYwcAADApkzI9CQAApSkxMVIIAACSKC4wpAkAALsn/jD/CgAABimvMMAJAAAsKNIw+goAAN8nVDIfCwAAvyggMaoKAABhKJAyMwsAAOcofDLXCgAAACDuKWYLAAC3IS0qKwoAAJIhgysJCgAA6yHLK3EIAAAYIocqbQgAAMwhJy10CAAAqCFULT8HAAB4IfAs8gkAAMQhBSwoBwAAACBsLZkGAADuIdAqBQcAAAAgJCx3BgAAACD2KkQGAAAAIFErKQsAAAAgySwACwAAhx7wLPIJAABtHoMrCQoAAEgeLSorCgAAMx4nLXQIAAAUHssrcQgAAOcdhyptCAAAVx5ULT8HAAA7HgUsKAcAAAAgbC2ZBgAAER7QKgUHAAAAICQsdwYAAAAg9ipEBgAAUCJ7KmsIAAAhIx4qbQgAAFciaCqUBgAAdyJlKVgKAAAbIr4q4wYAAAAghCr3BQAAACDkKhgGAAAAIPYqRAYAAO4h0CoFBwAAGCKHKm0IAADjIRIqRwoAAAAgwygZDAAAtyEtKisKAAAAIMopmgsAAAAg7ilmCwAASB4tKisKAAAcHhIqRwoAAIgdZSlYCgAA5x2HKm0IAACvHXsqawgAAN4cHiptCAAAER7QKgUHAACoHWgqlAYAAOQdvirjBgAAACD2KkQGAAAAIIQq9wUAAAAg5CoYBgAAzxEEJ6IGAADPEcAlKQcAALAQQyYJBwAA7RIEJ3AGAADtEpAlFQcAAO0SeCgRBwAAsBCPJW0IAADtEiQldwgAAK4PCCZKBwAATQ6KJW0IAACwEAUnnAYAAM8RSSgpBwAA7RLkKG4IAABNDg8mNQcAAAALJSZtCAAArg8XJ9EGAACwEMYnCQcAALAQeyhtCAAA7RJXKMIJAACuDyYoSgcAAE0OHye0BgAAAAuFJmkHAAAkCL8mbQgAAE0ORSg1BwAAAAtWJ/0GAAAkCPomqQcAALMHzCZtCAAAswcEJ6cHAAAkCIYnVwcAALMHjidVBwAAAAsyKGkHAAAkCBMoqQcAALMHFyinBwAATQ7LKG0IAAAAC5MobQgAACQITyhtCAAAswdQKG0IAACwEA0odQkAAO0SBCdPCgAATQ5NKKUJAACwEAUn4wkAAO0SsSXHCQAAAAs2KHEJAAAkCBQoMQkAALMHFygzCQAAsBD8JXUJAADtEiQldwgAALAQjyVtCAAATQ6KJW0IAAAkCIYngwkAALMHjieFCQAAAAtWJ90JAAAkCPomMQkAALMHBCczCQAAJAi/Jm0IAACzB8wmbQgAAAALJSZtCAAAAAuBJnEJAABNDgcmpQkAAE0OHycmCgAAch13BPMGAAA7HasCCwcAALocvQJYBgAAcR1xBPAHAAA7HbIC5gcAAN4cfQQnBgAA6hvfAhQGAADuG4EE2QUAAAodgQbrBQAA9BuJBpEFAAC2HXQG1QYAALYdZgb8BwAA/hxuBL8IAADpHNIClwgAABodXgbxCAAA7httBA4JAADqG+UC2ggAAPMbXgZPCQAA3hpxBL8IAADsGtIClwgAAMwaZgbxCAAAaxp3BPAHAACaGrIC5gcAADAacwb8BwAAaxp9BPMGAACaGqsCCwcAADEagAbVBgAA/xqABCcGAAAaG70CWAYAAO4bgQTZBQAA6hvfAhQGAAD0G4kGkQUAAN0aiAbrBQAA/BtjCHoFAADEGmII3wUAAAkcjAohBgAAAhpUCOcGAADlGpUKggYAAOAaHg2XBgAAURwFDSsGAADZGUMNkQcAACoakgp+BwAAqhlVDQkJAAACGkEIMQgAAA0aggqxCAAAdBo5DXkKAADCGi8IOwkAAL4apgv1CQAADhwZDTgLAADOGkcJkAkAAPsbJAigCQAAHBtUCuwJAAABHEEJ9AkAADMdJgg7CQAACxyFC38KAAClHfkM4goAAAgcTgpNCgAAVx1sCyUKAACPHuMMfAkAAPUcVArsCQAAAB5OCsMIAABlHtoM0gcAADUdRwmQCQAA9R0zCDEIAAD1HUcI5wYAAOcdYQp+BwAAgB3yDJsGAAA0HVkI3wUAAPwbYwh6BQAALR14CoEGAABRHAUNKwYAAAkcjAohBgAAyxphAPYFAADKGgAAAAYAAC4aAADsBgAA6hthAJ4FAAAvGmEA5QYAAOobAACkBQAAGBoAAOwHAAAKHWEA9gUAABoaYQDgBwAACh0AAAAGAAA9GgAA3AgAAKYdYQDlBgAAQhphAMwIAACnHQAA7AYAADsaYQDVCQAAvB0AAOwHAAA8GgAA5wkAALsdYQDgBwAAOhphAA8LAAB/HWEAzAgAADwaAAAgCwAAgB0AANwIAACMGgAAAwwAAGcdYQDVCQAAjRphAAoMAABiHQAA5wkAAOobAACRDAAAgh0AACALAADqG2EAlAwAAIYdYQAPCwAAVx1hABoMAABYHQAAEwwAAN8bAAAZCwAA0BsAAOQJAABiHQAA5wkAAIIdAAAgCwAAWB0AABMMAADqGwAAkQwAAIwaAAADDAAAPBoAACALAACAHQAA3AgAADwaAADnCQAA3xsAANwIAAC8HQAA7AcAAD0aAADcCAAA6hsAAO8HAACnHQAA7AYAABgaAADsBwAA6hsAAPIGAAAKHQAAAAYAAC4aAADsBgAA6hsAAKQFAADKGgAAAAYAAI8apQHNCQAAixo6AfMKAADqG28BPgsAAOobSgE0DAAA+hwVAcYLAADoGhUBtwsAADsdOgHzCgAAPh2nAAYMAADqG8YAeQwAAFcdYQAaDAAA6hthAJQMAAB1HbgA+QoAAIYdYQAPCwAAphqnAPYLAACNGmEACgwAADoaYQAPCwAAThq4APkKAAA7GmEA1QkAAFEa9wDFCQAAQhphAMwIAABgGjMBtggAADMaQwHYBwAAGhphAOAHAACmGlsCpggAAEMaQQHnBgAALxphAOUGAAB2GkYC2wcAAHYaQQL6BgAAmhqrAgsHAACaGrIC5gcAAOwa0gKXCAAAGhu9AlgGAAAEG1ECKQYAAOob3wIUBgAA6htbAuIFAADbGkUB7wUAAOobSAGfBQAAyxphAPYFAADqG2EAngUAAOob1QEVCgAA6huDAu0IAAAfHaUBzQkAAC4dWwKmCAAAVx33AMUJAABnHWEA1QkAAGkdMwG2CAAAfx1hAMwIAAC7HWEA4AcAAKIdQwHYBwAAph1hAOUGAABeHUYC2wcAAOkc0gKXCAAAOx2yAuYHAACSHUEB5wYAAAodYQD2BQAAXh1BAvoGAAA7HasCCwcAAPocRQHvBQAA6hthAJ4FAADqG0gBnwUAANAcUQIpBgAAuhy9AlgGAADqG1sC4gUAAOob3wIUBgAALh1bAqYIAABDHfQCrwkAAOobLwPnCQAA6huDAu0IAACSGvQCrwkAAKYaWwKmCAAA3Bo7A2QJAACmGlsCpggAAOwa0gKXCAAA6htiA58JAADqG+UC2ggAAPkcOwNkCQAA6RzSApcIAAAuHVsCpggAAKIE7ydWCgAAtgR1KDcKAAAVBIQoMgoAACIEIShOCgAA0QMsKEoKAABgBaMnYQoAAKYFXSg9CgAAZwWfJ3MKAADGA5koWgkAAMYDgCgzCgAA9QKBKDEKAAD/AjIoQAoAAMkCNCg+CgAAggOSKG4JAAC/AoEoMAoAAJICNig7CgAAtgKRKHwJAAB9AygobgkAAMIDHChaCQAAswIuKH0JAAB5AyYoTwkAAIICkSiACQAAfwIwKIIJAACJAoEoLwoAAE4CkSiECQAASwIyKIYJAADuAYEoLgoAAPcBOig0CgAAwAE8KDIKAAC4AZAojwkAALYBNyiRCQAAtwGBKC0KAACIAT4oLwoAAIMBkCiSCQAAgQE5KJUJAACAAYEoLQoAALAAgigqCgAAtwBEKCYKAABOAZAolgkAAEwBOyiaCQAAhACPKKUJAACEAEEoqQkAAJoEeickCgAAFAS/JzMKAADFA58nWgkAAKIE7ydWCgAAIgQhKE4KAABgBaMnYQoAAMQD2Cc0CgAA0QMsKEoKAAB/A70nbgkAAAMD5ycvCgAA/wIyKEAKAADEAs4nfgkAAH0DKChuCQAAswIuKH0JAAB/AjAoggkAAMIDHChaCQAAjwLTJ4MJAABLAjIohgkAAMwC6ycuCgAAyQI0KD4KAABbAtcniAkAANYB4yeTCQAAtgE3KJEJAACVAu8nLQoAAJICNig7CgAAgQE5KJUJAAANAvonKgoAAPcBOig0CgAAoAHoJ5gJAABMATsomgkAANQB/icpCgAAwAE8KDIKAABpAe0nnQkAAJwBAygnCgAAiAE+KC8KAADcABEoIwoAALcARCgmCgAAsAD+J60JAACEAEEoqQkAAHUEVydjCQAAYgUSJw4KAABlBDsniQgAAG0FGCc8CgAAZwWfJ3MKAAB8BeomcQkAAJEFxSaeCAAAyQapJtIJAAB1BRwngQoAAGkFlSeZCgAAWQWEJ9UKAAB8BrsmFwoAABMG0SZ4CgAAZgUYJ74KAAA8BQUnGwsAAC0FZCcuCwAAEgVUJ1sLAACKBcsmOwsAACEF+yZKCwAA8QRGJ4QLAADNBdomwwoAAJoG9yaUCgAAUQb5Jt4KAADoBvEmQgoAALgGcCezCgAAdAZeJ/8KAAD0BnsnZwoAAOIF4yZ2CwAA9AU4J54LAAAcB+wmCwoAABcHgCc3CgAAVwfoJpkJAABXB4QnywkAALMHBCczCQAAsweOJ4UJAACzB8wmbQgAAFcHpCaaCAAAswcEJ6cHAADgBnkmnQgAAFcH0yaiBwAAsweOJ1UHAABXB3UnRAcAAK8GRifiBgAA0watJkgHAACPBUcnygYAAFUGnyYtCQAAXQaAJpsIAABZBn4mDwgAAJQFqybHBwAAjQXRJigHAABrBBknswcAAH0EGSclBwAAhgR8J+EGAACcA4kneggAAMcDSicjBwAA1QOgJ/AGAACOA7An9AYAAKQDYyenBwAAgANoJyQHAAAAA3onKAcAAAEDuif/BgAAzAK9JwMHAABjA30nmQcAAMoCgicqBwAAlgLBJwcHAADmAo4nkwcAAJUCiScsBwAAogPcJ6cHAABjA+InmQcAANwC6CeSBwAAUwPpJ7UHAACyApQnkAcAAKgC6ieQBwAAfQKbJ40HAAB0AuwnjgcAACEC7yeKBwAASgKUJy4HAAA/AscnDgcAAAoCyycSBwAANQKlJ4oHAAAUApwnMAcAANUBzicWBwAAAAKsJ4cHAADtAfEnhwcAAN4BoycyBwAAywGzJ4UHAAC5AfMnhQcAADIB+Sd/BwAATgHDJ38HAABIAdgnIQcAAF4Btic3BwAAXQSTKFIJAABFBIYobwgAAKUDfSh6CAAAfgOTKE8JAAA/BYkoRQkAAIoCmChRCQAAhwIsKE8JAABTAi4oUAkAAFYCmShSCQAAHwIvKFAJAAByAn8onAgAAF8DeiiLCAAAbQIWKJ0IAABWAw8oiwgAAJwDAyh6CAAAUgMLKGsIAAA/AoAonwgAADkCGCihCAAAIgKaKFIJAAAMAoIoowgAAAYCGSilCAAAUQEfKLMIAABUAYYosAgAAGMBnihUCQAAYgE0KFAJAAAtATYoUQkAAC8BnyhUCQAA+AA3KFEJAAAgAYcoswgAAB0BISi3CAAA+gCgKFUJAAAHAKUoVwkAAAcAPihRCQAAAACOKMcIAAAAACkozQgAAOsAiCi3CAAA6AAiKLsIAADQBjUoIwoAALgFLChuCgAAaQWVJ5kKAADCBe0ntgoAAKUFzSf3CgAAWQWEJ9UKAACyBg4oXgoAADoGvScICwAAYAWgJ2QLAAAtBWQnLgsAAMUFiyeXCwAAfAbaJ7cKAAB0Bl4n/woAALgGcCezCgAA9AU4J54LAAD0BnsnZwoAABcHgCc3CgAAzQUuJ8YLAABXB4QnywkAAJ8FfSe/CwAAogUjJ+kLAABBBY4njgsAABIFVCdbCwAAVwc8KHUJAACzB44nhQkAALMHFygzCQAASgZxKB4JAABXB2soTwgAADQFkyhdCAAAswdQKG0IAADUBmAo3wgAAFcHDSh7BwAAswcXKKcHAADRBnsoSAgAADUGiChGCAAAyAZFKL8HAABGBj0ohQcAAFcHdSdEBwAAsweOJ1UHAABzBvMn9gYAAK8GRifiBgAATgVKKIgHAACGBd8nywYAAI8FRyfKBgAAkgQAKNYGAACGBHwn4QYAAFIERSiaBwAA7wMWKN4GAADVA6An8AYAAKkDQiinBwAApQMTKOQGAACOA7An9AYAAAEDuif/BgAAagM4KJkHAAAUAxUo7gYAAOECNiiSBwAAYwPiJ5kHAADcAugnkgcAAKID3CenBwAAqALqJ5AHAACtAjYokAcAAHQC7CeOBwAA3gIVKPIGAADMAr0nAwcAAHkCNSiOBwAAqAIWKPYGAACWAsEnBwcAACQCNCiKBwAAIQLvJ4oHAAA/AscnDgcAAO0B8SeHBwAATQIWKPwGAADwATMohwcAALkB8yeFBwAAGAIXKAAHAAAKAssnEgcAALwBMiiFBwAA4gEXKAQHAADVAc4nFgcAAEgB2CchBwAAMgExKH8HAAAyAfknfwcAAFEBGSgOBwAA8QRGJ4QLAACWBCYn5AsAALoEUycVDAAAqAQpJzcMAACRBA0nGgwAAB4FfSe1CwAAmgTfJg8MAADbBM0mQAwAALsExCYhDAAA4wT2JlcMAADLBB8nUgwAAPQEQydBDAAAGQUCJ0cMAAB1BW4n4gsAAOgAIii7CAAABQHiJ74IAAAuAPkn0AgAAAAAKSjNCAAANQALKE4JAAAHAD4oUQkAAPgANyhRCQAAFgH1J04JAAAtATYoUQkAADsB3Se5CAAATQHwJ04JAABiATQoUAkAAB0BISi3CAAAgwHqJ04JAAAfAi8oUAkAAHEB1ye1CAAAUQEfKLMIAAAGAhkopQgAABQCxienCAAALwLZJ04JAABTAi4oUAkAAGQC1CdOCQAAhwIsKE8JAABIAsEnoggAADkCGCihCAAAmALPJ04JAAB5AyYoTwkAAHsCvCeeCAAAbQIWKJ0IAABWAw8oiwgAAFQDpSeLCAAAewO4J08JAACcAwMoeggAAFEDoidrCAAAUgMLKGsIAACAAhAoZAgAAFUDgSe1BwAAmAKSJ74HAACGAvEnvQcAAFIC8ye/BwAAjwKxJ2MIAABjApcnwAcAAB4C9CfBBwAAWwK1J2AIAABMAhIoYggAAC8CnCfDBwAAqQGoJ8kHAAAnAronXggAABgCEyhgCAAAewEXKFoIAACGAfonxwcAAFEB/CfJBwAAnAHFJ1gIAAByAa0nzAcAABsB/ifLBwAAZgHJJ1UIAABGARkoWAgAADsBsifOBwAALwHNJ1MIAAAQARooVggAAD8AIChOCAAAcADdJ0oIAABPAAUo0gcAAIEAwyfXBwAAPwAgKE4IAAA/AHQoUwgAAE8ASyjPBwAAEwF0KFkIAABPAAUo0gcAABABGihWCAAAHQFJKMgHAAAbAf4nywcAAFEB/CfJBwAAUwFIKMYHAACGAfonxwcAAEkBdChbCAAARgEZKFgIAACJAUcoxAcAAH4BdChdCAAAewEXKFoIAAAeAnQoYggAABgCEyhgCAAAIwJFKL8HAAAeAvQnwQcAAFIC8ye/BwAAVwJFKL4HAACGAvEnvQcAAFICdChjCAAATAISKGIIAACLAkQovAcAAIYCdChlCAAAgAIQKGQIAABbA3QoawgAAFsDQSi1BwAAUwPpJ7UHAACiBSMn6QsAABkFAidHDAAADQXBJiQMAADbBM0mQAwAAOME9iZXDAAAuwTEJiEMAADZBLEm8AsAAJIF1SbECwAAzQUuJ8YLAACaBN8mDwwAAL0F3CagCwAARQW/JpALAABqBcUmaAsAAAAF8iZ0CwAApATeJtQLAACWBCYn5AsAAJEEDScaDAAA2xfHMzoIAADkFUc0MwcAABMWGTXCCAAAGRiQMugHAABzF1U0MAkAACIWsTLVBgAARxjxMH4IAADPFZU01QgAALQWyTDvBwAAABiBMPcJAACwFfczqAcAAN0VyDJjBwAAbRcuMKQJAABEGP4w/woAAFoWMTFSCAAAzxaTMj0JAAD5Fq8wwAkAANMX0jD6CgAAIBhUMh8LAABAFyAxqgoAAJ4XkDIzCwAA7ReuM5cKAAAYF3wy1woAAPsWSDRwCgAAihbtMy0KAAANAIIADP+CABCvnwAToa4AFACDABderQAWoq4AEV+tABd9BQANgv8AF4MGAAaiqwAKgf8ABX//ABdYWAAKUJ4ABQCBAAekqQAXg/8A/F6rAAH+gQAUoq0AE4IAAP1bqAAO/4IAEJ6xAOiD/QDrn7AACP+BAO0DgwAJXqsABGOwAO9ktAD8f/8ACX//AAR/AADqff4ABFpaABgAfQD8W1gABv9/ABioWQAKXlUACaVYABeDBgANgv8ACoH/AP/+fwAGpFcAFaJTABeD/wAO/34ABGNQANxkRQAI/38AywV0ABCeTwDYnkYAE4IAAOiD/QAIWVoAFFlZABR9BQAIfwQATGYFAA5aWAANfgQAEl5TAA5+BgAUfQ0AcSkpAHE6AwBMSEgAcQA5ABJjTgAbexIAF11TAEwBZgBx2CkAFQF9AEy5SABxxgMATJoFABSDBQAWqVoACIEDAAqoWwARgv0ACAJ/ABmnVwBXpPkAFAh9AFTeWQArGnUAKTNtAG/1PAB96fwAQA9tAB08bABv+z0Af/j8AEj/aAAeGnkAADtwAABLZgDpXVMAbf9AAH8D/gBK+2cAHwV7AGz+QwB/Bf8ASfpoAB/9ewAAG3wAAAZ/ACH5egBI+GgAAP5/ACL1egAA+X8AAPR+AN/5egDh/XsA4QV7AN71egAAyXMAIMpuAAClWQBFy10AGqZWADWlRwBmzjgATqQpAHfT+QBXpPUA4MpuAOamVgC4+GgAu8tdAMulRwC3+mgAlP5DAJrOOACypCkAidP5AKmk9QCBBf8AgQP+AJP/QACB+PwAtvtnAJH7PQCD6fwAuP9oAJH1PACppPkA4hp5AMAPbQDjPGwArN5ZANczbQDuY04A5XsSAOx9DQDuXlMA8n4GAPN+BADVGnUA8lpYAPh/BADsCH0A+FlaAOx9BQDnp1cA74L9APgCfwD2qFsA+IEDAOxZWQC0ZgUA6wF9AOqpWgDsgwUAtEhIAI8pKQCPOgMAjwA5ALQBZgCP2CkAtLlIAI/GAwC0mgUAFH0FAExmBQBLTLwAcToDAHIq2wATXasACH8EAEsAmQByAMgAB1ypAA1+BAAS/4IAS7O8AHLW2wBMmgUAccYDABKjrAAUgwUABf6BAA5cqQAOfgYABaOqAAiBAwAQAIIAE16tABClqQARgv0AHgyFABpitAAUfQ0AG3sSABxTpAA5zZsAV6T5AH3p/ABe4bAAf/j8ACbuiAAr340AXvOsAH8D/gAr8YkAHB2IAF4FqwB/Bf8AKgWIABIjhwAO9YIAACKGAAAzjADkU6QAAPWBAO4jhwDmYrQA5XsSAOx9DQDyfgYAAOCFAPL1ggDkHYgA7V6tAPJcqQDzfgQA4gyFANruiADz34YA+VypAPh/BADwAIIA+/6BAO1dqwDsfQUA7v+CAPujqgC1TLwAtGYFAI86AwCOKtsAtQCZAI4AyAC1s7wAjtbbALSaBQCPxgMA7qOsAOyDBQD4gQMA8KWpAO+C/QDHzZsAqaT5AIPp/ADV340AouGwAIH4/ACi86wAgQP+ANXxiQDz8IMAAO+CAKIFqwCBBf8A1gWIAPUEggAABIEAoQusAInT+QDVDYkApd6uAKmk9QC+tLMA1eiLAODHkwD1DIIA9e2DAPjPiwAADIIAAO6CAADRigAIz4sAC+2DACDHkwALBIIAK+iLAEK0swALDIIAW96uAFek9QB30/kAKw2JAF8LrAAN8IMADd+GAB/xegAc7nsAQ/lsAEb4agAA7n4AagJFAGwARAB/CQQAfwkBAH4KBwBpBUgAfgoKADv3cABmBUsAfgkNAGMBUAB+BhIALvN2ABDiegAA6n0A7NF0AOTuewDh8XoAANl5APDiegC9+WwAuvhqAMX3cAAU0XQAlgJFAJQARACBCQQAgQkBAIIKBwCXBUgAggoKAJoFSwCCCQ0A0vN2AJ0BUACCBhIA3vR6AKL9VQCF6hUAQO5sAOXwewCo4VYAQeprAMOeNQCppA8A7IMIAOaEAwD0ggoA7pdFAPuBCADr1HUAHpI3AACBBAA9y2IAPpIOAAGB/AA9lOMActEeAHLb1gB5/toAevQiAHv94QB69yMAV6brAE2nLgAAhR4AAIH8AKmm6wAAploAs6cuAIb3IwCF/eEAwO5sACL0egCG9CIAh/7aAL/qawAb8HsAXv1VAHvqFQBY4VYAFdR1AD2eNQBXpA8AFIMIABqEAwAMggoAEpdFAAWBCADikjcAAIEEAMPLYgDCkg4A/4H8AMOU4wCO0R4AjtvWAGEXsgBiFLIALxiMAH8JAQB/CQQALCCNAGYLtQB+CgcANAOMAA0VgwALIYYAACGFAA/6ggAAFIMA8xWDAPUhhgDUII0A0RiMAJ8XsgDx+oIAAPeBAAHogwCeFLIAgQkBAIEJBADMA4wAmgu1AIIKBwD/6IMAyvqNAJcEuQCCCgoAALeYAJYHugCCCQ0AywONABAAggDICo4AlAm+AIIGEgALB4IAwu+SAJHuxQCF6hUAqaQPAK+l3QDmhAMA54P+ANChuwDug/YABemDAPqerwD4gvMAS+GeACaZwAD+gfUAPZTjAAGB/ABy29YAVAKhAHn+2gBb/agAe/3hADavrwBXpusAAIH8AACI1gDKr68AqabrAIX94QCl/agAh/7aAKwCoQCO29YA8ACCADb6jQBpBLkAfgoKADUDjQBqB7oAfgkNAPUHggA4Co4AbAm+AH4GEgC14Z4A++mDAD7vkgBv7sUAe+oVAFekDwBRpd0AGoQDABmD/gAwobsAEoP2AAaerwAIgvMA2pnAAAKB9QDDlOMA/4H8AIjv2QC37poAtO+cAADvggAA74IAiPDaALfymQAA9IIAifDXAIbwIACF8RwAh+4iALYLmQAAD4IAiADWAIbyIgC0DJsA/xSDAPwCgQC0+psAiP3WAInu1gCJ6SYAjtkoAL3VYwDGy2QAweFqAAvYeAAQy3IAA+N8ALbiYwBR4V0AUNlbAETqaQB58yQAeegfAADdegBM52MAteZjAADjfACz7WMATepjAADtfgCy8GMArfFfAADxfgAA8X4ATe9jAE/yYwBT8l8AevciAHryIgB68yAAe/QcAHcD0wB19tAAeATWAEgRmQBHAJYA/xSDAPwCgQBJDZkAAA+CAHjz1wBK9JkAAPSCAHjx2QB48toASvCaAADvggBM8JwAAO+CAEv4mgB3/tUAeP7YAH8EBgBO+JwAfwQEAAD1gQB/BQgAAPWBAH4FCgC1+JoAfwH/ALL4nAB/AP8Aif3VAH7/EgCI/tgAfQAXAIIEDABd/lYAgQMJAFv9WQCDAxcAA/p/AIMDFQAD+n8AgfwCAKH8VACB/P8AnvxRAIH8BwCB+wMAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAV1UiAP90NQAAeyEArFwaAMBeOACpVSYAAmZLAP/4fwBwLCkAjygrAKo2TACIKAsAhBsGAKUrTgCFHQkAgg8AAAM4cgADKHkAhRcYAIQPFQCCDgwAgxULAIgL2QCHJQ0AqFbgAIwwEQCJFNkAsgScAIwl3ACOLd4AtRGbAAAAgQAAD4IAtyigAAApiAC4MaQAADOMAFFcIwA+XjsAUzZQAFcsUgB4IhcAdSwYAH0U/wB7HwQAfRIKAHwaDgB9FgkAfg8HAHkmDAB0MBEAWFbgAHIt3gB0JdwASDGkAHcU2QB4C9kASSigAAAzjAAAKYgASxGbAE4EnAAAD4IAAACBAI8oKwD/+H8AAAh/AHAsKQBi+lEAnvpRADdy9wBwLCkAWFbgAAB+DQAAbsEAyXL3AKhW4ACPKCsACfZ+AAYBfwD+YlAABQF/APlfVQBK/2cAAmpGAHQYLgAQfgEABF9UAAJfVQAE/38ABP5/ABRgrwACXVYABP1/AAdeqgAXAIMAfwEIAAr+gQAJAH8AB12qAAr9gQACXFgAB12qAAr8gQACWloABPt/AAT6fwAHXaoACvuCAAJYWwAE+X8AB12pAAr6ggACVl0AB1ypAAr4ggA+RlYATONiAFhHxgBq28UAJ6VQADGNGAA2kBoAOZYpAEr/ZwAJ9n4AIKxaAAYBfwAUqlsABQF/ACWisgAJpFcABP9/ABCfrwAXAIMACv6BAAr9gQB/AQgAEJ+wAAr8gQAJpVgABP5/ABCesQAQnbIACvuCAAmlWAAE/X8ACvqCAAmmWQAE+38AEJ2yAAr4ggAJp1oABPp/ABCcswA/ockAatvFAEzjYgAorVgABPl/AAmoXAAqiAUAIIX4ABKWvAALgvQAL4sSACGWwgAqiRAANo8UABODCQApihcAGoYWAOeEAwDtiCQA3py5AALZhwDY6IoAENeJAMmexQDJ+I4A7QODAOufsADKjQUA6IP9AK6wNgDYnkYAnQhPAMsFdACaC0sAqrxAAKAIUgC6tEkAogJVAASEHAC/qkMAYa8NAHQYLgAOggwAZrfvAHgnCwByMeUAZMLRABSE8QC+oDMAof5UAA2E6ABdw8MAbTDVAGcxyQC6nikAof5UAFbEuQBgNL8AC4TnAL+eMACq/l0AUMevAAqE5QDGnTUAs/tlAB2F9QBhxcgAcirZAHgBKgBsxR4AQaE1ANmaQAAWrV4AxvRxAAvjewD8fwQAE3vnAAtgUwD+X1QAAP9/AAD+fwD+X1QAAP1/AAVToAAQVqQACv6BABQAgwB/BQMABVOgAAr9gQAPAH4A/l9UAAVSnwAK/IEACvqCABBmSgAFUp8A/l9VAAD8fwAA/H8ABf9/AP5fVQAA+n8ABVGeAAr5ggD+X1UARU9HAFjeVQAFUZ4ACveCAGDVuQBOQrUAA2VNAAX+fwADZU0ABf1/AAJMmwADZU0ABfx/AAJMmgAF/4EABf6BAAtOnQAOAIIAfwT+AAJLmgAF/YEABfuBABJ53QAQAX4AAkuZAAJKmQAF+oEAA2VNAAX7fwADZE4ABfl/AANkTgBh4kwAAkqZAAX5gQBa268ARjypAExSPAAEfeoA+H4LAP9+7QABedkAB0qZAMZfPQDxfQ8A9n3vAP91zwASZEwABWNQAAYAfwAGAH8AC0eXAAVjUAAGAH8AB0iYAAVjUAAQ14kADtaJAAzTigAQ14kAB0eXAAzSigAERJUAAtmHAAhHlwAM0YsADM+LAP0/kgDY6IoA5kibAMn4jgD3dMwA31iqAO9ktADtA4MA6n3+AOZ78QDvdM4A8H3wANxkRQDwfRIAxmQ1AMsFdACdCE8AmgtLAMVMUwCgCFIAKVhSAHgnCwAoajkAyE9SAKICVQCh/lQAzVlLACx0GwByMeUA0lxKAKH+VACq/l0ALnURAG0w1QDZXE4As/tlAC52DABnMckA3ltSAPRRYQDG9HEALXcIAGA0vwAL43sAQWkdAHIq2QApGnUAWidRAHgBKgBBoTUAbMUeABatXgAK94IAYNW5ADKfvwApq1UAWN5VAAD6fwARnbIACKteAAD8fwAIq14AAPx/ABGesAAK+YIACKxfAAD9fwARn68ACvqCAAr8gQAIrF8AAP5/ABGgrwAIrF8AAP9/ABGhrgAK/YEACKxfAAkAfwARoa0ACv6BABQAgwAasWAAJKauAH8FAwAcsmEADwB+AAX/fwAhpK8ACq5hADWNDAAMn7AADgCCAAX/gQAF/oEAfwT+AAyesAAF/YEACq5hAAX+fwAhsV4AEAF+AAYAfwAKrmAABf1/AAyesQAMnbEABfuBAAX8fwAF+oEACq5gAAycsgAF+YEACq1gAAX7fwAMnLMACq1fAAX5fwBh4kwANa1QAFrbrwAwoL0AZu1JAFfQsAA9OqEACESVAAzNjABSUDcABv9/AAzOjAAFY1AACEWWAAVjUAAG/38ACEaWAAVjUAAG/38AP7JOADeW1QBX0LAAZu1JAAzNjAAPrl8ABv9/AAb/fwASjc4AD65fAAb/fwASjc0ADM6MAA+uYAASjc0ADM+LAA+uYAAGAH8ADNGLAAYAfwASjc0AD65gABKNzAAM0ooAD65gABKOzAAM04oADtaJACCUxgAllcYAENeJACjGlgAAx48AANyGACOorAAAqaMAKduNAADyggBa4KwAKPGIACgViQAAF4MAKUqhAABPnQAAdc4AK23QAAB//QBOOq4AWhKoAFvxqQB59NwAeBDZAFtN0wAudv4AYlH/AC5uLAAAdy0AXE0qAH0UAAB/+f8AdhcqAE8/TQArUFkAAFZeAH/1AQB9+BUAfPLrAHj9KgB+8w8Ad+naAH3v8gBz2NwAfOruAFTKsgB62wAAfe0BAFyz1wBuwf0AeOwlAH3xEwBGrMAAMJnIAD2Y2AAelMUAAJO/AByM1AAAiNUAF4XtAACD7ABKmvUAUJ8UAB2FDAAAggwAJqBKAACeUQBvzCEASKc3AFbRUQAn1nEAWgdZACcZdgAA2XkA2dZxANqgSgAAggwA2Rl2AAAfewAqKHEA1ihxAKrRUQCmB1kAuKc3AJHMIQCwnxQA44UMAACD7ADphe0AAIjVAJLB/QDkjNQAAJO/ALaa9QDDmNgA4pTFAACpowDQmcgA3aisAADHjwC6rMAApLPXAKzKsgDYxpYAANyGAI3Y3ACm4KwA19uNAADyggDY8YgA2BWJAAAXgwCl8akA10qhAABPnQAAdc4AphKoALI6rgDVbdAAAH/9AIf03ACIENkApU3TANJ2/gDSbiwAAHctAJ5R/wCDFAAApE0qAIH5/wCKFyoAsT9NANVQWQCB9QEAg/gVAITy6wCI/SoAgvMPAInp2gCD7/IAhOruAIbbAACD7QEAiOwlAIPxEwCG+SQAnw9RAKYEWQCoHFcA2Qp4ANcicwAAK3gAAAt+AAAlegApInMAJwp4AFgcVwBaBFkAYQ9RAHr5JAC/RqwAwm/4ACR6BAANW1gA2kxeAClKoQDG+I8AaQZHACTtiADOqrEAeBMkAH8C+gAhnrYA1YkMAHzk9wB36igAdtINABaDBwDpxG0Aa8kpABCwYQDyCn4AYtlHABgSewBl9EsAABZ9AGQSTABoD0cAfg4JAH0RDAB+CwYAYg6wAGsMRABlErUAAA2CAGgWuwAAEYIAABWDAAASfgAADn4AlQxEAJgPRwCcEkwAggsGAIIOCQCDEQwAng6wAJsStQAADYIAmBa7AAARggAAFYMAOW8YAEdmGgA6Y8kAQk9KADNu2gAAS5oAAGSxAAB41wAhevMAJ3YZADZcRQAAPHAAI3AxAABQYwAAbEQA3XAxAMpcRQC+T0oA2XYZAMdvGAC5ZhoA33rzAMZjyQDNbtoAAHjXAABLmgAAZLEA8wCCAO2hrgDwr58A7ACDAOqirgDpXq0A84L/AOmDBgD6oqsA9oH/APT/ggDvX60A6X0FAPmkqQDpg/8A+wCBAPZQngD7f/8A6VhYAAReqwD//oEA7KKtAO2CAAADW6gA8v+CAPCesQAYg/0AFZ+wAPj/gQATA4MA916rAPxjsAARZLQABH//APd//wD8fwAAFn3+APxaWgDoAH0ABFtYAPr/fwDoqFkA9l5VAPxjUAAkZEUA96VYAOmDBgDzgv8A9oH/APj/fwA1BXQA8v9+APCeTwAonkYA7YIAABiD/QDpg/8A66JTAPqkVwAB/n8AeO/ZAHjw2gBM75wAevAgAHvxHABJ7poAAO+CAADvggBJ8pkAAPSCAHfw1wB57iIATvBjAFPxXwBN7WMAAPF+AADxfgAA7X4AsfJjAK3yXwCz72MAhvMgAIX0HACG8iIAiPHZAIjy2gCI89cAtvCaALTwnAAA74IAAO+CAAD0ggC29JkAAA+CALcNmQABFIMAiATWALgRmQC5AJYABAKBAIv20ACJA9MAh+gfAIb3IgCH8yQAsNlbALPqYwCv4V0A8MtyALTnYwAA43wAvOppAADdegBL5mMA9dh4ADrLZAD943wAQ9VjAHLZKAA/4WoAd+kmAHfu1gBK4mMAevIiAHgA1gB4/dYATPqbAEoLmQAAD4IATAybAAQCgQABFIMAtfiaALL4nACI/tgAAPWBAIn+1QAA9YEAgQQGAEv4mgCBBAQATvicAIEFCAB3/dUAggUKAHj+2ACBAf8AfgQMAIEA/wB/AwkAgv8SAH0DFwCDABcAfQMVAKP+VgB//AIApf1ZAH/8/wD9+n8Af/wHAP36fwB/+wMAX/xUAGL8UQAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAAAAgQAAAIEAAACBAACpVSIAr1wjAAB7IQD+ZksAQF44AMJeOwBUXBoAVjZMAP04cgBbK04A/Sh5AHgoCwB7HQkArTZQAKksUgCIIhcAiywYAIMU/wCFHwQAgxIKAIQaDgCDFgkAgg8HAJAsKQCJFNkAiAvZAIcmDACMJdwAji3eAIwwEQCoVuAAuDGkALcooAAAM4wAACmIALURmwAAD4IAsgScAAAAgQABdDUAAfh/AFdVJgBxKCsAfBsGAH4PAAB7FxgAfA8VAH4ODAB9FQsAeAvZAHklDQBYVuAAdDARAHcU2QBOBJwAdCXcAHIt3gBLEZsAAACBAAAPggBJKKAASDGkAAApiAAAM4wAcSgrAGL6UQAACH8AAfh/AJ76UQCQLCkAyXL3AJAsKQCoVuAAAH4NAABuwQA3cvcAWFbgAHEoKwD39n4AB19VAAJiUAD6AX8A+wF/ALb/ZwD+akYAjBguAPB+AQD8X1QA/l9VAPz/fwD8/n8A7GCvAP5dVgD8/X8A+V6qAOkAgwCBAQgA9v6BAPcAfwD5XaoA9v2BAP5cWAD5XaoA9vyBAP5aWgD8+38A/Pp/APldqgD2+4IA/lhbAPz5fwD5XakA9vqCAP5WXQDCRlYAtONiAPlcqQD2+IIAqEfGAJbbxQDZpVAA4KxaAMqQGgD39n4A+gF/ALb/ZwDsqlsA+wF/ANuisgD3pFcA/P9/APCfrwDpAIMA9v6BAPb9gQCBAQgA8J+wAPb8gQD3pVgA/P5/APCesQDwnbIA9vuCAPelWAD8/X8A9vqCAPemWQD8+38A8J2yAPb4ggD3p1oA/Pp/APCcswD3qFwA/Pl/ANitWAC042IAwaHJAJbbxQDPjRgAx5YpANGLEgCfrw0AjBguANeKFwDWiRAAE4gkAJq37wCIJwsAjjHlAPyEHADyggwAnMLRAKPDwwCTMNUAmTHJAPOE6ACqxLkAoDS/AOyE8QBBqkMAQqAzAEa0SQBeAlUAX/5UAGAIUgBGnikAX/5UAFa8QABmC0sAUrA2AGMITwAonkYANQV0ABiD/QA2jQUAFZ+wABmEAwA3nsUAEwODADf4jgAo6IoAIpy5AP7ZhwDmhhYA7YMJAPWC9ADghfgA7pa8ANaIBQDflsIA8NeJAMqPFADblcYA8NeJAPLWiQDLjQwA4JTGAO6OzAD004oA9NKKAN+xXgDujcwA9NGLAPGuYADujc0AgQT+APABfgD6AH8A8gCCAPGuYAD6AH8A8a5gAPoAfwD6/38A7o3NAPTPiwD0zowA8a5gAO6NzQD0zYwA8a5fAPr/fwDujc4A8a5fAPr/fwCa7UkAwbJOAKnQsADJltUABH8EAPx96gDte+cA9WBTAAh+CwACX1QAAP9/AAD+fwACX1QAAP1/APtToADwVqQA9v6BAOwAgwCBBQMA8QB+APtToAD2/YEAAl9UAPtSnwD2/IEA9vqCAPtSnwACX1UAAPx/AAD8fwACX1UAAPp/APtRngD2+YIAAl9VALtPRwCo3lUAskK1AKDVuQD7UZ4A9veCADpfPQDXWFIAiCcLANhqOQDUdBsAjjHlADtMUwAzWUsA0nURAJMw1QAuXEoAOE9SAF/+VABeAlUAX/5UAGAIUgBmC0sAVv5dAGMITwAnXE4ATftlANJ2DACZMckAOmQ1ADUFdAAkZEUAD30PABp78QABfu0AFn3+ABB9EgAhWKoAEWS0ABB98AAKfe8AEXTOAAl0zAA3+I4AEwODABpImwAo6IoAAXXPAAM/kgD+2YcA/ESVAPDXiQD/edkA+UqZAPDXiQDued0A9UeXAPLWiQD004oA7mRMAPlImAD7Y1AA8AF+APoAfwCBBP4A+gB/APtjUAD6AH8A+UeXAPTSigD7Y1AA+EeXAPTRiwD7Y1AA+v9/APTPiwD6/38A+EaWAPtjUAD6/38A+EWWAPTOjAD7Y1AA+ESVAPTNjACp0LAArlA3AJrtSQDDOqEAoDS/AI4q2QC/aR0ApidRAIgBKgDTdwgAlMUeAOqtXgC/oTUA9eN7ANcadQAMUWEAOvRxACJbUgD294IA752yAM6fvwCg1bkA16tVAKjeVQAA+n8A+KteAAD8fwDvnrAA+KteAAD8fwD2+YIA+KxfAAD9fwDvn68A9vqCAPb8gQDvoK8A+KxfAAD+fwD4rF8AAP9/AO+hrgD2/YEA+KxfAPcAfwDvoa0A9v6BAOwAgwDcpq4A5rFgAIEFAwDksmEA8QB+APv/fwDfpK8A9J+wAPv/gQD7/oEA9q5hAPSesAD7/YEA9q5hAPv+fwD0nrEA9J2xAPauYAD7/X8A+/x/APv7gQD7+oEA9q5gAPScsgD7+YEA9q1gAPv7fwD0nLMA9q1fAPv5fwCf4kwAy61QAKbbrwDQoL0An+JMALRSPAC6PKkA/WROAKbbrwD7+X8A/kqZAPv5gQD7+oEA/kqZAPv7gQD9ZE4A+/t/AP5LmQD9ZU0A+/x/AP1lTQD7/X8A/kuaAPv9gQD7/oEA/kyaAPv/gQD9ZU0A+/5/AP5MmwD9ZU0A+/9/APBmSgD1Tp0A8gCCAE37ZQA69HEAJ5pAAOqtXgD143sAv6E1AOOF9QA6nTUAVv5dAJTFHgBBnjAA9oTlAPWE5wCwx68An8XIAI4q2QCIASoAQUasANdKoQDcegQAOviPAD5v+ADc7YgAMqqxAIgTJADfnrYAK4kMAIEC+gCE5PcA6oMHABfEbQCK0g0AieooAJXJKQDwsGEADgp+AJ7ZRwDoEnsAJkxeAJv0SwDzW1gAlwZHAJgCbAiRAq8IxQK2COkCdgigAioIRgIhCPoCNwhFAmQI9QEhCB8DxwhKA04IzwL1CAsDTAn1AawIowEkCFwCrQiJAu0IwwJBCdsCAQpCAuwIhAI8CZ8C8wmlAp8KQQI8CW0C7Ql5ApQKnwK2CnMCrApUAo8KUAKoCjkC6gkvAo0KLQKmCvsBPAn+AeoJAAKMCgACpQqsAbEIUQEsCLYBPglkAbgIAQE7CMMB7AkeAcAItABRCNwAzQjtAFMJdAFCCTQBSAlcAfcJIQEHCo8B8AnRAY4K0wGnCqwBkQqwAaoKhwGXCo4BrwpbAaMKYgG7CtAFnAtBBogLRQYyC8kFNwtRBjQLQAW0Cz0FRQvsBLwL7QRJC4sESwtcBoYLYAY7C00GhwttBs0LhQTACyEERQv7A7ULXgbSC5AGDgxTBtYLgwYXDMYGRgy+BlUMtgZfDHkGHgxQBqwMEwZYDNkF/gznBf0LiwWpDLAFJA1UBS4MKgXZDPcETAx3BG4M9ASmDXUFsg1jBAUN4wOBDNUEVg5QBVwOUgSoDdYDHA1jA5AMYwMJDMwCtQvGBBgPOwUdD0IEVQ7SA6sNwASmDzIFqg84BBYPywNVDmMDJA1jA6wNyQMWDzYEpg9jA1YOywOpD2MDFg9jA6kP/gIWD/sCVQ70AqsN/AKpD2MDuQ/LA7oPYwPHDzYEtg/KA8cPMwTED78EtQ+7BMMPMQW5DyoFyA/7AroP/ALHD5ACpg+RArYPkwLED44CFg8GAqYPBwK1DwsCww+VAbkPnAHID5QBqg+LAR0PAAIYD3cBXA6EAlUO8QFWDlEBsg10AqgN0wGmDRYBJA3wAhwNYwIFDeQCgQycAdkMTwJuDEECwAulAkULOwJLC9oBvAvZAUkLiQFFC88BTAyGAbQL/QA3C3IBLgz2AJwLgQAyCzsBqQztAP4M3wD9C7MAWAx2AKwMhQCIC3UANAtzANYLTQAeDBEAXwx5AIcLagCGC2YAOwtZAM0LaADSCzYADgxEABcMAABGDAgAVQxaBzALTgczC2EHgAtBBzsLUgeBC2wHfwvQByILXQfOC1AHzAvYB4ILVwgcC2cH0AtEBxkMNgcSDBUHWgwMB04MTQcdDB8HYgzPB+ULZAiEC6QIFguyB0MMhgecDF0I/wu4CIELOghwDAEI1gy2CAwMJAlyCwMJCQtoCfQKrQlIC5kIhgwvCPEMVwh+Db0IXg1wCCgOOgmGDEUJTg3UCBQOfgjqDlEJCQ4wCQwM5QjbDo0IeQ9dCdAOrgkLDLYJiwwxCgwMMQpRC7UKSAsxCo0MtQoLDD8Lcgv7CvQKYAsJC74LFgsxCkoNrQqLDDMLDAyrC4EL/wuECwsMHAutCwwMKQuGDKUKSg2KDIILkwwiCwYM/wuTDOUL9wx/CwkNMAv7DNALsQxDDAINgAsUDTMLIg07CxENgQsGDc4LEw3MCx8NGQwsDRIMTQ1aDFcNTgwVDR0MRA1iDNwMnAwoDHAMYQzWDMoLhgw0DPEMDAx+DR0LTg2mC14N8wsoDo4LFA7lC+oOEgsJDqAKBA4xCgMOfgvbDtYLeQ8GC9AOmwrLDjEKyg50C2AP0wuJDwULVA9yC28PywuYD2wLfA8FC2MPAAtvD50KTw+dCl0PmwpqDzEKTg8xCl0PMQppD8gJag/FCV0PYwlvD8gJyw5eCWMP9wh8D8YJTw/xCG8PlwiYD5AIiQ9eCVQP7whgD8IJBA69CUoN/A1kAAUOvwByDqMAZA5WAJUNZwD3DnsA6g43AGMPWwBUDxgAcg+eAAMPwQCAD+cAgQ72ABMPDgGRDz8BKg9mAbEPuAGXDlMBEA4pAZUNxwAlDrYBJQ2/AC4NZACVDTUBGg0pAbgMowDGDFYAqQz2AAUNtgEzDHsAQAw3AMcLWwDWCxgAuAueACcMwQCqC+cAFwwOAZkLPwGTDFMBAAxmAXkLuAFyDKoB1wvaAVoLNQLKDAwCNwwXArILRwJ6DGkCrwtPAlkLPgKpC18CWwtQAvILhQL+C3cCKgy6AgMMbwI6DK0CTgwBA0AMqAJeDPkCVwxWA2kMVgNkDPQCcAxUA7oMNQOgDMgCHA0BA/oMggJhDeACTQ1IApUNPQKVDdsCyQ3gApUNugHdDUgCMA6CAg4OAQNgDgwCuA6qAYoOyAJwDjUDsA5pAvMOFwJTD9oB0A81AngPRwInD28Cew9PAtEPPgKBD18Czw9QAjgPhQIsD3cCAA+6AvAOrQLcDgED6g6oAswO+QLTDlYDwQ5WA8YO9AK6DlQDPwzBAzYMEQShDC0E2wuzA8sL+AOwDMoDIgxkBLkLPQSBDJUECQ1BBBgNzwOFDdAD7Qy8BIUNRQQBDkEE8g3PA1oOygNpDi0Eyw7BAx0OvASFDccEugxKBdQOEQQvD7MDPw/4A4kOlQToDmQEUQ89BFAOSgW4DgIFCg+/BGkPiASFDVkFKw8UBYcP4QTdDlIFgQ6XBREPuwVZD4cFsA9dBcYO9wU8DxIGfA/xBc8P4AXPD+oFfw/5BcwP/gWDDwkGPw8ZBkUPJgb5DjgG/Q49BgcPSQbFDmAGyg5kBtYOcAaSDqcGpA6tBooOpAaPDi0GSw52BkAO1wX3DTEG/A2WBbkNBAaFDQIGhQ2VBQ4NlgVRDQQGEw0xBsoM1wW/DHYGewwtBoAMpAaJDJcFUgwCBQAMvwShC4gELQxSBd8LFAWDC+EERAz3BfkLuwWxC4cFWgtdBUYMYAYRDDgGzgsSBo4L8QU7C+AFOwvqBYwL+QU+C/4FhwsJBssLGQbFCyYGDQw9BgMMSQZADGQGNAxwBngMpwZmDK0GbQRMBzcEVgdPBLUHHwS8BwIEZQd/BK8HGgTqBt0D+gZXBN8GpARGB64EqAeYBNgGCASKBsMDlwZKBHwGkARxBgAEDga7AxkGpAOQBegDgAVIBAAGOQRtBZUE8QWQBFAF5gSeBegEOgX1BOQFOQWcBUEFNwUxBeYF4AQmBo8FpwWjBUcFawXxBc0FAwb6BWEFLAUoBnUFNQbaBGsGJwVtBtkE1QZyBXcGHwXXBtgERAfXBJ8HFwVGBxEFnQdlBd8GVQVNB0kFqAe5BYcGpAXrBogFVwdxBbcHEgYaBkUGhQX8BZwGVwY0BooGrAWZBksG1gbOBTwGsQZ+BscG4gX7Bh0GDgdXBiUHvgVkB54FxQfyBXYHJAaLB80F0Qf8Bd0HsQ3lB30NugdxDc4HOg3CB54N8AdADaoHxQ0lCP8MwwexDSYIAg2qB7YNZwi9DLAHog1dCLwMyAeEDZUIcQy9B3cNggh2DNMHQQ2QCEwM7AdIDagIOQzdBwgNqAgxDC0IBQ2PCBwMLAjCDKMINgx9CMAMighJDG4IdAyECHIMmwh+DCsIdAyECMAMighJDG4IMQwtCEwM7Ad2DNMHwwwnCAUNjwi8DMgHAA0pCEENkAj/DMMHNQ0qCHcNggg6DcIHbg0oCKINXQhxDc4HsQ0mCJ4N8AdWCHcJBAh/CQYIwwm+B8AJ0wfoCbgHegkHCO8JAwgxCU8IJwm2BygJxAcACqQH0AmRB4wJuwcOCpYH3wl0B6EJCAgKCgkIIAp9B08JVQdsCTcHPAljByEJGwcKCZgHAwnRBxcJsAf4CEkH8ggBB80IfQfZCJQHzggwB7gI6waKCCAHeghqB6QIYQdvCIQHngiBB2sIUAi7CTkI4glLCPkJVAgHCnkI2QlrCMsJmwibCX0IiAm2CGQJjAhKCaIIGwnQCDQJbAgACVMI9gg0CBcJbAjLCIQI1Ah5CJkIugjqCOkI/wiUCJ4IeghmCJoIaAjPCK4IAAnBCNwIbwgSCXwIFwoxCGYKKQhmCukHtQoxCLAK6QcdCukHmgrTB8wKpQerCqIHZgrYB2YKogcyCtMHIQqiBwAKpQf4DHQPEA12Dx4NZw8cDX0P/gxZD9QMeA/LDFIP0Ax6D2MNQw8qDXMPRA2XDzQNnQ86DaYPYg1fD0gNoQ8+Da8PbA2UD30NZw+EDVsPgA2RD44NUQ9uDZ8Pgg2bD00Nqw9xDakPhA2mD1gNxw9LDcoPUA3UD3kNxg+KDcMPXA3QD1UN3g97DdAPiw3ND2AN2g99DdkPjA3YD3AN8g9qDfwPfA3xD4gN/w+qDjEP1Q4UD7UO1Q7BDmEPnQ5YD5IONg+UDhgPgw4kD4YODA96DhoPmA7VDmQO9A5bDgAPaA7ODo8OvQ5nDroOXQ65DpsOuQ5dDssOUw63DlsO7w5TDvsOUw7JDjsOwg43DrEOUQ7rDkoO9g4tDq8OOQ7gDjAO6Q4xDr8OIw6uDjAO3A4mDuQOJw69Dg0OuA4CDrEOAA7KDgwOyQ4dDt8OJg7XDk8PCA9JD1IPaA9ODz8PeQ8TDwAPcQ8XDxoPVA8TD7EOJQ9/D+kOXA8JD4UPKw+WD/MOpA9lD4cPhA9ND4QPgQ+JDxsPXg+iD4APpg+AD7gPYw+0DzIPrA8+D7sPBQ+9DxwPyQ/3DtgPCw/gD+EO0g/uDroP1w7OD+EOtg/GDskP4A6dD8wOsQ+4DmkPmw5bD8IOlQ+qDnMPlw5hD44OaQ+dDnsPrA6SD7cOrQ+1DsMPjw6YD4kOhQ9/DnUPdw55D5MOrA+QDr0Pfg6JD24Ofg+FDpoPiQ6sD4cOvA91DowPew6bD38Oqw99DroPYw6cD18Okg9YDogPUQ6QD1cOlw9aDp8PZA6oD1sOpw9hDrMPWA6uDysNKQ93DdoOfQ02D8INNQ/BDU0PzA1OD84NNw/XDU8Pzw0ND48N8g7YDfYOqQ3gDqQN0g7aDRAP4w36DqUNxA7aDTgP5Q0TD+0N/g4TDgoPiA28DgsOHg8CDj8P/w1VDwoOVg/GDaYODA5BDxUOVw8WDiEPHQ4ODxcOQg82DkEPSA5SDx8OJA8oDhIPUA4sDz0ONQ+4DZUOzg2fDsENjw7XDZkOpQ10DssNiQ7yDYYOrw1wDqANYw6pDWAOdA2ADnkNbA5uDWQOuQ1rDrMNXA7PDVAOVA18DmcNWA7VDV4O3g1ZDtkNTA7mDXcO+w1/Du8NcQ4EDngO9g1rDhgOVQ7nDVUO4w1JDgYOQQ4DDk4OCQ5ZDjkN3w7sDB0P8QzkDh0NnQ4PDWYOkQxAD7EMEA+1DOQO3gyxDlENYg5TDTsOZQ06DmUNLw4ZDVkOVA0vDmYNIw4qDTwOVg0jDgENUg4LDUkOGQ0wDuQMYw4uDTEOHg0mDvIMeg61DHMOMg0mDiINHA4qDQoOwwyLDoUMiQ6cDKAObAyjDqsMuw53DL4OZwzJDl4Mrg5sDO4OfQzpDpQMyg6WDOYOagwTD5YMAw98DB8PWwwrD2cMPA9yDE8PkgxOD3gMWQ/CDF4PzAx/D7gMcA+VDGMPfwxoD4YMeA+aDHYPtQx/D8cMiQ+gDJgPkAyaD5IMow+zDJkPxAyaD6EMoQ+VDKwPswyiD8MMpA+kDKoPqwzBD6EMxg+0DKwPwwytD6gMzQ+1DMEPwAzED60MyA+zDMgPuQzMD7AM2Q+4DNUPqQzVD7QOFQ6WDvUNmA4CDocOCg59DgIOhQ4tDq0OIQ6TDi8OiA43DpcOOg6LDkEOsg4rDroOHg6bDkQOlg5nDrgONQ7ADicO1A5HDqgOZg6ZDnEOyA5TDqwOcA6bDnsOzQ5dDtoOUA6wDnsOnw6tDtMOZw7hDlgOAw9/DroOuQ73DpoOEA+FDiwPlg4dD30ONw9YDmgPpw5ID2YObw/FDmsPdA6AD5sOgA9xDoEPZw6FD6gObQ9oDoMPXA5MD1sOPQ9ODooPww6RD6sOqw+rDlEPUA5CD0UOcA9dDncPQg6JDz4OUA8nDosPMw5cDzUOeg83Do0PKA5gDysOVQ8dDn0PLQ5lDyEOWw8UDnQP9g10DwUOiw8CDoIPDw5aDeINRg3iDUoN7A1ADf8NNA31DVYN6w1mDfoNLg0ADlkN/A08DQkOWQ0GDmcNBg45DRMOWA0RDmcNEQ7zD60O8w+3DvsPuQ76D6cO5w/HDuAPsA7jD6QO2Q+lDuEPwA7WD7MOzw+mDtcPww7eD8wOzA+1Ds4Pxw7VD9AOvw+4Dr8PqQ7GD9gOtQ+qDsAPzA60D7sOtg/QDr0P3A6qD74OrA/VDrQP4Q6fD/IOkg/kDoQP8A6WD/wOVAcvAwEIbwMtCOECKweDA8UH2ANxB8ACNggTAuAGsAJ3BywCWAecAf0HSQEMBx8BfwedALwGJAB9BtoAsgUAAMQGfAHbBs8B6gZBAksGYAJYBvIBYwZjAdIF2ADmBXEBMwUEAb4EZgBsBYcB6wUFAukFVgJ9BRACFQW6AcAEcgEmBCQB5QV+ArcFmAIHBpACgQVvAqYFxgJWBrgCFQa6AjoGCQMCBvMCxwYQA8oFJgPPBQIDLAZYA78FVQN0BQwDqwX0AqMGWQN3BqwDEwagA9wG2QNXB0wEUQYeBJYGtwSaBTMEhwXbBKgFoQNIBaID8wQGBI0EfASoBMkDJgQABGEFXAPsBKgD5wRsA5UEhAPrBAkDiwQFAyYEnQO3A4QDpAPJA8ADfATCAwUDJgT+ApUE0AK3A9ACZgNsA2IDCQNgA6gD6wJcAwUDogNZAwYExgLbBLMCMwS3AbcEjQJVA/sBHgT2AE0EpQKiAzkCoANxAdkDiADZA9YBrAMiAYMDTABwA6kBWQMhAlgDhgERA/gALwMgAOICEgIJA20BsQLcAMECFwAUAtUALAL0AJwBTwBKAWMBQQJAASABzQCeAJABJQByAc8BiAF9Ac8B2gCZAgEAAQJhAvQB8gHpAWQBegLYABkDBQGNA2cAZgJxAWICBQLgAocBZAJWAs8CEAI4A7oBjANyAWcCfwKWApgCRQKQAssCcAKmAscC9gG5AjgCugJKAvQCggImA34CAgPYAgwDoQL0AtACzQJEA9MCPgNmAjwDBgKyA1gCqgPtASYEygImBE8CJgTVAaIE7QGaBFcCEAUGAg4FZgIIBdMCfQXNAv8JSASaCcgDQQkPBCYJzgMCCYkDPwkwBKAJ4gQZCeoDMQlQBL4I8AQ1CRMENAksBPUIdQRmCGkEJglDBPYIHgT1CFsEnAhpBEYICwSzCEwEZwgaBIsIqQOXCB0Eswi/A8kI5AP6CHAGUgleBkwJJQaPCQ4GmglDBoQJ1QW1CcQFRgnpBcQJ+gX6CacF0gksBg4K2gUiCggG+gg0BvoI9QWuCOkFqAglBqIIXgZwCNUFZQgOBloIQwY/CMQFMAj6BfoHpwUiCCwG5gfaBdIHCAYTChcBQgosAUEKtwACCpcBJAq/AOkJSQDWCVgA0AlhABgKwQAHChMB2Ql2AWkJ7wHRCW0BaQmvAWkJogEACW0B+Ah2AdAIlwHLCBMBvggXAY8ILAG6CMEAkAi3AK0IvwABCWEA6AhJAPsIWAA/BGcI7gN0CBQEswg0BCUI2wM2CI4EGgi8A8cIjANPCA0E8gjUA0sJSASqCJEEXAjfBBcIHAQ+CQoE/glSBOgIfQSmCOQEoggxBRcImQTkCFoENwlFBO4JRQSaCp0ENAl3BOYJcQSOCkwEsgp4BKYKlgSICpoEoQqrBOIJuwSECr0EngrjBDIJ5gTgCeoEggrqBJsKLQWkCIQFHQgoBTIJdQWpCNQFKQghBeAJGAWCChcFnAq8Ba8IIgY8CP4FuQjxBT8JPgWECjoFngpVBeIJYwWJCl0FoQqPBZMKiQWrCsQF9QmIBegJqgU3CWsFMwmLAl8HeALCB6gCyQdUAlkHSQK7B8ECagfYAtAH9gJ6B98C/gYbAw4HoQLyBmEC6wYgAlYHIAKxByAC5wbhAVgH5gGuB9oB6QajAV8HrgG5B5QB8AZvAWgHhgHIB1UB+wY6AXUHWAHWBxYBCwcFAYYHKgHhB9MAmwf7AO0HoQA0B9sAHQd7ANYGvQDABmEAWQb9AKsGpABDBnIAugUmANwFtwCUBekAKgYCAXEFQAGYBi4BEwZaAVcFhwGIBm0BuAW8AUkFhQFGBtMBfwaQAQIGzwE5BiACfQbDAa4FFQJMBcoB+AUVArAFbAJjBQYC9gVmAgQGwwKABRoCOAZqAoQGrwKQBrICFAYUA5UF8QKeBjYDrAb7AiIGWAOlBUADLga4Da4JpA2kCXgNxwnKDW0JhA3bCbUNbQlBDdUJuA0sCUgN7QmkDTcJBg3WCYQNAAkKDe8JeA0UCcYM7AlCDQcJwwzUCUgN7wh5DOEJCA3xCH0MygkGDQoJUgyzCcMM+AhADMIJwQwRCTUMcwl1DBoJIQx0CXIMAwk4DCIJSwwxCYMMcgnHDHQJwQwRCXUMGglLDDEJNQxzCVIMswl9DMoJBg0KCcMM1AkEDXAJQg0HCQYN1gk5DW0JeA0UCUEN1QlyDW0JpA03CXgNxwm1DW0JpA2kCQ8KeAkWCrwJYArDCV8K7wmTCugJLQriCagKvwmjCv8JXgoKCqwKDQpdCiAKwgrPCdAK3gkcCvoJEgoHCu0J2gn7CcwJywmcCegJiQmvCWYJ2QlLCcIJHAmVCTUJFQonCaoJ7Ah7CQEJ+QkBCeAJ1Qj4CcwIEQr3CDEKFwnqCZoIzwmfCOkJZwjJCWkIlAmwCIcJcQhkCcMIUQl+CGIKfwliCjEJrQp5Ca4KJwnVCosJ8gqfCegKTgkQC2oJLQs7CQELIAlJCwcJzAoCCZMKFgm1CvcIGwvxCGMLywjnCtgI0ArNCDMLtgh4C4cIQwt4CPoKowjfCp0IAgttCOIKaghACEEIOgj5B/EH+gfxBzkIpwf5B6IHQQi9B+QHiwe2B6wHsgfxB+gH8QezByUI5Ac2CLIHVwi2B54Onw2YDoQNeA6SDYYOoQ16DqgNww6jDcsOfQ3GDqUNMw5uDWwOng1TDsINYg7IDV0O0Q00DooNTg7MDVgO2g0rDsANGQ6SDRIOhg0WDrwNCA58DSgOyg0UDsYNSQ7WDSUO1A0SDtENPg7yDUsO9g1GDv8NHg7xDQwO7g06DvsNQQ4JDhsO+w0LDvgNNg4FDiYOHQ4sDicOGQ4EDgoOAw4aDhwODg4qDnUPhwt6D2cLOg9AC4wPfwuPD2cLlg+gC38PVQuRD1kLUg8wC44PLgudDzMLdw8QC00PFwttD/8KdA/5CkEPGwt+DwgLew/yCpQPJQuhDyoLhQ8AC5YP7QqPD94KmQ8cC6YPIQuXD9cKpw8GC7QPCAucD+YKng/QCq0P/Qq5D/8Kow/fCrMP9Aq+D/YKwQ/aCssP1Aq3D8wKvA/ACkIPhgt9D7wLAw+XC4gPvQuZD6ILWQ/NCysP4gt3DxAMmg+/C6APpAusD6cLhA//C5gP6AupD74LwA+7C74PqAvID6gLxA/PC8oPuQvSD6YLqQ/ZC6APBQyvD/cLkQ8VDLEPFgy9DwcMpg8jDM0P4gvYD+4Lhw8fDKAPLAx2Dy4MkQ89DGkPRQyFD04MRQ9LDEcPOAwjD1oMQQ8iDB0PSAwMD20MAw9eDOsOQQwJDzUMzw4VDFQPAQw5DwwMIA8UDAMP+QvnDgcM1Q6/C8AO3QuvDu4L1w5WC5sOyAuTDtsLhg7YC5UOmAuJDsULaw7GC2sO1QthDtYLfg6lC2AOyAtXDtcLYA6yC1YOygtzDowLaw6VC1UOowtwDn4LVg62C0wOqAtMDrkLQw6sCzQOswtHDs0LRg7ZCzwO2gs+Dr4LPQ7QCzIO2ws1DsELKw63CzMO0gssDsQLIg68CxAOywsaDswLGg7bCx8O1QtrDlUNXQ4KDR8OBQ0ZDmENqg5IDdQNYA3VDXgNyg15DcgNYg2/DXoNxw04DQcOHQ2+DSEN7Q0LDfIN/gzxDe8MvA07DbQNJQ28DWMNsQ0+DakNKQ2DDTUNiw1JDZQNag2XDYANjA2BDYoNbA2BDYINgQ1MDXkNOQ1/DW0NYA1sDU4NfQ1aDWANRg1YDXcNTw1uDT0NBQ9rDdQOiQ3KDqoN3g6bDeEOqw3PDrQNBA95DfwOoQ3jDsQN0g7GDfYOww0BD44NEA+jDRcPkw0HD8UNHg+EDSQPeg0ED84NLw9nDfUOzA0BD9cN4w7ODdMOzw0aD0oNOw9XDSwPPg3lDjsNGQ8UDaUODw0qDxkNAA8uDR8P6gwvD/UMAA8RDeEODw0CD/UM6w7mDCoPzgw4D9kM+g7LDBEPtAy4DtwM0w62DOIOngylDqUMsg6ODHkOyAyHDpEMlQ59DEIOpwx9DoQMiw50DH0OXAxFDo0MbA5nDEMOZgwvDoQMMQ5lDCgOjwwxDloMQg5aDDAOTwxoDlwMeA5RDEAOTgxkDlEMdA5HDD4OPAwvDjwMbQ41DC8OMQxdDj4MPQ4xDDAOJQxaDjQMaA4rDD0OJwxWDioMYg4gDFAODQxADhYMPA4NDEwOFwzTDtkN1g7wDeEO7A3jDvMN3Q74DeIO1w3fDgAO7g4ADuYOBA7uDvgN6Q7zDesO7A31DvEN8g7VDdEOnwreDqUK3g6ACtkOdArxDn0K9Q5xCgYPmQr7DqMKCQ+jCt8OsAr9Dq4KDA+uCtEOqgoAD7kKFw/TCuAOuwrRDrUK0Q7aCuMO3goHD9wKGg/dCgoP5woeD+cK5A7pCtEO5QoND/IKNg8TC+UO9QrRDvAKyQ4iC+IOMwsmDysLwg4uC7QOTQuzDi8LiA4eC4sOewtsDlILWQ5bC1IOUwuCDjMLZA5KC0sOSwt4DiwLfg4ZC1sOQgtGDi8Lbw4mC3UOFAtZDgMLNQ41Cy0OLQtWDhYLPg4nCyYOJQtNDg8LTw7+CjYOIAtEDgkLRQ75CiAO7QonDvoKEw4FCyEOCgt+DYAMjQ2EDJMNeQygDZYMkA1tDJMNowyvDYAMtA10DL0Ndwy4DYQMxw17DKgNnAybDaoMwQ2JDLANogykDbEMyw20DL8NxAzdDZYM4w2HDO0NiwznDZsM9g2PDNUNugzIDcsM8Q2fDN4NwAzQDdEMDg7nDCMOqwweDpcM5w/hC/oPzQvxD8QL+Q++C/8PxAv1D7cL7A+7C90P1gvfD+gL8w+vC9UP3AvXD8YLzg/LC9QPtgvpD7AL6g+jC/QPpwsqCV8C2gmvAusJkgIqCRQDwwkmAtYJ0QLkCZYD8wmbAvYJEAN1ClAD5gmxAuYJzAJICjQDwgoRAwMK+gIiCsUCQwoPA54KDQO7CpoCdAr2Ao0KlwJmCkECZwqrAiQKaQIfCocCBwgAAAcIAAAHCAAABwgAAAcIAAAHAAAABwgAAAcIAAAHAAAABwgAAAcIAAAHCAAABwgAAAcIAAAHCAAABwgAAAcIAAAHCAAACAAAAAcIAAAHCAAACAAAAAgJAAAIAAAACAAAAAgJAAAICQAACAkAAAgJAAAICQAACAAAAAgJAAAICQAABwgAAAgAAAAICQAACAkAAAcIAAAHCAAABwgAAAcIAAAHCAAACAAAAAcIAAAHCAAABwgAAAcIAAAHCAAABwgAAAgAAAAIAAAACAAAAAgJAAAICQoACAkKAAgJCgAICQoACAkKAAgJAAAICQAABwAAAAcAAAAHAAAABwAAAAcAAAAGBwAABgcAAAYHAAAGBwAABgcAAAcIAAAHAAAABwAAAAcIAAAGBwAABAYAAAMEBgAHCAAABwgAAAcIAAAHCAAABwgAAAcIAAAHCAAABwgAAAYHAAAGBwAAAgYHAAYHAAACBgcAAQIGBwIGBwABAgYHAgMGBwIDBgcBAgYHAQIGBwIDBgcCAwYHAQIGAAECBgcBAgYHAQIDBgIDBhoDBAYaAwQaAAABAi4AAQIuAQIAAAECAwYAAQIuAAECLgABAi4BAgAAAQIDGgECAwAAAQIuAAECLgECAAAAAQIuAAECAAABLjIAAQIyAQIAAAECAxoAAQIyAAEuMgABAi4AAS4yAAECLgABAi4AAQIuAAECLgABAi4AAQIuAAECLgABAjIAAQIyAAECMgABAjIAAQIyAAECMgABAjIAAQIyAAECMgABAjIAAQIyAAECMgABAjIAAQIyAQIaGwECAAABAhoAAQIaGwECGhsBAhobAQIaGwECAxoCAxobAgMaGwECGhsCAxobGhsAAAQaAAAaGwAAGhsAABobAAAaGwAAAgMaGxobAAAbAAAAAhobABsAAAAbAAAAAhobAAIaGwAaGwAAGhsAABobAAAbAAAAGwAAABscAAAbHAAAGxwAABsAAAAbHAAAGwAAABscAAAbHAAAGxwAABscAAAbHAAAGxwAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHCAAABwgAAAcAAAAGBwAABwAAAAcIAAAHCAAABwgAAAcIAAAHCAAABwgAAAYHAAAGBwAABgcAAAYHAAAGBwAABgcAAAYHAAACBgcAAgYHAAYHAAAGBwAABgcAAAQGAAADBAYAAgMGBwECBgcBAgYHAQIGBwECBgcCAwYHAQIDBgECBgcAAQIuAQIGAAIDBgcAAQIuAAECLgABAi4CAwYaAgMGGgIDBhoDBAYaAwQaAAIDBhoCAwYaGhsAAAQaAAAaGwAAGhsAAAECAxoCAwYaAgMaGxobAAAaGwAAGhsAABobAAACAxobAQIDGhsAAAAbAAAAGhsAABobAAAbAAAAGwAAABsAAAAaGwAAGwAAABsAAAAbAAAAGwAAABscAAAbHAAAGxwAABscAAAbHAAAGxwAABscAAAbHAAAGhsAAAIaGwACGhsAAgMaGwECGhsBAhobAQIDGgECGhsBAhobAQIaGwABAjIBAhoAAQIaAAECAAAAAQIyAAECMgABAjIAAQIyAAECAAABAjIAAQIyAAECMgABAjIAAQIyAAECMgABAjIAAQIyAAECMgABAjIAAQIyAAECMgABAjIAAQIyAAECLgABAi4AAQIuAAECLgABAi4AAQIuAAECLgABAi4AAQIuAAECLgABAi4AAQIuAQIGAAECAwYAAQIuAAEuMgABLgAAAQIuAAEuMgABAi4AAQIuAAECLgABAi4AAS4AAAEuAAABLgAAAS4AAAEuAC4AAAAALgAALgAAAAABLgAAAS4yAAEuMgABLjIAAS4yAAECMgABLjIAAS4yAAEyAAABAjIAATIAAAEuMgABAjIAAQIyAAECMgABAjIAATIAAAEyAAABMgAAATIAMgAAAAABMgAAMgAAMgAAAAAyAAAyAAAAMjMAAAAuMgAAMgAAMgAAAAAyAAAyAAAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMgAAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAAAAyMwAyMwAAADIzAAAyAAAALjIAAC4yAAAuMgAALjIAAC4yAAAuMgAALjIAAAEuMgAuMgAALjIAAC4yAAAuMgAALgAAAC4AAAAuLwAALgAAAC4AAC4AAAAuLwAALgAAAC4AAAAuAAAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAAAC4vAC4vAAAAAQIuAAECLgABAi4AAQIuAAECLgABAi4AAS4AAAEuAAABLgAAAS4yAAECLgABAjIAAS4yAAEuMgABLjIAAQIyAAECMgABAjIAAQIyAAEuMgABLjIALjIAAAECMgABAjIAAQIyAAEyAAABMgAAATIAAC4yAAABMgAAATIAAAEyAAAuMgAyAAAAMgAAAAAyAAAAMgAAMgAAADIAAAAyAAAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAAAAyMwAAMjMAADIAAAAuMgAALjIAAC4yAAAuMgAALjIAAC4yAAAuMgAALjIAAC4AAAAuLwAALi8ALi8AAAAuAAAAAS4AAAEuAAABLgAALgAALgAAAC4AAAAuLwAALgAAAC4AAAAuAAAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAvMAAALzAAAC8wAAAvMAAALzAAAC8wAAAvAAAALwAAAC8AAAAvMAAALzAAAC8AAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALwAAAC4vAAAvAAAALzAAAC8wAAAvMAAALzAAAC8AAAAvMAAALzAAAC4vAAAvAAAALzAAAC8wAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAuLwAALi8AAC4vAAAvAAAALwAAAC8AAAAvMAAALzAAAC8wAAAvMAAALzAAAC8wAAAvMDEALzAxAC8wMQAvMDEALzAxAC8wMQAvMAAAMDEAAC8wAAAvMDEALzAxADAxAAAvMDEAMDEAAC8wMQAwMQAALzAxADAxAAAvMDEAMDEAAC8wMQAwMQAALzAxADEAAAAwMQAAMQAAADAxAAAwMQAAMDEAADAxAAAwMQAAMDEAADEAAAAwMQAAMDEAADAxAAAxAAAAMDEAADAxAAAwMQAAMDEAADAxAAAwMQAALzAxADAxAAAvMDEALzAxAC8wMQAvMDEALzAxAC8wMQAvMAAALzAxADAxAAAwMQAAMDEAADAxAAAwMQAAMDEAADEAAAAwAAAALzAxAC8wAAAwMQAAMDEAADAxAAAwMQAAMDEAADAxAAAxAAAAMQAAAC8wMQAvMDEALzAxAC8wMQAvMDEALzAAAC8wAAAvMAAALzAxAC8wMQAvMAAALzAAAC8wAAAvMAAALzAAAC8wAAAvMAAALzAAAC8wAAAwMQAAMDEAADAxAAAwMQAAMDEAADAxAAAwMQAAMDEAAC8wMQAvMDEALzAxAC8wMQAvMAAALzAAAC8wAAAvMAAALzAAAC8wAAAvMDEALzAxAC8wAAAvMAAALzAAAC8wAAAvMDEALzAAAC8wAAAvMAAAMAAAAC8wAAAvMDEALzAAAC8wAAAvMAAALzAxAC8wAAAvMAAALzAAAC8wAAAvMAAALzAAAAoNDgANDgAADQ4RAA4AAAAJCg0OCgsNDgkKDQ4KCw0ODhEUAA4RAAAODwAADg8AAA4PAAAOEQAADg8AAA4PAAAODwAADhEAAA4RAAAODwAADhEAAA4PAAAODwAADg8AAA4PEAAODxAADxAAAA8QAAAPEAAADxAAAA8QAAAPEAAADxAAAA8QAAAPEAAADxAAAA8QAAAPEAAAEAAAABAAAAAQAAAAEAAAAA0OAAANAAAADQ4RFA0AAAAKCw0OCg0OAA0OEQANDgAADQ4RAA4AAAANDhEADg8AAA4PAAAODwAADhEAAA4PAAAODwAADhEAAA4PAAAODxAADg8AAA4PAAAODxAADxAAAA8QAAAODwAADg8AAA8QAAAODxAADxAAAA8QAAAPEAAADxAAAA8QAAAPEAAAEAAAABAAAAAQAAAAEAAAAA8QAAAPEAAACQ0UFwkNFwAJDRcACAkKDQkNFBcJDRQXCQoNAA0RFBcICQoNCQoNAAgJCg0ICQoNCAkKDQgJAAAJDRQXCAkXAAkNFBcICQAACAkAAAgJAAAICQAACAkKAAgJAAAICQoACAkKAAgJCgAICQoACAkKAAgJCg0JCgAACAkKDQoAAAAJCg0ACQoNAAoNAAAKCw0OCgsNAAoLDQAKCw0OCgsMDQsNAAAKCw0ACgsNAAoLDQALDA0ACwwNAAsMDQALDA0ACgsMAAoLDAALDA0ACwwAAAsMDQALDAAACwwAAAsMAAALDAAACwwAAAsMAAAMAAAACwwAAAsMAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAACQ0OEQ4RFAAOERQAERIAABESAAAREgAAERIAABESAAAREgAAERQAABESAAARFAAAERQAABESAAAREgAAERQAABESAAAREgAAERIAABITAAARFAAAEhMAABESEwASEwAAEhMAABQVAAASEwAAEhMAABITAAASEwAAEhMAABMAAAATAAAAEhMAABITAAATAAAAEwAAABQVAAAUFQAAFBUAABQVAAAUFQAAFBUAABUWAAAUFQAAFBUAABQVAAAUFwAAFBcAABQXAAAUFQAAFBUWABQVFgARFBcAFBcAABUWAAAVFgAAFRYAABUWAAAVFgAAFRYAABUWAAAVFgAAFgAAABUWAAAVFgAAFgAAABYAAAAWAAAACQ4RFAkNDhEJDREUCREUFwkUFwAJCg0ACQoNDgkAAAAJERQXFBcAABQXGAAUFxgAFxgZABQXAAAXGAAAFxgZABcAAAAXGBkACRQXABQXAAAXGAAACQ0UFxcYAAAXGAAACRQXAAkNFBcXGAAAFxgZABcYGQAJFBcACAkXAAgJFwAICQAACRcAAAgJAAAICQAACAkAAAgJAAAICQAACAkAAAgJAAAICQoACAkKAAgJCgAICQoACAkKAAgJCgAJCg0ACQoAAAkKDQ4KCw0OCgsNAAoNAAAKAAAACgsNAAoLDQAKCw0ACgsMDQoLDA0KCwwACwwAAAsMDQALDA0ACwwAAAsMAAALDA0ACwwNAAsMAAALDAAADAAAAAsMAAALDAAADAAAAAsMAAALDAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAEhMAABMAAAATAAAAEwAAABMAAAASEwAAEhMAABITAAASEwAAEhMAABITAAASEwAAEhMAABESEwAREgAAERITABITAAAREgAAERIAABESAAAREgAAERIAABESAAAREgAAERIAABESAAAOEQAAERIAABESAAARFAAADQ4RFA0RFAARFAAAERQAABEUAAAUFQAAFBcAABQVAAANFBcAFBUAABQXAAAUFQAAFBUAABQXAAAUFQAAFBUWABQVAAAUFQAAFBcAABQXAAAUFxgAFBUAABQVAAAUFRYAFBUWABQVFgAVFgAAFRYAABQVFgAUFRYAFRYAABUWAAAVFgAAFRYAABUWAAAVFgAAFgAAABUWAAAWAAAAFRYAABkAAAAYGQAAGQAAABgZAAAXGBkAGQAAABgZAAAXGBkAGBkAABcYGQAYGQAAFxgZABcYGQAXGBkAFxgZABgZAAAYGQAAGBkAABkAAAAXGBkAFxgZABgZAAAXGBkAFxgZABcYGQAXGBkAFxgZABcYGQAXGBkAFxgZABcYGQAXGBkAFxgZABcYGQAXGBkAFxgZABQXGBkXGAAAFxgAABQXGAAUFxgAFxgAABQXAAAUFwAACRQXAAkUFwAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAQFAAAFAAAABAUAAAQFAAAEBQAABAUAAAQFAAAEBQAABAUAAAQFAAAEBQAABAUAAAQFAAAEBQAABAUAAAQFAAAEBQAABAUAAAQFAAAEBQAABAUAAAQFAAAEBQAABAUAAAQFAAAEBQAABAUAAAQFAAAFAAAABAUAAAUAAAAFAAAABQAAAAUAAAAEBQAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAQFAAAFAAAABQAAAAUAAAAFAAAABAUAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAQFAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAUAAAAFAAAABQAAAAMEBhoDBAYAAwQGAAMEBQYDBAYAAwQFBgMEBQYDBAUGAwQFBgMEBRoDBAUGAwQFGgMEBhoDBAYaAwQGGgMEBRoDBBoAAwQaAAMEBRoDBAUaAwQaAAMEBRoDBAUaAwQFGgMEBRoDBAUaAwQGGgMEBgAEBgAAAwQGAAMEBgADBAUGAwQGGgMEBhoDBAYaAwQFBgMEBgADBAYAAwQGGgMEBgADBAYaAwQGGgMEGgADBBoAAwQaAAMEGgADBBoABBoAAAMEBRoDBBoAAwQFGgMEBhoDBAYaAwQGGhscAAAbHAAAGxwAABscAAAbHAAAGwAAABscAAAbHAAAGxwAABscAAAbHAAAGxwAABsAAAAbHAAAHAAAABscAAAbHAAAGxwAABscAAAbHAAAGxwAABwAAAAcHQAAHAAAABwAAAAcHQAAHB0AABwdAAAcHQAAHB0AABwAAAAcHQAAHB0AABscAAAcAAAAHB0AABwdAAAbHAAAGxwAABscAAAbHAAAGxwAABwAAAAcHQAAHB0eABscAAAbHAAAGxwAABscAAAcHR4AHB0eABwAAAAcHR4AHB0eABwdAAAcHQAAHAAAABwAAAAbHAAAGxwAADM0AAAzNAAAMzQAADM0AAAzNAAAMzQAADM0AAAzNAAAMwAAADMAAAAzAAAAMwAAADM0AAAzNAAAMwAAADM0AAAzNAAAMwAAADM0AAAzNAAAMwAAADM0AAAzNAAAMwAAADM0AAAzNAAAMwAAADM0AAAzNAAAMzQAADM0AAAzAAAAMwAAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADIzAAAyMwAAMjMAADM0NQAzNDUAMzQ1ADM0AAAzNDUAMzQAADM0NQAzNDUAMzQ1ADM0NQA0NQAAMzQ1ADM0NQAzNDUANDUAADM0NQA0NQAAMzQ1ADQ1AAAzNDUANDUAADQ1AAA0NQAANDUAADQ1AAA0NQAANQAAADQ1AAA1AAAANDUAADQ1AAA0NQAANQAAADQ1AAA0NQAANDUAADQ1AAA1AAAANDUAADQ1AAA0NQAANDUAADQ1AAAzNDUANDUAADM0NQAzNDUAMzQ1ADM0NQAzNDUAMzQ1ADM0AAAzNDUANDUAADQ1AAA0NQAANQAAADQ1AAA0NQAANDUAADQ1AAA1AAAANDUAADUAAAA0NQAANDUAADQ1AAA0NQAANDUAADQ1AAA0NQAANDUAADM0NQAzNDUAMzQ1ADM0NQAzNDUAMzQ1ADM0NQAzNAAAMzQAADM0AAAzNAAAMzQAADM0AAAzNAAAMzQAADM0AAAzNAAAMzQAADM0NQAzNAAANDUAADQAAAA0NQAAMzQAADQ1AAA0NQAAMzQ1ADM0NQAzNDUAMzQ1ADM0NQAzNAAAMzQAADM0AAAzNDUAMzQ1ADM0AAAzNAAAMzQAADM0AAAzNAAAMzQAADM0AAAzNAAAMzQAADM0AAAzNAAAMzQAADQAAAAzNAAAMzQ1ADM0AAAzNDUAMzQAADM0AAAzNAAAMzQAADM0AAAzNAAAHiEiAB0eISIhIiUAISIAACIAAAAeHyEiHR4hIh4fISIiJSgAIiUAACIjAAAiIwAAIiMAACIlAAAiIwAAIiMAACIjAAAiJQAAIiUAACIjAAAiJQAAIiMAACIjAAAiIwAAIiMkACIjJAAjJAAAIyQAACMkAAAjJAAAIyQAACMkAAAjJAAAIyQAACMkAAAjJAAAJAAAACQAAAAjJAAAIyQAACQAAAAkAAAAISIAACEiJQAhIiUoHiEiACEiAAAeHyEiISIlACIAAAAhIiUAIiMAACIjAAAiIwAAIiUAACIjAAAiIwAAIiUAACIjAAAiIyQAIiMAACIjAAAiIyQAIyQAACMkAAAiIwAAIiMAACMkAAAiIyQAIyQAACMkAAAjJAAAIyQAACMkAAAjJAAAIyQAACMkAAAkAAAAJAAAACQAAAAkAAAAIQAAACEAAAAdISgrHiEAAB4fISIdHiEAHR4hABwdHiEeHyEAHh8hIh4fICEdHiEAHh8hAB8hAAAfICEAHyAhAB8gIQAfICEAHyAhAB8gAAAeHyEAHR4hAB4fIQAcHR4hHgAAAB4fIQAdHgAAHh8gAB4fIAAcHR4hHB0eABwdHgAcHR4AHB0eABwdHgAcHQAAHB0eABwdAAAcHR4hHB0AABwdAAAcHQAAHB0rABwdAAAdISgrHB0eIRwdHiEcHR4hHSErAB0hKwAdISgrHSEoKx0hKCshJSgrHSgrAB0oKwAoKwAAISgrACgrAAAoKywAKywAACssAAAoKwAAKywAACssLQAoKywAKywtACgrAAAoKwAAKCssACgrAAAoKywtKywtACssLQArLC0AKywtACssLQArLC0AKywtACssLQArLC0AKywtACssLQArLC0AKywtACssLQAsLQAALQAAACwtAAAsLQAALC0AAB0hIiUdIiUoIiUoACIlKAAdISIlJSYAACUmAAAlJgAAJSYAACUmAAAlJgAAJSgAACUmAAAlKAAAJSgAACUoAAAlJgAAJSYAACUmAAAlJgAAJSYAACYnAAAmJwAAJSYnACYnAAAmJwAAJicAACYnAAAmJwAAJicAACYnAAAnAAAAJwAAACcAAAAnAAAAJicAACYnAAAdHiEAHR4hIh4fISIeHyEAHh8hAB4fICEdHiEAHh8hAB8gIQAfICEAHh8gIR4hAAAeHyEAHgAAAB4fIAAdHgAAHB0eAB8gAAAcHR4AHyAAAB8gAAAfICEAHyAhABwdHgAcHR4AHB0eAB0eISIcHQAAHSElKBwdAAAcHR4AHB0AABwdAAAcHQAAHQAAABwdAAAdKwAAHB0AABwdAAAcHSsAHB0rAB0lKCsdKCsAHSEoKx0oKwAdISgrHSUoKx0oKwAdKCsAJSgrACgrAAAoKwAAKywAACgrAAArAAAAKCssACgrAAAoKywAKCsAACssLQArLAAAKywtACssAAArLAAAKywtACssAAArLC0AKywtACssLQArLC0AKywtACssLQAsLQAALC0AACssLQArLC0ALC0AACwtAAArLC0ALC0AAC0AAAAtAAAALQAAAB8gAAAfIAAAHyAAACAAAAAgAAAAHyAAACAAAAAgAAAAIAAAACAAAAAgAAAAHyAAACAAAAAfIAAAJicAACYnAAAnAAAAJwAAACcAAAAnAAAA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DwAHAAEAEAALAA8AEAABAAsAEQAMABAAEQALABEAEgAMAA8AEwAQAA0AEwAPABAAFAARABMAFAAQABEAFQASABQAFQARABUAFgASABMAFwAUAA0AFwATABQAGAAVABcAGAAUABUAGQAWABgAGQAVABkAGgAWABkAGwAaABwAGwAZABgAHAAZABwAHQAbABcAHgAYAB4AHAAYAB8AHQAcAB4AHwAcAB8AIAAdACEAHgAXAA0AIQAXACIAHwAeACEAIgAeACMAIAAfACIAIwAfACMAJAAgACUAIQANAA4AJQANACYAJQAOACUAJwAhACcAIgAhACYAKAAlACgAJwAlACkAKAAmACcAKgAiACoAIwAiACkAKwAoACwAKwApACwALQArACsALQAuACgALwAnACsALwAoAC8AKgAnACsALgAwACsAMAAvAC4AMQAwAC4AMgAxADAAMwAvAC8AMwAqADAAMQAzACoANAAjADMANAAqADQAJAAjADQANQAkADMANgA0ADYANQA0ADEANgAzADYANwA1ADEAOAA2ADgANwA2ADIAOAAxADgAOQA3ADIAOgA4ADoAOQA4ADoAOwA5ADwAPQA+ADwAPgA/AD0AQAA+AEEAPAA/AEEAPwBCAEMAQQBCAEMAQgBEAEMARABFAEYARwBAAEYAQABIAD0ASABAAEkARgBIAEMARQBKAEoARQBLAEoASwBMAEkASABNAE4ASQBNAE8ASAA9AE8ATQBIAE4ATQBQAFEATgBQAFEAUABSAFMAUgBQAFQAUABNAFMAUABUAFQATQBPAFUAUwBUAFUAVABWAFYAVABPAFcAVQBWAFgATwA9AFYATwBYAFgAPQA8AFcAVgBZAFkAVgBYAFoAVwBZAFsAWAA8AFkAWABbAFsAPABBAFoAWQBcAFwAWQBbAF0AWwBBAFwAWwBdAF0AQQBDAEMAXgBdAFwAXQBeAEMASgBeAFoAXABfAFoAXwBgAFwAXgBhAF8AXABhAGIAXgBKAGEAXgBiAGIASgBMAGAAXwBjAGAAYwBkAF8AYQBlAGMAXwBlAGEAYgBmAGUAYQBmAGcAYgBMAGYAYgBnAGcATABoAGcAaABpAGQAYwBqAGQAagBrAGMAZQBsAGoAYwBsAGwAZQBtAGUAZgBtAGsAagBuAGsAbgBvAGoAbABwAG4AagBwAGwAbQBxAHAAbABxAG0AZgByAGYAZwByAHEAbQBzAG0AcgBzAHAAcQB0AG4AcAB1AHUAcAB0AHQAcQB2AHEAcwB2AHUAdAB3AHQAdgB4AHcAdAB4AHcAeAB5AHoAeAB2AHsAdgBzAHoAdgB7AHsAcwB8AHwAcwByAH0AeQB4AH0AeAB6AHcAeQB+AH0AfgB5AHcAfgB/AHUAdwB/AIAAfwB+AHUAfwCBAIAAggB/AIIAgQB/AG4AdQCBAIIAgwCBAG4AgQCEAIMAhACBAG8AbgCEAIMAhQCEAG8AhACGAIYAhACFAIYAhQCHAIAAfgCIAH0AiAB+AIAAiACJAIoAiAB9AIoAfQB6AIkAiACLAIoAiwCIAIkAiwCMAIoAegCNAI0AegB7AI4AiwCKAI4AigCNAIwAiwCPAI4AjwCLAIwAjwCQAJEAkACPAJEAkgCQAJMAkQCPAJMAjwCOAJQAkwCOAJQAjgCVAI4AjQCVAJYAlACVAI0AewCXAJUAjQCXAJcAewB8AJYAlQCYAJUAlwCYAJkAlgCYAJcAfACaAJgAlwCaAJkAmACbAJgAmgCbAJwAmQCbAJoAfACdAHwAcgCdAJ0AcgBnAJoAnQCeAJsAmgCeAJ0AZwCfAJ4AnQCfAGcAaQCfAJsAngCgAJwAmwCgAJ4AnwChAKAAngChAJ8AaQCiAJ8AogChAKIAaQCjAKIAowCkAKUAogCkAKUAoQCiAKUApACmAKUApgCnAKUAqAChAKAAoQCoAKUApwCpAKgApQCpAKkApwCqAKAAqACrAKgAqQCrAKkAqgCsAKsAqQCsAKwAqgCtAKAAqwCuAJwAoACuAJwArgCvAK4AqwCwAKsArACwAK8ArgCxAK4AsACxAK8AsQCyAKwArQCzALAArACzALMArQC0ALEAsAC1ALAAswC1ALIAsQC2ALEAtQC2ALIAtgC3ALMAtAC4ALUAswC4ALkAuAC0ALkAtAC6ALsAuAC5ALUAuAC8ALsAvAC4ALYAtQC8AL0AvAC7ALYAvAC+AL0AvgC8ALcAtgC+AL8AvgC9ALcAvgDAAL8AwAC+AMEAwgDDAMQAwwDCAMQAxQDDAMEAwwDGAMcAwQDGAMUAyADDAMYAwwDIAMUAyQDIAMcAxgDKAMsAxwDKAMYAyADMAMoAxgDMAMkAzQDIAMwAyADNAMkAzgDNAM4AzwDNAM4A0ADPANEAzQDPAMwAzQDRANEAzwDSAMoAzADTANMAzADRAMsAygDUANQAygDTANUAywDUANYA0QDSANMA0QDWANYA0gDXANQA0wDYANgA0wDWANUA1ADZANkA1ADYANoA1gDXANgA1gDaANoA1wDbANkA2ADcANwA2ADaANUA2QDdANUA3QDeAN0A3wDeAN0A4ADfAOEA2gDbANwA2gDhAOEA2wDiAOEA4gDjAOEA4wDkAOQA4wDlANwA4QDmAOEA5ADnAOEA5wDmAOQA5QDoAOgA5QDpAOQA6gDnAOQA6ADqANwA5gDrANkA3ADrANkA6wDdAOgA6QDsAOwA6QDtAOgA7gDqAOgA7ADuAO8A3QDrAO8A4ADdAOsA8ADvAOsA5gDwAPEA4ADvAPEA8gDgAPEA8wDyAO8A9ADxAO8A8AD0APEA9QDzAPUA8QD0APUA9gDzAPYA9wDzAPYA+AD3APkA+AD2APAA+gD0APUA9AD7APsA9AD6APUA/AD2APwA9QD7APkA9gD9AP0A9gD8APkA/QD+APkA/gD/AP0A/AAAAfwA+wABAQAB/AABAQEB+wACAfsA+gACAf8A/gADAf8AAwEEAf0ABQH+AP0AAAEFAf4ABgEDAf4ABQEGAQQBAwEHAQQBBwEIAQMBBgEJAQMBCQEHAQUBCgEGAQgBBwELAQgBCwEMAQ0BDAELAQ0BCwEOAQcBDwELAQ4BCwEPAQcBCQEPAQ4BDwEQARABDwERAQkBEQEPARABEQESARIBEQETARIBEwEUAQkBFQERARUBEwERAQYBFQEJARUBFgETAQYBCgEVAQoBFgEVAQoBFwEWARgBFwEKAQUBGAEKARgBGQEXAQABGAEFARoBGQEYAQABGgEYARoBGwEZAQABAQEaARoBHAEbARoBAQEdARoBHgEcARoBHQEeAR4BHwEcAQEBAgEdAR4BIAEfASABIQEfAR4BHQEiAR4BIgEgAR0BAgEjAR0BIwEiAQIBJAEjAQIB+gAkASABJQEhASUBJgEhASABIgEnASABJwElASIBIwEoASIBKAEnASMBKQEoASMBJAEpASUBKgEmASoBKwEmASUBJwEsASUBLAEqASoBLQErASwBLQEqAS0BLgErAS0BLwEuAS8BLQEwASwBMAEtAS8BMAExAScBMgEsATIBMAEsAScBKAEyATEBMAEzATIBMwEwATEBMwE0ASgBNQEyATUBMwEyASgBKQE1ATQBMwE2ATUBNgEzATQBNgE3ATgBNwE2ATgBNgE5ATUBOQE2AToBOAE5ATsBNQEpAToBOQE8AT0BOgE8ATUBPgE5AT4BPAE5ATsBPgE1AT0BPAE/AT8BQAE9AT8BQQFAAUIBPwE8AT4BQgE8AUMBQQE/AUIBQwE/AUMB7QBBAewA7QBDAewAQwFCAewAQgHuAO4AQgE+Ae4APgE7AeoA7gA7AeoAOwFEAUQBOwEpAecA6gBEAUQBKQEkAecARAFFAUUBRAEkAeYA5wBFAUUBJAH6AOYARQHwAPAARQH6AEYBRwFIAUYBSAFJAUoBRwFGAUkBSAFLAUkBSwFMAUwBSwFNAUwBTQFOAUsBTwFNAUsBUAFPAUgBUAFLAVABUQFPAUgBUgFQAUcBUgFIAVABUwFRAVIBUwFQAVQBUQFTAVQBUwFVAVYBVAFVAVIBVwFTAVUBUwFXAUcBWAFSAVgBVwFSAVkBWAFHAUoBWQFHAVgBWgFXAUoBWwFZAUoBXAFbAVkBXQFYAV0BWgFYAVkBWwFeAVkBXgFdAVwBXwFbAVwBYAFfAVsBYQFeAVsBXwFhAV0BXgFiAWABYwFfAWABZAFjAWQBZQFjAWQBZgFlAWMBZQFnAV8BYwFoAWMBZwFoAV8BaAFhAWgBZwFpAWgBaQFqAWEBaAFqAWsBagFpAV4BYQFsAWEBagFsAV4BbAFiAWsBbQFqAW0BbAFqAW4BbQFrAW0BbwFsAW8BYgFsAW4BcAFtAXABbwFtAXEBcAFuAW8BcgFiAXABcwFvAXMBcgFvAXQBcwFwAXEBdAFwAXMBdQFyAXEBdgF0AXEBdwF2AXgBdgF3AXgBdwF5AXoBdgF4AXoBewF2AXQBdgF7AXwBewF6AXQBfQFzAXQBewF9AX0BdQFzAXwBfgF7AX0BewF+AX8BfgF8AX0BgAF1AX0BfgGAAX8BgQF+AYABfgGBAYIBgQF/AYIBgwGBAYQBgQGDAYABgQGEAYQBgwGFAYQBhQGGAYABhAGHAYQBhgGHAYABhwF1AYcBhgGIAXUBhwGJAYcBiAGJAXUBiQFyAYoBiQGIAXIBiQGLAYoBiwGJAXIBiwFiAYoBjAGLAYoBjQGMAY4BjAGNAYsBjwFiAYsBjAGPAV0BYgGPAV0BjwFaAZABjwGMAY4BkAGMAZABWgGPAY4BkQGQAY4BkgGRAZMBWgGQAZMBkAGRAZQBWgGTAZQBVwFaAVUBVwGUAZUBkQGSAZUBkgGWAZcBkwGRAZcBkQGVAZgBlAGTAZgBkwGXAZkBVQGUAZkBlAGYAVYBVQGZAZoBVgGZAZsBmQGYAZoBmQGbAZwBmAGXAZsBmAGcAZoBmwGdAZoBnQGeAZ8BngGdAZ8BoAGeAaEBnwGdAZsBogGdAaEBnQGiAZsBnAGiAaMBoQGiAaMBogGkAZwBpAGiAaUBowGkAZwBlwGmAZwBpgGkAaYBlwGVAaUBpAGnAaYBpwGkAagBpQGnAagBpwGpAaYBqgGnAaYBlQGqAaoBqQGnAaoBlQGWAaoBqwGpAaoBlgGrAawBrQGuAa8BrQGsAa8BsAGtAawBrgGxAbABsgGtAbABswGyAa0BtAGuAa0BsgG0AbEBrgG1AbEBtQG2AbcBtgG1Aa4BuAG1Aa4BtAG4AbcBtQG5AbkBtQG4AbcBuQG6AbcBugG7AbwBuwG6AbwBugG9Ab4BvAG9AbkBvwG6Ab0BugG/AbkBuAHAAbkBwAG/AcABuAHBAbQBwQG4Ab4BvQHCAcMBvgHCAcMBwgHEAcIBvQHFAb0BvwHFAcQBwgHGAcIBxQHGAcQBxgHHAcUBvwHIAcAByAG/AcYBxQHJAcUByAHJAccBxgHKAcYByQHKAccBygHLAcABzAHIAcABwQHMAc0BywHKAc0BzgHLAc8BygHJAc8BzQHKAdABzwHJAdAByQHIAdEBzQHPAdIBzgHNAdEB0gHNAdIB0wHOAdQB0QHPAdQBzwHQAdUB0gHRAdYB0wHSAdUB1gHSAdYB1wHTAdYB2AHXAdYB2QHYAdUB2QHWAdoB2AHZAdoB2QHbAdsB2QHcAdUB3AHZAdsB3AHdAd4B1QHRAd4B3AHVAd4B0QHUAd0B3AHfAd4B3wHcAd0B3wHgAeEB3gHUAeEB3wHeAeAB3wHiAeEB4gHfAeAB4gHjAeMB4gHkAeMB5AHlAeYB5AHiAeYB4gHhAeEB1AHnAeYB4QHnAecB1AHQAeYB5wHoAecB0AHpAegB5wHpAekB0AHIAegB6QHqAeoB6QHrAekByAHrAeoB6wHsAesB7QHsAcgB7gHrAesB7gHtAcgBzAHuAcEB7gHMAe8B7QHuAcEB7wHuAe8B8AHtAfEB8AHvAfEB7wHyAfIB7wHBAfMB8QHyAfMB8gH0AfUB8wH0AfIBwQH2AfQB8gH2AfYBwQH3AbQB9wHBAbIB9wG0AbIB+AH3AbMB+AGyAbMB+QH4AfoB9wH4AfYB9wH6AfsB+AH5AfoB+AH7AfsB+QH8Af0B9gH6AfQB9gH9Af4B+gH7Af0B+gH+Af8B+wH8Af4B+wH/Af8B/AEAAgEC9AH9AfUB9AEBAgIC/QH+AQEC/QECAgMC/gH/AQIC/gEDAgQC/wEAAgMC/wEEAgQCAAIFAgQCBQIGAgQCBgIHAgMCBAIHAggCBwIGAggCCQIHAgMCBwIKAgkCCgIHAgICAwIKAgkCCwIKAgICCgIMAgsCDAIKAgECAgIMAgsCDQIMAgECDAIOAg0CDgIMAvUBAQIOAg0CDwIOAvUBDgIQAg8CEAIOAg8CEQIQAhICEwIUAhMCFQIUAhMCFgIVAhICFAIXAhgCFgITAhgCGQIWAhoCEwISAhoCGAITAhsCEgIXAhsCFwIcAh0CGgISAh0CEgIbAh4CGQIYAh4CHwIZAiACGAIaAiACHgIYAiECGgIdAiECIAIaAiICHwIeAiICIwIfAiICJAIjAiICJQIkAiYCIgIeAiYCJQIiAiYCHgIgAiYCJwIlAigCJgIgAigCJwImAigCIAIhAigCKQInAioCKQIoAioCKwIpAigCLAIqAi0CKwIqAi0CLgIrAi8CKgIsAi8CLQIqAigCMAIsAi8CLAIwAjACKAIhAjECLgItAjECMgIuAjMCLQIvAjMCMQItAjQCMgIxAjMCNAIxAjQCNQIyAjMCLwI2Ai8CMAI2AjMCNgI3AjMCNwI0AjYCMAI4AjACIQI4AjgCIQIdAjYCOAI5AjcCNgI5AjgCHQI6AjkCOAI6AjoCHQIbAjcCOQI7AjQCNwI7AjkCOgI8AjsCOQI8AjoCGwI9AjwCOgI9Aj0CGwIcAj0CHAI+Aj8CPQI+AjwCPQI/Aj8CPgJAAjsCPAJBAkECPAI/AkICPwJAAkECPwJCAkICQAJDAkQCOwJBAjQCOwJEAkUCQQJCAkQCQQJFAkYCQgJDAkUCQgJGAkYCQwJHAkgCNAJEAkgCNQI0AkgCSQI1AkgCRAJKAkoCRAJFAksCSQJIAksCSAJKAksCTAJJAk0CTAJLAk0CTgJMAk0CSwJPAksCSgJPAk0CTwJQAkoCRQJRAk8CSgJRAlECRQJGAlACTwJSAk8CUQJSAlACUgJTAlECRgJUAlICUQJUAlQCRgJHAlQCRwJVAlICVAJWAlMCUgJWAlYCVAJVAlMCVgJXAlYCVQJYAlcCVgJYAlcCWAJZAloCWwJcAlsCXQJcAloCXAJeAlsCXwJdAmACWgJeAl8CYQJdAmACXgJiAl8CYwJhAmQCYAJiAmECYwJlAmQCYgJmAmECZQJnAmgCZAJmAmcCZQJpAmgCZgJqAmcCaQJrAmgCagJsAmkCbQJrAmgCbAJuAmkCbwJtAnACbgJsAnECbQJvAnACbAJyAnECbwJzAnICdAJwAnUCcQJzAnICdgJ0AnUCdwJxAnQCdgJ4AnkCdwJ1AnQCeAJ5AnkCeAJ3AnoCewJ8AnoCfQJ7AnoCfgJ9AnoCfwJ+AnoCgAJ/AnoCfAKBAoECgAJ6AoECfAKCAoECgwKAAoECggKEAoQCgwKBAoQCggKFAoQChgKDAoQChQKHAocChgKEAocChQKIAocCiQKGAocCiAKKAooCiQKHAosCigKIAooCjAKJAosCjQKKAo4CjAKKAo4CigKNAo8CkAKRApACkgKRApECkgKTApAClAKSApECkwKVApYClAKQApcClgKQApcCkAKPApYCmAKUApICmQKTApUCkwKZApQCmgKSApICmgKZApQCmwKaApgCmwKUApoCnAKZApsCnQKaApoCnQKcApsCngKdAp8CmQKcApUCmQKfAp8CnAKgAqECngKbApgCoQKbAqECogKeAqECowKiAqECpAKjApgCpAKhAqQCpQKjApgCpgKkAqcCpgKYAqcCqAKmAqQCqQKlAqYCqQKkAqkCqgKlAqgCqwKmAqYCqwKpAqgCrAKrAqkCrQKqAqsCrQKpAq0CrgKqAq0CrwKuAqsCsAKtArACrwKtAqwCsAKrArACsQKvAqwCsgKwArICsQKwArICswKxAo8CkQK0ArQCkQKVArQClQK1ArUClQKfArUCnwK2ArYCnwKgArYCoAK3ArgCtgK3ArkCtQK2ArgCuQK2ArkCtAK1AroCuQK4ArsCtAK5AroCuwK5ArsCjwK0ArwCuwK6Ar0CjwK7ArwCvQK7Ar0ClwKPAr4CvQK8Ar4CvAK/AsAClwK9AsACvQK+AsEClwLAAsECwgKXAsMCwQLAAsMCwALEAsQCwAK+AsUCwwLEAsYCvgK/AsQCvgLGAsYCvwLHAsUCxALIAsgCxALGAskCxQLIAskCyALKAsgCxgLLAssCxgLHAsoCyALLAssCxwLMAsoCywLNAs0CywLMAs0CzALOAs8C0ALRAtAC0gLTAtAC0wLRAs8C0QLUAtUC0QLTAtYC1QLTAtYC1wLVAtUC2ALRAtcC2ALVAtgC1ALRAtcC2QLYAtkC2gLYAtgC2gLUAtkC2wLaAtsC1ALaAtsC3ALUAt0C3gLfAt8C3gLgAt0C3wLhAuIC3QLhAuIC4QLjAuMC5ALiAuEC3wLlAt8C4ALmAuUC3wLmAuAC5wLmAuAC6ALnAukC5wLoAucC6gLmAuUC5gLqAukC6wLnAuwC6wLpAucC7QLqAu0C5wLrAu4C6gLtAu8C6gLuAu8C5QLqAu4C7QLwAuUC7wLxAvIC8ALtAu0C6wLyAvIC8wLwAvIC6wL0AuwC9ALrAvUC8wLyAvIC9AL1AvUC9gLzAuwC9wL0AvcC9QL0AuwC+AL3AvkC9wL4AvYC9QL6AvcC+gL1AvYC+gL7AvkC/AL3AvoC9wL8Av0C/AL5Av4C+wL6AvoC/AL+Av4C/wL7Av0CAAP8Av4C/AIAAwED/wL+Av4CAAMBAwEDAgP/Av0CAwMAAwMDAQMAA/0CBAMDAwIDAQMFAwMDBQMBAwQDBQMDAwIDBQMGAwQDBgMFAwcDCAMJAwoDCAMHAwsDCgMHAwsDBwMMAwwDBwMNAwcDCQMNAwwDDQMOAw4DDQMPAw4DDwMQAw0DEQMPAw0DCQMRAxIDEAMPAxIDEwMQAxQDDwMRAxQDEgMPAwkDFQMRAxUDFAMRAxUDFgMUAxcDFAMWAwkDGAMVAxcDGQMUAxIDFAMZAxoDGQMXAxMDEgMbAxIDGQMbAxMDGwMcAxoDHQMZAxsDGQMdAxoDHgMdAxoDHwMeAxsDHQMgAxwDGwMgAx4DIAMdAxwDIAMhAyIDHgMfAyMDIQMgAx4DIwMgAyMDJAMhAyIDJQMeAyMDHgMlAyYDJQMiAyQDIwMnAyMDJQMnAyQDJwMoAyYDKQMlAycDJQMpAyYDKgMpAyYDKwMqAyoDKwMsAyoDLAMtAy0DLAMuAyoDLwMpAyoDLQMvAycDKQMvAy0DLgMvAygDJwMvAygDLwMuAzADMQMyAzIDMQMzAzQDMQMwAzADMgM1AzQDNgMxAzYDMwMxAzcDNAMwAzYDOAMzAwgDNgM0AwkDCAM0AwkDNAM3AwgDOQM2AwoDOQMIAzYDOgM4AzYDOQM6AzsDMwM4AzoDOwM4AzwDOgM5AzwDOQMKAzoDPAM7AzsDPQMzAzIDMwM9Az4DMgM9AzUDMgM+Az4DPQM/AzUDPgNAAz8DPQNBA0EDPQM7Az8DQQNCA0MDQgNBA0MDQQNEA0QDQQNFA0EDOwNFA0QDRQNGA0cDRQM7A0YDRQNHA0YDRwNIA0gDSQNKA0gDRwNJA0cDSwNJA0cDOwM8A0cDTANLA0cDPANMA0wDTQNLA0wDTgNNAzwDTgNMA04DTwNNAzwDUANOAwoDUAM8A04DUQNPA1ADUQNOAwoDUgNQAwsDUgMKAwsDUwNSA1IDVANQA1ADVANRA1MDVQNSA1IDVQNUA1MDVgNVA1cDVQNWA1gDVANVA1cDWANVA1kDUQNUA1gDWQNUA1oDTwNRA1kDWgNRA1oDWwNPA1wDWQNYA1oDWQNcA1cDXQNYA1wDWANdA1cDXgNdA18DXQNeA1sDWgNgA1oDXANgA1sDYANhA18DYgNdA1wDXQNiA2MDYgNfA2QDYANcA1wDYgNkA2UDYQNgA2QDZQNgA2UDZgNhA2QDYgNnA2MDZwNiA2gDZQNkA2QDZwNoA2kDZgNlA2gDaQNlA2kDagNmA2sDaANnA2kDaANrA2MDbANnA2sDZwNsA2MDbQNsA24DbANtA24DbwNsA28DawNsA28DcANrA2kDawNxA3ADcQNrA2oDaQNxA3ADcgNxA2oDcQNzA3IDcwNxA3IDdANzA3UD5QJ2A+EC5QJ1A+MC4QJ1A3YD5QJ3A+UC8QJ3A/ECeAN3A/ECeQN4A3oDeAN5A3oDewN4A3wDewN6A3cDeAN9A3sDfQN4A3cDfQN+A3YDdwN+A34DfQN/A34DfwOAA4EDfgOAA4EDdgN+A4IDfwN9A3sDggN9A4IDgwN/A3YDgQOEA4UDggN7A3wDhQN7A4YDgwOCA4UDhgOCA4YDhwODA4YDiAOHA3YDhAOJA4UDigOGA4YDigOIA3wDiwOFA4UDiwOKA3wDjAOLA40DiwOMA4kDhAOOA40DjwOLA48DigOLA5ADjwONA5EDiAOKA48DkQOKA5EDkgOIA5ADkwOPA5MDkQOPA5ADlAOTA5ADlQOUA5MDlgORA5YDkgORA5YDlwOSA5YDmAOXA5UDmQOUA5MDlAOZA5UDmAOZA5MDmQOWA5YDmQOYA4kDjgOaA5sDmgOOA5sDnAOaA50DnAObA54DiQOaA54DmgOcA50DnwOcA58DnQOgA54DnAOhA6EDnAOfA6IDngOhA6IDoQOjA6IDpAOeA54DpAOJA6IDpQOkA6YDpAOlA6MDoQOnA6EDnwOnA6MDpwOoA6kDqAOnA6YDqgOkA6oDiQOkA6oDpgOrA6oDdgOJA6kDpwOsA6wDpwOfA6kDrAOtA6kDrQOuA6wDnwOvA58DoAOvA7ADrwOgA6wDrwOxA7ADsQOvA6wDsQOtA7IDsQOwA7IDswOxA60DsQOzA7MDsgO0A64DrQO1A60DswO1A64DtQO2A7cDtgO1A7cDtQO4A7QDtwO4A7gDtQOzA7MDtAO5A7QDuAO5A7gDswO5A3UDdgO6A7oDdgOqA7sDdQO6A+MCdQO7A7sDugO8A7oDqgO9A7wDugO9A70DqgO+A7sDvwPjAsADuwO8A7sDwAO/A8ADvAPBA7wDvQPCA74DqgPDA6oDqwPDA6sDxAPDA6sDxQPEA8YDxAPFA8cDwwPEA74DwwPHA8YDyAPEA8kDyAPGA8gDygPEA8cDxAPKA8kDywPIA8wDvgPHA8wDxwPNA84DzQPHA84DxwPKA74DzAPPA84DygPQA8gD0APKA8sD0APIA84D0APRA74DzwPSA70DvgPSA9IDzwPTA9ED0APUA8sD1APQA9ED1APVA9YD1QPUA8IDvQPSA9ID0wPXA8ID0gPXA9cD0wPYA9cD2APZA9kDwgPXA9kD2APaA9kD2wPCA7wDwgPbA9kD2gPcA9wD2wPZA7wD2wPBA90D3APaA90D2gPeA98D3APdA98D4APcA9wD4QPbA8ED2wPhA+ED3APgA8ED4QPiA+ED4APiA+MD4APfA8ED4gPkA+AD5APiA8ED5APAA+MD5QPgA+AD5QPkA8AD5APlA+YD5QPjA+YD5wPlA8AD5QO/A+cDvwPlA+cD6AO/A+gD6QO/A+gD6gPpA78D6QPrA78D6wPjAuMC6wPkAusD7APkAukD7QPrA+sD7QPsA+oD7gPpA+kD7gPtA+oD7wPuA/AD7gPvA/ED7QPuA/AD8QPuA/ID7APtA/ED8gPtA/ID8wPsA/QD8QPwA/QD8gPxA/QD8AP1A/QD9QP2A/MD8gP3A/QD9wPyA/MD9wP4A/QD9gP5A/cD9AP5A/kD9gP6A/sD+AP3A/cD+QP7A/sD/AP4A/kD+gP9A/sD+QP9A/4D/QP6A/4D+gP/A/sD/QMABAAE/AP7A/4DAAT9AwAEAQT8AwIE/gP/AwEEAAQDBP4DAwQABAEEAwQEBAUEAwT+AwIEBQT+AwYEBAQDBAUEBgQDBAYEBQQCBAYEBwQEBAcEBgQCBAIECAQHBAgECQQHBAIECgQIBAsEDAQNBA4EDQQMBA4EDAQPBA4EDwQQBBEEDQQOBAsEDQQRBA4EEAQSBBEEDgQSBBMEEgQQBBMEFAQSBBEEEgQUBBUEFAQTBAsEEQQWBBEEFAQWBAsEFgQXBBUEGAQUBBYEFAQYBBgEFQQZBBcEFgQaBBYEGAQaBBcEGgQbBBwEGwQaBBgEGQQdBB4EHQQZBB8EGgQYBBwEGgQfBB8EGAQdBB4EIAQdBB8EHQQgBCEEIAQeBBwEHwQiBB8EIAQiBBwEIgQjBCEEJAQgBCIEIAQkBCQEIQQlBCMEIgQmBCIEJAQmBCMEJgQnBCgEJwQmBCQEJQQpBBgDKQQlBBgDCQMpBCoEJAQpBCoEJgQkBAkDKgQpBCgEJgQqBAkDNwMqBDcDKAQqBDcDKwQoBCsENwMsBCsELAQtBCwELgQtBDcDLwQsBCwEMAQuBDcDMQQvBDcDMAMxBDIELAQvBDIEMAQsBDEEMAM1AzMEMgQvBDEEMwQvBDMENAQyBDUEMgQ0BDEENgQzBDUENwQyBDAEMgQ3BDgENwQ1BDkELgQwBDAENwQ5BDkEOgQuBDYEMQQ7BDYEOwQ8BD0EPAQ7BD4EOgQ5BD4EPwQ6BDkENwRABDgEQAQ3BDkEQAQ+BDgEQQRABEEEPgRABDgEQgRBBD4EQwQ/BEQEQQRCBD4ERQRDBEEERQQ+BEQERgRBBEUEQQRGBEcERgREBEgEQwRFBEUERgRIBEgESQRDBEcESgRGBEgERgRKBEsESQRIBEgESgRLBEsETARJBEsETQRMBEsETgRNBE4ETwRNBFAESwRKBFAETgRLBE4EUARPBEcEUARKBEcETwRQBFEEUgRTBFIEVARTBFIEVQRUBFEEUwRWBFQEVgRTBFcEUQRWBFgEVARVBFcEVgRZBFQEWQRWBFgEWgRUBFkEVARaBNYDWgRYBFcEWQRbBFkEWgRbBFcEWwRcBNYDXQRaBFsEWgRdBNYD1ANdBFwEWwReBFsEXQReBNQDXgRdBFwEXgRfBNQDywNeBMkDXwReBMkDXgTLA2AEYQRiBGAEYgRjBGQEYgRhBGMEZQRgBGEEYARlBGMEZgRlBGcEZQRmBGEEZQRoBGQEYQRoBGcEaQRlBGkEaARlBGoEaQRnBGQEaARrBGkEawRoBGQEawRsBGoEbQRpBG0EawRpBGwEawRuBG0EbgRrBGwEbgRvBGoEcARtBG4EbQRwBGoEcQRwBHIEbwRuBHMEcARxBHIEbgR0BG4EcAR0BHMEdQRwBHUEdARwBD0EdQRzBHIEdAR2BHUEdgR0BHIEdgR3BD0EeAR1BHgEdgR1BD0EOwR4BHcEdgR5BHgEeQR2BHkEeAQ7BHcEeQR6BHsEegR5BHkEOwR8BHsEeQR8BDEEfAQ7BH0EewR8BDEEfQR8BH0EfgR7BDEENQN9BH0EQAN+BH0ENQNAA38EgASBBIIEgAR/BIIEgwSABH8EgQSEBIUEhASBBIYEfwSEBIUEhwSEBIcEhgSEBIUEiASHBIUEiQSIBIkEigSIBIkEiwSKBIwEigSLBIwEjQSKBI4EjQSMBIgEigSPBI0EjwSKBIcEiASQBIgEjwSQBIcEkASRBIcEkQSGBJIEkQSQBJMEkASPBJIEkASTBI0ElASPBJMEjwSUBJUElASNBI4ElQSNBJUElgSUBI4ElwSVBI4EmASXBJUEmQSWBJUElwSZBJoElASWBJoEkwSUBJoElgSZBJsEkwSaBJsEkgSTBJoEmQScBJsEmgScBJcEnQSZBJwEmQSdBJgEngSXBJcEngSdBJgEnwSeBKAEkgSbBKEEoASbBKAEogSSBKEEmwSjBJsEnASjBKQEoQSjBKIEpQSSBKUEkQSSBKIEpgSlBKUEhgSRBKYEpwSlBKcEhgSlBKYEqASnBKcEqQSGBIYEqQR/BKkEggR/BKgEqgSnBKgEqwSqBKwEqQSnBK0EpwSqBK0ErASnBKsErgSqBK4ErQSqBKsErwSuBKkEsASCBKwEsASpBIIEsASxBLIEsASsBLIEsQSwBIIEsQSzBLIEswSxBIMEggSzBIMEswS0BLQEswS1BLIEtQSzBLQEtQS2BLYEtQS3BLIEtwS1BLYEtwS4BLkEsgSsBLIEuQS3BLkErAStBLoEtwS5BK0EugS5BLgEtwS7BLoEuwS3BLgEuwS8BLwEuwS9BLoEvQS7BLwEvQS+BK0EvwS6BLoEwAS9BL8EwAS6BK4EvwStBL0EwATBBL8EwQTABL0EwQTCBL4EvQTCBMMEwQS/BMMEvwSuBMQEwgTBBMQEwQTDBL4EwgTFBMUEwgTEBL4ExQTGBL4ExgTHBMgEvgTHBMUEyQTGBMUExATKBMUEygTJBMoExATLBMsExATDBMoEzATJBMkEzQTGBMcExgTNBMkEzgTNBMwEzgTJBMcEzQTPBM4E0ATNBNAEzwTNBNEExwTPBNAE0QTPBMgExwTSBNEE0gTHBNMEyATSBNME0gTUBNEE1ATSBNUE0wTUBNYE0QTQBNUE1ATXBNgE1QTXBNEE2QTUBNYE2QTRBNoE1wTUBNoE1ATZBNgE1wTbBNoE2wTXBNwE2ATbBNoE3QTbBNwE2wTeBN4E2wTdBN4E3wTcBNoE4ATdBN4E3QTgBNkE4QTaBNoE4QTgBNkE1gThBOIE3gTgBOEE4gTgBN4E4wTfBOIE4wTeBOME5ATfBOEE5QTiBNYE5QThBOYE4wTiBOUE5gTiBOME5wTkBOYE5wTjBOgE5ATnBOkE5wTmBOgE5wTpBOgE6QTqBOgE6gTrBOkE5gTsBOsE6gTtBOsE7QTuBO8E7gTtBOkE8ATqBOkE7ATwBOoE8QTtBOoE8ATxBO8E7QTyBPIE7QTxBPME7wTyBPQE8ATsBPUE8QTwBPQE9QTwBPIE8QT2BPUE9gTxBPME8gT3BPcE8gT2BPME9wT4BPME+AT5BPcE9gT6BPsE9gT1BPsE+gT2BPcE+gT8BPsE/AT6BPcE/AT4BP0E+wT1BP0E9QT0BPsE/gT8BP0E/gT7BPgE/AT/BP4E/wT8BPkE+AQABfgE/wQABfkEAAWfBAEF/QT0BAIF/QQBBQEF9AQDBQIFBAX9BP0EBAX+BAUFBAUCBQMF9AQGBQYF9ATsBAYF7ATmBAMFBgUHBeUEBgXmBAcFBgXlBAcF5QQIBQgF5QQJBdYECQXlBAgFCQUKBQsFCQXWBAoFCQULBQsF1gTQBAoFCwUMBc4ECwXQBAwFCwUNBQwFDQUFBQ4FCwXOBA4FDQULBQUFDQUEBQQFDQUOBcwEDgXOBAQFDgUPBcwEDwUOBQQFDwUQBQQFEAX+BP4EEAX/BBEFEAUPBcwEEQUPBRIF/wQQBREFEgUQBRIFAAX/BBMFEQXMBMoEEwXMBBQFEgURBRMFFAURBcoEywQTBRQFFQUSBRUFAAUSBRUFnwQABRUFngSfBBUFFgWeBBQFFgUVBRYFnQSeBBMFFwUUBRQFFwUWBRMFywQXBRYFGAWdBBcFGAUWBZwEnQQYBaMEnAQYBRcFGQUYBaMEGAUZBcsEGQUXBcsEGgUZBaMEGQUaBcsEwwQaBRoFwwSuBKMEGgUbBRoFrgQbBaQEowQbBa8EGwWuBK8EpAQbBRwFHQUeBR0FHwUeBR0FIAUfBRwFHgUhBSIFHAUhBSMFHgUfBSIFIQUkBSUFIgUkBSYFIQUeBSMFJgUeBScFJAUhBSYFJwUhBSUFJAUoBSkFJQUoBScFKgUkBSoFKAUkBScFJgUrBSoFJwUrBSYFIwUrBSoFLAUoBSwFKgUrBSkFKAUtBSwFLQUoBS4FKQUtBS8FLAUrBSwFLwUtBS4FLQUwBS8FMAUtBTEFLgUwBTIFLwUrBS8FMgUwBTEFMAUzBTIFMwUwBSAFMQUzBSAFMwUfBTIFNAUzBTQFMgUrBTQFHwUzBSMFNAUrBTQFIwUfBTUFNgU3BTYFOAU3BTYFOQU4BTcFOAU6BTgFOwU6BTcFOgU8BTkFPQU4BTgFPQU7BT0FPgU7BTkFPwU9BT0FQAU+BT8FQAU9BT8FQQVABUIFNwU8BTUFNwVCBUIFPAVDBUIFQwVEBTUFQgVFBUIFRAVFBTUFRQVGBUUFRAVHBUYFRQVIBUUFRwVIBUYFSAVJBUgFRwVKBUkFSAVLBUgFSgVLBUsFSgVMBUkFSwVNBUsFTAVOBU0FSwVOBU0FTgVPBVAFUQVSBVAFUwVRBVAFUgVUBVQFUgVVBVQFVQVWBVQFVgVXBVQFVwVYBVAFVAVYBVAFWAVZBVAFWgVTBVkFWgVQBVoFWwVTBVkFXAVaBVwFXQVaBVoFXQVbBVwFXgVdBV8FXQVeBWAFWwVdBV8FYAVdBWAFYQVbBWIFYAVfBWMFYQVgBWIFYwVgBWMFZAVhBWMFYgVlBWMFZgVkBWMFZQVnBWMFZwVmBWcFZQVoBWcFaQVmBWcFaAVqBWcFagVpBWsFbAVtBW4FbAVrBW4FbwVsBXAFbgVrBW8FcQVsBW0FbAVxBW8FcgVxBW0FcQVzBXMFcQV0BWsFbQV1BXUFbQVzBXAFawV2BXYFawV1BXcFcAV2BXMFdAV4BXgFdAV5BXUFcwV6BXoFcwV4BXYFdQV7BXsFdQV6BXcFdgV8BXwFdgV7BX0FdwV8BXsFegV+BXwFewV+BXoFeAV/BX4FegV/BXgFeQWABX8FeAWABYAFeQWBBX4FfwWCBXwFfgWCBX8FgAWDBYIFfwWDBYAFgQWEBYMFgAWEBYQFgQWFBYQFhQWGBYcFhAWGBYMFhAWHBYcFhgWIBYIFgwWJBYkFgwWHBYoFhwWIBYkFhwWKBYoFiAWLBYwFggWJBXwFggWMBY0FiQWKBYwFiQWNBY4FigWLBY0FigWOBY4FiwWPBZAFfAWMBX0FfAWQBZEFfQWQBZAFjAWSBZIFjAWNBZEFkAWTBZMFkAWSBZQFkQWTBZUFjQWOBZIFjQWVBZYFjgWPBZUFjgWWBZYFjwWXBZQFkwWYBZkFlAWYBZkFmAWaBZgFmwWaBZwFlgWXBZwFlwWdBZ4FlgWcBZ4FlQWWBZ8FnAWdBZ8FnQWgBaEFnwWgBaEFoAWiBaMFnwWhBaQFnAWfBaMFpAWfBaQFngWcBZsFpAWjBZsFpQWkBaUFngWkBZgFpQWbBaUFpgWeBZgFpgWlBaYFlQWeBZgFkwWmBaYFkgWVBZMFkgWmBacFqAWpBaoFqAWnBaoFqwWoBacFqQWsBawFqQWtBawFrQWuBa8FrAWuBa8FrgWwBbEFpwWsBbEFrAWvBbIFqgWnBbIFpwWxBbMFqwWqBbMFtAWrBbUFqgWyBbUFswWqBbYFtAWzBbYFtwW0BbgFswW1BbgFtgWzBbkFtwW2BbkFugW3BbsFtgW4BbsFuQW2BbwFugW5BbwFvQW6Bb4FuQW7Bb4FvAW5Bb8FvQW8Bb8FwAW9BcEFvAW+BcEFvwW8BcIFwAW/BcIFwwXABcQFwwXCBcQFxQXDBcYFxAXCBccFwgW/BcYFwgXHBccFvwXBBcgFxgXHBcgFxwXJBckFxwXBBcoFyAXJBckFwQXLBcsFwQW+BcoFyQXMBcwFyQXLBcoFzAXNBcoFzQXOBcwFzwXNBcwF0AXPBcwFywXQBdAF0QXPBcsFvgXSBdAFywXSBdIFvgW7BdAF0wXRBdAF0gXTBdMF1AXRBdIFuwXVBdMF0gXVBdUFuwW4BdMF1gXUBdYF1wXUBdMF1QXYBdUFuAXZBdgF1QXZBdkFuAW1BdoF0wXYBdoF1gXTBdgF2QXbBdoF2AXbBdkFtQXcBdsF2QXcBdwFtQWyBdYF3QXXBdoF3QXWBd0F3gXXBdoF2wXfBdoF3wXdBd0F4AXeBd8F4AXdBeAF4QXeBd8F4gXgBeAF4wXhBeMF4AXiBeMF5AXhBd8F5QXiBd8F2wXlBeMF4gXlBdsF3AXlBeUF3AXmBeUF5gXjBdwFsgXmBeYFsgWxBeYFsQXnBeMF5gXnBecFsQWvBeMF6AXkBeMF5wXoBegF6QXkBecFrwXqBegF5wXqBeoFrwWwBeoFsAXrBegF6gXsBegF7AXpBewF6gXrBewF7QXpBewF6wXuBewF7gXtBe8F8AXxBfIF8AXvBe8F8QXzBfIF9AXwBfMF8QX1BfYF9AXyBfMF9QX3BfYF+AX0BfcF9QX5BfoF+AX2BfcF+QX7BfoF/AX4BfkF/QX7BfoF/gX8BfkF/wX9BfoFAAb+Bf8FAQb9BQIG/gUABv8FAwYBBgIGBAb+BQEGAwYFBgQGAgYGBgEGBQYHBgQGBgYIBgkGBwYFBgYGCgYIBgkGCwYHBgYGDAYKBg0GCwYJBgwGDgYKBg0GCQYOBgwGDQYOBg8GEAYRBg8GEQYSBg8GEgYTBg8GEwYUBg8GFAYVBg8GFQYWBhAGDwYWBhAGFwYRBhAGFgYYBhAGGQYXBhkGEAYYBhkGGgYXBhkGGAYbBhkGHAYaBhwGGQYbBhwGHQYaBhwGGwYeBhwGHwYdBh8GHAYeBiAGHQYfBh8GHgYhBiAGHwYiBiMGHwYhBiMGIgYfBiQGJQYmBiUGJwYmBiYGJwYoBiUGKQYnBiYGKAYqBicGKwYoBioGKAYrBikGLAYnBicGLAYrBiwGLQYrBiwGLgYtBi8GKwYtBioGKwYvBi8GLQYwBjEGLgYsBikGMQYsBjEGMgYuBjMGMgYxBjQGMQYpBjMGMQY0BjQGKQYlBjUGMwY0BjYGNAYlBjUGNAY2BjcGNQY2BjYGJQYkBjcGNgY4BjgGNgYkBjkGNwY4BjkGOgY3BjgGJAY7BjwGOgY5BjwGPQY6Bj4GOQY4Bj4GOAY7Bj8GPAY5Bj8GOQY+BkAGPwY+BkAGPgZBBkEGPgY7BkEGOwZCBkMGPwZABkMGRAY/BkQGPAY/BkUGRAZDBkUGRgZEBkQGRwY8BkYGRwZEBkcGPQY8BkYGSAZHBkcGSQY9BkgGSQZHBkgGSgZJBjsGJAZLBiQGJgZLBjsGSwZMBksGJgYqBkwGSwZNBksGKgZNBk0GKgYvBkwGTQZOBk0GLwZPBk4GTQZPBk8GLwYwBk8GMAZQBlEGTwZQBk4GTwZRBlEGUAZSBlEGUgZTBlEGUwZUBk4GUQZUBlQGUwZVBk4GVAZWBlcGTgZWBlcGVgZYBlQGVQZZBlYGVAZZBlkGVQZaBlgGVgZbBlYGWQZbBlgGWwZcBlkGWgZdBlsGWQZdBl0GWgZeBl0GXgZfBlsGXQZgBlwGWwZgBmAGXQZfBlwGYAZhBmAGXwZiBmEGYAZiBmEGYgZjBmQGZQZmBmQGZgZnBmcGZgZoBmcGaAZpBmoGaAZmBmsGaAZqBmsGagZsBmoGZgZtBmwGagZtBm0GZgZlBmwGbQZuBm4GbQZvBm0GZQZvBm4GbwZwBnAGbwZlBnAGZQZxBnIGcwZ0BnIGdAZ1BnQGdgZ1BncGcwZyBncGeAZzBngGdwZ5BnMGegZ0BnQGewZ2BnoGewZ0BnYGewZ8BnYGfAZ9Bn4GfQZ8BnwGewZ/BnoGfwZ7Bn4GfAaABoEGfgaABnwGfwaCBoIGgAZ8BoMGggZ/BoQGgwZ/BoQGfwZ6BoMGhQaCBnoGhgaEBocGggaFBoIGhwaABocGhQaIBocGiQaABoEGgAaJBooGhwaIBocGigaJBooGiAaLBoEGiQaMBowGiQaKBoEGjAaNBo4GjQaMBosGjwaKBowGigaPBosGkAaPBo4GjAaRBo8GkQaMBpIGjgaRBpMGjwaQBo8GkwaRBpMGkAaUBpIGkQaVBpMGlQaRBpIGlQaWBpIGlgaXBpMGmAaVBpgGkwaUBpYGlQaYBpgGlAaZBpcGlgaaBpYGmAaaBpkGmgaYBpcGmgabBpkGmwaaBpwGnQaeBp8GnQacBp8GoAadBqEGnwacBqAGogadBqAGowaiBp0GogakBp0GpAaeBqUGogajBqUGowamBqcGpAaiBqcGogalBp4GpAaoBqgGpAanBqgGpwapBqoGqQanBp4GqAarBqoGpwasBqUGrAanBq0GqgasBqYGrgalBqUGrgasBqYGrwauBq0GrAawBq4GsAasBq0GsAaxBq0GsQayBq4GswawBq8GswauBrEGsAazBq8GtAazBrUGsgaxBrYGswa0BrEGswa2BrYGtAa3BrUGsQa4BrYGuAaxBrkGtQa4BrcGuga2BrYGuga4BrcGuwa6BrkGuAa8BroGvAa4BrsGvQa6BroGvQa8BrsGvga9Br8GvQa+Br8GvgbABsEGvAa9BsEGvQa/BrkGvAbBBsEGvwbABrkGwQbCBsEGwAbCBpwGngbDBsQGnAbDBqEGnAbEBp4GxQbDBqEGxAbGBqEGxgbHBsQGwwbIBsMGyQbIBsMGxQbJBsoGxAbIBscGxgbLBscGywbMBs0GzAbLBsQGzgbGBsQGygbOBsYGzwbLBsYGzgbPBs0GywbQBtAGywbPBs0G0AbRBs0G0QbSBtMG0gbRBtQG0QbQBtMG0QbVBtQG1QbRBtYG0wbVBtAGzwbXBtQG0AbXBtcGzwbYBs4G2AbPBtkG1AbXBtcG2AbZBs4G2gbYBtkG2AbbBtoG2wbYBtkG2wbcBtoG3QbbBtwG3gbZBtkG3gbUBtwG3wbeBsoG2gbOBuAG3QbaBsoG4AbaBuAG4QbdBuIG4QbgBuIG4AbKBuIG4wbhBuQG5QbjBuQG4wbiBuYG5AbiBuYG4gbnBugG5gbnBuIGygbpBuIG6QbnBugG5wbqBuoG5wbpBusG6AbqBusG6gbsBu0G7AbqBu0G6gbuBuoG6QbuBu8G7QbuBvAG6QbKBsoGyAbwBskG8AbIBvAG8QbpBskG8QbwBukG8QbyBskG8gbxBukG8gbuBskG8wbyBsUG8wbJBvQG7gbyBvQG8gbzBu8G7gb0BsUG9QbzBvUG9AbzBvYG7wb0BvUG9gb0BvYG9wbvBvgG9QbFBvkG9wb2BvkG+gb3BvkG+wb6BvwG9gb1BvwG+Qb2BvgG/Ab1Bp4G+AbFBvkG/Qb7BvwG/Qb5BvsG/Qb+BvsG/gb/BgAH/wb+Bv4G/QYBB/wGAQf9BgAH/gYCBwMHAAcCBwQHAgf+Bv4GAQcEBwMHAgcFBwYHAQf8BgYHBwcBBwgHAQcHBwgHBAcBB/wGCQcGBwgHCgcEBwQHCgcCBwoHBQcCBwgHCwcKBwsHDAcKBwoHDAcFBwsHDQcMBw4HDAcNBw8HBQcMBwMHBQcPBwMHDwcQBxEHEAcPBw8HDAcSBw4HEgcMBxEHDwcTBxIHEwcPBxQHEQcTBw4HFQcSBxIHFQcTBw4HFgcVBxQHEwcXBxUHFwcTBxYHGAcVBxUHGAcXBxYHGQcYBxoHGAcZBxoHGwcYBxsHGgccBx0HFwcYBx0HGAcbBxQHFwcdBxsHHAcdBxQHHQccBx4HHwcgBx4HIAd6BnMGHgd6BngGHgdzBiAHIQd6BnoGIQeGBngGIgceByIHHwceB4YGIQcjB4YGIwckByUHJAcjByUHIwcmBycHJQcmByEHKAcjByYHIwcoByEHKQcoByAHKQchBykHKgcoBykHKwcqBywHKwcpBywHKQcgByAHLQcsBy4HKAcqByYHKAcuBy4HKgcvBzAHJgcuBycHJgcwBzEHLgcvBzAHLgcxBzEHLwcyBzEHMgczBzAHMQc0BzEHMwc0BycHMAc1BzAHNAc1BycHNQc2BzcHNgc1BzcHNQc4BzgHNQc0BzkHNwc4BzoHNAczBzgHNAc6BzoHMwc7BzkHOAc8BzwHOAc6BzkHPAc9BzkHPQc+Bz4HPQc/BzwHPwc9Bz4HPwdABzwHOgdBBzwHQQc/B0EHOgc7B0EHQAc/B0EHOwdCB0EHQgdAByIHeAZDB0MHeAZEB3gGeQZEB0QHeQZFB0QHRQdGB0cHRgdFB0cHRQdIB0kHRAdGB0MHRAdJB0oHRgdHB0gHSwdHB0gHTAdLB00HSgdHB00HRwdLB0oHTgdGB0kHRgdOB08HTgdKB00HTwdKB08HUAdOB00HUQdPB1IHTgdQB1IHSQdOB1MHSQdSB1MHQwdJB00HVAdRB1UHQwdTB00HVgdUB0sHVgdNB1YHVwdUB0sHWAdWB1gHSwdMB1gHTAdZB1UHWgdDB1sHWgdVB1sHXAdaB10HQwdaByIHQwddB1wHXgdaB10HXwciB1wHYAdeB10HWgdhB14HYQdaByIHXwcfB2AHYgdeB2AHYwdiB14HZAdhB2UHXQdhB2UHYQdkB10HZQdfB2YHZAdeB2UHZAdmB2YHXgdiB2UHZgdnB18HZQdnB2IHZwdmB2MHaAdiB2MHaQdoB2oHYgdoB2IHagdnB2oHaAdrB18HZwdsB2oHbAdnB20HagdrB2oHbQdsB20HawduB28HbQduB2wHbQdvB28HbgdwB18HbAdxB2wHbwdxB18HcQcfB3IHbwdwB3EHbwdyB3IHcAdzBx8HcQd0B3EHcgd0Bx8HdAcgB3MHdQdyB3MHdgd1B3cHdQd2B3IHdQd4B3IHeAd0B3cHeQd1B3UHegd4B3UHeQd6B3QHeAd7B3sHeAd6B3sHegd8B3QHewd9B34HfAd6B34Hegd/B38Hegd5B4AHfgd/B3cHgQd5B38HeQeBB3cHggeBB4AHfweDB4MHfweBB4IHhAeBB4MHgQeEB4IHhQeEB4AHgweGB4QHhgeDB4AHhgeHB4gHhAeFB4kHhweGB4gHigeEB4QHigeGB4kHhgeLB4sHhgeKB4wHiQeLB4gHjQeKB4sHigeNB4gHjgeNB4wHiwePB48HiweNB44HkAeNB48HjQeQB44HkQeQB5IHkAeRB4wHjweTB5AHkwePB4wHkweUB5IHlQeQB5AHlQeTB5QHlQeSB5QHkweVB5YHlweYB5kHmAeXB5kHlweaB5YHmAebB5sHWQeWB5sHWAdZB5kHmgecB5kHnAedB5wHngedB50HnweZB6AHmAeZB58HoAeZB6AHoQeYB58HoQegB6EHmweYB58HogehB6EHogdXB6EHowebB6EHVwejB1gHmwejB1YHowdXB1gHowdWB6QHpQemB6QHpgenB6gHpwemB6UHqAemB6gHqQenB6gHqgepB6gHqweqB6UHqweoB6wHqgerB6QHrQelB6wHqweuB6UHrgerB6UHrQeuB68HrAeuB6QHsAetB68HrgexB60HsQeuB7EHsgevB7AHswetB60HswexB7AHtAezB7UHswe0B7YHsQezB7UHtgezB7EHtweyB7YHtwexB7gHsge3B7gHtwe5B7YHuQe3B7oHuAe5B7UHuwe2B7YHuwe5B7UHvAe7B7oHuQe9B7sHvQe5B70Hvge6B7wHvwe7B7sHvwe9B7wHwAe/B8EHvwfAB8IHvQe/B8EHwge/B70Hwwe+B8IHwwe9B6sGvgfDB6sGwweeBp4GwwfCB54Gwgf4BvgGwgfBB/gGwQfEB8QHxQf4BsQHxgfFB8UHxgfHB/gGxQfIB/gGyAf8BvwGyAcJBwkHyAfJB8kHyAfFBwkHyQfKB8sHygfJB8kHxQfMB8UHxwfMB8sHyQfNB8wHzQfJB84HywfNB88HzAfHB8wHzwfNB88HxwfQB84HzQfRB88H0QfNB84H0QfSB9MHzwfQB88H0wfRB9MH0AfUB9IH0QfTB9MH1AfVB84H0gfWB9cH1gfSB9IH0wfYB9MH1QfYB9cH0gfZB9gH2QfSB9oH1wfZB9sH2AfVB9gH2wfZB9sH1QfcB9oH2QfdB9sH3QfZB94H2wfcB9sH3gfdB94H3AffB94H3wfgB94H4AfhB+EH4AfiB+MH3QfeB+MH3gfhB9oH3QfjB+EH4gfjB9oH4wfiB+QH5QfmB+cH5QfkB+YH5QfnB+QH5gfoB+cH5AfpB+gH5gfqB+YH5wfqB+gH6gfrB+wH6wfqB+wH6gftB+0H6gfnB+4H7AftB+kH7wfnB+0H5wfvB+kH8AfvB+4H7QfxB/EH7QfvB/AH8gfvB/EH7wfyB/AH8wfyB/QH8gfzB/EH8gf0B/QH8wf1B+4H8Qf2B/EH9Af2B+4H9gf3B/gH9wf2B/gH9gf5B/kH9gf0B/oH+Af5B/UH+wf0B/kH9Af7B/UH/Af7B/oH+Qf9B/0H+Qf7B/wH/gf7B/0H+wf+B/wH/wf+BwAI/gf/B/0H/gcACAAI/wctByAHAAgtB3QHAAggB/0HAAgBCHQHAQgACPoH/QcBCH0HAQh0B/oHAQgCCH0HAggBCAMIBAgFCAYIBAgHCAYIBQgECAgIBQgGCAgICQgFCAMIBQgKCAoIBQgJCAoICwgDCAwICQgICAoIDQgLCA0I3wYLCA0I3gbfBg4IDQgKCAoICQgOCA8I3gYNCA4IDwgNCA8I1AbeBtQGDwjVBg8IDggQCA8IEAjVBgkIEAgOCNYG1QYQCAkIEQgQCNYGEAgRCAwIEQgJCNYGEQgSCBMIEQgMCBMIEggRCBQIFQgWCBcIFQgUCBQIFggYCBcIGQgVCBoIGQgXCBsIFggVCBoIHAgZCB0IHAgaCB4IFQgZCBsIFQgeCB8IGQgcCB4IGQgfCB0IIAgcCCEIIAgdCB8IHAgiCCIIHAggCB8IIwgeCCIIIwgfCB4IIwgbCCIIIAgkCCQIIwgiCCEIJQggCCQIIAglCCYIJQghCCcIIwgkCCQIJQgnCCYIKAglCCcIJQgoCCkIKAgmCCoIIwgnCCcIKAgqCCkIKwgoCCoIKAgrCBgIKwgpCBgIFggrCCoIKwgsCCwIIwgqCCwIKwgWCBsIIwgsCCwIFggbCHHDwjhvw0IifcNCLgAAAICYidQsZPHAOImJVLcAAAAAcvFAro+JVDdk8cA4AAAAgG3AQr+kqfW+tmgWvgAAgD9xw8I4EOxUIpOCy6IAAACA7opuoCYxwjjuiu62AAAAACUxQiL9iu42JTHCOAAAAIBuwEK/D48Yv/B3O74AAIA/ccPCOGz9C6pOvcGtAAAAgFtV3St8V8I4HfPMNgAAAICAP8EtDvPMtnxXwjgAAACAcMBCv9xxNb9RvJK+AACAP3HDwjh758+pmxbCrQAAAIAJ8JAsYn2/OJc8jjcAAACAfa2+LZQ8jrdjfb84AAAAgHDAQr9pUE+/WNPEvgAAgD9xw8I4RNbbrP0ViK0AAACADsi3LMhYwjhdt8u2AAAAADtjiy1tt8s2yljCOAAAAIBwwEK/xcSCv/EjDL4AAIA/ccPCOCagSismrEOrAAAAgJOrQ6sMpcI47pBZNgAAAAAdoEor1pBZtg6lwjgAAACAbsBCv2tziL+qvnq+AACAP4Xq6TVPb8A4PG9uNwAAAIAkfFc3Ui5wt4aKvjgAAAAAddvAOH7SizRnalm3AAAAgEgwsb7RmyS/Z6mFvwAAgD9Mzmy0U/bBOO4jDTcAAACAZC05NhH4DLfb4ME4AAAAgEytwjg3Dfw0YRM3tgAAAIBqiGa+ZERUvzk4g78AAIA/3HVONTacwjixvXG2AAAAgMVXqrYENXQ2jFLCOAAAAAAvd8I4aSMZtXE4qzYAAACAT/Ahvt9glL/SDWa/AACAPz3tVrX/AME4l4hQtwAAAAA8naW1kFhQNz7/wDgAAAAAMb3COB2ngDUFwJU1AAAAgPXzMr69N7q/1KVBvwAAgD8BF863fyo9OLJFojgAAACAjMekOJL757eSPiw4AAAAgNJJNDiuEqA4DFwBuAAAAIDHDgy/ENAVvwD5vL8AAIA/azE0uIYobTh5CHs4AAAAgI4dcDjI7+q3fKqNOAAAAIDCNHg46eeOOKizt7cAAACA4AbWvSCeP7/QA8G/AACAP5+9LLgbTY04sAFNOAAAAICrAU046BPOt9tjnTgAAACAH02NOM98dzjOE863AAAAgCIQk70mo3C/Coq0vwAAgD86Bpc47/B1OHTKUTUAAACAn8hRNRF0E7a6s8I4AAAAAO3wdTiE9pa4wnMTtgAAAIBa7Z6/RJ4lv1nQcL8AAIA/9IqdtspVwjhMloW2AAAAAPOXhba2wX02OWzCOAAAAADLVcI4Z/6iNn/FfTYAAACAZrH0vRryvL/peGa/AACAP1byk7aVXcI4wjiFtgAAAABXNYW2Ldl9NnVswjgAAAAAml3COAhimTZO0n02AAAAgLk2/r0s4MC/i4RmvwAAgD/iupK2lF7COHkdhbYAAAAA3hqFtp6+fTaRbMI4AAAAAJdewjjpKJg2dLl9NgAAAIDleP+9uJzDv8GHZr8AAIA/bSCJtullwjh5pYS2AAAAAL/ChLafn3021WzCOAAAAADXZcI4DoqONhvdfTYAAACAVMXcvY9Kvb8wW2a/AACAP3HNd7Ynb8I4cxyEtgAAAAAJNYS2Ra59NjFtwjgAAAAAGW/COJxKgTa84X02AAAAgG/26b2av8G/N2xmvwAAgD91HIi2rWbCOCGShLYAAAAANLGEtr+PfTbnbMI4AAAAAJpmwjgBhY02+dB9NgAAAICUmd29BATFv0RdZr8AAIA/g5b7tNmYwjiKon+2AAAAAA2ef7ZQIn42/m/COAAAAADcmMI42IQnNRUefjYAAACAta4UvqyevL/3t2a/AACAPwI3zjLvmcI4PkJ+tgAAAIDWOX620Rx+NnRwwjgAAAAA8ZnCOGAyDDSuFH42AAAAgJTfHL7cosC/sc1mvwAAgD+PNJC0c5nCONwcf7YAAAAAcBt/tpkpfjYlcMI4AAAAAHKZwjg6f+M0dCh+NgAAAIC+7Re+LIvDvxjAZr8AAIA/OfesNT6Wwjjt0nq2AAAAgOXPerZZH342j3HCOAAAAABAlsI4zH6YtaMcfjYAAACA8HAdviziu789xGa/AACAP1n3bzTymcI4UsZ9tgAAAIDVvn22xSx+NphwwjgAAAAA9pnCOAiIlLOVJX42AAAAgNDbC76ejr+/0pVmvwAAgD8Deqe0YJnCON0Zf7YAAAAA9h5/tjsIfjYvcMI4AAAAAF+Zwjjxuvo0pQ1+NgAAAIAY7wK+wLTBv5OAZr8AAIA//+npNVRvwLhrbm43AAAAgOg4H7d/LXC3VGe/uAAAAACatcE409SLNG/TIbcAAACAxnvlva08XD9qNF0/AACAP8rUbLRW9sG4YyMNNwAAAIDwAf82hfcMtwxPwbgAAAAAFBzCOKEP/DSwoP42AAAAgOHCjL4eoi8/p8ZfPwAAgD+LdE41O5zCuCO7cbYAAACAK0sLOGIydDaKubW4AAAAgLbgtTg9Ihm1d08LOAAAAIBmIwa/auG4PrCQUD8AAIA/m+5WtQ8BwbjthVC3AAAAAKuiWrfkVVA35hG/uAAAAABD1MA4jKeANet0WrcAAACApk6BvcDOWD3i6nk/AACAP3IWzreKKj24wEWiOAAAAICPR7g4jPvnt/akRTcAAAAApEqRN68SoDjUqlE4AAAAgGJjZb/qXR0+0jDBvgAAgD8gMjS4gyhtuAMIezgAAACA76CsOLfv6rdh2wg4AAAAgEPe87Xt54446UWEOAAAAIAGHkK/sho2PoreGL8AAIA/urwsuDRNjbg3Ak04AAAAgLJ+rDidEc63raYUOAAAAICCela3G313OLv9kzgAAACAbjw6v7DHJz6C3yG/AACAPysGlzgi8XW4jbVRNQAAAICpnzu2vHMTtuKewjgAAAAAHa91uHH2lrgAzWi2AAAAAAjMpz2fnaA+BSNtvwAAgD/Tip22z1XCuMiUhbYAAACA4nC+uEm+fTapG6A3AAAAAHtlnreD/qI2S2y+uAAAAIBqEHw/QBcsPfj+Ej0AAIA/oPKTtptdwrjxNIW2AAAAgAF9wLj11H02xNJkNwAAAAC8pGG352CZNsJ4wLgAAACA5hF7P0A8PTySQcE9AACAPxK+kraMXsK4WyiFtgAAAIDPtMC4V9l9Ni/DWDcAAAAAt5xVt4MqmDaasMC4AAAAgKnfej9A2yC8yPLQPQAAgD9ZIIm27WXCuEekhLYAAACAtQrCuOWcfTbMGew2AAAAALhC5rYzio420AbCuAAAAIBgSXg/EAwjPX4CEj4AAIA/1cx3tipvwrhkHoS2AAAAAF6OwriBsn02EzQHtgAAAAAFuxE2WkqBNt2KwrgAAACAyo5zPwByrDuD6nE+AACAP1cliLanZsK4epaEtgAAAIAgJMK4IKt9Njcs1jYAAAAAtWDQtnuFjTZJIMK4AAAAgH8FeD/gOai8ZOcYPgAAgD8rl/u025jCuCCff7YAAAAAd4Tbt94efjb1s7q4AAAAAILeujjjhSc1hH3btwAAAIAWnq49sOY+PQPTeD8AAIA/F2/OMuyZwrhzT362AAAAgN5BL7YBKn42O4bCuAAAAAC4r8I47TIMNMgLL7YAAACAiPoovoDjeTxwLXY/AACAP8U8kLR5mcK4URB/tgAAAABK+Yy3Ch1+Ni1iv7gAAAAAHoy/OHCC4zRy8oy3AAAAgCCZgLyAgvS7Dr55PwAAgD9t9qw1QpbCuIvPerYAAACAcFdjOOMbfjaX8524AAAAgMAgnjjifZi1G1tjOAAAAICDoTK/UCNWPf0jLT8AAIA//d1vNACawrhfqH22AAAAgJ138DbCDn42MwXCuAAAAICgLsI4J3KUs7CS8DYAAACAgkd7vqA4wjyfuHA/AACAP+N2p7RgmcK4/iV/tgAAAABeMp63rxR+NlGKvrgAAAAAXrS+OMSo+jR+K563AAAAgLhD0jyAWuE7wLJ4PwAAgD9KZsI4JkSxNS0quTYAAACA0quMNUGDwrikG5o2AAAAAAEfuzZOu5e2GS7CuAAAAIBwZ16/SJLoPu+sEj4AAIA/Rb/COC8vijWwAyY1AAAAgE//czUI5r+45OmENwAAAABgwFI1EdqEtzPnv7gAAACAk/dbvy4Hij4QtB8+AACAP2/DwjjkMG2wwefnLwAAAICD+BSvBgpXuEplorgAAAAA53aRMCplojjxCVe4AAAAgHN0W796L+W9xt0WPgAAgD9vw8I4kZCFsBq+OS8AAACAZOYNLkl9R7cYKcG4AAAAALMCljD3KME4an1HtwAAAIB/dFu/oXZovnSzVz0AAIA/ambCOL1CsbUmE7k2AAAAgHvO1LVIg8K4mNuUNgAAAAAlxLY2FLeXtjw1wrgAAACA2Uosvzmm8z7Uox4+AACAP1G/wjgEMYq1v0olNQAAAIARRpa19eW/uPDOhDcAAAAAmxToNN/bhLdh67+4AAAAgOUNKr8/qpI+BhAhPgAAgD98w8I4ItezMMnb3q8AAACAwAGbL2kIV7jZZaK4AAAAALOGiK99aKI4mwpXuAAAAIB8DCq/Jz/lvQzgFj4AAIA/fMPCOJZ/vzCPczQvAAAAgLlGgy/Tfke3GSnBuAAAAADl0aGv8ivBOGh9R7cAAACAdAwqvzl/aL7ts1c9AACAP4mICD2JiIg9zszMPYmICD6rqio+zcxMPvDubj6JiIg+mpmZPquqqj68u7s+zczMPt/d3T7w7u4+AQAAP4mICD8SERE/m5kZPyMiIj+sqio/NDMzP727Oz9FREQ/zsxMP1dVVT/f3V0/aGZmP/Dubj95d3c/AACAP0REhD+JiIg/zcyMPxERkT9WVZU/mpmZP97dnT8iIqI/Z2amP6uqqj/v7q4/NDOzP3h3tz+8u7s/AADAP0VExD+JiMg/zczMPxIR0T9WVdU/mpnZP97d3T8jIuI/Z2bmP6uq6j/v7u4/NDPzP3h39z+8u/s/AQAAQImICD2JiAg9iYiIPc7MzD2JiAg+q6oqPs3MTD7w7m4+iYiIPomICD2JiIg9zszMPYmICD6rqio+zcxMPvDubj6JiIg+mpmZPquqqj68u7s+zczMPt/d3T7w7u4+AQAAP4mICD8SERE/m5kZPyMiIj+sqio/NDMzP727Oz+JiAg9nAL9BCz+3H+cAv0ELP7cf5oC/QQs/tx/lwL9BC3+3H+TAvsEL/7cf48C9wQy/t1/igLzBDT+3X+EAvEEN/7df30C8QQ4/t1/dQLyBDr+3X9sAvQEO/7df2QC9gQ8/t5/XQL3BD7+3n9XAvcEQP7ef1AC9QRD/t5/SALyBEb+3n9BAvIESP7ffzkC9ARK/t9/MQL2BEv+338rAvcETP7ffyUC9wRN/t9/IAL2BE/+338aAvUEUP7ffxUC9QRQ/t9/EQL2BFH+338OAvYEUf7ffw4C9wRR/t9/DwL3BFD+338SAvgETv7ffxYC+ARN/t9/GwL5BEv+338hAvkESv7ffycC+ARJ/t9/LwL3BEj+3381AvYER/7ffzsC9gRG/t5/QAL3BET+3n9FAvgEQ/7ef0sC+ARB/t5/UgL3BEH+3n9YAvcEQP7ef10C9gQ//t5/YQL3BD7+3n9lAvgEPP7df2oC+gQ6/t1/bwL7BDj+3X90AvwENv7df3kC/QQ1/t1/fgL9BDP+3X+DAv0EMv7df4gC/AQx/tx/jAL9BDH+3H+PAv0EMP7cf5IC/gQw/tx/lQL+BDD+3H+YAv4EL/7cf5oC/gQu/tx/mwL+BC7+3H+dAv4ELv7cf50C/gQt/tx/0QNbCpL9f3/QA1sKkv1/f8wDXAqT/X9/xwNaCpX9f3+/A1YKmP2Af7YDTgqd/YF/rANFCqH9gn+gA0EKpv2Df5IDQAqp/YN/ggNCCqv9hH9xA0UKrv2Ef2EDSQqx/YR/UwNLCrT9hH9GA0oKuf2FfzgDRQq+/YZ/KgNACsP9h38aAz8KyP2HfwoDQQrM/Yh/+wJFCs79iH/uAkgK0f2If+MCRwrU/Yh/2AJFCtb9iX/NAkQK2P2Jf8MCQwra/Yl/uwJECtv9iX+2AkUK2/2Jf7QCRgra/Yl/twJICtj9iX+9AkkK1f2Jf8YCSgrS/Yh/zwJLCtD9iH/aAksKzf2If+cCSgrM/Yh/9gJICsr9h38DA0cKyP2Hfw4DSArF/Yd/GANKCsL9hn8jA0wKv/2Gfy8DTAq9/YV/PANLCrz9hX9IA0kKuv2Ff1IDSQq4/YV/WgNKCrX9hH9jA00Ksf2Ef2wDUQqt/YN/dgNVCqr9g3+BA1cKpv2Cf4sDWAqk/YJ/lQNYCqH9gX+fA1gKn/2Bf6gDWAqd/YF/sANZCpz9gH+3A1oKm/2Af70DXAqa/YB/wwNdCpr9f3/IA10Kmf1/f8wDXQqX/X9/zwNcCpb9f3/SA1wKlf1/f9MDXAqV/X9/ZAWWCu/+cH9iBZYK7/5xf14Flgrw/nF/WQWUCvL+cX9SBZAK9P5yf0gFhwr4/nN/PgV+Cvz+dH8yBXkK//51fyQFdwoC/3Z/FAV5CgX/dn8DBXwKCP93f/MEgAoL/3d/5QSBCg//d3/YBIAKE/94f8sEegoY/3l/vAR0Ch3/en+sBHIKIf97f5wEdAol/3t/jQR4Cij/fH+BBHoKK/98f3UEeQou/3x/agR3CjD/fX9gBHUKMv9+f1YEdQoz/35/TQR1CjT/fn9IBHYKNf9+f0YEeAo0/35/SQR5CjL/fn9QBHsKMP9+f1gEfAot/31/YQR+Cir/fX9sBH4KKP98f3oEfQom/3x/iAR7CiT/fH+VBHoKIv97f6AEewog/3t/qgR+Ch3/en+1BIEKGv95f8EEgQoY/3l/zgSAChb/eX/aBH4KFf94f+QEfgoS/3h/7ASACg//d3/1BIMKDP93f/4EiAoJ/3Z/CQWMCgb/dX8TBY8KA/91fx4FkAoA/3R/KAWRCv7+c38xBZEK/P5zfzoFkQr6/nN/QgWSCvn+cn9JBZMK+P5yf1AFlQr3/nF/VQWWCvf+cX9aBZYK9v5xf14Flgr1/nF/YQWWCvP+cX9kBZYK8/5wf2YFlgrz/nB/HQuR/jIAgX8nC5H+MQCAfzkLkf4tAH9/VguR/ioAfH+AC5H+KwB4f7ULk/4tAHR/8AuV/i4Abn8uDJb+LABof2gMl/4lAGN/nQyY/h8AXX/SDJj+HwBYfwsNmP4nAFJ/Rg2X/jEATH+BDZj+MwBGf7kNmf4tAEB/7Q2a/iQAO38UDpz+HQA2fygOnf4ZADR/Kw6e/hcANH8kDp/+FgA1fx4Oof4XADV/Hg6i/hgANX8iDqP+GwA1fyYOo/4cADR/Ig6j/hwANX8VDqP+HAA2fwIOo/4dADh/7g2j/iAAO3/bDaP+IwA9f80Nov4nAD5/vw2i/igAQH+yDaL+JQBBf6QNov4gAEJ/lg2i/hwARH+GDaL+HQBGf3ENof4hAEh/Ug2i/iYAS38qDaT+JwBPf/0MqP4mAFR/1Qyr/iYAWH+4DKr+KQBbf6QMpv4uAF1/kQyh/jIAX394DJ3+NABhf1gMnP4xAGR/Nwyc/iwAZ38ZDJz+JwBqf/8LnP4lAG1/6Auc/iUAb3/RC53+JABxf7gLnf4jAHN/nAud/iAAdn+AC53+HAB5f2gLnP4cAHt/VQub/iAAfH9HC5j+JgB+fzwLk/4sAH9/MAuR/jAAf38kC5L+MgCBfx0Lk/4yAIF/rLgfzYW2gTmvuB3NgbaAObW4F82DtoU5vbgMzZC2ljnIuPrMqbazOdW458zLttw54rjSzPG2CzrwuL7MGLc6Ov64qcxBt2w6DbmTzG23ojocuXzMnrfcOiu5ZczRtxg7O7lNzAG4UTtLuTXMK7iDO125HcxPuK87brkHzHS42jt8ufHLnLgJPIm53cvJuDw8lrnJy/a4bjykubXLHrmcPLG5octDucU8vLmQy2O56TzEuYPLgLkJPci5e8uYuSI9x7l7y6W5MD3BuYPLpbkwPba5kcuYuSE9q7mhy4S5Cj2hua/LbLnuPJq5ustMucs8lLnFyyW5nzyNudLL97htPIO55MvJuDs8d7n4y6K4DzxpuQzMg7jsO1u5HsxruM87TbkwzFW4sztAuUPMPLiWOzO5VswfuHM7KLlmzP+3TjsguXPM4LcpOxi5f8zFtwo7ELmJzLK38ToKuZHMobfcOgW5mMyNt8M6/riizHG3ojr2uK/MUbd8Ou24vcwyt1c65bjKzBe3NzrfuNXMArceOtm43szwtgg60bjpzOC29DnHuPXM0bbfOb24As3Dtss5tbgLzba2ujmwuBLNqrarOa64F82etp05rbgazZO2kDmsuB3NibaGOay4H82FtoE5A8W89/j9RnEHxb739f1IcQTFwffx/Udx9MTD9+79P3HbxMr37v0yccDE1vfz/SVxqMTn9/z9GnGVxPj3Bf4RcYDECfgN/gdxY8Qc+BP++nA/xDL4Fv7ocBfETPgU/tRw7MNm+BH+wHDGw4D4EP6tcKXDmPgV/p1wisOw+Bv+kHBuw8b4Hv6DcFHD2/gd/nRwM8Pu+B3+ZXAWw/74H/5XcPrCDPki/khw4MIY+ST+O3DKwiP5Jv4vcLnCK/kp/idwr8Iv+Sz+InCtwjD5Lf4hcK/CMPko/iJwtcIt+SP+JXC9wif5Iv4pcMrCIfkn/jBw4MIc+TH+O3D9whj5Nv5LcBzDE/kx/ltwM8ML+SP+Z3A/wwD5Ev5scEPD9fgE/m5wS8Pr+P39cnBdw+D4+/17cHnD0fj6/YlwmsPA+Pj9mXC3w6749/2ocM3Dnfj7/bJw28OO+AT+uXDmw4L4E/6+cPnDdfgf/shwGcRn+CH+2HBCxFb4GP7scGvERPgK/gBxisQy+P/9D3GdxCH4+f0YcanEEfj3/R1xtMQC+Pb9InHAxPb39v0nccrE6/f4/Sxx0sTg9/39L3HZxNX3Bf4ycePEzPcL/jdx78TE9wr+PXH9xL/3AP5DcQPFvff5/UZxPwJSDDDMXnQ/AlEMLcxddD8CTQwpzFx0PgJIDCDMWHQ7AkYMDsxRdDMCSwz1y0V0KQJWDN3LOXQdAmIMyMsvdBICcAy4yyZ0BgJ/DKXLHHT4AZMMj8sRdOgBqgx1ywJ02AHCDFjL83PIAdcMOsvjc7cB6Qway9NzpgH4DPnKwnOWAQcN1cqwc4kBFQ2wyp5zfwEjDY7KjXN3ATENdMp/c28BPg1lyndzZwFJDVvKcXNfAVANUMprc1oBUw1CymRzWAFTDTLKXXNXAVINKMpYc1gBUg0mylhzWgFPDS3KW3NdAUsNNMpfc2ABRQ05ymJzYgFBDT/KZXNjAUANSspqc2UBQA1bynJzaQE7DWzKe3NxATENdsqAc3sBJw13yoJzhAEfDXjKg3OMARcNgcqIc5QBDA2ZypRznAH+DLvKpXOmAfAM3Mq2c7IB4wzxysFzvwHbDPrKxXPMAdcM/8rIc9cB0wwPy9Bz3gHNDC3L3nPmAcEMUMvvc+8BsAxty/5z+wGeDHrLBnQIAo0MfcsJdBYCgAyBywx0IQJ3DJDLE3QpAnEMqssfdC8CbQzKyy50NAJnDOjLPHQ5AmAMAMxHdD0CWQwRzFB0QQJUDCDMV3RDAlEMK8xcdEQCUAwwzF50LhZ8DsAGC30pFngOwQYMfRkWdA7FBg99+xVwDssGFX3PFWsOzwYdfZAVZg7SBih9QRVjDtUGNn3kFGIO1gZGfX4UZA7XBlZ9ExRmDtkGZ32jE2kO3AZ4fS0TbA7hBop9sxJvDucGnH06EnAO7QatfcURaw7xBr59UhFkDvEGz33eEF0O8gbgfWoQWQ71Bu99+w9cDvwG/X2UD2IOBQcIfjcPag4LBxJ+4w5tDg8HHH6aDm0OEgckflsOaw4UByx+KQ5pDhUHMX4HDmkOFQc1fvQNag4VBzd+7w1sDhQHOH7yDW0OEgc3fv0Naw4PBzZ+EQ5qDgcHNX4tDmgO/gYyflEOZw74Bi9+fg5mDvYGKn6xDmUO9QYkfukOZA70Bh5+Iw9jDvEGF35fD2IO7QYQfqEPYQ7qBgh+6g9hDukG/306EGEO6gb1fY0QZA7sBup93xBqDusG3n0sEXIO6AbTfXkReg7lBsh9yBF+DuMGvH0cEn0O5AawfXYSeg7kBqR90hJ1DuMGl30uE3MO4AaJfYgTcw7cBnt93xN4DtgGbX0zFH0O0wZgfYYUgA7OBlJ92RSCDsgGRX0pFYEOwgY3fXcVfw6/Bit9wxV9Dr0GHn0LFnwOvgYRfS4WfA6+Bgt969Az0yb1u23p0EjTRfXGbevQU9Nb9c5t8NBW02f10m320FfTbfXWbf7QV9Nu9dptBtFa02/13m0P0V/TdvXlbRvRY9OJ9e1tLNFi06v1921B0VrT0vUBblXRVdPv9QpuYtFc0wH2FG5u0WPTCfYdbn7RWNMB9h5ukNFF0/j1HW6f0UTTDvYlbqzRV9NJ9jduuNFs04f2S27E0XTTpvZVbtDRcdOs9lpu29Ft0672XW7j0W3TsfZgbubRb9Oq9mJu6NFs05f2YG7q0WTTgvZcbunRX9N09lhu5tFY02L2Um7l0U3TSPZLbuPRRtM09kZu3NFO0y32Rm7R0VvTJvZGbsnRWNMM9j9uxdFB0+H1MG7A0SzTuPUhbrnRI9Od9RhurtEk04j1Em6g0SvTcvUNbpLRMNNg9Qduh9Ey02D1BG6A0TPTdvUDbnrROdOY9QZucNFI07b1C25k0VrTxPUOblfRX9O89QpuTNFS05r1/W1D0T7TaPXsbTjRMtM99d5tK9Ey0y712G0h0TvTOvXYbRnRQNNL9dltEdFD00/1120J0UPTQ/XSbQPROdMs9clt/tAt0xL1v2340CjTA/W5bfLQK9MH9bht7tAw0xj1u23s0DPTJPW8bevQM9Mm9bttrQCiFVj/J36tAKIVWP8nfq0AoRVb/yd+rgChFWD/J36vAKEVYv8nfq8AoRVg/yd+sACiFVv/J36xAKEVVf8nfrEAohVT/yd+rgCkFVj/Jn6rAKYVY/8mfqsAphVp/yZ+rQCkFWL/Jn6vAKIVWf8nfrMAnxVa/yd+tgCdFWP/KH61AJ4Va/8nfrAAohVu/yd+rACkFW//Jn6rAKUVcP8mfq0AphV1/yZ+rwClFXz/Jn6vAKUVfP8mfrEApRV0/yZ+swCkFW3/Jn61AKMVav8nfrYAohVq/yd+twCgFWv/J367AJ8Vb/8nfr8AnRVx/yh+vwCbFWn/KH7AAJkVX/8ofsMAlhVh/yl+yQCRFWr/Kn7MAI8VbP8qfswAjxVi/yp+yQCQFVP/Kn7IAJAVR/8pfsgAjxVI/yp+xwCQFVX/Kn7CAJQVZP8pfrkAmxVm/yh+sgCiFVj/J361AKYVUP8mfrcAphVO/yZ+tACkFVH/Jn6yAJ8VU/8nfrEAmxVT/yh+sgCbFVP/KH6yAJ8VUv8nfrMApBVR/yZ+tQClFVD/Jn64AKMVTf8mfrcAoBVO/yd+tgCdFU//J362AJ0VT/8nfrUAoRVQ/yd+swCjFVH/Jn6wAKMVVP8nfq4AohVW/yd+xvvBAP/v636v+8QA/u/qfp/7xgD97+p+mPvGAPvv6X6X+8YA+e/pfpL7yAD37+h+h/vKAPXv6H5/+8wA9O/nfnf7zgD07+d+aPvQAPPv5n5L+9AA8e/lfh37zwDu7+N+5PrNAOnv4H63+s0A5e/efqr6zwDh791+q/rTAN/v3H6Z+tUA4e/cfm/61ADk79p+SPrTAOXv2X4w+tMA4+/Yfhv61ADd79Z+AvrUANTv1H7w+dUAze/SfvH51gDN79J+AvrYANLv037u+d0A0O/Sfov56QDB78t+7/j7AKfvv348+BIBi++xfoL3KwFx76F+zvZCAVjvkX4x9lUBQ++Dfsr1YwE073h+tPVpAS/vdn7e9WoBMu96fi32ZQE574F+mPZbAUXvi34U900BVO+WfpX3PAFl76F+FfgnAXrvrH6a+BIBke+3fiv5/wCo78N+vfnuALzvzX46+t4Ayu/Vfpj60wDT79p+3frMANvv3n4R+8oA4u/hfjn7ywDn7+N+UPvLAOvv5X5b+8oA7+/lfmj7yADy7+Z+fPvIAPTv536V+8gA9e/ofrP7yQD57+p+zvvKAP/v7H7d+8kAAvDsftr7yAAB8Ox+zPvFAP3v637F+8QA/O/rfsX7xAD87+t+tO3o/yEAr36z7ej/IQCufqft6P8hAK1+lO3o/x0Aqn587ef/GgCmfmPt5/8WAKN+Se3m/xEAn34n7eX/DACafgDt5P8FAJR+3Ozj////j3677OL/+v+Kfpzs4v/1/4V+f+zh//D/gH5i7OH/6/98fkns4P/n/3h+Nezg/+T/dX4n7OD/4f9zfh/s4P/g/3F+HOzg/+D/cX4b7OD/4P9xfhrs4P/g/3F+Guzg/+D/cX4Z7OD/4P9wfhvs3//g/3F+Iezf/+H/cn70693/2f9rflzr2f/A/1J+bOrT/5n/Kn5I6cz/aP/2fRDoxP81/7x95+a9/wT/gn3r5bb/2v5OfT/lsv+9/il9AOWx/7P+HH0e5bL/uP4ifX3ltP/I/jd9Dea3/+D+VX3E5rz//v57fZznwf8i/6Z9iOjH/0n/03176c3/cf//fWfq0/+Y/yl+QuvY/7z/Tn4G7N3/3P9tfqTs4P/2/4Z+Du3j/wgAln467eT/DwCdfkjt5P8RAJ9+Ve3l/xMAoX5i7eX/FgCjfm/t5f8YAKR+e+3m/xoApn6G7eb/HACofpDt5v8dAKl+lu3m/x4Aqn6b7eb/HwCrfqPt5/8gAKx+rO3n/yEArX6y7ef/IQCufrTt5/8hAK5+iu8gA3IC336A7x8DbgLefnXvHgNmAt1+aO8cA1sC235b7xsDTQLafk3vGAM6Ath+Pu8VAyIC134s7xEDBgLVfhjvDQPnAdN+Ae8IA8cB0H7p7gMDpwHOftLu/QKFAct+u+74AmUByX6l7vECRgHGfpTu6wIpAcR+gu7lAgoBwn5i7t8C5gC+fjzu2wLAALl+IO7WAp0AtX4Q7tICfwCzfv/tzgJmALF+7O3KAlAAr37d7cYCQACtftftxAI0AKx+1+3CAiwArH7W7cECJQCsftPtwAIgAKt+1O3BAiAAq37e7cECJwCtfuftwwIwAK5+6e3FAjsArn7s7ccCRACvfvntygJQALB+Ee7MAmIAtH4t7s8CeQC4fkPu0gKPALp+Ue7VAqIAvH5c7tgCtgC+fmTu3QLMAL9+ae7iAuAAv35t7ucC9AC/fnru6wIJAcF+ke7wAiIBxH6r7vQCPgHHfr7u+AJZAcl+ze78AnQBy37g7gADjwHNfvTuBAOrAc9+A+8IA8QB0X4Q7wsD2wHSfiTvDgPxAdR+O+8RAwcC135Q7xQDHALZfmLvFgMwAtt+de8ZA0QC3X6E7xsDUwLffovvHANdAuB+i+8dA2UC336K7x4DbQLfforvHwNyAt9+0efV/yv9qX3O59X/K/2ofcvn1f8q/ad9xefV/yn9pn2659X/KP2kfajn1f8m/aF9kufV/yP9nH1859X/IP2YfWPn1v8c/ZN9SOfW/xj9jX0s59b/E/2IfRLn1v8P/YN99+bW/wv9fX3c5tb/B/14fcPm1v8D/XN9qubW/wD9bX2J5tX/+/xnfWPm1f/3/F99VubU//X8XH1p5tP/9vxgfTrm0v/u/FZ9IOXQ/8P8Gn3w4sz/bfyafHLgx/8M/Px7297E/837j3vS3sT/zPuNeyjgx/8A/Oh7LeLK/0/8a3wi5M7/nPzhfHjl0P/R/C19C+bR/+f8TH0g5tL/6/xRfRnm0v/q/E99IubS/+z8UX025tL/7vxVfUjm0v/x/Fl9WObS//P8XX1s5tL/9vxhfYDm0v/5/GV9kubS//z8aH2j5tL//vxsfbXm0v8B/XB9yubS/wT9dH3k5tL/CP15ff/m0v8M/X99FOfS/xD9g30j59L/Ev2GfTLn0v8U/Yl9RefS/xf9jX1Z59L/Gv2RfWvn0v8d/ZV9fOfS/yD9mH2M59L/Iv2bfZvn0v8k/Z59qefS/yX9oX2159L/J/2jfb/n0v8o/aV9yOfS/yn9p33O59L/Kv2ofdHn0v8q/al9St3fAd8H73pF3d4B2wfuejXd3QHUB+p6It3aAccH5XoU3dcBswfjegzd0AGdB+J6A93HAYcH4Xrw3L4BbwfdetTctgFSB9d6utysATMH0Xqn3KABFQfOepfclAH5Bst6hNyHAdwGx3pu3HoBvAbDelzcbgGbBsB6S9xiAXoGvHov3FcBWAa2eg3cTgE4Bq568NtEARwGp3re2zoBAwajetDbMQHrBaB6w9sqAdUFnXq32yMBwgWberPbHgG0BZp6tdsaAawFm3q02xkBpwWbeq3bGAGmBZl6qtsYAacFmHqv2xoBrgWZernbHAG2BZx6wtsfAcAFnnrJ2yMBygWgetLbKAHXBaJ65NssAekFpnr92zEB/wWsehTcNgEWBrJ6J9w8AS0Gtno13EMBQwa5ejzcTQFWBrp6PdxXAWQGuno+3GMBcga5ekjcbQGFBrt6W9x1AZ8Gv3px3H0BvAbEeoPchgHVBsd6k9yPAewGy3ql3JcBBAfOerncnwEdB9J6ytynATMH1nra3LABRwfZeu3ctwFcB916A929AXQH4noZ3cEBjwfnei7dxQGmB+t6Pt3KAbcH7npF3c8BxQfwekbd1QHPB+96Rt3ZAdcH73pJ3d0B3Qfvekrd3QHfB+965tw6AGT7AXvi3DoAZPv/et7cOgBj+/562dw6AGP7/XrP3DoAYvv6ervcOgBf+/R6o9w6AFz77XqN3DoAWfvnenjcOgBW++B6YNw6AFT72npF3DoAUfvSeivcOgBO+8p6Etw6AEz7wnr42zoASfu7et3bOgBG+7N6xNs5AET7q3qs2zkAQfukepTbOQA/+516e9s5ADz7lXpk2zkAOvuOek/bOQA3+4h6PNs5ADX7gnor2zkAM/t9eh7bOQAy+3l6Fts5ADH7dnoR2zkAMPt1eg/bOQAw+3R6ENs5ADD7dXoV2zkAMft2ehzbOQAy+3h6Jds5ADP7e3ov2zkANPt+ejfbOQA1+4F6QNs5ADb7g3pP2zkAOPuIemLbOQA6+456cds5ADv7knp82zkAPPuVeozbOQA++5p6pNs5AEH7onq92zkAQ/upetLbOgBF+69659s6AEf7tXr72zoASvu8eg/cOgBM+8J6JNw6AE77yHo53DoAUPvOekzcOgBS+9R6XNw6AFP72Hpu3DoAVfveeoPcOgBX++R6mNw6AFr76nqp3DoAXPvverXcOgBe+/J6v9w6AF/79XrK3DoAYPv4etXcOgBi+/x63tw6AGP7/nrk3DoAZPsAe+bcOgBk+wF71NkKAhQMjnnK2QgCEQyLeb/ZBwIJDIl5tdkDAvwLh3mo2f0B7QuFeZnZ9QHbC4J5h9nsAccLfnl02eIBrwt6eV7Z2AGTC3d5SdnMAXQLc3kz2b8BVgtveR3ZsQE6C2t5BdmjAR4LZnnu2JUBAAthedvYhwHeCl55xth6AbsKW3mp2G4BmgpUeYnYYwF+Ck15b9hXAWUKR3le2EwBTQpDeU7YQgE1CkB5Ptg6AR4KPXkw2DMBCwo6eSjYLQH9CTh5J9gpAfUJOXkm2CYB8gk5eSLYJgHzCTd5HdgnAfcJNXkf2CkB+wk2eSjYLAEACjh5M9gvAQgKO3k82DQBFAo9eUPYOQEkCj55T9g/ATcKQHlh2EUBSwpEeXPYTAFfCkl5hNhTAXQKTHmV2FsBigpQeaLYZQGcClJ5rNhxAawKVHm12HwBvgpVecTYhwHUClh529iQAesKXXn02JkBAQtjeQfZpAEWC2d5GNmuAS4Lankt2bcBSgtueUTZvwFlC3N5VdnIAX0Ldnlj2dIBkQt4eXLZ2gGkC3t5hNniAbkLf3mY2egBzAuDearZ7wHdC4d5uNn1AewLinnC2foB+guLecfZAAIGDIx5zNkEAg8MjXnR2QgCEwyOedTZCAITDI95TNVyAcP3X3hH1XIBwvddeETVcgHC9114P9VyAcH3Wngx1XIBv/dWeB7VcwG+9094CtVzAb33R3j31HMBvPdBeOHUdAG79zl4yNR1Abn3L3it1HYBuPcmeJTUeAG39x14e9R5AbX3E3hf1HoBtPcJeEPUewGy9/93J9R8AbH39HcO1H4Br/frd/fTfwGu9+J34NOAAa332nfK04EBrPfSd7fTgQGr98t3ptOCAar3xHeX04IBqfe/d4vTgwGn97p3hNODAaf3t3eB04MBp/e2d4DTgwGn97Z3gNODAaf3tneD04MBp/e3d4rTgwGo97p3lNODAan3vXee04MBqffBd6fTggGq98V3sdOCAar3yXe+04EBq/fNd83TgAGs99N339OAAa332nfw038BrvfgdwLUfgGv9+d3FNR9AbD37Xcn1HwBsff0dzrUfAGy9/x3TtR7AbP3A3hk1HoBtPcLeHnUeQG19xN4jNR4Abb3Gnie1HcBt/cgeLHUdgG49yd4xdR1Abn3LnjY1HUBuvc1eOnUdAG79zx4+dRzAbz3QXgJ1XMBvfdHeBjVcgG+90x4JNVyAb73UXgw1XIBv/dVeDvVcgG/91l4RdVyAcH3XXhK1XIBwvdfeEzVcgHC91944leJxiI5wS3bV4DGIDnFLc1Xb8YdOc8tuVdUxhc52y2eVzDGDznrLX1XBcYJOfstWFfVxQY5CC4uV6DFBTkWLgJXaMUCOSYu01Yuxfw4Oi6kVvLE8zhSLnNWtcTqOGwuQFZ2xOE4hi4KVjTE2TifLtFV8MPQOLkumlWsw8c40y5lVW3DvzjsLjRVM8O4OAIvCFUAw7I4Fy/hVNPCrDgpL79Uq8KoODgvolSKwqg4QC+JVG3CqzhFL3VUVsKtOEgvbFRMwqw4TC91VFbCrDhKL45Uc8KuOEAvr1SawrM4MS/PVMDCuTgiL+1U48K8OBYvClUFw704DC8oVSjDvzgBL0dVTMPDOPMuZ1Vyw8k44y6IVZrD0DjSLqpVxMPXOMAuzVXuw984rS7vVRjE5TicLg9WP8TpOI4uL1ZlxOo4gy5OVovE6zh5Lm5Ws8TuOGwuj1bbxPM4Xi6tVgLF9jhQLspWJcX3OEcu5FZFxfc4Py7+VmXF+Tg2LhdXhcX8OCouMFelxQE5Hi5KV8bFBTkRLmNX58UJOQYue1cFxgw5+y2QVyDGDznxLaJXN8YSOektsFdKxhQ54i29V1vGFjncLchXacYZOdUt01d3xh45zS3dV4TGITnFLeJXisYiOcItxjajGHgWxm7KNp4YcBbHbtY2kxhkFsZu7DaCGFcWwW4PN2oYTha3bjo3SxhKFqluaTcmGEoWmm6YN/0XThaLbsY3zxdZFntu9jegF2sWam4lOHAXfhZYblI4PxeIFklugDgOF4UWPW6zON4WdRYwbvM4rRZhFh1uPjl+FlAWA26KOU4WRxbnbdA5HRZEFs1tDDrvFT8Wt21AOsUVNhambWo6ohUqFpltiTqHFSIWj22eOnEVIRaJbaw6YRUoFoNttTpWFTMWfm23OlIVPBZ8bbI6VBU+Fn1tqTpaFTwWgm2gOmIVOhaGbZo6axU8FoZtlDp1FT4Wh22JOoEVPBaLbXc6kBU2FpNtYDqlFTUWm21FOr4VPRajbSQ62RVMFqxt+zn2FVkWum3NORIWXhbLbZ05MRZeFt5tcDlVFl8W7m1EOX0WYxb8bRc5phZrFgpu5zjNFnMWGW67OO8WeRYnbpU4Dxd9FjNucjgwF3wWPm5QOFMXdxZKbio4dxdwFlduATibF24WZG7VN70XchZzbqY33hd5FoFudzf+F34WkW5JNx8Yfxahbh83Phh+Fq9u/zZaGH4WuW7oNnEYgBa/btg2hBh/FsNuzTaUGHwWxW7HNp8YeRbGbsc2oxh4FsZuzQ+RFGfUhHXVD4QUZdSEdecPbBRl1IZ1AhBIFGLUh3UjEB0UWNSGdUgQ7BNH1IN1cBCzEzbUgXWcEHMTLdSCdcoQMBMu1Id19RDzEjbUjnUbEbkSQdSWdT8RgBJM1J11YhFGElPUpHWDEQ4SVdSpdZ8R3RFT1Kt1uRGyEU3UrHXTEYYRRNSrdfERVRE51Kl1EBIhETPUqnUuEvAQNdStdUgSxhA71LF1WxKiED3UtHVrEoYQPNS1dXgSbxA61LZ1gBJfEDvUt3WDElUQQdS6dYISUhBK1L51fhJWEFLUwXV2EmIQU9TBdWwSdBBN1L51YBKIEEPUuXVREpsQN9S1dT8SsRAr1LB1KBLOEB/Uq3UQEvEQGNSndfgRExEY1KZ14xEvESDUqHXOEUcRLNSsdbYRZRE11K51mRGPETvUr3V5EcIRQdSudVcR9xFG1K11NxEnEkrUrHUaEVISSNSpdf4QfBJC1KR14BCpEjvUn3XAENgSONSadaEQBxM31Jd1hBA0EzbUk3VpEF0TNdSQdVAQghM21I51OhClEz7UjnUmEMcTTdSQdRMQ6xNc1JN1ABAQFGTUknXwDzUUZNSOdeMPVhRi1Il12Q9yFGLUhnXQD4gUZdSEdc4PkBRn1IR1Gw3I1mP8angPDc/WZ/xtePgM39Zx/HZ40wz51oH8g3ikDB3XlfyVeHMMRter/Kh4Rgxw18P8vHghDJbX3PzNeAYMttfy/Nt4+AvQ1wX95Xj7C+XXFf3teAsM+dcn/fJ4IwwP2Dz993g9DCnYU/3+eFwMRNhn/QR5hAxf2Hj9CXm2DHnYhv0Nee4Mk9iR/Q95Jg2s2Jr9EnlaDcHYo/0TeYwN09iv/RN5uQ3j2L39FHneDfLYyf0VefoN/djR/RV5Dg4D2dT9FXkdDgLZ1v0TeSwO/NjY/Q95Og722NX9DHlDDvHYyP0JeUoO7Niw/QZ5Ug7l2JT9AnlcDtnYff38eGIOy9hr/fd4YQ692Fz98nhaDqzYS/3teFcOl9g5/eZ4WA572Cb93HhcDlzYFv3ReFkOP9gF/ch4TQ4k2PP8wHg7DgrY3/y5eCsO8NfK/LJ4Hg7W17L8qngVDr3Xl/yieAwOpdd7/Jp4Ag6M12H8knj4DXPXS/yKeO0NW9c2/IN45A1F1yD8fHjbDS/XCvx1eNINGdf3+254xA0D1+z7Z3ixDe7W7PtieJkN3dbz+194fw3S1v37X3hmDcvWCfxgeE8NyNYa/GJ4OQ3H1jH8ZXgkDcjWUfxoeBsNyNZj/Gp4kix4XjL3c0ltLJVeN/dkSV0sol49915JUyynXkb3XklJLKZeVfdoSUAsn15q93lJNiyWXoP3jUkrLJBem/efSRwsjl6x961JCiyPXsT3uEn9K5Be0ffASfArl17W979J4iumXtL3tUnfK69eyfepSfcro16896lJIyyHXqv3sUlBLHZel/exSUgse16C96VJSiyGXm/3k0lPLJFeWfeASVEsnl5D92xJWCyiXjH3X0l2LJFeJPdhSaQscV4c925JxixaXhX3dknPLFdeD/dzScwsXl4J92xJzixhXgX3Z0nZLFpeBvdpSe4sSF4K93RJBC04Xgn3e0kKLTleAPd1SQMtRV719mdJAy1IXvH2ZEkSLTde9vZxSSEtIl4A94RJHS0fXgb3i0kFLTReBfd+Se0sTl4A92tJ7CxRXv/2aEkGLTheBPd4SSEtHl4K94pJIy0cXgj3jEkWLSpeAfeBSRUtLV789nxJHC0oXvz2f0kTLS5e/PZ9SfcsRF789nJJ1SxdXv72Zkm3LHJeB/dfSZwsg14Q91pJgyyWXhT3UkluLKdeFfdISWMssF4V90RJbCynXhb3SUmELJReF/dVSZMshl4a911JkyyDXiH3YkmRLH1eLPdsSZIseF4y93NJ/eiBEnv7dnz56HoSkvt3fOPofhKe+3N8x+iEEqD7bXyq6IUSmPtnfInohRKJ+2B8ZOiGEnr7WXw96IUSbftRfBnohBJl+0p8+ueAEmD7RHzg534SXvs/fMznfhJg+zx8xOd+Emb7OnzL534SZ/s8fOHnfxJS+z98A+h/Ei/7RHws6HwSGftMfFPodxIc+1R8d+h0Eiv7XHyb6HMSO/tkfMLocBJL+2x86OhtElP7dHwG6W8STPt5fBvpdRI6+3t8K+l6Ei/7fXw46XoSMvt/fEPpexI6+4F8Sul+Ej77gnxN6YMSOvuCfEzpihIw+4F8S+mREij7f3xK6ZYSL/t+fE3pmhI9+398UumaEj/7gHxU6ZcSMvuAfFbplBIk+4B8VemREib7gXxT6Y4SOvuCfFDpjhJR+4J8S+mRElb7gXxE6ZQSRPt+fEDplxIu+3x8QOmXEin7fHw/6ZgSMft8fDvpmhI0+3t8N+mcEi77enw46ZoSL/t6fDjplRI++3x8NemPElP7fXwu6YgSaft9fCnpgRJ8+358Jel8Eo37f3wk6XkSmfuAfCPpdxKc+4B8Hul6EpT7fnwX6X8Shft7fA/pghJ9+3l8COmCEnz7eHwB6YISfPt3fP3oghJ8+3Z8qv3eo4z3a1iZ/d+jm/dtWIP936O2929YcP3eo873b1hl/d2j2/dwWGD93aPg93BYW/3do+H3cFhW/d2j4fdwWFT93aPi93BYV/3do+H3b1hg/dyj3fduWG7926PY921YfP3ao9P3bFiF/dmjzvdrWIb92aPO92tYhP3Zo9H3a1h//dmj1vdrWHv92aPa92xYe/3Zo9r3bFh9/dqj1/dsWID92aPY92xYgP3Zo973bViA/dmj4vdtWIL92aPj921YhP3Zo+P3bViE/dqj4fdtWIH93KPP925Yev3ho6T3b1hy/emjaPdxWG798KMu93NYc/31owT3dFh8/faj8fZzWID99qPv9nNYf/31o/T2c1h8/fWj/PZzWHn986MK93NYfP3xoxr3cliF/e+jJfdxWI397aMr93BYkP3soy/3cFiO/eyjM/dwWI7966M293BYkP3qoz73b1iT/emjSvdvWJr956NP925Ywv3noxP3aVgM/uajlvZdWF3+5qMP9lBYlv7mo7H1Rlio/uajl/VDWJ3+5aOx9UVYf/7ko+z1SlhU/uOjP/ZRWCP+4qOa9llY9f3ho/L2YFjO/eCjPvdnWLP94KNz92pYqv3fo4f3bFir/d+jivdsWKn936OL92xY7P3MAzjtiX7u/cwDQu2LfvD9zANN7Y1+8f3MA03tjX7x/cwDSu2MfvL9zANP7Y1+9f3MA1/tj371/cwDZu2QfvP9zANV7Y5+8P3MAz/ti37x/cwDQu2LfvP9zANV7Y5+8/3MA1btjn7t/cwDP+2Kfun9zAMw7Yh+7P3MAz3tin7z/cwDVu2OfvX9zANf7Y9+8/3MA1Xtjn7w/cwDSe2Mfu79zANC7Yt+6/3MAzftiX7p/cwDLO2Ifun9zAMw7Yh+6v3NAz7tin7r/c0DQu2Lfun9zQM47Yl+6f3MAzTtiX7u/cwDQ+2LfvP9zANV7Y5+9f3MA1vtj371/csDV+2OfvX9ywNT7Y5+9f3LA1LtjX71/csDUe2NfvX9ywNQ7Y1+9f3LA1DtjX71/csDT+2NfvT9ywNP7Y1+9P3LA0/tjX7z/cwDT+2NfvP9zANP7Y1+8v3MA0/tjX7y/cwDUO2Nfu39zAM+7Yp+sf3QA27san46/dgDzOokfrb84QMA6c99WvzoA7znkH0+/OkDXed8fVT86AOo54x9hvzlA1born3L/OADSOndfRr92gNe6hB+av3VA3TrQH6u/dEDYuxoftr9zgP+7IB+6f3NAzHtiH7p/c0DNO2Jfur9zQM57Yl+XAW7qXPxRl1mBbupbPFFXWkFu6lu8URdaQW6qXLxRV1oBbqpdfFFXWcFuql28UVdZgW6qXbxRV1oBbqpcvFFXWsFu6lu8URdbQW7qW7xRF1vBbqpb/FEXWwFu6lu8URdaAW7qWzxRF1mBbupavFFXWYFvKlp8UVdZwW8qWXxRV1nBb2pZPFFXWQFvaln8UVdYgW9qWnxRl1iBb2pafFGXWIFvalo8UZdYwW9qWbxRl1mBb6pYvFGXWoFvqlb8UVdbgW/qVXxRF1tBb+pVvFEXWgFvqlk8UZdZQW8qXXxR11qBbqpg/FHXXEFuKmO8UddcgW3qZjxR11xBbepm/FIXXAFt6mZ8UhdbwW4qZfxSF1tBbipl/FIXWkFuKmX8UhdZQW4qZfxSV1mBbipk/FIXWoFuamO8UhdbQW5qYnxR11uBbmphvFHXWoFuqmF8UddYgW6qYbxSF1eBbuphfFIXV4Fu6mC8UhdXwW7qYLxSF1cBbuphPFJXVgFuqmJ8UldVwW6qYvxSl1aBbqpifFJXVwFu6mE8UldWgW7qX/xSV1XBbypf/FJXVMFu6mE8UpdUwW7qYPxSl1cBbypdvFIXWYFvalo8UZdaAW9qWXxRl1iBb2pbvFHXV4FvKl08Uhd7/wxBlbeTHvw/DEGZd5Qe/H8MQZp3lF78fwxBm7eUnvz/DEGft5Xe/b8MgaY3l57+fwyBrTeZnv7/DIGxt5re/z8MgbO3m17+/wyBsnea3v6/DIGu95ne/f8Mgah3mB78vwxBnjeVXvr/DAGOd5Ee+D8MAbe3Sp70vwvBmfdCXvB/C4G3dzieq/8LQZH3LZ6nPwsBqfbhnqJ/CoGBNtVenb8KQZj2iN6ZPwoBszZ9HlU/CcGRtnJeUf8JQbZ2KZ5PvwkBozYjXk4/CQGXdh+eTT8JAY92HN5MfwjBh/YaXku/CMGBthheS38Iwb/1155LvwjBgrYYnkx/CMGINhpeTT8JAY62HJ5OPwkBlrYfHk8/CUGg9iKeUL8JQaz2Jp5SPwmBuXYqnlO/CYGGNm7eVX8JwZS2c15XfwnBpTZ4nlm/CgG3Nn5eW78KAYm2hB6d/wpBm7aJ3qA/CoGtto9eon8KgYB21R6kvwrBk7bbHqb/CsGmtuDeqT8LAbj25h6rPwtBizcrnq1/C0GdtzDer78Lga+3Nh6xvwuBgHd7HrN/C8GQd3+etX8LwZ/3RB72/wwBrPdH3vg/DEG3d0qe+T8MQYC3jV76PwyBijeP3vr/DIGSd5Ie+z8MgZW3kx73Bez9GP7KX3dF7L0Zfsofd4XsvRp+yh92hey9Gz7KX3OF7H0b/ssfb0XsfRz+y99sBew9Hj7MX2sF6/0fvsyfa0Xr/SB+zJ9rhev9ID7Mn2vF7D0e/syfbgXsfRz+zB90Rey9Gr7K333F7P0XfsjfScYtfRN+xp9XBi49Dj7D32aGLv0JPsCfeEYvfQQ+/R8MRnA9Pv643yGGcP04/rRfNUZx/TJ+sB8GxrK9LL6sXxYGsz0nvqjfJAaz/SM+pd8vRrR9H76jXzYGtH0ePqHfOca0vR2+oN88hrS9Hj6gXz5GtH0ffqAfPca0fSC+oB88BrQ9If6gnzoGtD0ivqEfN0az/SO+oZ8zBrO9JP6iny4Gs70mfqPfKEazfSf+pR8hRrM9Kb6mnxlGsv0q/qhfEYayvSw+qh8KxrJ9Lj6rnwMGsf0wfq0fOkZxvTM+rx8xBnE9Nj6xHyfGcP04/rMfHsZwfTu+tR8VRnA9Pj63HwqGb70AvvkfAEZvfQO++182xi79Br79Xy2GLn0Jfv9fJMYuPQu+wR9dRi39DX7Cn1cGLb0PfsPfUQYtfRI+xR9LRi09FH7GX0WGLP0V/sdfQIYsvRZ+yF98xey9Fz7JH3kF7H0YfsnfdwXsfRj+yh9yydCDyz1NXi/J0MPL/U5eL4nQw8v9Tl4uidDDzD1OnivJ0QPM/U+eKMnRA829UN4mydEDzn1RXiXJ0UPOvVHeJMnRQ879Uh4kydFDzv1SHiaJ0QPOfVGeKknRA819UB4vidDDy/1OXjZJ0IPKPUweAEoQA8d9SJ4Oyg8Dw71DXiBKDkP/PT1d8woNQ/p9Np3GSkxD9b0vndnKSwPw/Sid7QpKA+v9IZ3/SkkD530bHc+KiEPjfRTd3MqHg9/9D93mSocD3b0MXewKhsPcPQpd8EqGg9s9CN30CoZD2j0HXfZKhgPZvQZd9cqGQ9m9Bp3zioZD2n0HnfDKhkPbPQid7gqGg9u9CZ3qiobD3L0K3eWKhwPd/Qzd4AqHQ989Dt3aioeD4L0Q3dQKiAPifRNdzIqIQ+Q9Fh3EyojD5j0Y3fyKSUPoPRwd88pJw+p9Hx3qikpD7L0ineFKSsPu/SXd2EpLQ/E9KR3PSkvD830sncYKTEP1/S/d/QoMw/g9Mx30ig0D+j02HexKDYP8PTkd5IoOA/49O93cyg5DwD1+ndVKDoPB/UEeDcoOw8P9Q94HSg9Dxb1GHgHKD4PHPUgePInPw8i9Sd43ic/Dyf1LnjQJ0APK/UzeMsnQA8s9TV4NRkMLAcKFHULLT/e4QbAchEtQN7iBr5yGi1B3uMGunIYLUHe4wa7cgctP97fBsJy7iw93tgGy3LfLDve0wbRcuIsPN7TBtBy6Cw83tQGznLhLDze0wbQctssO97SBtJy4iw83tUG0HL5LD7e2wbHchktQN7kBrtyRC1D3vEGqnJ7LUbeAQeUcr0tSt4TB3pyBi5P3ikHXXJSLlTePwc+cp4uWd5VBx9y5y5e3moHAXIxL2LefwfjcXkvZ96UB8Vxsy9r3qUHrHHUL27erweeceUvb960B5dx8i9v3rcHknH9L3DeugeNcQQwcN67B4pxAzBw3rwHinH+L2/euweMcfkvbt66B45x+C9v3rkHj3H0L2/euAeRcekvb961B5ZxzC9t3q0HonGCL2vemAfCcREvad56B/JxzS5n3mcHDnLrLmXebgcBciAvY957B+pxHC9h3nkH63HrLl7eawcAcrwuW95eBxNyoC5Z3lYHHnKGLljeTgcpclMuVN4/Bz5yGC5Q3i4HVXI0LlLeNgdKcgkvYN50B/NxgzB63uIHVHH3MZXeTgiycKkyo96CCGNwSjKb3mYIjnAWMYTeDQgVcY0vad6aB7xxMi5S3jYHS3JbLUTe9wagchEtQN7iBr5yCy0/3uAGwHIZeC4PfvkTKRx4Lg99+QgpIHgsD3z5/igjeCoPffn2KCZ4Jw9/+e8oKXgiD3755ygueBsPfPnbKDV4FA95+cooPXgLD3X5tShFeAIPdfmgKE14+A53+YwoVXjvDnn5eShbeOYOefloKGF43A53+VooZ3jRDnX5SyhueMgOc/k6KHV4wQ5x+SYofXi+DnD5ESiDeLwObvn+J4h4uw5t+e8njHi3Dmr55CeQeLEOaPnaJ5R4qg5m+dInmHiiDmT5yCebeJsOYvm/J554lw5f+bgnn3iXDlv5tCefeJkOV/mzJ554nQ5V+bUnnHihDlb5uSeZeKYOV/nCJ5R4qw5Z+c8njnivDlj54CeIeLQOV/nwJ4R4ug5Y+fongXi+Dlr5ASh/eMMOXPkGKHx4yQ5e+Q4od3jPDmL5GyhweNUOZvkvKGh42Q5p+UQoYnjeDmz5VCheeOMObfleKFx46Q5v+WQoWXjwDnD5aihVePgOcvl0KE94AQ90+YMoSHgID3b5lShBeA4PePmnKDt4Eg96+bcoNngVD3r5xSgyeBgPe/nRKC14HA98+d0oKXggD3355ygmeCUPffnvKCN4KA9++fcoIHgpD375/ygdeCsPf/kHKRp4LA9/+RApGXgtD4D5FCkCL1oMKgVMdvcuWAwlBVF27S5UDCAFVXblLlMMGwVZdt4uWAwYBVt22C5iDBkFXXbPLm8MHgVedsQuewwjBWF2ti6CDCQFZnalLoEMIAVtdpguegwZBXN2ki5xDBIFd3aTLmwMEAV3dpUucQwUBXZ2ki59DBoFdXaHLokMHQV4dnUujwwZBX92YC6JDBAFiHZPLn4MBgWQdkQudgwABZV2Py51DP8EmHY9LnkMAQWYdjsufwwFBZh2Ny6DDAkFmXYzLoUMCwWadjAuhAwOBZt2Ly6CDBEFnHYuLn8MEwWddiwufAwTBZ12Li55DBMFnXY2LncMFAWadkcueAwWBZN2Wy5/DBsFi3ZrLooMIAWDdnEukgwjBX92bC6UDCEFgnZiLo4MGgWGdl8ugwwUBYl2ai57DBEFhnZ/LnoMEwV9dpYufwwYBXN2pi6FDB8FbHasLoUMIgVqdqwufQwgBWt2ri5yDBsFa3azLmkMFwVqdr0uZQwWBWd2yC5kDBYFY3bPLmcMFgVgdtIuagwYBV520i5sDBoFXnbVLmsMHQVcdt4uZgweBVl26y5gDCAFVXb3LlsMIgVRdv8uVwwiBU52Ay9YDCMFTHYCL1oMJgVMdgEvWwwoBUx2AS9bDCgFTHbYuXP6ggl9at65c/qECYFq47ly+oYJhGrnuXL6hwmHauu5c/qGCYpq77l2+oAJjGrxuXr6dwmPavO5f/ptCZJq9bmD+mUJlGr1uYX6YAmUavS5hvpdCZRq77mI+lkJkWrpuYv6UgmOauO5kfpGCYtq4rmX+jkJjGrkuZz6LwmOaui5n/orCZFq6rmf+iwJk2rquZ/6LQmTaui5n/otCZJq5bmh+igJkGrhuaT6IAmOat25qfoXCY1q2bms+g8Ji2rWua/6BwmJatK5svoCCYdqzrm0+v4IhWrLubT6/QiDasq5tPr9CINqybmz+v8IgmrGubL6AgmAasK5sfoDCX1qvbmw+gQJemq8ubD6BAl5ar+5r/oHCXpqxrms+g4JfmrOuaj6GQmDatK5o/okCYRq0bmf+i0JgmrNuZz6Mgl/asm5m/o0CXxqxrma+jUJemrHuZj6OQl6asi5lPpBCXpqyLmP+kwJeWrJuYv6Vwl4asq5hvpgCXhqzLmD+mgJeGrQuYD6bwl6ata5fvp0CX1q3Ll9+ngJgWrfuXz6egmDat25e/p8CYJq2bl6+n4JfmrUuXn6fwl7atG5ePqBCXlq0rl3+oIJeWrUuXf6ggl7ati5ePqCCX1q2bl4+oIJfmrefNjtGxSTB9581u0aFJMH3nzU7RkUkAfffNXtGRSFB+B81+0YFHEH4nzY7RgUVAfjfNbtGxQwB+R80e0fFAkH5XzM7SMU4wbmfMftJhS/BuZ8we0pFKEG5ny57SwUhQblfK/tLxRrBuV8pe0yFE0G5Xyd7TYUJQbmfJntOhT3Beh8me09FM0F6Xyb7T0UrgXrfJztPBSYBet8mu08FIUF63yV7T8UcQXqfJDtQxRXBet8jO1HFDoF63yJ7UgUHgXrfIbtSRQIBet8gu1LFPoE63x/7UsU9ATrfH/tSxT1BOt8ge1KFPoE63yF7UkUAAXrfIftSBQOBet8h+1IFCEF6XyF7UoUNQXofIbtSxRFBel8i+1KFFAF6nyT7UcUXQXrfJvtQhRzBex8ou09FJEF63yl7TgUtAXqfKbtNxTUBel8pe04FO4F6Hyn7TgUBAbofKztMxQbBul8s+0sFDYG6ny57SUUVQbpfL3tIhR4Bud8vu0iFJoG5nzB7SIUuwblfMbtIRTYBuV8y+0gFPAG5HzO7R8UBwfifM7tIBQgB+F8ze0iFDgH33zM7SIUTwfefMztIRRhB958ze0gFHAH3nzQ7R4UewfefNPtHBSFB9581+0aFI8H3nzY7RoUlQcbLAsGUgP1dxcsBQZPA/d3ECwCBksD+ncBLAMGSQMAeOorDQZHAwh4zisbBkUDEXitKygGQgMdeIcrMgZAAyp4Wis5BjwDOngnKz0GNgNMePQqPAYxA194ySo3BiwDbnipKjQGKwN6eI0qNgYrA4R4aipBBioDkHg5Kk8GJQOgeP8pWQYdA7R4xClcBhUDyXiRKVgGDQPbeGcpUwYGA+l4RClRBv8C9ngjKVQG+gIBef8oWwb5Ag152ihkBvoCGXm5KGoG+wIjeaEoagb7Aix5kShmBvkCMXmIKGAG9wI1eYMoXgb1AjZ5hSheBvUCNnmXKFsG9QIwebkoVgb1AiV55ChSBvQCF3kMKVIG9AIJeScpVgb1AgB5OClbBvcC+nhIKVsG/AL0eGQpVgYBA+p4kilPBgcD23jKKUoGDAPIeAAqRwYPA7V4KypHBhUDpnhLKkcGHgOaeGgqRQYqA5B4iio+BjQDhHi0KjMGOAN2eOQqKAY3A2V4FSsiBjYDVHhAKyIGNwNFeGMrJgY7Azh4gSsnBj4DLXifKyIGQAMieLsrGAZBAxh41SsNBkMDEHjqKwQGRQMIePsr/wVJAwJ4BywABkwD/XcQLAUGTwP6dxksCQZRA/Z3HSwKBlMD9Xc5qCUKletTWj2oIgqZ61haQqggCpzrXlpKqB8KnutmWlSoIAqc629aXqgiCpfreFppqCUKkuuBWnaoJwqN64xahqgpConrmlqZqCsKhuusWq2oLAqE679av6gtCoHrz1rNqDAKe+vbWtmoMwpz6+Ra5ag3Cmrr7Vr2qDkKZOv8WgypOgpk6xBbI6k5CmbrJ1s5qTgKaus9W0qpNgpt605bWKk2Cm3rW1tkqTcKaetlW3CpOgpj629bfKk+ClvreVuIqUIKVeuCW5GpRApR64lblqlEClHrj1uaqUMKUuuSW5ypQgpU65Vbm6lBClfrlFuTqUEKWOuOW4apQApa64Fbc6k+ClzrcVtiqT0KXuthW1apPApg61ZbT6k7CmTrUVtKqTkKaOtNW0GpOAps60VbMKk2Cm/rNlsaqTYKb+shWwSpNgpv6wxb8ag2Cm7r+lrkqDYKbuvtWtqoNgpu6+Nazqg2CnDr2Vq/qDMKduvLWqyoLwp+67tamKgrCoXrq1qHqCkKiuucWnmoKAqM649abqgnCo7rhFpjqCcKket6WlmoJQqT63JaUaglCpXralpKqCYKletjWkSoJgqV611aQKgmCpXrWVo8qCYKletWWjqoJgqV61NaOagmCpXrUlpD+wLRef70dj77+9B3/vF2Ovv30HX+73Y2+/fQcf7vdjH7/dBs/vF2K/sJ0Wf+9nYh+xXRZP76dhb7INFg/v52Dfsm0V7+AHcH+yjRXf4AdwT7JdFc/v92/vog0Vv+/Xb1+h3RWP77dun6IdFW/vx23Pot0VP+AHfR+jvRT/4Fd8z6QdFK/gd3zPo80Ub+BXfO+jHRQ/4Bd876KNFA/v12zfol0T7+/HbK+inRPv7+dsb6L9E9/gB3xPo10T7+AnfC+jjRQP4Dd8L6NtFC/gN3xfox0UP+AXfJ+izRRP7/ds76J9FF/v120/ok0UX+/HbX+iLRRf78dtn6ItFF/vx22fom0UX+/XbY+i3RRP4Ad9j6NNFC/gJ33Po20UP+A3fj+jHRRv4Cd+v6KNFI/v928Poi0Uv+/Hbx+iLRTP79dvL6J9FO/v928/os0VD+AXf2+irRVP4Ad/v6ItFX/v12AfsX0Vv++XYG+w3RXf72dgr7CNFf/vR2D/sI0WH+9HYV+wzRY/72dhr7ENFm/vh2H/sT0Wn++XYk+xPRbv75dij7DtFw/vh2LPsH0XH+9XYv+wDRcv7zdjL7/dBz/vF2Nvv90HX+8nY7+wDRd/7zdkH7AtF5/vR2Q/sC0Xr+9HadAv8EK/7cfy8DLgT0/d9/1AMgA9n94n/GBPIBlf3ffyQG3QBT/dF/XwhhAAz9sH+aCuT/xvyEf6YMnv++/FR/0gNeCpH9f3/3BM4IyfyOf0EGuwYc/Jt/JghnBAX7kH/eCk8CBfpff1EPXwFA+eR+vhNwAH74Pn7HFwQARfiIfWQFmQrv/nB/igYmCfT9fH/UBy4HBP2Ff7kJAwWi+3R/cAwQA176O3/hED0CfPmxfksVaAGd+P19UxkFAVb4On0dC5P+MwCBf0QS5ADL/69+5xltAyL/TH0pHykFUf4HfEUftAVO/fV7VRp1BRj8FH1bFTQF5Pr+faQRggUi+Xh+g7hSzWq2WjlOtHzOZL91P6ixwc8lxppDsLGizhbKDEaMs4jLEsrWRbO138jVxaJCCbhYxr3BRT9duRHFI77ZO0HAe/e9/qhukNSo85kO4HaY8EzykRqAe14G+PO6HcB7KQx19H8b4XvGCBnxUhbYfFwFye0TEWx9/giC6IcINn3FCaoPh80rdCgILwWmxP5wxwDm/ii/WW7/+WD9isD3bh75d/zpx8tyy/vn+u/T/XeD/mb5cuDce7H/0PsZ6zV+CB1fDM7+CnwgKpf6KP67eEczKuvDAGhz6TW/48gBlnAONOXjp/5/cQMwDui0+PtzwCtT7Mry7nW0Kufv+O+BdlfIStK538RklcmUz4bcF2N4yoTNr9l4YcHKxcxS2LBgfsp0zQzZM2HEyS7PeNucYhPJ8tDr3fRjV8hK0rnfxGQWCKUVmQXFfb4JkhUOB5d9VAt/FXAIYn0wDHYVLwlCfdsLexXkCE99egqNFbAHf30ZCZ0VewaqfRYIqBWZBcR9JvafAEb1Kn8B8fAAzfW0fkvrJwFF9u59pudHAX/2S3186EkBY/ZxfYztFQH99UJ+o/LhAJv13n4m9p8ARvUqf7Lt4f9VAK5+6unI/7b/E35/5av//P44fYril/9+/o18F+Oa/5X+rnwI57L/PP+Jff/qy//k/0N+sO3d/1UArn7u6TkDFQjHffLmCAPUBGR9SeOqAqMBsny74DUC4f8ZfCDhAwKKADN8Z+RqAlID63y359ECGAZ+fe7pPwMUCMd9zufH/3H9qX2D58X/Zf2bfWnmwf85/WF9O+W9/wn9IX0Y5bz/A/0afSvmv/8t/VR9PufB/1f9jX3O58L/bf2pffDXswDgD4Z4Z9h0AJQN9XgS2CwATwsVeVrX2v8ICvR4Fdev/30K03h41/z/egzEeN3XSQB1Dq148Ne2AN8Phnjj3B4AtfsDe8HeIADm+4l7ut8gAAD8zHus3yIA/vvIexrfIwDv+6F7X94kANz7bnul3SUAyPs6e+PcJQC0+wN7jtR4ACMVh3Zj1xQAJhSzd0zZs/82E3t4xNlm/8EStHgF2VD/BBNseHfXq//SE8h37dUGAJ4UHXeN1HoAIhWHdlbVrwEQ91V4kdafASD3xHjw1poBJPfleJLWngEf98V4ItakARn3nnjs1acBFveLeLbVqQEU93d4VtWuAQ/3VXj+V7zGSjmaLdJRm8AQPGotjktnu+4+0SyGRkq4mEFTLIxDArcsQ4EsAEOSt/5DAC2iQhW4d0SkLQFCMbjTRC8ulDtCF7wWhGxHKLEbeBpMczEQgCNDGgt3EP29KqkU1XbG9ogtTRAmdir6QCrDEIN3kP3pJjIRsniW/U0l/Q5/eR0IsBEw00524AP9HNnVQ3UdATApGda1cV4AyC/p1mhvLwDJLcfY6XCCAL0kvdsgddQAcxvw3pB4QwFtEyLhr3rMBw7WGfP8dzIDE+Q/8OB71fZq9Dru5H356uD8aO8ffUTjcPqL8cN7jN308mby03kH2IzrVfMxdyrTbec+86V0gjtfWy/nRD4tPQ1YYejMQWA/XlTc6ftELUHlUeLql0Y/QWJSkurbRTY/y1Uy6SNDEz0RWdvnUUCDO19bL+dEPsbfQhJQ+VZ6K+JNEpr59Hpo5FUS3vl8e4TlVxIA+rt7/ORTEvD5nXsW40sSt/kuezHhQhJ++bZ6xd89ElP5V3pEBd2jMfYmWD4G8KPk8ZRXXgdgpGztHVclCOCks+rxVgkI6aRy6yxXBQdwpGnvm1f/BQ+kZfPzV0QF4KMx9ilYHP7TAzDtiX5N/eIDXOoRfm788gNR53t93vv8A13lEH3/+/kDz+Upfcj86wOK6Lp9kP3bA0jrOn4b/tEDLe2IflUNSare8ORcYw6tqh7unFyaDy2rM+tCXHAQjKtc6QZcTRB/q9DpHFwzDwSrbOxyXBYOlKoL77xcVQ1Iqt3w41wx/UMGVN5Me4z9RwZG4RJ81/1KBrzjqXz2/UsGwOTjfOH9SgYJ5Lp8ov1IBvzhP3xj/UQG8d+7ezH9QwZU3kx79h6e9TECvntzICv24gFpez4in/aIAfd6iSPU9koBnnpcI7P2VgGoerYhTfapARZ7DiDm9fsBfXv2Hpj1MAK9e9gnXg979TR40yOQD372hXlMILgPYfeNerEeyQ/J9/t6oB+/D473vHqcIpwPzvbkeZMldw8Q9vh42CdaD371NXhUHFosVxTkcm0boix+Fcty7BrCLM4WnHL2GrYssBdwckIbliyHF3NynBt/LFgWo3L2G2gsKBXQclQcWyxVFORyRS0E3joGoXLhKuTdiAWLc+sozd33BEB0KCjE3b8EhHTAKMrd7ARPdF4q3d1lBbtz+ivx3d0FIXNELQPePQahcv53+g+m+RopynVaDuL6ty8ncbsLO/t5OmJsNgeV+n1DIGgIB0P2dkmSZqQJy/LNSt5kPQxY7wlMwWWMDgPxyUoBL1wMKQVMdtA2hAnRCdtyzkM6BrYK2mudUJADNAcYYytcQwE4B4NYKWaB/44G1UypbsH9zAUGQLd0Fv+CBT4047ki+kAKbmpcv4b7JArrbY7E5vnvC49w1sj39hUQBHL7yND2cRAGcvbB1vffDqpuL7vl+D4N32rpsvj3Ig+7ZLx8D+0rFLEH8nlL5Z8W9BAydRjh9BnvHxZvW98hHSQu7mkE4SUeZDk3aEPnKx24P/hlou0LHLlFfGeW9r8bZUUbLAoGUgP1d008OQBd95Jw7UsX+tzucGV0WUf3Qep/WC9kivi36NFLX2yO+cvsBkE6c6X6HPFvNQB54fh99gMoUKiaCunqNFqZpY0JrvDLWM6n7Qc89cpbHK6BBYL47mF1t0oDlfpEafe/PQQ392Zu6MgpBejzyHK8x5sHAO9zcTj7lNSf/k14ePpd1oEC4ni8+0TWigbAeDr7GdZSCmh4K/nG1cULEHgo9DnWbwr0dybvttYoCaB3eei+2KwHSnevAZwBQwD6fzwB0QLm//Z/tQABBI7/7n/9/+cE4v7mf1H/vgVu/tt/bP83Bm7+1n/X/9gFmf7bf3AA/wSh/uR/NQHRA5D+7X+7AdUB9f74fy0Ct/+///p/QwIj/pkA9n+7AfH8awHxfw0BtvsZAud/qwCz+r0C238LAf751gLSf0oB+fmgAtJ/aQGa+qAC2X+fAfj7hwLmf/MB7v0mAvJ/DgKd/54B+H+vAZwBQwD6f/EB9gIrAu5/CwGWBUcB3X8BAOcHTgDAf5L+UgkO/6V/Pv1gCiz+iH95/Z4KHf6Ef0/+wQkf/pl/fv9/CB3+s38GAQcHuv3HfxEC8APB/eZ/8ALU/07+838aAzX85f/nfw4Cnfn4Ac5/tgBd92gDqH/2/9H1XASEf7oAavVpBHt/PQFu9k4Ej395AS33YgScf94Btfg8BLR/ggKd+1sE0n+0ApH+aQTif/EB9gIrAu5/hAOoAokC5X+eAmAF/gHXf5QBzAdUAb5/JQBeCUYAp3/R/oYKif+Ofwv/xQqC/4p/4v/qCWf/nH8RAawIO/+yf5oCRAep/sJ/pAMyBEj+3X+DBA0ATP7of64EQPxn/9t/oQNp+R8BxX9JAv/2QgKjf4kBVvUBA4J/TALv9P8Cdn/QAvT1BwOJfwsDrvYzA5R/cQM4+EEDrH8VBBb7wAPIf0cEAv4wBNd/hAOoAokC5X+SB3z8if+5f28HGvvQ/q5/iwgT+WH/hX+1CdX3P/9df30MwPYxAA1/Rg7j9jcB3X6yDdn3HAAAf/8MUvgUABp/kwr7+GABXH8RCe36tQGQf5IIgv3SAK9/tAa0/l0Cy3+dB/4Bof6/f/oFIASi/8p/2ASMBYD/yH9NBCoG+P7Ff8sFiQWC/r1/fwYqBen9tn/tBbMEXPy4f3AFTALv/NN/AQbP/0P903+SB3z8if+5fx+4oM3TtV04+reVzZ62LTndt3vNkbckOsS3XM2EuBU7qrdOzTK5ujuJt2nNRLm+O2y3s82AuO46dbcHzgG3ZjnPtyLOM7WVN4m4182SswU2cLlDzXGyDTUkur3M6LGvNFy6jMzasbU0KbqwzAey2TTbufPMK7LoNK+5Is0jss00pbk3zfyxnTScuUTN8bGLNHu5TM1Astw0OLlQzQ2zsDXJuGHNTbTwNh+4oM3TtV04UcZ8DREiO2z9yYcOaSQ4bXLOqRAfJcdu7dIwE9gkXXB+1mEVKSSPcXvYRhbYIoFy2Nj1FK0fynOj1yoRqRl6da3UwQtzEZd2YdBgBlwJRHZWzDECqwMHdTLKFf8gASF0Zcpw/BgBK3QVzBH6UQLSdNjNYfjYA3N1ms4w+OEFrXUbziz6OwlddZ7MKf7bDWV0lMomA8USv3KUyPEHYBe0cArHnQsqHIBuUcZ8DREiO2x9+D8Me5vtTfP4ChCPoHhT4vl5Ezem6Vjg+h4WSKs5XXn7mhebrtFfPPv1F9OvvWD9+XEXeq+BYBz4KxZmrsNfavYTFBOt7l6r9SkRVqviXSn2qg2eqABcqffoCYikmFio+SoGYp98U6L70wIemk5NJ/1uALWVQEfc/Vj/oZJ0QnL9gf/0kJo/z/uVALeQFz9l+WACAJISQU336QSwlAtFu/Y6CCKYw0l9+D8Me5vtTaICJApT8bh+igKqDFbxf37AAqENM/FgfgoDew3/8Fx+LgOeDMvwbH4MA0ALjfCGfrkCVwkk8KN+kwLiBnbvtn4WAzEEk+6yfl8E5AGo7ZZ++gV7ANrsan4wB/v/NOxAfn0HAAC56yh+1gYbAHXrJ36aBTMAbes1fjMEmwCR60l+/AKoAQLsYX5uAiwDnex1fuMChAQN7Xl+8gN7BXPtd35MBNwGa+6GfqICJApT8bh+IctKzAzmMWXGDDMV2QocffavAwZQ70xiQLHxBWvvW2NitMYFre/PZTe4kAUB8JxogbthBU3w2WrovE0FbfDBa4u8UgVl8IZrkLtgBU7w4mobunUFLPDpaVK4jgUE8K9oW7aqBdjvR2datMYFrO/JZXGy4QWD705kwbD4BWDv82JnrwsGRe/UYYKuFwYz7xJhL64bBizvymBerhkGMO/zYM6uEwY571NhVa8MBkPvxWHGrwYGTO8kYvavAwZP70tiZqkv/lf0gl2cqjj+kPSkXo6tTP4a9UhhLLFm/sL1T2RKtHv+Uva9Zp61hP6P9rpnR7WC/n/2eWdYtHv+VPbHZvaycv4V9rhlRbFm/sf1Y2Rqr1n+cfXeYoatTP4Z9UJhuqtA/sX0ql8kqjT+evQ1XuCoK/4+9AJdCqgm/hf0Mly8pyP+CPTmW+inJf4Q9BFcUago/iT0eFzPqCv+O/TyXDmpLv5P9FhdZqkv/lf0gl3HrOUElvDlXwqu2QSz8P5gGLG6BPrwi2PXtJQEVPF2ZhC4cwSk8ctob7llBMbxvmkVuWkEvvGAaR64cwSl8dVosLaCBILx0WfxtJMEV/GJZgWzpwQo8RJlELG6BPnwhWMzr80EzvD7YY2t3QSo8JJgPazqBInwaV9dq/IEd/CgXgyr9QRw8FZeOqv0BHTwgF6oq/AEffDjXius6wSH8FpfmaznBJHwvF/IrOUElPDlX6Cudf9T9Bti5q93/4b0LGP+sn3/A/WlZcm2hP+b9XhoCrqJ/x32umpsu4z/VfakaxG7i/9G9mhrGLqK/x/2w2qnuIf/5vXIaeO2hP+f9Yto8rSA/1H1IWf3sn3/AfWfZRSxef+19CJkaK92/3L0w2ITrnT/PPSiYTGtcv8Z9N9g36xy/wz0l2ANrXL/E/S/YHytc/8l9CBhAa50/zr0k2FxrnX/S/TzYaCudf9R9BtimagWADz4L13RqR0AYPhTXsisLgC1+PpgbbBCAB35BGSQs1MAdvl1Zue0WwCc+XRnjrRZAJL5M2ees1QAd/l/ZjmyTABQ+W9lhrBDACD5GGSnrjgA6viRYsCsLgC0+PNg8aojAID4Wl9YqRoAUvjjXRKoEgAt+K9cOqcOABT43lvspgwAC/iSWxinDQAR+L1bgqcPAB34JFwBqBEALPifXGyoFAA5+AVdmKgVAD/4L10KrJkAevYkYE2tlgCZ9jxhW7CQAOf2yWMctIkARvezZlW3gwCY9whptLiAALv3+mlauIEAsve9aWO3gwCZ9xJp9bWFAHX3Dmg1tIkASPfGZkmyjAAY91BlVLCQAOb2w2N2rpQAt/Y5YtCslwCN9tFgf6uaAGz2qF+gqpsAVvbfXk+qnABO9pVefaqcAFL2v17qqpsAXfYiX26rmgBq9phf3KuZAHX2+18KrJkAe/YkYNajkvtQ/atY/qSn+3z93VnQp9v75f2nXEurGvxj/t1fTK5P/M3+c2KUr2b8+f6CY0CvYPzu/j1jWa5Q/M/+fmIDrTn8oP5eYWOrG/xm/vJfmqn7+yb+VV7Jp9r75P2gXBGmu/uk/fJajKSf+2v9aFlXo4n7Pf0lWIqievsf/UpXQKJ1+xP9+lZqonj7Gv0nV86if/sp/ZNXR6OI+zv9FFiso4/7S/1/WNajkftR/atYaaSvA8T1v1iUpaEDy/XxWW6ofwPf9bxc8atVA/n18l/6rjADEvaJYkWwIQMd9phj8K8lAxr2U2MHrzADE/aUYq6tQAMH9nNhCaxUA/r1CGA8qmkD7PVqXmeofwPf9bVcqaaUA9L1BlsgpacDyPV8WeijtQPB9ThYGaO/A7z1XVfOosMDuvUNV/iiwQO79TtXXqO8A771p1fXo7YDwPUnWD6ksQPD9ZJYaaSvA8T1v1h2Vd7ElzsULfJV5sTlOWQuiFZzxWE5pC5IVlnFBTotLnVWicXwOTAuzFabxc84CS9OVv3EuzhDLxRW5sRZOdAuuVXPxG86AC7SVObD8jrXLRlUKMNFO8ctRFPnwlY9Niw8UaTAaT20LPtQJcDBPFotGU9Hvi49by2qTeq8gD17LdpNOr3fPR4t105Wvh4+sCzgT5W/iD4ULO9R4sGrPmkr81Osw0U9Eyx2Vd7ElzsULVUy9wvMDGB0TDKOD/IFhHRjMpMQEgVhdPAxARG6A4906jDNEO8CC3WvMIoPDwJVdRMx2A3VA1d10jJVCzUKe3TKNPoIJA9Ec7A2TgdAETNyxzUDBtgUG3JVMiEE1BqDctss0wGaI3VyLygzAB8q/nG3Jn3/0ix4cf0oyv6DLvlvECte/m0uOW/YKwf/qiptcJ4s6QAoJGNy8C5kBCAb3nMjMf4IFBGadFUy9wvMDGB09xmtC/mpZlroGXkNfqe7V44cHRCppHVTzh50Ebih/06UHroPaZ+gTL8fbA68notLdSANDkmfBEylHyQN9J9cTXIe1QzAo1lSIxwaC62sVVxhG4sIjrUXZF8cZQZfuANmVx04BNK2vmQiHy4EErXnYroe2QO9swViSx26A7qx4GAeHW8Ena8mX/gc+gM8rShdSxwkBKGr6FsPHIAH2azfXMMagQmRrbZd9xmtC/mpZloMApjfzwHMe9EBEeBYAO97ygMi5Ib6wHxZCO7mzvS9fK4Nl+Tp6nl60Q7q49zqLnrjDgTkSutFehcN/OGn51F5Qw3B4mbupXqdChLjjO3aeskF9OIA7RB7CwVB41/tOXv8BlriW/BVezAI3OOn8/t7/wji4hn11numCEPgrvdre5AGeN99+XJ7qgZ83Xn7/npdBgrcaP6qeqgJAuCa/Yl7wgAf4DEB9HsMApjfzwHMewo37lOs+S5P8jb2U8n5OU+1NgpUDvpST2k2I1Rm+nJPIzY6VLf6kE/1NUlU6/qjT+81TFTz+qVP7zVNVPP6o0/vNU1U8/qjT+81TVTz+qNP7zVNVPP6o0/vNU1U8/qjT+81TFTz+qRP7zVMVPP6pU/vNUtU8/qlT+81S1Ty+qVP7zVLVPL6pU8MNkJU0fqZT1M2K1SA+nxPpzYPVB/6WU/tNvhTzvk7Two37lOs+S5PxPKiEqj85X0Q8qESkPzRfVfwnhJY/Jx9MO6aEhD8UX0w7JYSzvsCfenqlBKk+8x8ueqUEp77w3y06pQSnfvDfKvqlBKc+8F8n+qUEpv7v3yR6pQSmfu9fIPqkxKX+7p8deqTEpb7uHxo6pMSlPu1fF3qkxKT+7N8VuqTEpL7snxU6pMSkfuyfDPrlRKu+9l8Su2YEvP7L33J750SRfyKfeLxoBKL/Mx9xPKiEqj85X2fJeeurr0wP/UlO68RvcE+xyYLsJO7rT3LJxmxu7lNPLgoHLILuP46TinGsvq2JjpXKdGy6bYYOvwoaLKQt506Viivsb64ijt3J8CwVLrAPHEmtK8wvCA+VyWjrjG+jD89JKGtMcDpQDkjwKwJwh5CYyIPrI7DFkPRIZqrl8S6Q5shcav4xPZDCSLHqzHEfEMMI5msXMJUQjwkoK0zwOpANyWFrmu+tD+fJeeurr0wPyfpmQS1prFY+eiYBB+mDViI6JYEtKR3Vv7nlAT3onBUgOeRBGGhhFIx548EY6BFUSznjwRToDFRXOeQBO6g9VG055IECaJSUyvolQSGoxpVt+iXBEmlIFdO6ZkEMqc5WeXpmgQdqT1bcOqbBOSqBl3j6psEXqx1XjLrmwRgrWhfT+ubBL+twF8U65sE/awLX4nqmwQ1q1Vd5emaBB+pPltf6ZkEaqd0WSfpmQS1prFY1SqEucm6NEU4K925ObrBRCcsu7rduKNDTy3YuzG3NUJeLui8qbXYQAovmL2ztPU/FC+jvaS05z+sLje9OrVyQO4tdrxLtmpB7yx6u7u3rULEK1+6bbkbRIMqO7lAu5RFQSknuBS9/0YZKDS3xL5ASCQnc7YpwEBJfib0tRzB6klAJsa1dcEoSr0mJba/wKlJ5ScKtxC/d0hAKSa4Fr0AR14qG7l1u75F1SqEucm6NUWB9iUFRamDXW32HwWhqOdcO/YPBROnZlv/9fsEKaV6Wcf15wRqo6ZXpfXaBFGidlaj9doEQKJjVrj14gTroh5X3vXvBCOkalgT9gEFx6UcWlD2FgW3pwdckvYrBc+pA17U9j8F6KvqXxH3UAXYrZlhRPdeBXOv8WJm92cFi7DVY3P3awXysChkWfdkBSCwfmMc91MFL67jYdT2PwXpq+tfmfYtBQuqO16B9iYFRamDXfxTWPkP5xNdmVRm+dvmeFwVVov5YOb3WulXuvnI5QtZk1nm+T7lNlefWgP65uQGVrBaBfrh5PNVDFrz+RblrlbjWNT5d+X6V1JXq/n55axZeFV8+ZPml1t5U0v5OeeTXXhRHPne53tfnk/y+HfoKmEVTtH49uiCYglNuvhM6WZjpkyy+GzpuWNvTcP4K+kQY0pP6/iS6HRhdlEc+d/nfF8/U0b5S+fMXfxTV/kO5xNdj1YyC5Lp5VosVxwLa+lHWqlY5woN6cBYfVqjCpvozVYoXGIKMujyVDRdOArx579TRF01Cuznq1OhXE8KFehoVHdbfQpe6LlV5lm5CsDocVcMWP0KNOljWQxWQwux6WhbCVSHCzDqV10uUsMLpOoOX6RQ9AsF62xgl08UDEfrVWE0Tx8MYOupYf5PCAwu6/xg2lHOC7nqWV8IVIcLMOpYXdJVSwvA6aFbj1YxC5Hp5VphX2YisROYS/RfMiK9E/NKVWGvIdkTW0kGYwkh/BNTR49kayAZFGZFhGUEICsUKESUZf4fLBQURP5kPCAhFNhE7GOtIA0UNEZ6YkAh8RP9R8Rg5iHOEwRK516RIqcTIUwHXTUjfhMpTkpbxiNXE/lP11k5JDUTbVHbWIUkHhNlUn1YoSQVE79SO1loJCcTB1L7Wt8jTxNJUAZdNiN+EytOsV6kIqITXExiX2YisBOYSy9eqOXVFaJPvF7P5QMW+04QYDHmcxZcTbFhr+b9Fk1LK2Mn53sXWkkXZHXnyhcXSCZkeufPFwJIlmNK554XyUiPYvXmRxcqSithhubQFvpLhF8J5kUWCU65XYflrxUtUOtbC+UZFTxSPVqe5I4UElTYWEfkHBSKVeRXDuTOE4RWilf547ET31ZBWCTk6xMlVvFZi+R2FGNU6VsL5RgVPlKFXXnlnhVpUC9eqOXVFaJPhXUm/I/9gzLOb7r9FQBFPhpvOf6gAns/D3IT/JMGkzkmcqr8hgkGOd9yDf47Cas3lXVD/SwKdTHSd4H6ogsjK6N1yvn2CQ8xQXfh+jcGyy3Ke1b8YgQKIJx/I/5FAn4JX4Du/zsCawkDgQ//FgjTDd+BfgDNBq4UgoJBAiQEvhiDgigCQgTDGGGB/ACxBBMSOoB1AC4ESQZjfxQAbPzxC4V7Jf9M/4ghhXUm/I/9gzJfaTX2TfU0R41gn/Z2+lJTAktu8mX+0GbPKO7xywB/eAgXIfPTAD99oBFo+G8Bin52DGn5BgE3f2MMNPqwAEN/kCkW/NIB/Hj3Oh3+ggSAcZQ51v8OBD5ytyYnAn8A+3kpEq0Eu/6cfgEZLQSi/XB9khvOBIL82nxMKzAFr/tDeCU85gBN++JwrE3J++n5d2W2XF/21vUhV81odPiT9VlIoG27+fT1AUFfaTX2TfU0R/iq0AHp+oVf6qzp+30I6GCVsub/lv/tZUi5rf+t/69qmrgM/8wAOWqIt+D+vQB/aVm57f5sALlqWr9jAoP5QW7lwBwCDPoub56t6QI6+Jth0aOiApv4dFgRo4sBi/rVV7W4AQDj/UhqksVQ/o8B3HEKwNn+7ADcbuu7m/1CA1BsEbpT/LcF/WoOtDD82gXLZhuu6/ocCOdhGai+/Z4C+VzOppP/N//MW/iq0AHp+oVfHXzkBVMIlB1If58DbAs2Bv+Blf878AoQ0IR/AarrIhz8hXMDle3UIWyFdQWD8W8hIIQlBVPytRxMgiYE4/NwFKqA1gPK9QYHtX7B+3sIdA90eND7VwhGKqNwkv3+CBQ87mtuAL0HXkR4aiUEeQW3Rm9tMAU/BflBsG+jBJ8FGT6acOQEvwVkPBJzRQVdBnI3AnItBtkGcjmzcgkGawjcN1135AZpCOksHXzkBVMIlB1rOPT7CwPHcsQkaveVAkZ65wui76ECXH6oB9Hs0AQ6froSU/EzAr99HChD/UkDeXl3P1X7XQMBb5ZR+QAQA5JiqmFaAHEBuFJrbH7/bf8IRAVv3P+7/7I/bGgSATUBAErtWVkCtAEKW31CRgNuAVBtniCsB04BhntiDFIB+P9kfygJ4vvsAJl/BAkv/OUAnn+rIbr8ZgFwe3w2X/3Q/8pz4Dza/pkAlnBrOPT7CwPHcvWpiP8gAMJe2K6b/63/+mJWyY8Fa/QFc9XXqQiS7dB3LtYHBzLwunej0l4GMvGZdlzKjgSp9JJzGcPvA0/1AHBWutYBufkua4e1zwDT+wNoP7gUAP79+WkXv2L//f9RbmTB/P6cAKJvLMTw/qMAJnHoyCb/HACHc6PInQD2/FxzMsaJAxj3zHHXxTUDC/iycVPGkv7vAT1yZrjW/W0DBGqRqxb++QIiYPWpiP8gAMJeBQYqA/T9zX8FBpsC7v7Tf6YFkgOM/9J/wgW7BcEAvH8HBrUFrQC6f4UEVwPt/99/LgPkA8n/5n+gAlIGAgDQf28C6wZUAMl/jgOTBh0Ax38cBFkGcf/Ff3kEQgaG/b5/qAX8AwH8v3/3B4IA5fqlf8oJLQA++4h/jQjdAET8p38/ByIBD/3BfxsHpAEv/cJ/7gZVAof9w38MB1cDm/y3f0gGeQTO+7J/BQYqA/T9zX8xaAu8R404veLAIzwsZgy8KVA4vWLFJDzNDA281xE4vajjJTwAyw68uM03vYcYJzxcBBG8e4Q3vdj8KDxiyxO8uDU3vT2aLDw+BBe8cNs2vXdtMjz/fhq8e2k2vWKfOTzjKh28Pdg1vfSeQDyOtB68Ry81vRmPRjyOgh+8uIg0vRTySzzgcyC8ZgA0vfgAUjw78iG8wqMzvbeGWTxkCiS8UmAzvX1DYjyvLye8cAwzvbkQazyHviq8cIcyvXdZcjw+3S28zdExvUf5djzc0C+86wgxvX4geTwC6TC811EwvXRLejyq5jG8hcQvvf4qfDxXpjK8e2EvvYlcfzwdnjO8KRQvvfTlgTzumjS868kuveVohDwXAzW8pHouvRDihjxT9jS8XDAuvb38iDzpYTS8hfYtvSBkijxwuzO8uM8tvfniijyP0DK8wrUtvWt8ijzA9TG8FKgtvbFxiTw5lTG8pLQtvVsViDycGjG81/EtvbGvhjy50TC8XGouvbt7hTzPHjG8RwUvvc56hDwe7zG8wpMvve9ngzwrFDO8uOovvQb+gTz5jzK81wcwvXadfzwrjjC8RxIwvabweTy2Jy68AEQwvcMHdDyXVSy8HsEwvSAdbzydWSu8CXwxvfaTazz02Cq8pEAyvUfxaDxHMyq8hdsyvb2HZjxGyii81z0zvXljYzzY8Ca8FH4zvT5cXzzpBiW84cQzvdiyWjzZeCO89Ss0vfWKVTwhISK867M0vY34TzxGriC8pEY1vZwsSjxwFR+89co1vRyARDwBPB28PTQ2vcpNPzwKrhq8hYs2vc/KOjxAlBe8KeE2vUECNzz4SBW8Hjo3vQDqMzwruhO8UpE3vedpMTzdbhK8Ct43vdpRLzxxRhG89Rk4vRRPLTy76g+8Ckc4vZQDKzz3Hw68Hmg4vXxAKDxwCAy8ZoM4vRJCJTw/+gq81484vY/DIzzYVWa9FI04vQmFFjzekb284RExvdA/sjwk9pU8CnkbvYidrzwzwk09M+/svIBLBD1cwmg9rvW0vId2RT2s6Ac9XOtuvIpRoz3wOxw8uNbnu9Dn4z309Je8wl3+O3LGHj4QCpu8wiYEvTzumb1ZqwW8AFbAvI5ykb3qSZy7KPBMvCF4d7018zc7wuX3u9KrSb130fw6XCc7vC4JN73QRK66e6yGvIeTDL3mVgq7pFikvI+DyLzi9y+7XH3OvPswx7zK97a6hdoWvSEn5rwumXu7AJkzvWpMMr3v8iq8e8AqvQK4Z71tccy84bIBvXyzf73Yjg+94W6gvGGIhr0ZPCq9CuNHvJ+0m73sUBy9exgmvNiNtL1w3P68R+2bvI4Unb1k9NS8n13uvDdkhb0sLNK8HwwSvepijr0Usbe8K7Ejvbm+kL3vRvq8hdMzvRTImL0bxRe9GJwvvZekmL0QCpu8wiYEvTzumb0=\");\n\n//# sourceURL=webpack:///./assets/boy.glb?");

/***/ }),

/***/ "./node_modules/pepjs/dist/pep.js":
/*!****************************************!*\
  !*** ./node_modules/pepjs/dist/pep.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * PEP v0.5.1 | https://github.com/jquery/PEP\n * Copyright jQuery Foundation and other contributors | http://jquery.org/license\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  /**\n   * This is the constructor for new PointerEvents.\n   *\n   * New Pointer Events must be given a type, and an optional dictionary of\n   * initialization properties.\n   *\n   * Due to certain platform requirements, events returned from the constructor\n   * identify as MouseEvents.\n   *\n   * @constructor\n   * @param {String} inType The type of the event to create.\n   * @param {Object} [inDict] An optional dictionary of initial event properties.\n   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.\n   */\n  var MOUSE_PROPS = [\n    'bubbles',\n    'cancelable',\n    'view',\n    'screenX',\n    'screenY',\n    'clientX',\n    'clientY',\n    'ctrlKey',\n    'altKey',\n    'shiftKey',\n    'metaKey',\n    'button',\n    'relatedTarget',\n    'pageX',\n    'pageY'\n  ];\n\n  var MOUSE_DEFAULTS = [\n    false,\n    false,\n    null,\n    0,\n    0,\n    0,\n    0,\n    false,\n    false,\n    false,\n    false,\n    0,\n    null,\n    0,\n    0\n  ];\n\n  function PointerEvent(inType, inDict) {\n    inDict = inDict || Object.create(null);\n\n    var e = document.createEvent('Event');\n    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);\n\n    // define inherited MouseEvent properties\n    // skip bubbles and cancelable since they're set above in initEvent()\n    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {\n      p = MOUSE_PROPS[i];\n      e[p] = inDict[p] || MOUSE_DEFAULTS[i];\n    }\n    e.buttons = inDict.buttons || 0;\n\n    // Spec requires that pointers without pressure specified use 0.5 for down\n    // state and 0 for up state.\n    var pressure = 0;\n\n    if (inDict.pressure !== undefined && e.buttons) {\n      pressure = inDict.pressure;\n    } else {\n      pressure = e.buttons ? 0.5 : 0;\n    }\n\n    // add x/y properties aliased to clientX/Y\n    e.x = e.clientX;\n    e.y = e.clientY;\n\n    // define the properties of the PointerEvent interface\n    e.pointerId = inDict.pointerId || 0;\n    e.width = inDict.width || 1;\n    e.height = inDict.height || 1;\n    e.pressure = pressure;\n    e.tiltX = inDict.tiltX || 0;\n    e.tiltY = inDict.tiltY || 0;\n    e.twist = inDict.twist || 0;\n    e.tangentialPressure = inDict.tangentialPressure || 0;\n    e.pointerType = inDict.pointerType || '';\n    e.hwTimestamp = inDict.hwTimestamp || 0;\n    e.isPrimary = inDict.isPrimary || false;\n    e.detail = 0;\n    return e;\n  }\n\n  /**\n   * This module implements a map of pointer states\n   */\n  var USE_MAP = window.Map && window.Map.prototype.forEach;\n  var PointerMap = USE_MAP ? Map : SparseArrayMap;\n\n  function SparseArrayMap() {\n    this.array = [];\n    this.size = 0;\n  }\n\n  SparseArrayMap.prototype = {\n    set: function(k, v) {\n      if (v === undefined) {\n        return this.delete(k);\n      }\n      if (!this.has(k)) {\n        this.size++;\n      }\n      this.array[k] = v;\n    },\n    has: function(k) {\n      return this.array[k] !== undefined;\n    },\n    delete: function(k) {\n      if (this.has(k)) {\n        delete this.array[k];\n        this.size--;\n      }\n    },\n    get: function(k) {\n      return this.array[k];\n    },\n    clear: function() {\n      this.array.length = 0;\n      this.size = 0;\n    },\n\n    // return value, key, map\n    forEach: function(callback, thisArg) {\n      return this.array.forEach(function(v, k) {\n        callback.call(thisArg, v, k, this);\n      }, this);\n    }\n  };\n\n  var CLONE_PROPS = [\n\n    // MouseEvent\n    'bubbles',\n    'cancelable',\n    'view',\n    'detail',\n    'screenX',\n    'screenY',\n    'clientX',\n    'clientY',\n    'ctrlKey',\n    'altKey',\n    'shiftKey',\n    'metaKey',\n    'button',\n    'relatedTarget',\n\n    // DOM Level 3\n    'buttons',\n\n    // PointerEvent\n    'pointerId',\n    'width',\n    'height',\n    'pressure',\n    'tiltX',\n    'tiltY',\n    'pointerType',\n    'hwTimestamp',\n    'isPrimary',\n\n    // event instance\n    'type',\n    'target',\n    'currentTarget',\n    'which',\n    'pageX',\n    'pageY',\n    'timeStamp'\n  ];\n\n  var CLONE_DEFAULTS = [\n\n    // MouseEvent\n    false,\n    false,\n    null,\n    null,\n    0,\n    0,\n    0,\n    0,\n    false,\n    false,\n    false,\n    false,\n    0,\n    null,\n\n    // DOM Level 3\n    0,\n\n    // PointerEvent\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    '',\n    0,\n    false,\n\n    // event instance\n    '',\n    null,\n    null,\n    0,\n    0,\n    0,\n    0\n  ];\n\n  var BOUNDARY_EVENTS = {\n    'pointerover': 1,\n    'pointerout': 1,\n    'pointerenter': 1,\n    'pointerleave': 1\n  };\n\n  var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');\n\n  /**\n   * This module is for normalizing events. Mouse and Touch events will be\n   * collected here, and fire PointerEvents that have the same semantics, no\n   * matter the source.\n   * Events fired:\n   *   - pointerdown: a pointing is added\n   *   - pointerup: a pointer is removed\n   *   - pointermove: a pointer is moved\n   *   - pointerover: a pointer crosses into an element\n   *   - pointerout: a pointer leaves an element\n   *   - pointercancel: a pointer will no longer generate events\n   */\n  var dispatcher = {\n    pointermap: new PointerMap(),\n    eventMap: Object.create(null),\n    captureInfo: Object.create(null),\n\n    // Scope objects for native events.\n    // This exists for ease of testing.\n    eventSources: Object.create(null),\n    eventSourceList: [],\n    /**\n     * Add a new event source that will generate pointer events.\n     *\n     * `inSource` must contain an array of event names named `events`, and\n     * functions with the names specified in the `events` array.\n     * @param {string} name A name for the event source\n     * @param {Object} source A new source of platform events.\n     */\n    registerSource: function(name, source) {\n      var s = source;\n      var newEvents = s.events;\n      if (newEvents) {\n        newEvents.forEach(function(e) {\n          if (s[e]) {\n            this.eventMap[e] = s[e].bind(s);\n          }\n        }, this);\n        this.eventSources[name] = s;\n        this.eventSourceList.push(s);\n      }\n    },\n    register: function(element) {\n      var l = this.eventSourceList.length;\n      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {\n\n        // call eventsource register\n        es.register.call(es, element);\n      }\n    },\n    unregister: function(element) {\n      var l = this.eventSourceList.length;\n      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {\n\n        // call eventsource register\n        es.unregister.call(es, element);\n      }\n    },\n    contains: /*scope.external.contains || */function(container, contained) {\n      try {\n        return container.contains(contained);\n      } catch (ex) {\n\n        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n        return false;\n      }\n    },\n\n    // EVENTS\n    down: function(inEvent) {\n      inEvent.bubbles = true;\n      this.fireEvent('pointerdown', inEvent);\n    },\n    move: function(inEvent) {\n      inEvent.bubbles = true;\n      this.fireEvent('pointermove', inEvent);\n    },\n    up: function(inEvent) {\n      inEvent.bubbles = true;\n      this.fireEvent('pointerup', inEvent);\n    },\n    enter: function(inEvent) {\n      inEvent.bubbles = false;\n      this.fireEvent('pointerenter', inEvent);\n    },\n    leave: function(inEvent) {\n      inEvent.bubbles = false;\n      this.fireEvent('pointerleave', inEvent);\n    },\n    over: function(inEvent) {\n      inEvent.bubbles = true;\n      this.fireEvent('pointerover', inEvent);\n    },\n    out: function(inEvent) {\n      inEvent.bubbles = true;\n      this.fireEvent('pointerout', inEvent);\n    },\n    cancel: function(inEvent) {\n      inEvent.bubbles = true;\n      this.fireEvent('pointercancel', inEvent);\n    },\n    leaveOut: function(event) {\n      this.out(event);\n      this.propagate(event, this.leave, false);\n    },\n    enterOver: function(event) {\n      this.over(event);\n      this.propagate(event, this.enter, true);\n    },\n\n    // LISTENER LOGIC\n    eventHandler: function(inEvent) {\n\n      // This is used to prevent multiple dispatch of pointerevents from\n      // platform events. This can happen when two elements in different scopes\n      // are set up to create pointer events, which is relevant to Shadow DOM.\n      if (inEvent._handledByPE) {\n        return;\n      }\n      var type = inEvent.type;\n      var fn = this.eventMap && this.eventMap[type];\n      if (fn) {\n        fn(inEvent);\n      }\n      inEvent._handledByPE = true;\n    },\n\n    // set up event listeners\n    listen: function(target, events) {\n      events.forEach(function(e) {\n        this.addEvent(target, e);\n      }, this);\n    },\n\n    // remove event listeners\n    unlisten: function(target, events) {\n      events.forEach(function(e) {\n        this.removeEvent(target, e);\n      }, this);\n    },\n    addEvent: /*scope.external.addEvent || */function(target, eventName) {\n      target.addEventListener(eventName, this.boundHandler);\n    },\n    removeEvent: /*scope.external.removeEvent || */function(target, eventName) {\n      target.removeEventListener(eventName, this.boundHandler);\n    },\n\n    // EVENT CREATION AND TRACKING\n    /**\n     * Creates a new Event of type `inType`, based on the information in\n     * `inEvent`.\n     *\n     * @param {string} inType A string representing the type of event to create\n     * @param {Event} inEvent A platform event with a target\n     * @return {Event} A PointerEvent of type `inType`\n     */\n    makeEvent: function(inType, inEvent) {\n\n      // relatedTarget must be null if pointer is captured\n      if (this.captureInfo[inEvent.pointerId]) {\n        inEvent.relatedTarget = null;\n      }\n      var e = new PointerEvent(inType, inEvent);\n      if (inEvent.preventDefault) {\n        e.preventDefault = inEvent.preventDefault;\n      }\n      e._target = e._target || inEvent.target;\n      return e;\n    },\n\n    // make and dispatch an event in one call\n    fireEvent: function(inType, inEvent) {\n      var e = this.makeEvent(inType, inEvent);\n      return this.dispatchEvent(e);\n    },\n    /**\n     * Returns a snapshot of inEvent, with writable properties.\n     *\n     * @param {Event} inEvent An event that contains properties to copy.\n     * @return {Object} An object containing shallow copies of `inEvent`'s\n     *    properties.\n     */\n    cloneEvent: function(inEvent) {\n      var eventCopy = Object.create(null);\n      var p;\n      for (var i = 0; i < CLONE_PROPS.length; i++) {\n        p = CLONE_PROPS[i];\n        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];\n\n        // Work around SVGInstanceElement shadow tree\n        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.\n        // This is the behavior implemented by Firefox.\n        if (HAS_SVG_INSTANCE && (p === 'target' || p === 'relatedTarget')) {\n          if (eventCopy[p] instanceof SVGElementInstance) {\n            eventCopy[p] = eventCopy[p].correspondingUseElement;\n          }\n        }\n      }\n\n      // keep the semantics of preventDefault\n      if (inEvent.preventDefault) {\n        eventCopy.preventDefault = function() {\n          inEvent.preventDefault();\n        };\n      }\n      return eventCopy;\n    },\n    getTarget: function(inEvent) {\n      var capture = this.captureInfo[inEvent.pointerId];\n      if (!capture) {\n        return inEvent._target;\n      }\n      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {\n        return capture;\n      }\n    },\n    propagate: function(event, fn, propagateDown) {\n      var target = event.target;\n      var targets = [];\n\n      // Order of conditions due to document.contains() missing in IE.\n      while (target != null && target !== document && !target.contains(event.relatedTarget)) {\n        targets.push(target);\n        target = target.parentNode;\n\n        // Touch: Do not propagate if node is detached.\n        if (!target) {\n          return;\n        }\n      }\n      if (propagateDown) {\n        targets.reverse();\n      }\n      targets.forEach(function(target) {\n        event.target = target;\n        fn.call(this, event);\n      }, this);\n    },\n    setCapture: function(inPointerId, inTarget, skipDispatch) {\n      if (this.captureInfo[inPointerId]) {\n        this.releaseCapture(inPointerId, skipDispatch);\n      }\n\n      this.captureInfo[inPointerId] = inTarget;\n      this.implicitRelease = this.releaseCapture.bind(this, inPointerId, skipDispatch);\n      document.addEventListener('pointerup', this.implicitRelease);\n      document.addEventListener('pointercancel', this.implicitRelease);\n\n      var e = new PointerEvent('gotpointercapture', { bubbles: true });\n      e.pointerId = inPointerId;\n      e._target = inTarget;\n\n      if (!skipDispatch) {\n        this.asyncDispatchEvent(e);\n      }\n    },\n    releaseCapture: function(inPointerId, skipDispatch) {\n      var t = this.captureInfo[inPointerId];\n      if (!t) {\n        return;\n      }\n\n      this.captureInfo[inPointerId] = undefined;\n      document.removeEventListener('pointerup', this.implicitRelease);\n      document.removeEventListener('pointercancel', this.implicitRelease);\n\n      var e = new PointerEvent('lostpointercapture', { bubbles: true });\n      e.pointerId = inPointerId;\n      e._target = t;\n\n      if (!skipDispatch) {\n        this.asyncDispatchEvent(e);\n      }\n    },\n    /**\n     * Dispatches the event to its target.\n     *\n     * @param {Event} inEvent The event to be dispatched.\n     * @return {Boolean} True if an event handler returns true, false otherwise.\n     */\n    dispatchEvent: /*scope.external.dispatchEvent || */function(inEvent) {\n      var t = this.getTarget(inEvent);\n      if (t) {\n        return t.dispatchEvent(inEvent);\n      }\n    },\n    asyncDispatchEvent: function(inEvent) {\n      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));\n    }\n  };\n  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);\n\n  var targeting = {\n    shadow: function(inEl) {\n      if (inEl) {\n        return inEl.shadowRoot || inEl.webkitShadowRoot;\n      }\n    },\n    canTarget: function(shadow) {\n      return shadow && Boolean(shadow.elementFromPoint);\n    },\n    targetingShadow: function(inEl) {\n      var s = this.shadow(inEl);\n      if (this.canTarget(s)) {\n        return s;\n      }\n    },\n    olderShadow: function(shadow) {\n      var os = shadow.olderShadowRoot;\n      if (!os) {\n        var se = shadow.querySelector('shadow');\n        if (se) {\n          os = se.olderShadowRoot;\n        }\n      }\n      return os;\n    },\n    allShadows: function(element) {\n      var shadows = [];\n      var s = this.shadow(element);\n      while (s) {\n        shadows.push(s);\n        s = this.olderShadow(s);\n      }\n      return shadows;\n    },\n    searchRoot: function(inRoot, x, y) {\n      if (inRoot) {\n        var t = inRoot.elementFromPoint(x, y);\n        var st, sr;\n\n        // is element a shadow host?\n        sr = this.targetingShadow(t);\n        while (sr) {\n\n          // find the the element inside the shadow root\n          st = sr.elementFromPoint(x, y);\n          if (!st) {\n\n            // check for older shadows\n            sr = this.olderShadow(sr);\n          } else {\n\n            // shadowed element may contain a shadow root\n            var ssr = this.targetingShadow(st);\n            return this.searchRoot(ssr, x, y) || st;\n          }\n        }\n\n        // light dom element is the target\n        return t;\n      }\n    },\n    owner: function(element) {\n      var s = element;\n\n      // walk up until you hit the shadow root or document\n      while (s.parentNode) {\n        s = s.parentNode;\n      }\n\n      // the owner element is expected to be a Document or ShadowRoot\n      if (s.nodeType !== Node.DOCUMENT_NODE && s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n        s = document;\n      }\n      return s;\n    },\n    findTarget: function(inEvent) {\n      var x = inEvent.clientX;\n      var y = inEvent.clientY;\n\n      // if the listener is in the shadow root, it is much faster to start there\n      var s = this.owner(inEvent.target);\n\n      // if x, y is not in this root, fall back to document search\n      if (!s.elementFromPoint(x, y)) {\n        s = document;\n      }\n      return this.searchRoot(s, x, y);\n    }\n  };\n\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n  var map = Array.prototype.map.call.bind(Array.prototype.map);\n  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);\n  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);\n  var MO = window.MutationObserver || window.WebKitMutationObserver;\n  var SELECTOR = '[touch-action]';\n  var OBSERVER_INIT = {\n    subtree: true,\n    childList: true,\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: ['touch-action']\n  };\n\n  function Installer(add, remove, changed, binder) {\n    this.addCallback = add.bind(binder);\n    this.removeCallback = remove.bind(binder);\n    this.changedCallback = changed.bind(binder);\n    if (MO) {\n      this.observer = new MO(this.mutationWatcher.bind(this));\n    }\n  }\n\n  Installer.prototype = {\n    watchSubtree: function(target) {\n\n      // Only watch scopes that can target find, as these are top-level.\n      // Otherwise we can see duplicate additions and removals that add noise.\n      //\n      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see\n      // a removal without an insertion when a node is redistributed among\n      // shadows. Since it all ends up correct in the document, watching only\n      // the document will yield the correct mutations to watch.\n      if (this.observer && targeting.canTarget(target)) {\n        this.observer.observe(target, OBSERVER_INIT);\n      }\n    },\n    enableOnSubtree: function(target) {\n      this.watchSubtree(target);\n      if (target === document && document.readyState !== 'complete') {\n        this.installOnLoad();\n      } else {\n        this.installNewSubtree(target);\n      }\n    },\n    installNewSubtree: function(target) {\n      forEach(this.findElements(target), this.addElement, this);\n    },\n    findElements: function(target) {\n      if (target.querySelectorAll) {\n        return target.querySelectorAll(SELECTOR);\n      }\n      return [];\n    },\n    removeElement: function(el) {\n      this.removeCallback(el);\n    },\n    addElement: function(el) {\n      this.addCallback(el);\n    },\n    elementChanged: function(el, oldValue) {\n      this.changedCallback(el, oldValue);\n    },\n    concatLists: function(accum, list) {\n      return accum.concat(toArray(list));\n    },\n\n    // register all touch-action = none nodes on document load\n    installOnLoad: function() {\n      document.addEventListener('readystatechange', function() {\n        if (document.readyState === 'complete') {\n          this.installNewSubtree(document);\n        }\n      }.bind(this));\n    },\n    isElement: function(n) {\n      return n.nodeType === Node.ELEMENT_NODE;\n    },\n    flattenMutationTree: function(inNodes) {\n\n      // find children with touch-action\n      var tree = map(inNodes, this.findElements, this);\n\n      // make sure the added nodes are accounted for\n      tree.push(filter(inNodes, this.isElement));\n\n      // flatten the list\n      return tree.reduce(this.concatLists, []);\n    },\n    mutationWatcher: function(mutations) {\n      mutations.forEach(this.mutationHandler, this);\n    },\n    mutationHandler: function(m) {\n      if (m.type === 'childList') {\n        var added = this.flattenMutationTree(m.addedNodes);\n        added.forEach(this.addElement, this);\n        var removed = this.flattenMutationTree(m.removedNodes);\n        removed.forEach(this.removeElement, this);\n      } else if (m.type === 'attributes') {\n        this.elementChanged(m.target, m.oldValue);\n      }\n    }\n  };\n\n  function shadowSelector(s) {\n    return 'body /shadow-deep/ ' + s;\n  }\n  function rule(v) {\n    return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + '; }';\n  }\n  var attrib2css = [\n    { selector: '[touch-action=\"none\"]', value: 'none' },\n    { selector: '[touch-action=\"auto\"]', value: 'auto' },\n    { selector: '[touch-action~=\"pan-x\"]', value: 'pan-x' },\n    { selector: '[touch-action~=\"pan-y\"]', value: 'pan-y' },\n    { selector: '[touch-action~=\"pan-up\"]', value: 'pan-up' },\n    { selector: '[touch-action~=\"pan-down\"]', value: 'pan-down' },\n    { selector: '[touch-action~=\"pan-left\"]', value: 'pan-left' },\n    { selector: '[touch-action~=\"pan-right\"]', value: 'pan-right' }\n  ];\n  var styles = '';\n\n  // only install stylesheet if the browser has touch action support\n  var hasNativePE = window.PointerEvent || window.MSPointerEvent;\n\n  // only add shadow selectors if shadowdom is supported\n  var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;\n\n  function applyAttributeStyles() {\n    if (hasNativePE) {\n      attrib2css.forEach(function(r) {\n        styles += r.selector + rule(r.value) + '\\n';\n        if (hasShadowRoot) {\n          styles += shadowSelector(r.selector) + rule(r.value) + '\\n';\n        }\n      });\n\n      var el = document.createElement('style');\n      el.textContent = styles;\n      document.head.appendChild(el);\n    }\n  }\n\n  var pointermap = dispatcher.pointermap;\n\n  // radius around touchend that swallows mouse events\n  var DEDUP_DIST = 25;\n\n  // left, middle, right, back, forward\n  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];\n\n  var HAS_BUTTONS = false;\n  try {\n    HAS_BUTTONS = new MouseEvent('test', { buttons: 1 }).buttons === 1;\n  } catch (e) {}\n\n  // handler block for native mouse events\n  var mouseEvents = {\n    POINTER_ID: 1,\n    POINTER_TYPE: 'mouse',\n    events: [\n      'mousedown',\n      'webkitmouseforcechanged',\n      'mousemove',\n      'mouseup',\n      'mouseover',\n      'mouseout'\n    ],\n    register: function(target) {\n      dispatcher.listen(target, this.events);\n    },\n    unregister: function(target) {\n      dispatcher.unlisten(target, this.events);\n    },\n    lastTouches: [],\n\n    // collide with the global mouse listener\n    isEventSimulatedFromTouch: function(inEvent) {\n      var lts = this.lastTouches;\n      var x = inEvent.clientX;\n      var y = inEvent.clientY;\n      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {\n\n        // simulated mouse events will be swallowed near a primary touchend\n        var dx = Math.abs(x - t.x);\n        var dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {\n          return true;\n        }\n      }\n    },\n    prepareEvent: function(inEvent) {\n      var e = dispatcher.cloneEvent(inEvent);\n\n      // forward mouse preventDefault\n      var pd = e.preventDefault;\n      e.preventDefault = function() {\n        inEvent.preventDefault();\n        pd();\n      };\n      e.pointerId = this.POINTER_ID;\n      e.isPrimary = true;\n      e.pointerType = this.POINTER_TYPE;\n      if ('webkitForce' in inEvent) {\n        e.pressure = inEvent.webkitForce - MouseEvent.WEBKIT_FORCE_AT_MOUSE_DOWN;\n      }\n      return e;\n    },\n    prepareButtonsForMove: function(e, inEvent) {\n      var p = pointermap.get(this.POINTER_ID);\n\n      // Update buttons state after possible out-of-document mouseup.\n      if (inEvent.which === 0 || !p) {\n        e.buttons = 0;\n      } else {\n        e.buttons = p.buttons;\n      }\n      inEvent.buttons = e.buttons;\n    },\n    mousedown: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var p = pointermap.get(this.POINTER_ID);\n        var e = this.prepareEvent(inEvent);\n        if (!HAS_BUTTONS) {\n          e.buttons = BUTTON_TO_BUTTONS[e.button];\n          if (p) { e.buttons |= p.buttons; }\n          inEvent.buttons = e.buttons;\n        }\n        pointermap.set(this.POINTER_ID, inEvent);\n        if (!p || p.buttons === 0) {\n          dispatcher.down(e);\n        } else {\n          dispatcher.move(e);\n        }\n      }\n    },\n\n    // This is called when the user force presses without moving x/y\n    webkitmouseforcechanged: function(inEvent) {\n      this.mousemove(inEvent);\n    },\n    mousemove: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var e = this.prepareEvent(inEvent);\n        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }\n        e.button = -1;\n        pointermap.set(this.POINTER_ID, inEvent);\n        dispatcher.move(e);\n      }\n    },\n    mouseup: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var p = pointermap.get(this.POINTER_ID);\n        var e = this.prepareEvent(inEvent);\n        if (!HAS_BUTTONS) {\n          var up = BUTTON_TO_BUTTONS[e.button];\n\n          // Produces wrong state of buttons in Browsers without `buttons` support\n          // when a mouse button that was pressed outside the document is released\n          // inside and other buttons are still pressed down.\n          e.buttons = p ? p.buttons & ~up : 0;\n          inEvent.buttons = e.buttons;\n        }\n        pointermap.set(this.POINTER_ID, inEvent);\n\n        // Support: Firefox <=44 only\n        // FF Ubuntu includes the lifted button in the `buttons` property on\n        // mouseup.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366\n        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];\n        if (e.buttons === 0) {\n          dispatcher.up(e);\n        } else {\n          dispatcher.move(e);\n        }\n      }\n    },\n    mouseover: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var e = this.prepareEvent(inEvent);\n        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }\n        e.button = -1;\n        pointermap.set(this.POINTER_ID, inEvent);\n        dispatcher.enterOver(e);\n      }\n    },\n    mouseout: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var e = this.prepareEvent(inEvent);\n        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }\n        e.button = -1;\n        dispatcher.leaveOut(e);\n      }\n    },\n    cancel: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      dispatcher.cancel(e);\n      this.deactivateMouse();\n    },\n    deactivateMouse: function() {\n      pointermap.delete(this.POINTER_ID);\n    }\n  };\n\n  var captureInfo = dispatcher.captureInfo;\n  var findTarget = targeting.findTarget.bind(targeting);\n  var allShadows = targeting.allShadows.bind(targeting);\n  var pointermap$1 = dispatcher.pointermap;\n\n  // this should be long enough to ignore compat mouse events made by touch\n  var DEDUP_TIMEOUT = 2500;\n  var ATTRIB = 'touch-action';\n  var INSTALLER;\n\n  // bitmask for _scrollType\n  var UP = 1;\n  var DOWN = 2;\n  var LEFT = 4;\n  var RIGHT = 8;\n  var AUTO = UP | DOWN | LEFT | RIGHT;\n\n  // handler block for native touch events\n  var touchEvents = {\n    events: [\n      'touchstart',\n      'touchmove',\n      'touchforcechange',\n      'touchend',\n      'touchcancel'\n    ],\n    register: function(target) {\n      INSTALLER.enableOnSubtree(target);\n    },\n    unregister: function() {\n\n      // TODO(dfreedman): is it worth it to disconnect the MO?\n    },\n    elementAdded: function(el) {\n      var a = el.getAttribute(ATTRIB);\n      var st = this.touchActionToScrollType(a);\n      if (typeof st === \"number\") {\n        el._scrollType = st;\n        dispatcher.listen(el, this.events);\n\n        // set touch-action on shadows as well\n        allShadows(el).forEach(function(s) {\n          s._scrollType = st;\n          dispatcher.listen(s, this.events);\n        }, this);\n      }\n    },\n    elementRemoved: function(el) {\n\n      // In some cases, an element is removed before a touchend.\n      // When this is the case, we should wait for the touchend before unlistening,\n      // because we still want pointer events to bubble up after removing from DOM.\n      if (pointermap$1.size > 0) {\n        var evts = this.events;\n        el.addEventListener('touchend', function() {\n          el._scrollType = undefined;\n          dispatcher.unlisten(el, evts);\n        });\n      } else {\n        el._scrollType = undefined;\n        dispatcher.unlisten(el, this.events);\n      }\n\n      // remove touch-action from shadow\n      allShadows(el).forEach(function(s) {\n        s._scrollType = undefined;\n        dispatcher.unlisten(s, this.events);\n      }, this);\n    },\n    elementChanged: function(el, oldValue) {\n      var a = el.getAttribute(ATTRIB);\n      var st = this.touchActionToScrollType(a);\n      var oldSt = this.touchActionToScrollType(oldValue);\n\n      // simply update scrollType if listeners are already established\n      if (typeof st === \"number\" && typeof oldSt === \"number\") {\n        el._scrollType = st;\n        allShadows(el).forEach(function(s) {\n          s._scrollType = st;\n        }, this);\n      } else if (typeof oldSt === \"number\") {\n        this.elementRemoved(el);\n      } else if (typeof st === \"number\") {\n        this.elementAdded(el);\n      }\n    },\n    scrollTypes: {\n      UP: function(s) {\n        return s.includes('pan-y') || s.includes('pan-up') ? UP : 0;\n      },\n      DOWN: function(s) {\n        return s.includes('pan-y') || s.includes('pan-down') ? DOWN : 0;\n      },\n      LEFT: function(s) {\n        return s.includes('pan-x') || s.includes('pan-left') ? LEFT : 0;\n      },\n      RIGHT: function(s) {\n        return s.includes('pan-x') || s.includes('pan-right') ? RIGHT : 0;\n      }\n    },\n    touchActionToScrollType: function(touchAction) {\n      if (!touchAction) {\n        return;\n      }\n\n      if (touchAction === \"auto\") {\n        return AUTO;\n      }\n\n      if (touchAction === \"none\") {\n        return 0;\n      }\n\n      var s = touchAction.split(' ');\n      var st = this.scrollTypes;\n\n      // construct a bitmask of allowed scroll directions\n      return st.UP(s) | st.DOWN(s) | st.LEFT(s) | st.RIGHT(s);\n    },\n    POINTER_TYPE: 'touch',\n    firstTouch: null,\n    isPrimaryTouch: function(inTouch) {\n      return this.firstTouch === inTouch.identifier;\n    },\n    setPrimaryTouch: function(inTouch) {\n\n      // set primary touch if there no pointers, or the only pointer is the mouse\n      if (pointermap$1.size === 0 || (pointermap$1.size === 1 && pointermap$1.has(1))) {\n        this.firstTouch = inTouch.identifier;\n        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };\n        this.scrolling = false;\n      }\n    },\n    removePrimaryPointer: function(inPointer) {\n      if (inPointer.isPrimary) {\n        this.firstTouch = null;\n        this.firstXY = null;\n      }\n    },\n    typeToButtons: function(type) {\n      var ret = 0;\n      if (type === 'touchstart' || type === 'touchmove' || type === 'touchforcechange') {\n        ret = 1;\n      }\n      return ret;\n    },\n    touchToPointer: function(inTouch) {\n      var cte = this.currentTouchEvent;\n      var e = dispatcher.cloneEvent(inTouch);\n\n      // We reserve pointerId 1 for Mouse.\n      // Touch identifiers can start at 0.\n      // Add 2 to the touch identifier for compatibility.\n      var id = e.pointerId = inTouch.identifier + 2;\n      e.target = captureInfo[id] || findTarget(e);\n      e.bubbles = true;\n      e.cancelable = true;\n      e.button = 0;\n      e.buttons = this.typeToButtons(cte.type);\n      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;\n      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;\n      e.pressure = inTouch.force !== undefined ?\n        inTouch.force :\n        inTouch.webkitForce !== undefined ?\n          inTouch.webkitForce : undefined;\n      e.isPrimary = this.isPrimaryTouch(inTouch);\n      if (inTouch.altitudeAngle) {\n        var tan = Math.tan(inTouch.altitudeAngle);\n        var radToDeg = 180 / Math.PI;\n        e.tiltX = Math.atan(Math.cos(inTouch.azimuthAngle) / tan) * radToDeg;\n        e.tiltY = Math.atan(Math.sin(inTouch.azimuthAngle) / tan) * radToDeg;\n      } else {\n        e.tiltX = 0;\n        e.tiltY = 0;\n      }\n      if (inTouch.touchType === 'stylus') {\n        e.pointerType = 'pen';\n      } else {\n        e.pointerType = this.POINTER_TYPE;\n      }\n\n      // forward modifier keys\n      e.altKey = cte.altKey;\n      e.ctrlKey = cte.ctrlKey;\n      e.metaKey = cte.metaKey;\n      e.shiftKey = cte.shiftKey;\n\n      // forward touch preventDefaults\n      var self = this;\n      e.preventDefault = function() {\n        self.scrolling = false;\n        self.firstXY = null;\n        cte.preventDefault();\n      };\n      return e;\n    },\n    processTouches: function(inEvent, inFunction) {\n      var tl = inEvent.changedTouches;\n      this.currentTouchEvent = inEvent;\n      for (var i = 0, t; i < tl.length; i++) {\n        t = tl[i];\n        inFunction.call(this, this.touchToPointer(t));\n      }\n    },\n\n    // For single axis scrollers, determines whether the element should emit\n    // pointer events or behave as a scroller\n    shouldScroll: function(inEvent) {\n      if (this.firstXY) {\n        var ret;\n        var st = inEvent.currentTarget._scrollType;\n        if (st === 0) {\n\n          // this element is a `touch-action: none`, should never scroll\n          ret = false;\n        } else if (st === AUTO) {\n\n          // this element is a `touch-action: auto`, should always scroll\n          ret = true;\n        } else {\n          var t = inEvent.changedTouches[0];\n\n          var dy = t.clientY - this.firstXY.Y;\n          var dya = Math.abs(dy);\n          var dx = t.clientX - this.firstXY.X;\n          var dxa = Math.abs(dx);\n\n          var up = st & UP;\n          var down = st & DOWN;\n          var left = st & LEFT;\n          var right = st & RIGHT;\n\n          if (left && right) {\n\n            // should scroll on the x axis\n            ret = dxa > dya;\n          } else if (left) {\n\n            // should scroll left\n            ret = dxa > dya && dx > 0;\n          } else if (right) {\n\n            // should scroll right\n            ret = dxa > dya && dx < 0;\n          }\n\n          if (!ret) {\n            if (up && down) {\n\n              // should scroll on the y axis\n              ret = dxa < dya;\n            } else if (up) {\n\n              // should scroll up\n              ret = dxa < dya && dy > 0;\n            } else if (down) {\n\n              // should scroll down\n              ret = dxa < dya && dy < 0;\n            }\n          }\n\n        }\n        this.firstXY = null;\n        return ret;\n      }\n    },\n    findTouch: function(inTL, inId) {\n      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {\n        if (t.identifier === inId) {\n          return true;\n        }\n      }\n    },\n\n    // In some instances, a touchstart can happen without a touchend. This\n    // leaves the pointermap in a broken state.\n    // Therefore, on every touchstart, we remove the touches that did not fire a\n    // touchend event.\n    // To keep state globally consistent, we fire a\n    // pointercancel for this \"abandoned\" touch\n    vacuumTouches: function(inEvent) {\n      var tl = inEvent.touches;\n\n      // pointermap.size should be < tl.length here, as the touchstart has not\n      // been processed yet.\n      if (pointermap$1.size >= tl.length) {\n        var d = [];\n        pointermap$1.forEach(function(value, key) {\n\n          // Never remove pointerId == 1, which is mouse.\n          // Touch identifiers are 2 smaller than their pointerId, which is the\n          // index in pointermap.\n          if (key !== 1 && !this.findTouch(tl, key - 2)) {\n            var p = value.out;\n            d.push(p);\n          }\n        }, this);\n        d.forEach(this.cancelOut, this);\n      }\n    },\n    touchstart: function(inEvent) {\n      this.vacuumTouches(inEvent);\n      this.setPrimaryTouch(inEvent.changedTouches[0]);\n      this.dedupSynthMouse(inEvent);\n      if (!this.scrolling) {\n        this.processTouches(inEvent, this.overDown);\n      }\n    },\n    overDown: function(inPointer) {\n      pointermap$1.set(inPointer.pointerId, {\n        target: inPointer.target,\n        out: inPointer,\n        outTarget: inPointer.target\n      });\n      dispatcher.enterOver(inPointer);\n      dispatcher.down(inPointer);\n    },\n\n    // Called when pressure or tilt changes without the x/y changing\n    touchforcechange: function(inEvent) {\n      this.touchmove(inEvent);\n    },\n    touchmove: function(inEvent) {\n      if (!this.scrolling) {\n        if (this.shouldScroll(inEvent)) {\n          this.scrolling = true;\n          this.touchcancel(inEvent);\n        } else {\n          if (inEvent.type !== 'touchforcechange') {\n            inEvent.preventDefault();\n          }\n          this.processTouches(inEvent, this.moveOverOut);\n        }\n      }\n    },\n    moveOverOut: function(inPointer) {\n      var event = inPointer;\n      var pointer = pointermap$1.get(event.pointerId);\n\n      // a finger drifted off the screen, ignore it\n      if (!pointer) {\n        return;\n      }\n      var outEvent = pointer.out;\n      var outTarget = pointer.outTarget;\n      dispatcher.move(event);\n      if (outEvent && outTarget !== event.target) {\n        outEvent.relatedTarget = event.target;\n        event.relatedTarget = outTarget;\n\n        // recover from retargeting by shadow\n        outEvent.target = outTarget;\n        if (event.target) {\n          dispatcher.leaveOut(outEvent);\n          dispatcher.enterOver(event);\n        } else {\n\n          // clean up case when finger leaves the screen\n          event.target = outTarget;\n          event.relatedTarget = null;\n          this.cancelOut(event);\n        }\n      }\n      pointer.out = event;\n      pointer.outTarget = event.target;\n    },\n    touchend: function(inEvent) {\n      this.dedupSynthMouse(inEvent);\n      this.processTouches(inEvent, this.upOut);\n    },\n    upOut: function(inPointer) {\n      if (!this.scrolling) {\n        dispatcher.up(inPointer);\n        dispatcher.leaveOut(inPointer);\n      }\n      this.cleanUpPointer(inPointer);\n    },\n    touchcancel: function(inEvent) {\n      this.processTouches(inEvent, this.cancelOut);\n    },\n    cancelOut: function(inPointer) {\n      dispatcher.cancel(inPointer);\n      dispatcher.leaveOut(inPointer);\n      this.cleanUpPointer(inPointer);\n    },\n    cleanUpPointer: function(inPointer) {\n      pointermap$1.delete(inPointer.pointerId);\n      this.removePrimaryPointer(inPointer);\n    },\n\n    // prevent synth mouse events from creating pointer events\n    dedupSynthMouse: function(inEvent) {\n      var lts = mouseEvents.lastTouches;\n      var t = inEvent.changedTouches[0];\n\n      // only the primary finger will synth mouse events\n      if (this.isPrimaryTouch(t)) {\n\n        // remember x/y of last touch\n        var lt = { x: t.clientX, y: t.clientY };\n        lts.push(lt);\n        var fn = (function(lts, lt) {\n          var i = lts.indexOf(lt);\n          if (i > -1) {\n            lts.splice(i, 1);\n          }\n        }).bind(null, lts, lt);\n        setTimeout(fn, DEDUP_TIMEOUT);\n      }\n    }\n  };\n\n  INSTALLER = new Installer(touchEvents.elementAdded, touchEvents.elementRemoved,\n    touchEvents.elementChanged, touchEvents);\n\n  var pointermap$2 = dispatcher.pointermap;\n  var HAS_BITMAP_TYPE = window.MSPointerEvent &&\n    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';\n  var msEvents = {\n    events: [\n      'MSPointerDown',\n      'MSPointerMove',\n      'MSPointerUp',\n      'MSPointerOut',\n      'MSPointerOver',\n      'MSPointerCancel',\n      'MSGotPointerCapture',\n      'MSLostPointerCapture'\n    ],\n    register: function(target) {\n      dispatcher.listen(target, this.events);\n    },\n    unregister: function(target) {\n      dispatcher.unlisten(target, this.events);\n    },\n    POINTER_TYPES: [\n      '',\n      'unavailable',\n      'touch',\n      'pen',\n      'mouse'\n    ],\n    prepareEvent: function(inEvent) {\n      var e = inEvent;\n      if (HAS_BITMAP_TYPE) {\n        e = dispatcher.cloneEvent(inEvent);\n        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];\n      }\n      return e;\n    },\n    cleanup: function(id) {\n      pointermap$2.delete(id);\n    },\n    MSPointerDown: function(inEvent) {\n      pointermap$2.set(inEvent.pointerId, inEvent);\n      var e = this.prepareEvent(inEvent);\n      dispatcher.down(e);\n    },\n    MSPointerMove: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      dispatcher.move(e);\n    },\n    MSPointerUp: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      dispatcher.up(e);\n      this.cleanup(inEvent.pointerId);\n    },\n    MSPointerOut: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      dispatcher.leaveOut(e);\n    },\n    MSPointerOver: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      dispatcher.enterOver(e);\n    },\n    MSPointerCancel: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      dispatcher.cancel(e);\n      this.cleanup(inEvent.pointerId);\n    },\n    MSLostPointerCapture: function(inEvent) {\n      var e = dispatcher.makeEvent('lostpointercapture', inEvent);\n      dispatcher.dispatchEvent(e);\n    },\n    MSGotPointerCapture: function(inEvent) {\n      var e = dispatcher.makeEvent('gotpointercapture', inEvent);\n      dispatcher.dispatchEvent(e);\n    }\n  };\n\n  function applyPolyfill() {\n\n    // only activate if this platform does not have pointer events\n    if (!window.PointerEvent) {\n      window.PointerEvent = PointerEvent;\n\n      if (window.navigator.msPointerEnabled) {\n        var tp = window.navigator.msMaxTouchPoints;\n        Object.defineProperty(window.navigator, 'maxTouchPoints', {\n          value: tp,\n          enumerable: true\n        });\n        dispatcher.registerSource('ms', msEvents);\n      } else {\n        Object.defineProperty(window.navigator, 'maxTouchPoints', {\n          value: 0,\n          enumerable: true\n        });\n        dispatcher.registerSource('mouse', mouseEvents);\n        if (window.ontouchstart !== undefined) {\n          dispatcher.registerSource('touch', touchEvents);\n        }\n      }\n\n      dispatcher.register(document);\n    }\n  }\n\n  var n = window.navigator;\n  var s;\n  var r;\n  var h;\n  function assertActive(id) {\n    if (!dispatcher.pointermap.has(id)) {\n      var error = new Error('NotFoundError');\n      error.name = 'NotFoundError';\n      throw error;\n    }\n  }\n  function assertConnected(elem) {\n    var parent = elem.parentNode;\n    while (parent && parent !== elem.ownerDocument) {\n      parent = parent.parentNode;\n    }\n    if (!parent) {\n      var error = new Error('InvalidStateError');\n      error.name = 'InvalidStateError';\n      throw error;\n    }\n  }\n  function inActiveButtonState(id) {\n    var p = dispatcher.pointermap.get(id);\n    return p.buttons !== 0;\n  }\n  if (n.msPointerEnabled) {\n    s = function(pointerId) {\n      assertActive(pointerId);\n      assertConnected(this);\n      if (inActiveButtonState(pointerId)) {\n        dispatcher.setCapture(pointerId, this, true);\n        this.msSetPointerCapture(pointerId);\n      }\n    };\n    r = function(pointerId) {\n      assertActive(pointerId);\n      dispatcher.releaseCapture(pointerId, true);\n      this.msReleasePointerCapture(pointerId);\n    };\n  } else {\n    s = function setPointerCapture(pointerId) {\n      assertActive(pointerId);\n      assertConnected(this);\n      if (inActiveButtonState(pointerId)) {\n        dispatcher.setCapture(pointerId, this);\n      }\n    };\n    r = function releasePointerCapture(pointerId) {\n      assertActive(pointerId);\n      dispatcher.releaseCapture(pointerId);\n    };\n  }\n  h = function hasPointerCapture(pointerId) {\n    return !!dispatcher.captureInfo[pointerId];\n  };\n\n  function applyPolyfill$1() {\n    if (window.Element && !window.Element.prototype.setPointerCapture) {\n      Object.defineProperties(window.Element.prototype, {\n        'setPointerCapture': {\n          value: s\n        },\n        'releasePointerCapture': {\n          value: r\n        },\n        'hasPointerCapture': {\n          value: h\n        }\n      });\n    }\n  }\n\n  applyAttributeStyles();\n  applyPolyfill();\n  applyPolyfill$1();\n\n  var pointerevents = {\n    dispatcher: dispatcher,\n    Installer: Installer,\n    PointerEvent: PointerEvent,\n    PointerMap: PointerMap,\n    targetFinding: targeting\n  };\n\n  return pointerevents;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/pepjs/dist/pep.js?");

/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, FaceColors, FileLoader, FlatShading, Float16BufferAttribute, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GammaEncoding, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGL1Renderer, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ACESFilmicToneMapping\", function() { return ACESFilmicToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddEquation\", function() { return AddEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddOperation\", function() { return AddOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AdditiveAnimationBlendMode\", function() { return AdditiveAnimationBlendMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AdditiveBlending\", function() { return AdditiveBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlphaFormat\", function() { return AlphaFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlwaysDepth\", function() { return AlwaysDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlwaysStencilFunc\", function() { return AlwaysStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AmbientLight\", function() { return AmbientLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AmbientLightProbe\", function() { return AmbientLightProbe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationClip\", function() { return AnimationClip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationLoader\", function() { return AnimationLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationMixer\", function() { return AnimationMixer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationObjectGroup\", function() { return AnimationObjectGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationUtils\", function() { return AnimationUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcCurve\", function() { return ArcCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayCamera\", function() { return ArrayCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrowHelper\", function() { return ArrowHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Audio\", function() { return Audio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioAnalyser\", function() { return AudioAnalyser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioContext\", function() { return AudioContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioListener\", function() { return AudioListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioLoader\", function() { return AudioLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AxesHelper\", function() { return AxesHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AxisHelper\", function() { return AxisHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BackSide\", function() { return BackSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicDepthPacking\", function() { return BasicDepthPacking; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicShadowMap\", function() { return BasicShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryTextureLoader\", function() { return BinaryTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bone\", function() { return Bone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanKeyframeTrack\", function() { return BooleanKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundingBoxHelper\", function() { return BoundingBoxHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box2\", function() { return Box2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box3\", function() { return Box3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box3Helper\", function() { return Box3Helper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxBufferGeometry\", function() { return BoxGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxGeometry\", function() { return BoxGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxHelper\", function() { return BoxHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferAttribute\", function() { return BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferGeometry\", function() { return BufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferGeometryLoader\", function() { return BufferGeometryLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ByteType\", function() { return ByteType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cache\", function() { return Cache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CameraHelper\", function() { return CameraHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasRenderer\", function() { return CanvasRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasTexture\", function() { return CanvasTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CatmullRomCurve3\", function() { return CatmullRomCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CineonToneMapping\", function() { return CineonToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CircleBufferGeometry\", function() { return CircleGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CircleGeometry\", function() { return CircleGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClampToEdgeWrapping\", function() { return ClampToEdgeWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clock\", function() { return Clock; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorKeyframeTrack\", function() { return ColorKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompressedTexture\", function() { return CompressedTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompressedTextureLoader\", function() { return CompressedTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConeBufferGeometry\", function() { return ConeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConeGeometry\", function() { return ConeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeCamera\", function() { return CubeCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeReflectionMapping\", function() { return CubeReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeRefractionMapping\", function() { return CubeRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeTexture\", function() { return CubeTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeTextureLoader\", function() { return CubeTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeUVReflectionMapping\", function() { return CubeUVReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeUVRefractionMapping\", function() { return CubeUVRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicBezierCurve\", function() { return CubicBezierCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicBezierCurve3\", function() { return CubicBezierCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicInterpolant\", function() { return CubicInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceBack\", function() { return CullFaceBack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceFront\", function() { return CullFaceFront; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceFrontBack\", function() { return CullFaceFrontBack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceNone\", function() { return CullFaceNone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Curve\", function() { return Curve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CurvePath\", function() { return CurvePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CustomBlending\", function() { return CustomBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CustomToneMapping\", function() { return CustomToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CylinderBufferGeometry\", function() { return CylinderGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CylinderGeometry\", function() { return CylinderGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cylindrical\", function() { return Cylindrical; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture\", function() { return DataTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture2DArray\", function() { return DataTexture2DArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture3D\", function() { return DataTexture3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTextureLoader\", function() { return DataTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataUtils\", function() { return DataUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DecrementStencilOp\", function() { return DecrementStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DecrementWrapStencilOp\", function() { return DecrementWrapStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultLoadingManager\", function() { return DefaultLoadingManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthFormat\", function() { return DepthFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthStencilFormat\", function() { return DepthStencilFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthTexture\", function() { return DepthTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLight\", function() { return DirectionalLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLightHelper\", function() { return DirectionalLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscreteInterpolant\", function() { return DiscreteInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DodecahedronBufferGeometry\", function() { return DodecahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DodecahedronGeometry\", function() { return DodecahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DoubleSide\", function() { return DoubleSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DstAlphaFactor\", function() { return DstAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DstColorFactor\", function() { return DstColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DynamicBufferAttribute\", function() { return DynamicBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DynamicCopyUsage\", function() { return DynamicCopyUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DynamicDrawUsage\", function() { return DynamicDrawUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DynamicReadUsage\", function() { return DynamicReadUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgesGeometry\", function() { return EdgesGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgesHelper\", function() { return EdgesHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EllipseCurve\", function() { return EllipseCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EqualDepth\", function() { return EqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EqualStencilFunc\", function() { return EqualStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquirectangularReflectionMapping\", function() { return EquirectangularReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquirectangularRefractionMapping\", function() { return EquirectangularRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Euler\", function() { return Euler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcher\", function() { return EventDispatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudeBufferGeometry\", function() { return ExtrudeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudeGeometry\", function() { return ExtrudeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FaceColors\", function() { return FaceColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FileLoader\", function() { return FileLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlatShading\", function() { return FlatShading; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float16BufferAttribute\", function() { return Float16BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float32Attribute\", function() { return Float32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float32BufferAttribute\", function() { return Float32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float64Attribute\", function() { return Float64Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float64BufferAttribute\", function() { return Float64BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FloatType\", function() { return FloatType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fog\", function() { return Fog; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FogExp2\", function() { return FogExp2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Font\", function() { return Font; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FontLoader\", function() { return FontLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrontSide\", function() { return FrontSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Frustum\", function() { return Frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GLBufferAttribute\", function() { return GLBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GLSL1\", function() { return GLSL1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GLSL3\", function() { return GLSL3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GammaEncoding\", function() { return GammaEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterDepth\", function() { return GreaterDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterEqualDepth\", function() { return GreaterEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterEqualStencilFunc\", function() { return GreaterEqualStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterStencilFunc\", function() { return GreaterStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GridHelper\", function() { return GridHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Group\", function() { return Group; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HalfFloatType\", function() { return HalfFloatType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLight\", function() { return HemisphereLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLightHelper\", function() { return HemisphereLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLightProbe\", function() { return HemisphereLightProbe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IcosahedronBufferGeometry\", function() { return IcosahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IcosahedronGeometry\", function() { return IcosahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageBitmapLoader\", function() { return ImageBitmapLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageLoader\", function() { return ImageLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageUtils\", function() { return ImageUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImmediateRenderObject\", function() { return ImmediateRenderObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IncrementStencilOp\", function() { return IncrementStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IncrementWrapStencilOp\", function() { return IncrementWrapStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedBufferAttribute\", function() { return InstancedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedBufferGeometry\", function() { return InstancedBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedInterleavedBuffer\", function() { return InstancedInterleavedBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedMesh\", function() { return InstancedMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int16Attribute\", function() { return Int16Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int16BufferAttribute\", function() { return Int16BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int32Attribute\", function() { return Int32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int32BufferAttribute\", function() { return Int32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int8Attribute\", function() { return Int8Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int8BufferAttribute\", function() { return Int8BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntType\", function() { return IntType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterleavedBuffer\", function() { return InterleavedBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterleavedBufferAttribute\", function() { return InterleavedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interpolant\", function() { return Interpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateDiscrete\", function() { return InterpolateDiscrete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateLinear\", function() { return InterpolateLinear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateSmooth\", function() { return InterpolateSmooth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvertStencilOp\", function() { return InvertStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSONLoader\", function() { return JSONLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeepStencilOp\", function() { return KeepStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyframeTrack\", function() { return KeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOD\", function() { return LOD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatheBufferGeometry\", function() { return LatheGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatheGeometry\", function() { return LatheGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layers\", function() { return Layers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LensFlare\", function() { return LensFlare; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessDepth\", function() { return LessDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessEqualDepth\", function() { return LessEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessEqualStencilFunc\", function() { return LessEqualStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessStencilFunc\", function() { return LessStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Light\", function() { return Light; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightProbe\", function() { return LightProbe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line3\", function() { return Line3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineBasicMaterial\", function() { return LineBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCurve\", function() { return LineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCurve3\", function() { return LineCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineDashedMaterial\", function() { return LineDashedMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineLoop\", function() { return LineLoop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinePieces\", function() { return LinePieces; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineSegments\", function() { return LineSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineStrip\", function() { return LineStrip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearEncoding\", function() { return LinearEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearFilter\", function() { return LinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearInterpolant\", function() { return LinearInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipMapLinearFilter\", function() { return LinearMipMapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipMapNearestFilter\", function() { return LinearMipMapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipmapLinearFilter\", function() { return LinearMipmapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipmapNearestFilter\", function() { return LinearMipmapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearToneMapping\", function() { return LinearToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Loader\", function() { return Loader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoaderUtils\", function() { return LoaderUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadingManager\", function() { return LoadingManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogLuvEncoding\", function() { return LogLuvEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopOnce\", function() { return LoopOnce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopPingPong\", function() { return LoopPingPong; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopRepeat\", function() { return LoopRepeat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LuminanceAlphaFormat\", function() { return LuminanceAlphaFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LuminanceFormat\", function() { return LuminanceFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MOUSE\", function() { return MOUSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Material\", function() { return Material; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaterialLoader\", function() { return MaterialLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Math\", function() { return MathUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MathUtils\", function() { return MathUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix3\", function() { return Matrix3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix4\", function() { return Matrix4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaxEquation\", function() { return MaxEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshBasicMaterial\", function() { return MeshBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshDepthMaterial\", function() { return MeshDepthMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshDistanceMaterial\", function() { return MeshDistanceMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshFaceMaterial\", function() { return MeshFaceMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshLambertMaterial\", function() { return MeshLambertMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshMatcapMaterial\", function() { return MeshMatcapMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshNormalMaterial\", function() { return MeshNormalMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshPhongMaterial\", function() { return MeshPhongMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshPhysicalMaterial\", function() { return MeshPhysicalMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshStandardMaterial\", function() { return MeshStandardMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshToonMaterial\", function() { return MeshToonMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MinEquation\", function() { return MinEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MirroredRepeatWrapping\", function() { return MirroredRepeatWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MixOperation\", function() { return MixOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiMaterial\", function() { return MultiMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiplyBlending\", function() { return MultiplyBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiplyOperation\", function() { return MultiplyOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestFilter\", function() { return NearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipMapLinearFilter\", function() { return NearestMipMapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipMapNearestFilter\", function() { return NearestMipMapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipmapLinearFilter\", function() { return NearestMipmapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipmapNearestFilter\", function() { return NearestMipmapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NeverDepth\", function() { return NeverDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NeverStencilFunc\", function() { return NeverStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoBlending\", function() { return NoBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoColors\", function() { return NoColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoToneMapping\", function() { return NoToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NormalAnimationBlendMode\", function() { return NormalAnimationBlendMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NormalBlending\", function() { return NormalBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotEqualDepth\", function() { return NotEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotEqualStencilFunc\", function() { return NotEqualStencilFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NumberKeyframeTrack\", function() { return NumberKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Object3D\", function() { return Object3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectLoader\", function() { return ObjectLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectSpaceNormalMap\", function() { return ObjectSpaceNormalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OctahedronBufferGeometry\", function() { return OctahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OctahedronGeometry\", function() { return OctahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneFactor\", function() { return OneFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusDstAlphaFactor\", function() { return OneMinusDstAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusDstColorFactor\", function() { return OneMinusDstColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusSrcAlphaFactor\", function() { return OneMinusSrcAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusSrcColorFactor\", function() { return OneMinusSrcColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OrthographicCamera\", function() { return OrthographicCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PCFShadowMap\", function() { return PCFShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PCFSoftShadowMap\", function() { return PCFSoftShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PMREMGenerator\", function() { return PMREMGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParametricBufferGeometry\", function() { return ParametricGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParametricGeometry\", function() { return ParametricGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Particle\", function() { return Particle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleBasicMaterial\", function() { return ParticleBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleSystem\", function() { return ParticleSystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleSystemMaterial\", function() { return ParticleSystemMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path\", function() { return Path; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PerspectiveCamera\", function() { return PerspectiveCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneBufferGeometry\", function() { return PlaneGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneGeometry\", function() { return PlaneGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneHelper\", function() { return PlaneHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloud\", function() { return PointCloud; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloudMaterial\", function() { return PointCloudMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointLight\", function() { return PointLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointLightHelper\", function() { return PointLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Points\", function() { return Points; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointsMaterial\", function() { return PointsMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolarGridHelper\", function() { return PolarGridHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolyhedronBufferGeometry\", function() { return PolyhedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolyhedronGeometry\", function() { return PolyhedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionalAudio\", function() { return PositionalAudio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyBinding\", function() { return PropertyBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyMixer\", function() { return PropertyMixer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuadraticBezierCurve\", function() { return QuadraticBezierCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuadraticBezierCurve3\", function() { return QuadraticBezierCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return Quaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuaternionKeyframeTrack\", function() { return QuaternionKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuaternionLinearInterpolant\", function() { return QuaternionLinearInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REVISION\", function() { return REVISION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBADepthPacking\", function() { return RGBADepthPacking; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBAFormat\", function() { return RGBAFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBAIntegerFormat\", function() { return RGBAIntegerFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x10_Format\", function() { return RGBA_ASTC_10x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x5_Format\", function() { return RGBA_ASTC_10x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x6_Format\", function() { return RGBA_ASTC_10x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x8_Format\", function() { return RGBA_ASTC_10x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_12x10_Format\", function() { return RGBA_ASTC_12x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_12x12_Format\", function() { return RGBA_ASTC_12x12_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_4x4_Format\", function() { return RGBA_ASTC_4x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_5x4_Format\", function() { return RGBA_ASTC_5x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_5x5_Format\", function() { return RGBA_ASTC_5x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_6x5_Format\", function() { return RGBA_ASTC_6x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_6x6_Format\", function() { return RGBA_ASTC_6x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x5_Format\", function() { return RGBA_ASTC_8x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x6_Format\", function() { return RGBA_ASTC_8x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x8_Format\", function() { return RGBA_ASTC_8x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_BPTC_Format\", function() { return RGBA_BPTC_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ETC2_EAC_Format\", function() { return RGBA_ETC2_EAC_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_PVRTC_2BPPV1_Format\", function() { return RGBA_PVRTC_2BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_PVRTC_4BPPV1_Format\", function() { return RGBA_PVRTC_4BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT1_Format\", function() { return RGBA_S3TC_DXT1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT3_Format\", function() { return RGBA_S3TC_DXT3_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT5_Format\", function() { return RGBA_S3TC_DXT5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBDEncoding\", function() { return RGBDEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBEEncoding\", function() { return RGBEEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBEFormat\", function() { return RGBEFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBFormat\", function() { return RGBFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBIntegerFormat\", function() { return RGBIntegerFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBM16Encoding\", function() { return RGBM16Encoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBM7Encoding\", function() { return RGBM7Encoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_ETC1_Format\", function() { return RGB_ETC1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_ETC2_Format\", function() { return RGB_ETC2_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_PVRTC_2BPPV1_Format\", function() { return RGB_PVRTC_2BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_PVRTC_4BPPV1_Format\", function() { return RGB_PVRTC_4BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_S3TC_DXT1_Format\", function() { return RGB_S3TC_DXT1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGFormat\", function() { return RGFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGIntegerFormat\", function() { return RGIntegerFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RawShaderMaterial\", function() { return RawShaderMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ray\", function() { return Ray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Raycaster\", function() { return Raycaster; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectAreaLight\", function() { return RectAreaLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedFormat\", function() { return RedFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedIntegerFormat\", function() { return RedIntegerFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReinhardToneMapping\", function() { return ReinhardToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepeatWrapping\", function() { return RepeatWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReplaceStencilOp\", function() { return ReplaceStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReverseSubtractEquation\", function() { return ReverseSubtractEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RingBufferGeometry\", function() { return RingGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RingGeometry\", function() { return RingGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_10x10_Format\", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_10x5_Format\", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_10x6_Format\", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_10x8_Format\", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_12x10_Format\", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_12x12_Format\", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_4x4_Format\", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_5x4_Format\", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_5x5_Format\", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_6x5_Format\", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_6x6_Format\", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_8x5_Format\", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_8x6_Format\", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SRGB8_ALPHA8_ASTC_8x8_Format\", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SceneUtils\", function() { return SceneUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderChunk\", function() { return ShaderChunk; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderLib\", function() { return ShaderLib; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderMaterial\", function() { return ShaderMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShadowMaterial\", function() { return ShadowMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shape\", function() { return Shape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeBufferGeometry\", function() { return ShapeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeGeometry\", function() { return ShapeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapePath\", function() { return ShapePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeUtils\", function() { return ShapeUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShortType\", function() { return ShortType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Skeleton\", function() { return Skeleton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SkeletonHelper\", function() { return SkeletonHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SkinnedMesh\", function() { return SkinnedMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SmoothShading\", function() { return SmoothShading; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sphere\", function() { return Sphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphereBufferGeometry\", function() { return SphereGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphereGeometry\", function() { return SphereGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spherical\", function() { return Spherical; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphericalHarmonics3\", function() { return SphericalHarmonics3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplineCurve\", function() { return SplineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLight\", function() { return SpotLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLightHelper\", function() { return SpotLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sprite\", function() { return Sprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpriteMaterial\", function() { return SpriteMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcAlphaFactor\", function() { return SrcAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcAlphaSaturateFactor\", function() { return SrcAlphaSaturateFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcColorFactor\", function() { return SrcColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticCopyUsage\", function() { return StaticCopyUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticDrawUsage\", function() { return StaticDrawUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticReadUsage\", function() { return StaticReadUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StereoCamera\", function() { return StereoCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StreamCopyUsage\", function() { return StreamCopyUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StreamDrawUsage\", function() { return StreamDrawUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StreamReadUsage\", function() { return StreamReadUsage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringKeyframeTrack\", function() { return StringKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubtractEquation\", function() { return SubtractEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubtractiveBlending\", function() { return SubtractiveBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TOUCH\", function() { return TOUCH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TangentSpaceNormalMap\", function() { return TangentSpaceNormalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TetrahedronBufferGeometry\", function() { return TetrahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TetrahedronGeometry\", function() { return TetrahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextBufferGeometry\", function() { return TextGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextGeometry\", function() { return TextGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureLoader\", function() { return TextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusBufferGeometry\", function() { return TorusGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusGeometry\", function() { return TorusGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusKnotBufferGeometry\", function() { return TorusKnotGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusKnotGeometry\", function() { return TorusKnotGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Triangle\", function() { return Triangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriangleFanDrawMode\", function() { return TriangleFanDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriangleStripDrawMode\", function() { return TriangleStripDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrianglesDrawMode\", function() { return TrianglesDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TubeBufferGeometry\", function() { return TubeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TubeGeometry\", function() { return TubeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UVMapping\", function() { return UVMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16Attribute\", function() { return Uint16Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16BufferAttribute\", function() { return Uint16BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32Attribute\", function() { return Uint32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32BufferAttribute\", function() { return Uint32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8Attribute\", function() { return Uint8Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8BufferAttribute\", function() { return Uint8BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8ClampedAttribute\", function() { return Uint8ClampedAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8ClampedBufferAttribute\", function() { return Uint8ClampedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uniform\", function() { return Uniform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformsLib\", function() { return UniformsLib; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformsUtils\", function() { return UniformsUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedByteType\", function() { return UnsignedByteType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedInt248Type\", function() { return UnsignedInt248Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedIntType\", function() { return UnsignedIntType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort4444Type\", function() { return UnsignedShort4444Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort5551Type\", function() { return UnsignedShort5551Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort565Type\", function() { return UnsignedShort565Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShortType\", function() { return UnsignedShortType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VSMShadowMap\", function() { return VSMShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return Vector2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector4\", function() { return Vector4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VectorKeyframeTrack\", function() { return VectorKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vertex\", function() { return Vertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexColors\", function() { return VertexColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VideoTexture\", function() { return VideoTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGL1Renderer\", function() { return WebGL1Renderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLCubeRenderTarget\", function() { return WebGLCubeRenderTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLMultisampleRenderTarget\", function() { return WebGLMultisampleRenderTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderTarget\", function() { return WebGLRenderTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderTargetCube\", function() { return WebGLRenderTargetCube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderer\", function() { return WebGLRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLUtils\", function() { return WebGLUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WireframeGeometry\", function() { return WireframeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WireframeHelper\", function() { return WireframeHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WrapAroundEnding\", function() { return WrapAroundEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XHRLoader\", function() { return XHRLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroCurvatureEnding\", function() { return ZeroCurvatureEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroFactor\", function() { return ZeroFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroSlopeEnding\", function() { return ZeroSlopeEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroStencilOp\", function() { return ZeroStencilOp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sRGBEncoding\", function() { return sRGBEncoding; });\n/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '127';\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst FlatShading = 1;\nconst SmoothShading = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst CubeUVRefractionMapping = 307;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedShort565Type = 1019;\nconst UnsignedInt248Type = 1020;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst RGBEFormat = RGBAFormat;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\nconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\nconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\nconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\nconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\nconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\nconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\nconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\nconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\nconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\nconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\nconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\nconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\nconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\nconst GammaEncoding = 3007;\nconst RGBEEncoding = 3002;\nconst LogLuvEncoding = 3003;\nconst RGBM7Encoding = 3004;\nconst RGBM16Encoding = 3005;\nconst RGBDEncoding = 3006;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nfunction EventDispatcher() {}\n\nObject.assign( EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n} );\n\nconst _lut = [];\n\nfor ( let i = 0; i < 256; i ++ ) {\n\n\t_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\n\n}\n\nlet _seed = 1234567;\n\nconst MathUtils = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: function () {\n\n\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\t\tconst d0 = Math.random() * 0xffffffff | 0;\n\t\tconst d1 = Math.random() * 0xffffffff | 0;\n\t\tconst d2 = Math.random() * 0xffffffff | 0;\n\t\tconst d3 = Math.random() * 0xffffffff | 0;\n\t\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\n\t\treturn uuid.toUpperCase();\n\n\t},\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\n\n\tinverseLerp: function ( x, y, value ) {\n\n\t\tif ( x !== y ) {\n\n\t\t\treturn ( value - x ) / ( y - x );\n\n\t\t } else {\n\n\t\t\treturn 0;\n\n\t\t }\n\n\t},\n\n\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\tlerp: function ( x, y, t ) {\n\n\t\treturn ( 1 - t ) * x + t * y;\n\n\t},\n\n\t// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n\n\tdamp: function ( x, y, lambda, dt ) {\n\n\t\treturn MathUtils.lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n\t},\n\n\t// https://www.desmos.com/calculator/vcsjnyz7x4\n\n\tpingpong: function ( x, length = 1 ) {\n\n\t\treturn length - Math.abs( MathUtils.euclideanModulo( x, length * 2 ) - length );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\t// Deterministic pseudo-random float in the interval [ 0, 1 ]\n\n\tseededRandom: function ( s ) {\n\n\t\tif ( s !== undefined ) _seed = s % 2147483647;\n\n\t\t// Park-Miller algorithm\n\n\t\t_seed = _seed * 16807 % 2147483647;\n\n\t\treturn ( _seed - 1 ) / 2147483646;\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * MathUtils.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * MathUtils.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tceilPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tfloorPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tsetQuaternionFromProperEuler: function ( q, a, b, c, order ) {\n\n\t\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t\t// rotations are applied to the axes in the order specified by 'order'\n\t\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t\t// angles are in radians\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c2 = cos( b / 2 );\n\t\tconst s2 = sin( b / 2 );\n\n\t\tconst c13 = cos( ( a + c ) / 2 );\n\t\tconst s13 = sin( ( a + c ) / 2 );\n\n\t\tconst c1_3 = cos( ( a - c ) / 2 );\n\t\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\t\tconst c3_1 = cos( ( c - a ) / 2 );\n\t\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYX':\n\t\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZY':\n\t\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXZ':\n\t\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZX':\n\t\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXY':\n\t\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYZ':\n\t\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t}\n\n};\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector2.prototype.isVector2 = true;\n\nclass Matrix3 {\n\n\tconstructor() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tscale( sx, sy ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tconst te = this.elements;\n\n\t\tconst a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\n\t\tconst a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\n\n\t\tte[ 0 ] = c * a11 + s * a21;\n\t\tte[ 3 ] = c * a12 + s * a22;\n\t\tte[ 6 ] = c * a13 + s * a23;\n\n\t\tte[ 1 ] = - s * a11 + c * a21;\n\t\tte[ 4 ] = - s * a12 + c * a22;\n\t\tte[ 7 ] = - s * a13 + c * a23;\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nMatrix3.prototype.isMatrix3 = true;\n\nlet _canvas;\n\nconst ImageUtils = {\n\n\tgetDataURL: function ( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement == 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n};\n\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.image = image;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tconst image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = MathUtils.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tlet url;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\t// process array of images e.g. CubeTexture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( let i = 0, l = image.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t// check cube texture with data textures\n\n\t\t\t\t\t\tif ( image[ i ].isDataTexture ) {\n\n\t\t\t\t\t\t\turl.push( serializeImage( image[ i ].image ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\turl.push( serializeImage( image[ i ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// process single image\n\n\t\t\t\t\turl = serializeImage( image );\n\n\t\t\t\t}\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: url\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype.isTexture = true;\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.prototype.slice.call( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\t\tthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector4.prototype.isVector4 = true;\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass WebGLRenderTarget extends EventDispatcher {\n\n\tconstructor( width, height, options ) {\n\n\t\tsuper();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\toptions = options || {};\n\n\t\tthis.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.texture.image = {};\n\t\tthis.texture.image.width = width;\n\t\tthis.texture.image.height = height;\n\t\tthis.texture.image.depth = 1;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tsetTexture( texture ) {\n\n\t\ttexture.image = {\n\t\t\twidth: this.width,\n\t\t\theight: this.height,\n\t\t\tdepth: this.depth\n\t\t};\n\n\t\tthis.texture = texture;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tthis.texture.image.width = width;\n\t\t\tthis.texture.image.height = height;\n\t\t\tthis.texture.image.depth = depth;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\n\nclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width, height, options ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.samples = 4;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy.call( this, source );\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n}\n\nWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerp( qa, qb, qm, t ) {\n\n\t\tconsole.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );\n\t\treturn qm.slerpQuaternions( qa, qb, t );\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize();\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\tthis.copy( qa ).slerp( qb, t );\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n}\n\nQuaternion.prototype.isQuaternion = true;\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$c );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector3.prototype.isVector3 = true;\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst x = array[ i ];\n\t\t\tconst y = array[ i + 1 ];\n\t\t\tconst z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\tconst x = attribute.getX( i );\n\t\t\tconst y = attribute.getY( i );\n\t\t\tconst z = attribute.getZ( i );\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getCenter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getSize() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\t_box$3.copy( geometry.boundingBox );\n\t\t\t_box$3.applyMatrix4( object.matrixWorld );\n\n\t\t\tthis.union( _box$3 );\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getParameter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$b );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$3.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$3, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$3 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );\n\n\t\treturn clampedPoint.sub( point ).length();\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Box3: .getBoundingSphere() target is now required' );\n\t\t\t//target = new Sphere(); // removed to avoid cyclic dependency\n\n\t\t}\n\n\t\tthis.getCenter( target.center );\n\n\t\ttarget.radius = this.getSize( _vector$b ).length() * 0.5;\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nBox3.prototype.isBox3 = true;\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$3 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the seperating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is seperating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _toFarthestPoint = /*@__PURE__*/ new Vector3();\nconst _toPoint = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$2.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );\n\t\t\ttarget = new Box3();\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\n\t\t_toPoint.subVectors( point, this.center );\n\n\t\tconst lengthSq = _toPoint.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\t\t\tconst missingRadiusHalf = ( length - this.radius ) * 0.5;\n\n\t\t\t// Nudge this sphere towards the target point. Add half the missing distance to radius,\n\t\t\t// and the other half to position. This gives a tighter enclosure, instead of if\n\t\t\t// the whole missing distance were just added to radius.\n\n\t\t\tthis.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );\n\t\t\tthis.radius += missingRadiusHalf;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\n\t\t// To enclose another sphere into this sphere, we only need to enclose two points:\n\t\t// 1) Enclose the farthest point on the other sphere into this sphere.\n\t\t// 2) Enclose the opposite point of the farthest point into this sphere.\n\n\t\t_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );\n\n\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );\n\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\treturn _vector$a.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$a.dot( this.direction );\n\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, y, z, 0,\n\t\t\tx, 1, z, 0,\n\t\t\tx, y, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$2.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$2.elements[ 0 ] *= invSX;\n\t\t_m1$2.elements[ 1 ] *= invSX;\n\t\t_m1$2.elements[ 2 ] *= invSX;\n\n\t\t_m1$2.elements[ 4 ] *= invSY;\n\t\t_m1$2.elements[ 5 ] *= invSY;\n\t\t_m1$2.elements[ 6 ] *= invSY;\n\n\t\t_m1$2.elements[ 8 ] *= invSZ;\n\t\t_m1$2.elements[ 9 ] *= invSZ;\n\t\t_m1$2.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$2 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far ) {\n\n\t\tif ( far === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\n\t\t}\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\t\tconst c = - ( far + near ) / ( far - near );\n\t\tconst d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\t\tconst z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nMatrix4.prototype.isMatrix4 = true;\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order, update ) {\n\n\t\tconst clamp = MathUtils.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix$1.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix$1, order, update );\n\n\t}\n\n\tsetFromVector3( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\ttoVector3( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n}\n\nEuler.prototype.isEuler = true;\n\nEuler.DefaultOrder = 'XYZ';\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = 1 << channel | 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = new Vector3();\nconst _q1 = new Quaternion();\nconst _m1$1 = new Matrix4();\nconst _target = new Vector3();\n\nconst _position$3 = new Vector3();\nconst _scale$2 = new Vector3();\nconst _quaternion$2 = new Quaternion();\n\nconst _xAxis = new Vector3( 1, 0, 0 );\nconst _yAxis = new Vector3( 0, 1, 0 );\nconst _zAxis = new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nfunction Object3D() {\n\n\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = Object3D.DefaultUp.clone();\n\n\tconst position = new Vector3();\n\tconst rotation = new Euler();\n\tconst quaternion = new Quaternion();\n\tconst scale = new Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation._onChange( onRotationChange );\n\tquaternion._onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new Matrix4();\n\tthis.matrixWorld = new Matrix4();\n\n\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.animations = [];\n\n\tthis.userData = {};\n\n}\n\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\nObject3D.DefaultMatrixAutoUpdate = true;\n\nObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Object3D,\n\n\tisObject3D: true,\n\n\tonBeforeRender: function () {},\n\tonAfterRender: function () {},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function ( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateOnWorldAxis: function ( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t},\n\n\ttranslateOnAxis: function ( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t},\n\n\ttranslateX: function ( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t},\n\n\ttranslateY: function ( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t},\n\n\ttranslateZ: function ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t},\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );\n\n\t},\n\n\tlookAt: function ( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$1.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$1.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$1 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$1.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$1 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t},\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclear: function () {\n\n\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\tconst object = this.children[ i ];\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t}\n\n\t\tthis.children.length = 0;\n\n\t\treturn this;\n\n\n\t},\n\n\tattach: function ( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$1.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$1.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$1 );\n\n\t\tthis.add( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\treturn this;\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );\n\t\t\ttarget = new Quaternion();\n\n\t\t}\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t},\n\n\tgetWorldScale: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldScale() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t},\n\n\tgetWorldDirection: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t},\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.parent === null ) {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t}\n\n\t\t// update children\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateWorldMatrix( false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nPlane.prototype.isPlane = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$1 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getNormal() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getBarycoord() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\tthis.getBarycoord( point, a, b, c, _v3$1 );\n\n\t\treturn ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );\n\n\t}\n\n\tstatic getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\n\n\t\tthis.getBarycoord( point, p1, p2, p3, _v3$1 );\n\n\t\ttarget.set( 0, 0 );\n\t\ttarget.addScaledVector( uv1, _v3$1.x );\n\t\ttarget.addScaledVector( uv2, _v3$1.y );\n\t\ttarget.addScaledVector( uv3, _v3$1.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getMidpoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getPlane() target is now required' );\n\t\t\ttarget = new Plane();\n\n\t\t}\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetUV( point, uv1, uv2, uv3, target ) {\n\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nlet materialId = 0;\n\nfunction Material() {\n\n\tObject.defineProperty( this, 'id', { value: materialId ++ } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\n\tthis.blending = NormalBlending;\n\tthis.side = FrontSide;\n\tthis.vertexColors = false;\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = SrcAlphaFactor;\n\tthis.blendDst = OneMinusSrcAlphaFactor;\n\tthis.blendEquation = AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.stencilWriteMask = 0xff;\n\tthis.stencilFunc = AlwaysStencilFunc;\n\tthis.stencilRef = 0;\n\tthis.stencilFuncMask = 0xff;\n\tthis.stencilFail = KeepStencilOp;\n\tthis.stencilZFail = KeepStencilOp;\n\tthis.stencilZPass = KeepStencilOp;\n\tthis.stencilWrite = false;\n\n\tthis.clippingPlanes = null;\n\tthis.clipIntersection = false;\n\tthis.clipShadows = false;\n\n\tthis.shadowSide = null;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.dithering = false;\n\n\tthis.alphaTest = 0;\n\tthis.alphaToCoverage = false;\n\tthis.premultipliedAlpha = false;\n\n\tthis.visible = true;\n\n\tthis.toneMapped = true;\n\n\tthis.userData = {};\n\n\tthis.version = 0;\n\n}\n\nMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Material,\n\n\tisMaterial: true,\n\n\tonBeforeCompile: function ( /* shaderobject, renderer */ ) {},\n\n\tcustomProgramCacheKey: function () {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// for backward compatability if shading is set in the constructor\n\t\t\tif ( key === 'shading' ) {\n\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': \\'' + key + '\\' is not a property of this material.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\t\tdata.refractionRatio = this.refractionRatio;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\t\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\n\t\t}\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\tdata.depthFunc = this.depthFunc;\n\t\tdata.depthTest = this.depthTest;\n\t\tdata.depthWrite = this.depthWrite;\n\t\tdata.colorWrite = this.colorWrite;\n\n\t\tdata.stencilWrite = this.stencilWrite;\n\t\tdata.stencilWriteMask = this.stencilWriteMask;\n\t\tdata.stencilFunc = this.stencilFunc;\n\t\tdata.stencilRef = this.stencilRef;\n\t\tdata.stencilFuncMask = this.stencilFuncMask;\n\t\tdata.stencilFail = this.stencilFail;\n\t\tdata.stencilZFail = this.stencilZFail;\n\t\tdata.stencilZPass = this.stencilZPass;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.morphTargets === true ) data.morphTargets = true;\n\t\tif ( this.morphNormals === true ) data.morphNormals = true;\n\t\tif ( this.skinning === true ) data.skinning = true;\n\n\t\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nObject.defineProperty( Material.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tset( value ) {\n\n\t\tif ( value && value.isColor ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = MathUtils.euclideanModulo( h, 1 );\n\t\ts = MathUtils.clamp( s, 0, 1 );\n\t\tl = MathUtils.clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tconst h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tconst s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tconst l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopyGammaToLinear( color, gammaFactor = 2.0 ) {\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToGamma( color, gammaFactor = 2.0 ) {\n\n\t\tconst safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t}\n\n\tconvertGammaToLinear( gammaFactor ) {\n\n\t\tthis.copyGammaToLinear( this, gammaFactor );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToGamma( gammaFactor ) {\n\n\t\tthis.copyLinearToGamma( this, gammaFactor );\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex() {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t}\n\n\tgetHexString() {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Color: .getHSL() target is now required' );\n\t\t\ttarget = { h: 0, s: 0, l: 0 };\n\n\t\t}\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle() {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\t_hslA.h += h; _hslA.s += s; _hslA.l += l;\n\n\t\tthis.setHSL( _hslA.h, _hslA.s, _hslA.l );\n\n\t\treturn this;\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\tif ( attribute.normalized === true ) {\n\n\t\t\t// assuming Uint8Array\n\n\t\t\tthis.r /= 255;\n\t\t\tthis.g /= 255;\n\t\t\tthis.b /= 255;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n}\n\nColor.NAMES = _colorKeywords;\n\nColor.prototype.isColor = true;\nColor.prototype.r = 1;\nColor.prototype.g = 1;\nColor.prototype.b = 1;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\nconst _vector$9 = new Vector3();\nconst _vector2 = new Vector2();\n\nfunction BufferAttribute( array, itemSize, normalized ) {\n\n\tif ( Array.isArray( array ) ) {\n\n\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t}\n\n\tthis.name = '';\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\tthis.normalized = normalized === true;\n\n\tthis.usage = StaticDrawUsage;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n}\n\nObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nObject.assign( BufferAttribute.prototype, {\n\n\tisBufferAttribute: true,\n\n\tonUploadCallback: function () {},\n\n\tsetUsage: function ( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tlet color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tlet vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tlet vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tconst array = this.array;\n\t\tlet offset = 0;\n\n\t\tfor ( let i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tlet vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2.fromBufferAttribute( this, i );\n\t\t\t\t_vector2.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2.x, _vector2.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$9.fromBufferAttribute( this, i );\n\t\t\t\t_vector$9.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.x = this.getX( i );\n\t\t\t_vector$9.y = this.getY( i );\n\t\t\t_vector$9.z = this.getZ( i );\n\n\t\t\t_vector$9.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyNormalMatrix: function ( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.x = this.getX( i );\n\t\t\t_vector$9.y = this.getY( i );\n\t\t\t_vector$9.z = this.getZ( i );\n\n\t\t\t_vector$9.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttransformDirection: function ( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.x = this.getX( i );\n\t\t\t_vector$9.y = this.getY( i );\n\t\t\t_vector$9.z = this.getZ( i );\n\n\t\t\t_vector$9.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tonUpload: function ( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.prototype.slice.call( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\t\tif ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n//\n\nfunction Int8BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\n\n}\n\nInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\n\n\nfunction Uint8BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\n\n}\n\nUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\n\n\nfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\n\n}\n\nUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\n\n\nfunction Int16BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\n\n}\n\nInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\n\n\nfunction Uint16BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\n\n}\n\nUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\n\n\nfunction Int32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\n\n}\n\nInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\n\n\nfunction Uint32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\n\n}\n\nUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\n\nfunction Float16BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\n\n}\n\nFloat16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nFloat16BufferAttribute.prototype.constructor = Float16BufferAttribute;\nFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\n\nfunction Float32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\n\n}\n\nFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\n\n\nfunction Float64BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\n\n}\n\nFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\nfunction arrayMax( array ) {\n\n\tif ( array.length === 0 ) return - Infinity;\n\n\tlet max = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t}\n\n\treturn max;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nlet _id = 0;\n\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\nconst _box$1 = new Box3();\nconst _boxMorphTargets = new Box3();\nconst _vector$8 = new Vector3();\n\nfunction BufferGeometry() {\n\n\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\tthis.morphTargetsRelative = false;\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n\tthis.userData = {};\n\n}\n\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: BufferGeometry,\n\n\tisBufferGeometry: true,\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tsetAttribute: function ( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tdeleteAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\thasAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$1.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.min, _box$1.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.max, _box$1.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$1.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$1.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$1.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$1.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$1.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$1.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$1.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$1.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$8.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$8.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst indices = index.array;\n\t\tconst positions = attributes.position.array;\n\t\tconst normals = attributes.normal.array;\n\t\tconst uvs = attributes.uv.array;\n\n\t\tconst nVertices = positions.length / 3;\n\n\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tconst tangents = attributes.tangent.array;\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tconst attribute1 = attributes[ key ];\n\t\t\tconst attributeArray1 = attribute1.array;\n\n\t\t\tconst attribute2 = geometry.attributes[ key ];\n\t\t\tconst attributeArray2 = attribute2.array;\n\n\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\tconst length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$8.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nconst _inverseMatrix$2 = new Matrix4();\nconst _ray$2 = new Ray();\nconst _sphere$3 = new Sphere();\n\nconst _vA$1 = new Vector3();\nconst _vB$1 = new Vector3();\nconst _vC$1 = new Vector3();\n\nconst _tempA = new Vector3();\nconst _tempB = new Vector3();\nconst _tempC = new Vector3();\n\nconst _morphA = new Vector3();\nconst _morphB = new Vector3();\nconst _morphC = new Vector3();\n\nconst _uvA$1 = new Vector2();\nconst _uvB$1 = new Vector2();\nconst _uvC$1 = new Vector2();\n\nconst _intersectionPoint = new Vector3();\nconst _intersectionPointWorld = new Vector3();\n\nfunction Mesh( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry;\n\tthis.material = material;\n\n\tthis.updateMorphTargets();\n\n}\n\nMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Mesh,\n\n\tisMesh: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$3.copy( geometry.boundingSphere );\n\t\t_sphere$3.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// Check boundingBox before continuing\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\tlet intersection;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst uv = geometry.attributes.uv;\n\t\t\tconst uv2 = geometry.attributes.uv2;\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst drawRange = geometry.drawRange;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\t// non-indexed buffer geometry\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\tconst end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\tconst a = i;\n\t\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t}\n\n} );\n\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {\n\n\t_vA$1.fromBufferAttribute( position, a );\n\t_vB$1.fromBufferAttribute( position, b );\n\t_vC$1.fromBufferAttribute( position, c );\n\n\tconst morphInfluences = object.morphTargetInfluences;\n\n\tif ( material.morphTargets && morphPosition && morphInfluences ) {\n\n\t\t_morphA.set( 0, 0, 0 );\n\t\t_morphB.set( 0, 0, 0 );\n\t\t_morphC.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\tconst influence = morphInfluences[ i ];\n\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );\n\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );\n\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_vA$1.add( _morphA );\n\t\t_vB$1.add( _morphB );\n\t\t_vC$1.add( _morphC );\n\n\t}\n\n\tif ( object.isSkinnedMesh && material.skinning ) {\n\n\t\tobject.boneTransform( a, _vA$1 );\n\t\tobject.boneTransform( b, _vB$1 );\n\t\tobject.boneTransform( c, _vC$1 );\n\n\t}\n\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv2 ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv2, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv2, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv2, c );\n\n\t\t\tintersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\n/**\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction ShaderMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = default_vertex;\n\tthis.fragmentShader = default_fragment;\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\tthis.uniformsNeedUpdate = false;\n\n\tthis.glslVersion = null;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nShaderMaterial.prototype = Object.create( Material.prototype );\nShaderMaterial.prototype.constructor = ShaderMaterial;\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nShaderMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = cloneUniforms( source.uniforms );\n\n\tthis.defines = Object.assign( {}, source.defines );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = Object.assign( {}, source.extensions );\n\n\tthis.glslVersion = source.glslVersion;\n\n\treturn this;\n\n};\n\nShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tconst data = Material.prototype.toJSON.call( this, meta );\n\n\tdata.glslVersion = this.glslVersion;\n\tdata.uniforms = {};\n\n\tfor ( const name in this.uniforms ) {\n\n\t\tconst uniform = this.uniforms[ name ];\n\t\tconst value = uniform.value;\n\n\t\tif ( value && value.isTexture ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t};\n\n\t\t} else if ( value && value.isColor ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'c',\n\t\t\t\tvalue: value.getHex()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\tvalue: value\n\t\t\t};\n\n\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t}\n\n\t}\n\n\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\tconst extensions = {};\n\n\tfor ( const key in this.extensions ) {\n\n\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t}\n\n\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\treturn data;\n\n};\n\nfunction Camera() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new Matrix4();\n\n\tthis.projectionMatrix = new Matrix4();\n\tthis.projectionMatrixInverse = new Matrix4();\n\n}\n\nCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Camera,\n\n\tisCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\treturn this;\n\n\t},\n\n\tgetWorldDirection: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Camera: .getWorldDirection() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t},\n\n\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\n\n\t\tObject3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\nfunction PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\tCamera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov;\n\tthis.zoom = 1;\n\n\tthis.near = near;\n\tthis.far = far;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n}\n\nPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\tconstructor: PerspectiveCamera,\n\n\tisPerspectiveCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tconst vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn MathUtils.RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function () {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tconst data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\nconst fov = 90, aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget !== true ) {\n\n\t\t\tconsole.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.renderTarget = renderTarget;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst renderTarget = this.renderTarget;\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0 );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1 );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2 );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3 );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4 );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5 );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\tformat = format !== undefined ? format : RGBFormat;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\t// Why CubeTexture._needsFlipEnvMap is necessary:\n\t\t//\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)\n\t\t// when using WebGLCubeRenderTarget.texture as a cube texture.\n\n\t\tthis._needsFlipEnvMap = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nCubeTexture.prototype.isCubeTexture = true;\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size, options, dummy ) {\n\n\t\tif ( Number.isInteger( options ) ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );\n\n\t\t\toptions = dummy;\n\n\t\t}\n\n\t\tsuper( size, size, options );\n\n\t\toptions = options || {};\n\n\t\tthis.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t\tthis.texture._needsFlipEnvMap = false;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.format = RGBAFormat; // see #18859\n\t\tthis.texture.encoding = texture.encoding;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nclass DataTexture extends Texture {\n\n\tconstructor( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data || null, width: width || 1, height: height || 1 };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nDataTexture.prototype.isDataTexture = true;\n\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$2 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$2.center.set( 0, 0, 0 );\n\t\t_sphere$2.radius = 0.7071067811865476;\n\t\t_sphere$2.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$2 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$7 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction WebGLAnimation() {\n\n\tlet context = null;\n\tlet isAnimating = false;\n\tlet animationLoop = null;\n\tlet requestId = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tanimationLoop( time, frame );\n\n\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tcontext.cancelAnimationFrame( requestId );\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLAttributes( gl, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type = 5126;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = 5126;\n\n\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\ttype = 5131;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttype = 5123;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = 5122;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = 5125;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = 5124;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = 5120;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = 5121;\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRange = attribute.updateRange;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, updateRange.offset, updateRange.count );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\n\t\t\t}\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\nvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie(float roughness, float NoH) {\\n\\tfloat invAlpha = 1.0 / roughness;\\n\\tfloat cos2h = NoH * NoH;\\n\\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\n}\\nfloat V_Neubelt(float NoV, float NoL) {\\n\\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\n}\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 H = normalize( V + L );\\n\\tfloat dotNH = saturate( dot( N, H ) );\\n\\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\n}\\n#endif\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = - mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}\";\n\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n#endif\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\n\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\n#ifdef REFLECTIVITY\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#endif\\n#ifdef CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheen;\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularRoughness;\\n\\tvec3 specularColor;\\n#ifdef CLEARCOAT\\n\\tfloat clearcoat;\\n\\tfloat clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tvec3 sheenColor;\\n#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = ccDotNL * directLight.color;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tccIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t\\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\n\\t\\t\\tmaterial.specularRoughness,\\n\\t\\t\\tdirectLight.direction,\\n\\t\\t\\tgeometry,\\n\\t\\t\\tmaterial.sheenColor\\n\\t\\t);\\n\\t#else\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\\n\\t#endif\\n\\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t\\tfloat ccDotNL = ccDotNV;\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\n\\t#ifdef CLEARCOAT\\n\\t\\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\nvar map_particle_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\n\nvar normal_fragment_maps = \"#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif\";\n\nvar clearcoat_normal_fragment_begin = \"#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\n\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif\";\n\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\nvar transmissionmap_fragment = \"#ifdef USE_TRANSMISSIONMAP\\n\\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\\n#endif\";\n\nvar transmissionmap_pars_fragment = \"#ifdef USE_TRANSMISSIONMAP\\n\\tuniform sampler2D transmissionMap;\\n#endif\";\n\nvar uv_pars_fragment = \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif\";\n\nvar uv_vertex = \"#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif\";\n\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\nvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nvar cube_frag = \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nvar meshtoon_frag = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshtoon_vert = \"#define TOON\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshphysical_frag = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define REFLECTIVITY\\n\\t#define CLEARCOAT\\n\\t#define TRANSMISSION\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef TRANSMISSION\\n\\tuniform float transmission;\\n#endif\\n#ifdef REFLECTIVITY\\n\\tuniform float reflectivity;\\n#endif\\n#ifdef CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheen;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <transmissionmap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#ifdef TRANSMISSION\\n\\t\\tfloat totalTransmission = transmission;\\n\\t#endif\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <transmissionmap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#ifdef TRANSMISSION\\n\\t\\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\\n\\t#endif\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphysical_vert = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\n\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar shadow_vert = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst ShaderChunk = {\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tencodings_fragment: encodings_fragment,\n\tencodings_pars_fragment: encodings_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_fragment: lightmap_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_vertex: lights_lambert_vertex,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_toon_fragment: lights_toon_fragment,\n\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\ttransmissionmap_fragment: transmissionmap_fragment,\n\ttransmissionmap_pars_fragment: transmissionmap_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tuv2_pars_fragment: uv2_pars_fragment,\n\tuv2_pars_vertex: uv2_pars_vertex,\n\tuv2_vertex: uv2_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_frag: background_frag,\n\tbackground_vert: background_vert,\n\tcube_frag: cube_frag,\n\tcube_vert: cube_vert,\n\tdepth_frag: depth_frag,\n\tdepth_vert: depth_vert,\n\tdistanceRGBA_frag: distanceRGBA_frag,\n\tdistanceRGBA_vert: distanceRGBA_vert,\n\tequirect_frag: equirect_frag,\n\tequirect_vert: equirect_vert,\n\tlinedashed_frag: linedashed_frag,\n\tlinedashed_vert: linedashed_vert,\n\tmeshbasic_frag: meshbasic_frag,\n\tmeshbasic_vert: meshbasic_vert,\n\tmeshlambert_frag: meshlambert_frag,\n\tmeshlambert_vert: meshlambert_vert,\n\tmeshmatcap_frag: meshmatcap_frag,\n\tmeshmatcap_vert: meshmatcap_vert,\n\tmeshtoon_frag: meshtoon_frag,\n\tmeshtoon_vert: meshtoon_vert,\n\tmeshphong_frag: meshphong_frag,\n\tmeshphong_vert: meshphong_vert,\n\tmeshphysical_frag: meshphysical_frag,\n\tmeshphysical_vert: meshphysical_vert,\n\tnormal_frag: normal_frag,\n\tnormal_vert: normal_vert,\n\tpoints_frag: points_frag,\n\tpoints_vert: points_vert,\n\tshadow_frag: shadow_frag,\n\tshadow_vert: shadow_vert,\n\tsprite_frag: sprite_frag,\n\tsprite_vert: sprite_vert\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() },\n\t\tuv2Transform: { value: new Matrix3() },\n\n\t\talphaMap: { value: null },\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 },\n\t\trefractionRatio: { value: 0.98 },\n\t\tmaxMipLevel: { value: 0 }\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tlightProbe: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {}\n\t\t} },\n\n\t\tdirectionalLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {}\n\t\t} },\n\n\t\tspotLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotShadowMap: { value: [] },\n\t\tspotShadowMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {}\n\t\t} },\n\n\t\tpointLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} },\n\n\t\tltc_1: { value: null },\n\t\tltc_2: { value: null }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: new Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t}\n\n};\n\nconst ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\tspecular: { value: new Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\troughness: { value: 1.0 },\n\t\t\t\tmetalness: { value: 0.0 },\n\t\t\t\tenvMapIntensity: { value: 1 } // temporary\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\ttoon: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.normal_vert,\n\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: new Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\tcube: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.envmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: new Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: new Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: mergeUniforms( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearcoat: { value: 0 },\n\t\t\tclearcoatMap: { value: null },\n\t\t\tclearcoatRoughness: { value: 0 },\n\t\t\tclearcoatRoughnessMap: { value: null },\n\t\t\tclearcoatNormalScale: { value: new Vector2( 1, 1 ) },\n\t\t\tclearcoatNormalMap: { value: null },\n\t\t\tsheen: { value: new Color( 0x000000 ) },\n\t\t\ttransmission: { value: 0 },\n\t\t\ttransmissionMap: { value: null },\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\nfunction WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {\n\n\tconst clearColor = new Color( 0x000000 );\n\tlet clearAlpha = 0;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction render( renderList, scene, camera, forceClear ) {\n\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tbackground = cubemaps.get( background );\n\n\t\t}\n\n\t\t// Ignore background in AR\n\t\t// TODO: Reconsider this.\n\n\t\tconst xr = renderer.xr;\n\t\tconst session = xr.getSession && xr.getSession();\n\n\t\tif ( session && session.environmentBlendMode === 'additive' ) {\n\n\t\t\tbackground = null;\n\n\t\t}\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.cube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render\n\n\t};\n\n}\n\nfunction WebGLBindingStates( gl, extensions, attributes, capabilities ) {\n\n\tconst maxVertexAttributes = gl.getParameter( 34921 );\n\n\tconst extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );\n\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tif ( vaoAvailable ) {\n\n\t\t\tconst state = getBindingState( geometry, program, material );\n\n\t\t\tif ( currentState !== state ) {\n\n\t\t\t\tcurrentState = state;\n\t\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t\t}\n\n\t\t\tupdateBuffers = needsUpdate( geometry, index );\n\n\t\t\tif ( updateBuffers ) saveCache( geometry, index );\n\n\t\t} else {\n\n\t\t\tconst wireframe = ( material.wireframe === true );\n\n\t\t\tif ( currentState.geometry !== geometry.id ||\n\t\t\t\tcurrentState.program !== program.id ||\n\t\t\t\tcurrentState.wireframe !== wireframe ) {\n\n\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\tcurrentState.program = program.id;\n\t\t\t\tcurrentState.wireframe = wireframe;\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh === true ) {\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, 34963 );\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( 34963, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.createVertexArray();\n\n\t\treturn extension.createVertexArrayOES();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );\n\n\t\treturn extension.bindVertexArrayOES( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );\n\n\t\treturn extension.deleteVertexArrayOES( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( geometry, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tlet attributesNum = 0;\n\n\t\tfor ( const key in geometryAttributes ) {\n\n\t\t\tconst cachedAttribute = cachedAttributes[ key ];\n\t\t\tconst geometryAttribute = geometryAttributes[ key ];\n\n\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\tif ( cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t\tattributesNum ++;\n\n\t\t}\n\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( geometry, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\t\tlet attributesNum = 0;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tconst data = {};\n\t\t\tdata.attribute = attribute;\n\n\t\t\tif ( attribute.data ) {\n\n\t\t\t\tdata.data = attribute.data;\n\n\t\t\t}\n\n\t\t\tcache[ key ] = data;\n\n\t\t\tattributesNum ++;\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\t\tcurrentState.attributesNum = attributesNum;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset ) {\n\n\t\tif ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tif ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {\n\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;\n\n\t\t}\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tconst geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\tvertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\tvertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( name === 'instanceMatrix' ) {\n\n\t\t\t\t\tconst attribute = attributes.get( object.instanceMatrix );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 0, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 1, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 2, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 3, 1 );\n\n\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );\n\n\t\t\t\t} else if ( name === 'instanceColor' ) {\n\n\t\t\t\t\tconst attribute = attributes.get( object.instanceColor );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute, 1 );\n\n\t\t\t\t\tgl.bindBuffer( 34962, buffer );\n\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatilibity\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\nfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tlet extension, methodName;\n\n\t\tif ( isWebGL2 ) {\n\n\t\t\textension = gl;\n\t\t\tmethodName = 'drawArraysInstanced';\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\tmethodName = 'drawArraysInstancedANGLE';\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ methodName ]( mode, start, count, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\nfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\tlet maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\t/* eslint-disable no-undef */\n\tconst isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||\n\t\t( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );\n\t/* eslint-enable no-undef */\n\n\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tconst maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\tconst maxTextures = gl.getParameter( 34930 );\n\tconst maxVertexTextures = gl.getParameter( 35660 );\n\tconst maxTextureSize = gl.getParameter( 3379 );\n\tconst maxCubemapSize = gl.getParameter( 34076 );\n\n\tconst maxAttributes = gl.getParameter( 34921 );\n\tconst maxVertexUniforms = gl.getParameter( 36347 );\n\tconst maxVaryings = gl.getParameter( 36348 );\n\tconst maxFragmentUniforms = gl.getParameter( 36349 );\n\n\tconst vertexTextures = maxVertexTextures > 0;\n\tconst floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );\n\tconst floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\tconst maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;\n\n\treturn {\n\n\t\tisWebGL2: isWebGL2,\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\tfloatVertexTextures: floatVertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\nfunction WebGLCubeMaps( renderer ) {\n\n\tlet cubemaps = new WeakMap();\n\n\tfunction mapTextureMapping( texture, mapping ) {\n\n\t\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\t\ttexture.mapping = CubeReflectionMapping;\n\n\t\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\t\ttexture.mapping = CubeRefractionMapping;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\tif ( cubemaps.has( texture ) ) {\n\n\t\t\t\t\tconst cubemap = cubemaps.get( texture ).texture;\n\t\t\t\t\treturn mapTextureMapping( cubemap, texture.mapping );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\tif ( image && image.height > 0 ) {\n\n\t\t\t\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget( image.height / 2 );\n\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\t\t\t\t\t\tcubemaps.set( texture, renderTarget );\n\n\t\t\t\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\treturn mapTextureMapping( renderTarget.texture, texture.mapping );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemap = cubemaps.get( texture );\n\n\t\tif ( cubemap !== undefined ) {\n\n\t\t\tcubemaps.delete( texture );\n\t\t\tcubemap.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubemaps = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLExtensions( gl ) {\n\n\tconst extensions = {};\n\n\tfunction getExtension( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tlet extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t}\n\n\treturn {\n\n\t\thas: function ( name ) {\n\n\t\t\treturn getExtension( name ) !== null;\n\n\t\t},\n\n\t\tinit: function ( capabilities ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tgetExtension( 'EXT_color_buffer_float' );\n\n\t\t\t} else {\n\n\t\t\t\tgetExtension( 'WEBGL_depth_texture' );\n\t\t\t\tgetExtension( 'OES_texture_float' );\n\t\t\t\tgetExtension( 'OES_texture_half_float' );\n\t\t\t\tgetExtension( 'OES_texture_half_float_linear' );\n\t\t\t\tgetExtension( 'OES_standard_derivatives' );\n\t\t\t\tgetExtension( 'OES_element_index_uint' );\n\t\t\t\tgetExtension( 'OES_vertex_array_object' );\n\t\t\t\tgetExtension( 'ANGLE_instanced_arrays' );\n\n\t\t\t}\n\n\t\t\tgetExtension( 'OES_texture_float_linear' );\n\t\t\tgetExtension( 'EXT_color_buffer_half_float' );\n\n\t\t},\n\n\t\tget: function ( name ) {\n\n\t\t\tconst extension = getExtension( name );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n\tconst geometries = {};\n\tconst wireframeAttributes = new WeakMap();\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tconst geometry = event.target;\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\tattributes.remove( geometry.index );\n\n\t\t}\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tattributes.remove( geometry.attributes[ name ] );\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tconst attribute = wireframeAttributes.get( geometry );\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\twireframeAttributes.delete( geometry );\n\n\t\t}\n\n\t\tbindingStates.releaseStatesOfGeometry( geometry );\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tdelete geometry._maxInstanceCount;\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tif ( geometries[ geometry.id ] === true ) return geometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tgeometries[ geometry.id ] = true;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\tfor ( const name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], 34962 );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], 34962 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateWireframeAttribute( geometry ) {\n\n\t\tconst indices = [];\n\n\t\tconst geometryIndex = geometry.index;\n\t\tconst geometryPosition = geometry.attributes.position;\n\t\tlet version = 0;\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tconst array = geometryIndex.array;\n\t\t\tversion = geometryIndex.version;\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = array[ i + 0 ];\n\t\t\t\tconst b = array[ i + 1 ];\n\t\t\t\tconst c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = geometryPosition.array;\n\t\t\tversion = geometryPosition.version;\n\n\t\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tconst a = i + 0;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\t\tattribute.version = version;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates\n\n\t\t//\n\n\t\tconst previousAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( previousAttribute ) attributes.remove( previousAttribute );\n\n\t\t//\n\n\t\twireframeAttributes.set( geometry, attribute );\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tconst currentAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( currentAttribute ) {\n\n\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\t// if the attribute is obsolete, create a new one\n\n\t\t\t\tif ( currentAttribute.version < geometryIndex.version ) {\n\n\t\t\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t}\n\n\t\treturn wireframeAttributes.get( geometry );\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tlet type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tlet extension, methodName;\n\n\t\tif ( isWebGL2 ) {\n\n\t\t\textension = gl;\n\t\t\tmethodName = 'drawElementsInstanced';\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\tmethodName = 'drawElementsInstancedANGLE';\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\nfunction WebGLInfo( gl ) {\n\n\tconst memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tconst render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase 4:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.frame ++;\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\nfunction numericalSort( a, b ) {\n\n\treturn a[ 0 ] - b[ 0 ];\n\n}\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl ) {\n\n\tconst influencesList = {};\n\tconst morphInfluences = new Float32Array( 8 );\n\n\tconst workInfluences = [];\n\n\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\tworkInfluences[ i ] = [ i, 0 ];\n\n\t}\n\n\tfunction update( object, geometry, material, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\n\t\tlet influences = influencesList[ geometry.id ];\n\n\t\tif ( influences === undefined ) {\n\n\t\t\t// initialise list\n\n\t\t\tinfluences = [];\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t}\n\n\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t}\n\n\t\t// Collect influences\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst influence = influences[ i ];\n\n\t\t\tinfluence[ 0 ] = i;\n\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t}\n\n\t\tinfluences.sort( absNumericalSort );\n\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tif ( i < length && influences[ i ][ 1 ] ) {\n\n\t\t\t\tworkInfluences[ i ][ 0 ] = influences[ i ][ 0 ];\n\t\t\t\tworkInfluences[ i ][ 1 ] = influences[ i ][ 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tworkInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;\n\t\t\t\tworkInfluences[ i ][ 1 ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tworkInfluences.sort( numericalSort );\n\n\t\tconst morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\tconst morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst influence = workInfluences[ i ];\n\t\t\tconst index = influence[ 0 ];\n\t\t\tconst value = influence[ 1 ];\n\n\t\t\tif ( index !== Number.MAX_SAFE_INTEGER && value ) {\n\n\t\t\t\tif ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\tmorphInfluencesSum += value;\n\n\t\t\t} else {\n\n\t\t\t\tif ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {\n\n\t\t\t\t\tgeometry.deleteAttribute( 'morphTarget' + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {\n\n\t\t\t\t\tgeometry.deleteAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\nfunction WebGLObjects( gl, geometries, attributes, info ) {\n\n\tlet updateMap = new WeakMap();\n\n\tfunction update( object ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\tconst geometry = object.geometry;\n\t\tconst buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateMap.get( buffergeometry ) !== frame ) {\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateMap.set( buffergeometry, frame );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\tif ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {\n\n\t\t\t\tobject.addEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\t\t}\n\n\t\t\tattributes.update( object.instanceMatrix, 34962 );\n\n\t\t\tif ( object.instanceColor !== null ) {\n\n\t\t\t\tattributes.update( object.instanceColor, 34962 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateMap = new WeakMap();\n\n\t}\n\n\tfunction onInstancedMeshDispose( event ) {\n\n\t\tconst instancedMesh = event.target;\n\n\t\tinstancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\tattributes.remove( instancedMesh.instanceMatrix );\n\n\t\tif ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\nclass DataTexture2DArray extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\nclass DataTexture3D extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in DataTexture3D directly.\n\t\t//\n\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nDataTexture3D.prototype.isDataTexture3D = true;\n\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\nconst emptyTexture = new Texture();\nconst emptyTexture2dArray = new DataTexture2DArray();\nconst emptyTexture3d = new DataTexture3D();\nconst emptyCubeTexture = new CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array( 16 );\nconst mat3array = new Float32Array( 9 );\nconst mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tconst firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tconst n = nBlocks * blockSize;\n\tlet r = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( textures, n ) {\n\n\tlet r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\tr[ i ] = textures.allocateTextureUnit();\n\n\t}\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or THREE.MatrixN)\n\nfunction setValueM2( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM3( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM4( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single integer / boolean\n\nfunction setValueV1i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single integer / boolean vector (from flat array)\n\nfunction setValueV2i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform2iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV3i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform3iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV4i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform4iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\n// Single unsigned integer\n\nfunction setValueV1ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1ui( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single unsigned integer vector (from flat array)\n\nfunction setValueV2ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform2uiv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV3ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform3uiv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV4ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform4uiv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.safeSetTexture2D( v || emptyTexture, unit );\n\n}\n\nfunction setValueT3D1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture3D( v || emptyTexture3d, unit );\n\n}\n\nfunction setValueT6( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.safeSetTextureCube( v || emptyCubeTexture, unit );\n\n}\n\nfunction setValueT2DArray1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2DArray( v || emptyTexture2dArray, unit );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1f; // FLOAT\n\t\tcase 0x8b50: return setValueV2f; // _VEC2\n\t\tcase 0x8b51: return setValueV3f; // _VEC3\n\t\tcase 0x8b52: return setValueV4f; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2; // _MAT2\n\t\tcase 0x8b5b: return setValueM3; // _MAT3\n\t\tcase 0x8b5c: return setValueM4; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\n\n\t\tcase 0x1405: return setValueV1ui; // UINT\n\t\tcase 0x8dc6: return setValueV2ui; // _VEC2\n\t\tcase 0x8dc7: return setValueV3ui; // _VEC3\n\t\tcase 0x8dc8: return setValueV4ui; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3D1;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArray1;\n\n\t}\n\n}\n\n\n// Array of scalars\n\nfunction setValueV1fArray( gl, v ) {\n\n\tgl.uniform1fv( this.addr, v );\n\n}\n\n// Array of vectors (from flat array or array of THREE.VectorN)\n\nfunction setValueV2fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 2 );\n\n\tgl.uniform2fv( this.addr, data );\n\n}\n\nfunction setValueV3fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 3 );\n\n\tgl.uniform3fv( this.addr, data );\n\n}\n\nfunction setValueV4fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniform4fv( this.addr, data );\n\n}\n\n// Array of matrices (from flat array or array of THREE.MatrixN)\n\nfunction setValueM2Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n}\n\nfunction setValueM3Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 9 );\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n}\n\nfunction setValueM4Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 16 );\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n}\n\n// Array of integer / boolean\n\nfunction setValueV1iArray( gl, v ) {\n\n\tgl.uniform1iv( this.addr, v );\n\n}\n\n// Array of integer / boolean vectors (from flat array)\n\nfunction setValueV2iArray( gl, v ) {\n\n\tgl.uniform2iv( this.addr, v );\n\n}\n\nfunction setValueV3iArray( gl, v ) {\n\n\tgl.uniform3iv( this.addr, v );\n\n}\n\nfunction setValueV4iArray( gl, v ) {\n\n\tgl.uniform4iv( this.addr, v );\n\n}\n\n// Array of unsigned integer\n\nfunction setValueV1uiArray( gl, v ) {\n\n\tgl.uniform1uiv( this.addr, v );\n\n}\n\n// Array of unsigned integer vectors (from flat array)\n\nfunction setValueV2uiArray( gl, v ) {\n\n\tgl.uniform2uiv( this.addr, v );\n\n}\n\nfunction setValueV3uiArray( gl, v ) {\n\n\tgl.uniform3uiv( this.addr, v );\n\n}\n\nfunction setValueV4uiArray( gl, v ) {\n\n\tgl.uniform4uiv( this.addr, v );\n\n}\n\n\n// Array of textures (2D / Cube)\n\nfunction setValueT1Array( gl, v, textures ) {\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tgl.uniform1iv( this.addr, units );\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6Array( gl, v, textures ) {\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tgl.uniform1iv( this.addr, units );\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1fArray; // FLOAT\n\t\tcase 0x8b50: return setValueV2fArray; // _VEC2\n\t\tcase 0x8b51: return setValueV3fArray; // _VEC3\n\t\tcase 0x8b52: return setValueV4fArray; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2Array; // _MAT2\n\t\tcase 0x8b5b: return setValueM3Array; // _MAT3\n\t\tcase 0x8b5c: return setValueM4Array; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\n\n\t\tcase 0x1405: return setValueV1uiArray; // UINT\n\t\tcase 0x8dc6: return setValueV2uiArray; // _VEC2\n\t\tcase 0x8dc7: return setValueV3uiArray; // _VEC3\n\t\tcase 0x8dc8: return setValueV4uiArray; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1Array;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6Array;\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nfunction SingleUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.size = activeInfo.size;\n\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nPureArrayUniform.prototype.updateCache = function ( data ) {\n\n\tconst cache = this.cache;\n\n\tif ( data instanceof Float32Array && cache.length !== data.length ) {\n\n\t\tthis.cache = new Float32Array( data.length );\n\n\t}\n\n\tcopyArray( cache, data );\n\n};\n\nfunction StructuredUniform( id ) {\n\n\tthis.id = id;\n\n\tthis.seq = [];\n\tthis.map = {};\n\n}\n\nStructuredUniform.prototype.setValue = function ( gl, value, textures ) {\n\n\tconst seq = this.seq;\n\n\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tconst u = seq[ i ];\n\t\tu.setValue( gl, value[ u.id ], textures );\n\n\t}\n\n};\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tconst path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tconst match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex;\n\n\t\tlet id = match[ 1 ];\n\t\tconst idIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tconst map = container.map;\n\t\t\tlet next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nfunction WebGLUniforms( gl, program ) {\n\n\tthis.seq = [];\n\tthis.map = {};\n\n\tconst n = gl.getProgramParameter( program, 35718 );\n\n\tfor ( let i = 0; i < n; ++ i ) {\n\n\t\tconst info = gl.getActiveUniform( program, i ),\n\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\tparseUniform( info, addr, this );\n\n\t}\n\n}\n\nWebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {\n\n\tconst u = this.map[ name ];\n\n\tif ( u !== undefined ) u.setValue( gl, value, textures );\n\n};\n\nWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\n\n\tconst v = object[ name ];\n\n\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n};\n\n\n// Static interface\n\nWebGLUniforms.upload = function ( gl, seq, values, textures ) {\n\n\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tconst u = seq[ i ],\n\t\t\tv = values[ u.id ];\n\n\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\tu.setValue( gl, v.value, textures );\n\n\t\t}\n\n\t}\n\n};\n\nWebGLUniforms.seqWithValue = function ( seq, values ) {\n\n\tconst r = [];\n\n\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tconst u = seq[ i ];\n\t\tif ( u.id in values ) r.push( u );\n\n\t}\n\n\treturn r;\n\n};\n\nfunction WebGLShader( gl, type, string ) {\n\n\tconst shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\treturn shader;\n\n}\n\nlet programIdCount = 0;\n\nfunction addLineNumbers( string ) {\n\n\tconst lines = string.split( '\\n' );\n\n\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t}\n\n\treturn lines.join( '\\n' );\n\n}\n\nfunction getEncodingComponents( encoding ) {\n\n\tswitch ( encoding ) {\n\n\t\tcase LinearEncoding:\n\t\t\treturn [ 'Linear', '( value )' ];\n\t\tcase sRGBEncoding:\n\t\t\treturn [ 'sRGB', '( value )' ];\n\t\tcase RGBEEncoding:\n\t\t\treturn [ 'RGBE', '( value )' ];\n\t\tcase RGBM7Encoding:\n\t\t\treturn [ 'RGBM', '( value, 7.0 )' ];\n\t\tcase RGBM16Encoding:\n\t\t\treturn [ 'RGBM', '( value, 16.0 )' ];\n\t\tcase RGBDEncoding:\n\t\t\treturn [ 'RGBD', '( value, 256.0 )' ];\n\t\tcase GammaEncoding:\n\t\t\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\n\t\tcase LogLuvEncoding:\n\t\t\treturn [ 'LogLuv', '( value )' ];\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );\n\t\t\treturn [ 'Linear', '( value )' ];\n\n\t}\n\n}\n\nfunction getShaderErrors( gl, shader, type ) {\n\n\tconst status = gl.getShaderParameter( shader, 35713 );\n\tconst log = gl.getShaderInfoLog( shader ).trim();\n\n\tif ( status && log === '' ) return '';\n\n\t// --enable-privileged-webgl-extension\n\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\tconst source = gl.getShaderSource( shader );\n\n\treturn 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers( source );\n\n}\n\nfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\tconst components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\n\n}\n\nfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\tconst components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tlet toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase CineonToneMapping:\n\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\tbreak;\n\n\t\tcase ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tcase CustomToneMapping:\n\t\t\ttoneMappingName = 'Custom';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );\n\t\t\ttoneMappingName = 'Linear';\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nfunction generateExtensions( parameters ) {\n\n\tconst chunks = [\n\t\t( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tconst chunks = [];\n\n\tfor ( const name in defines ) {\n\n\t\tconst value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tconst attributes = {};\n\n\tconst n = gl.getProgramParameter( program, 35721 );\n\n\tfor ( let i = 0; i < n; i ++ ) {\n\n\t\tconst info = gl.getActiveAttrib( program, i );\n\t\tconst name = info.name;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )\n\t\t.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )\n\t\t.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\n// Resolve Includes\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes( string ) {\n\n\treturn string.replace( includePattern, includeReplacer );\n\n}\n\nfunction includeReplacer( match, include ) {\n\n\tconst string = ShaderChunk[ include ];\n\n\tif ( string === undefined ) {\n\n\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t}\n\n\treturn resolveIncludes( string );\n\n}\n\n// Unroll Loops\n\nconst deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops( string ) {\n\n\treturn string\n\t\t.replace( unrollLoopPattern, loopReplacer )\n\t\t.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );\n\n}\n\nfunction deprecatedLoopReplacer( match, start, end, snippet ) {\n\n\tconsole.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );\n\treturn loopReplacer( match, start, end, snippet );\n\n}\n\nfunction loopReplacer( match, start, end, snippet ) {\n\n\tlet string = '';\n\n\tfor ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\tstring += snippet\n\t\t\t.replace( /\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]' )\n\t\t\t.replace( /UNROLLED_LOOP_INDEX/g, i );\n\n\t}\n\n\treturn string;\n\n}\n\n//\n\nfunction generatePrecision( parameters ) {\n\n\tlet precisionstring = 'precision ' + parameters.precision + ' float;\\nprecision ' + parameters.precision + ' int;';\n\n\tif ( parameters.precision === 'highp' ) {\n\n\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\n\t} else if ( parameters.precision === 'mediump' ) {\n\n\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\n\t} else if ( parameters.precision === 'lowp' ) {\n\n\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\n\t}\n\n\treturn precisionstring;\n\n}\n\nfunction generateShadowMapTypeDefine( parameters ) {\n\n\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t} else if ( parameters.shadowMapType === VSMShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\n\t}\n\n\treturn shadowMapTypeDefine;\n\n}\n\nfunction generateEnvMapTypeDefine( parameters ) {\n\n\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeReflectionMapping:\n\t\t\tcase CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase CubeUVReflectionMapping:\n\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapTypeDefine;\n\n}\n\nfunction generateEnvMapModeDefine( parameters ) {\n\n\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeRefractionMapping:\n\t\t\tcase CubeUVRefractionMapping:\n\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapModeDefine;\n\n}\n\nfunction generateEnvMapBlendingDefine( parameters ) {\n\n\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.combine ) {\n\n\t\t\tcase MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapBlendingDefine;\n\n}\n\nfunction WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {\n\n\tconst gl = renderer.getContext();\n\n\tconst defines = parameters.defines;\n\n\tlet vertexShader = parameters.vertexShader;\n\tlet fragmentShader = parameters.fragmentShader;\n\n\tconst shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );\n\tconst envMapTypeDefine = generateEnvMapTypeDefine( parameters );\n\tconst envMapModeDefine = generateEnvMapModeDefine( parameters );\n\tconst envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );\n\n\n\tconst gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\tconst customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );\n\n\tconst customDefines = generateDefines( defines );\n\n\tconst program = gl.createProgram();\n\n\tlet prefixVertex, prefixFragment;\n\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\tif ( parameters.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.instancing ? '#define USE_INSTANCING' : '',\n\t\t\tparameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',\n\n\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',\n\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\n\t\t\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUvs ? '#define USE_UV' : '',\n\t\t\tparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t'#ifdef USE_INSTANCING',\n\n\t\t\t'\tattribute mat4 instanceMatrix;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_COLOR',\n\n\t\t\t'\tattribute vec3 instanceColor;',\n\n\t\t\t'#endif',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_TANGENT',\n\n\t\t\t'\tattribute vec4 tangent;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if defined( USE_COLOR_ALPHA )',\n\n\t\t\t'\tattribute vec4 color;',\n\n\t\t\t'#elif defined( USE_COLOR )',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t'\t#else',\n\n\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t'\t#endif',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\n\t\t\tparameters.sheen ? '#define USE_SHEEN' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\n\t\t\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUvs ? '#define USE_UV' : '',\n\t\t\tparameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\n\t\t\tShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tparameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\tparameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',\n\t\t\tparameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\tparameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\tparameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',\n\t\t\tgetTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),\n\n\t\t\tparameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = resolveIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = resolveIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {\n\n\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\n\t\tversionString = '#version 300 es\\n';\n\n\t\tprefixVertex = [\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#define varying in',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tconst glVertexShader = WebGLShader( gl, 35633, vertexGlsl );\n\tconst glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( parameters.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, parameters.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\t// check for link errors\n\tif ( renderer.debug.checkShaderErrors ) {\n\n\t\tconst programLog = gl.getProgramInfoLog( program ).trim();\n\t\tconst vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\tconst fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\tlet runnable = true;\n\t\tlet haveDiagnostics = true;\n\n\t\tif ( gl.getProgramParameter( program, 35714 ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconst vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\tconst fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// Clean up\n\n\t// Crashes in iOS9 and iOS10. #18402\n\t// gl.detachShader( program, glVertexShader );\n\t// gl.detachShader( program, glFragmentShader );\n\n\tgl.deleteShader( glVertexShader );\n\tgl.deleteShader( glFragmentShader );\n\n\t// set up caching for uniform locations\n\n\tlet cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\tcachedUniforms = new WebGLUniforms( gl, program );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tlet cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tbindingStates.releaseStatesOfProgram( this );\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t//\n\n\tthis.name = parameters.shaderName;\n\tthis.id = programIdCount ++;\n\tthis.cacheKey = cacheKey;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\nfunction WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {\n\n\tconst programs = [];\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\tconst floatVertexTextures = capabilities.floatVertexTextures;\n\tconst maxVertexUniforms = capabilities.maxVertexUniforms;\n\tconst vertexTextures = capabilities.vertexTextures;\n\n\tlet precision = capabilities.precision;\n\n\tconst shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'toon',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tconst parameterNames = [\n\t\t'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',\n\t\t'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',\n\t\t'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',\n\t\t'roughnessMap', 'metalnessMap', 'gradientMap',\n\t\t'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',\n\t\t'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',\n\t\t'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',\n\t\t'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',\n\t\t'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',\n\t\t'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',\n\t\t'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',\n\t\t'sheen', 'transmissionMap'\n\t];\n\n\tfunction getMaxBones( object ) {\n\n\t\tconst skeleton = object.skeleton;\n\t\tconst bones = skeleton.bones;\n\n\t\tif ( floatVertexTextures ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tconst nVertexUniforms = maxVertexUniforms;\n\t\t\tconst nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tconst maxBones = Math.min( nVertexMatrices, bones.length );\n\n\t\t\tif ( maxBones < bones.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map ) {\n\n\t\tlet encoding;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\\'t use render targets as textures. Use their .texture property instead.' );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t} else {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tfunction getParameters( material, lights, shadows, scene, object ) {\n\n\t\tconst fog = scene.fog;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\n\t\tconst envMap = cubemaps.get( material.envMap || environment );\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tconst maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet vertexShader, fragmentShader;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\n\t\t\tvertexShader = shader.vertexShader;\n\t\t\tfragmentShader = shader.fragmentShader;\n\n\t\t} else {\n\n\t\t\tvertexShader = material.vertexShader;\n\t\t\tfragmentShader = material.fragmentShader;\n\n\t\t}\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tconst parameters = {\n\n\t\t\tisWebGL2: isWebGL2,\n\n\t\t\tshaderID: shaderID,\n\t\t\tshaderName: material.type,\n\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tdefines: material.defines,\n\n\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\tglslVersion: material.glslVersion,\n\n\t\t\tprecision: precision,\n\n\t\t\tinstancing: object.isInstancedMesh === true,\n\t\t\tinstancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n\n\t\t\tsupportsVertexTextures: vertexTextures,\n\t\t\toutputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map ),\n\t\t\tmatcap: !! material.matcap,\n\t\t\tmatcapEncoding: getTextureEncodingFromMap( material.matcap ),\n\t\t\tenvMap: !! envMap,\n\t\t\tenvMapMode: envMap && envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( envMap ),\n\t\t\tenvMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\tlightMapEncoding: getTextureEncodingFromMap( material.lightMap ),\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n\t\t\ttangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n\t\t\tclearcoatMap: !! material.clearcoatMap,\n\t\t\tclearcoatRoughnessMap: !! material.clearcoatRoughnessMap,\n\t\t\tclearcoatNormalMap: !! material.clearcoatNormalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tgradientMap: !! material.gradientMap,\n\n\t\t\tsheen: !! material.sheen,\n\n\t\t\ttransmissionMap: !! material.transmissionMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexTangents: ( material.normalMap && material.vertexTangents ),\n\t\t\tvertexColors: material.vertexColors,\n\t\t\tvertexAlphas: material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n\t\t\tvertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,\n\t\t\tuvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp2: ( fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: !! material.flatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning && maxBones > 0,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: floatVertexTextures,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\n\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\tnumClipIntersection: clipping.numIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\tflipSided: material.side === BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,\n\n\t\t\tindex0AttributeName: material.index0AttributeName,\n\n\t\t\textensionDerivatives: material.extensions && material.extensions.derivatives,\n\t\t\textensionFragDepth: material.extensions && material.extensions.fragDepth,\n\t\t\textensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n\t\t\textensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n\n\t\t\trendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),\n\t\t\trendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),\n\t\t\trendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),\n\n\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\n\t\t};\n\n\t\treturn parameters;\n\n\t}\n\n\tfunction getProgramCacheKey( parameters ) {\n\n\t\tconst array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( parameters.fragmentShader );\n\t\t\tarray.push( parameters.vertexShader );\n\n\t\t}\n\n\t\tif ( parameters.defines !== undefined ) {\n\n\t\t\tfor ( const name in parameters.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( parameters.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parameters.isRawShaderMaterial === false ) {\n\n\t\t\tfor ( let i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\tarray.push( renderer.outputEncoding );\n\t\t\tarray.push( renderer.gammaFactor );\n\n\t\t}\n\n\t\tarray.push( parameters.customProgramCacheKey );\n\n\t\treturn array.join();\n\n\t}\n\n\tfunction getUniforms( material ) {\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\t\tlet uniforms;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\t\t\tuniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t} else {\n\n\t\t\tuniforms = material.uniforms;\n\n\t\t}\n\n\t\treturn uniforms;\n\n\t}\n\n\tfunction acquireProgram( parameters, cacheKey ) {\n\n\t\tlet program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( let p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tconst preexistingProgram = programs[ p ];\n\n\t\t\tif ( preexistingProgram.cacheKey === cacheKey ) {\n\n\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\tfunction releaseProgram( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tconst i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tgetParameters: getParameters,\n\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\tgetUniforms: getUniforms,\n\t\tacquireProgram: acquireProgram,\n\t\treleaseProgram: releaseProgram,\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tprograms: programs\n\t};\n\n}\n\nfunction WebGLProperties() {\n\n\tlet properties = new WeakMap();\n\n\tfunction get( object ) {\n\n\t\tlet map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.program !== b.program ) {\n\n\t\treturn a.program.id - b.program.id;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList( properties ) {\n\n\tconst renderItems = [];\n\tlet renderItemsIndex = 0;\n\n\tconst opaque = [];\n\tconst transparent = [];\n\n\tconst defaultProgram = { id: - 1 };\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tlet renderItem = renderItems[ renderItemsIndex ];\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tprogram: materialProperties.program || defaultProgram,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.program = materialProperties.program || defaultProgram;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\t( material.transparent === true ? transparent : opaque ).push( renderItem );\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\t( material.transparent === true ? transparent : opaque ).unshift( renderItem );\n\n\t}\n\n\tfunction sort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfunction finish() {\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.program = null;\n\t\t\trenderItem.group = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\topaque: opaque,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\t\tfinish: finish,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists( properties ) {\n\n\tlet lists = new WeakMap();\n\n\tfunction get( scene, renderCallDepth ) {\n\n\t\tlet list;\n\n\t\tif ( lists.has( scene ) === false ) {\n\n\t\t\tlist = new WebGLRenderList( properties );\n\t\t\tlists.set( scene, [ list ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= lists.get( scene ).length ) {\n\n\t\t\t\tlist = new WebGLRenderList( properties );\n\t\t\t\tlists.get( scene ).push( list );\n\n\t\t\t} else {\n\n\t\t\t\tlist = lists.get( scene )[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction UniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nfunction ShadowUniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\n\n\nlet nextVersion = 0;\n\nfunction shadowCastingLightsFirst( lightA, lightB ) {\n\n\treturn ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );\n\n}\n\nfunction WebGLLights( extensions, capabilities ) {\n\n\tconst cache = new UniformsCache();\n\n\tconst shadowCache = ShadowUniformsCache();\n\n\tconst state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\n\t\t\tnumDirectionalShadows: - 1,\n\t\t\tnumPointShadows: - 1,\n\t\t\tnumSpotShadows: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadow: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadow: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\trectArea: [],\n\t\trectAreaLTC1: null,\n\t\trectAreaLTC2: null,\n\t\tpoint: [],\n\t\tpointShadow: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: []\n\n\t};\n\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\n\n\tconst vector3 = new Vector3();\n\tconst matrix4 = new Matrix4();\n\tconst matrix42 = new Matrix4();\n\n\tfunction setup( lights ) {\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tlet numDirectionalShadows = 0;\n\t\tlet numPointShadows = 0;\n\t\tlet numSpotShadows = 0;\n\n\t\tlights.sort( shadowCastingLightsFirst );\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tconst color = light.color;\n\t\t\tconst intensity = light.intensity;\n\t\t\tconst distance = light.distance;\n\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumDirectionalShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumSpotShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\t// (a) intensity is the total visible light emitted\n\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\n\t\t\t\t// (b) intensity is the brightness of the light\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumPointShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( rectAreaLength > 0 ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t// WebGL 2\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t} else {\n\n\t\t\t\t// WebGL 1\n\n\t\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t\t} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tconst hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\n\t\t\thash.numPointShadows !== numPointShadows ||\n\t\t\thash.numSpotShadows !== numSpotShadows ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\tstate.spotShadowMatrix.length = numSpotShadows;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\thash.numPointShadows = numPointShadows;\n\t\t\thash.numSpotShadows = numSpotShadows;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\tfunction setupView( lights, camera ) {\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = state.point[ pointLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tsetupView: setupView,\n\t\tstate: state\n\t};\n\n}\n\nfunction WebGLRenderState( extensions, capabilities ) {\n\n\tconst lights = new WebGLLights( extensions, capabilities );\n\n\tconst lightsArray = [];\n\tconst shadowsArray = [];\n\n\tfunction init() {\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights() {\n\n\t\tlights.setup( lightsArray );\n\n\t}\n\n\tfunction setupLightsView( camera ) {\n\n\t\tlights.setupView( lightsArray, camera );\n\n\t}\n\n\tconst state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tlights: lights\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\t\tsetupLightsView: setupLightsView,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates( extensions, capabilities ) {\n\n\tlet renderStates = new WeakMap();\n\n\tfunction get( scene, renderCallDepth = 0 ) {\n\n\t\tlet renderState;\n\n\t\tif ( renderStates.has( scene ) === false ) {\n\n\t\t\trenderState = new WebGLRenderState( extensions, capabilities );\n\t\t\trenderStates.set( scene, [ renderState ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= renderStates.get( scene ).length ) {\n\n\t\t\t\trenderState = new WebGLRenderState( extensions, capabilities );\n\t\t\t\trenderStates.get( scene ).push( renderState );\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStates.get( scene )[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n/**\n * parameters = {\n *\n *  referencePosition: <float>,\n *  nearDistance: <float>,\n *  farDistance: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>\n *\n * }\n */\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.referencePosition = new Vector3();\n\t\tthis.nearDistance = 1;\n\t\tthis.farDistance = 1000;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.fog = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.referencePosition.copy( source.referencePosition );\n\t\tthis.nearDistance = source.nearDistance;\n\t\tthis.farDistance = source.farDistance;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\nvar vsm_frag = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\\n\\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean * HALF_SAMPLE_RATE;\\n\\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\nvar vsm_vert = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\nfunction WebGLShadowMap( _renderer, _objects, _capabilities ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterials = [],\n\t\t_distanceMaterials = [],\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = _capabilities.maxTextureSize;\n\n\tconst shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\n\t\tdefines: {\n\t\t\tSAMPLE_RATE: 2.0 / 8.0,\n\t\t\tHALF_SAMPLE_RATE: 1.0 / 8.0\n\t\t},\n\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vsm_vert,\n\n\t\tfragmentShader: vsm_frag\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\tconst _state = _renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\n\n\t\t\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tconst pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t_renderer.setRenderTarget( shadow.map );\n\t\t\t_renderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\tscope.needsUpdate = false;\n\n\t\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = _objects.update( fullScreenMesh );\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.mapPass );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.map );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {\n\n\t\tconst index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n\n\t\tlet material = _depthMaterials[ index ];\n\n\t\tif ( material === undefined ) {\n\n\t\t\tmaterial = new MeshDepthMaterial( {\n\n\t\t\t\tdepthPacking: RGBADepthPacking,\n\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning\n\n\t\t\t} );\n\n\t\t\t_depthMaterials[ index ] = material;\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tfunction getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {\n\n\t\tconst index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n\n\t\tlet material = _distanceMaterials[ index ];\n\n\t\tif ( material === undefined ) {\n\n\t\t\tmaterial = new MeshDistanceMaterial( {\n\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning\n\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ index ] = material;\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tfunction getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {\n\n\t\tlet result = null;\n\n\t\tlet getMaterialVariant = getDepthMaterialVariant;\n\t\tlet customMaterial = object.customDepthMaterial;\n\n\t\tif ( light.isPointLight === true ) {\n\n\t\t\tgetMaterialVariant = getDistanceMaterialVariant;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( customMaterial === undefined ) {\n\n\t\t\tlet useMorphing = false;\n\n\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t}\n\n\t\t\tlet useSkinning = false;\n\n\t\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\t\tif ( material.skinning === true ) {\n\n\t\t\t\t\tuseSkinning = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst useInstancing = object.isInstancedMesh === true;\n\n\t\t\tresult = getMaterialVariant( useMorphing, useSkinning, useInstancing );\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\tmaterial.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tresult.referencePosition.setFromMatrixPosition( light.matrixWorld );\n\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\tresult.farDistance = shadowCameraFar;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = _objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n}\n\nfunction WebGLState( gl, extensions, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tfunction ColorBuffer() {\n\n\t\tlet locked = false;\n\n\t\tconst color = new Vector4();\n\t\tlet currentColorMask = null;\n\t\tconst currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentDepthMask = null;\n\t\tlet currentDepthFunc = null;\n\t\tlet currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( 2929 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( 2929 );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 512 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 519 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 513 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 514 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 518 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 516 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 517 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentStencilMask = null;\n\t\tlet currentStencilFunc = null;\n\t\tlet currentStencilRef = null;\n\t\tlet currentStencilFuncMask = null;\n\t\tlet currentStencilFail = null;\n\t\tlet currentStencilZFail = null;\n\t\tlet currentStencilZPass = null;\n\t\tlet currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( ! locked ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( 2960 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( 2960 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef !== stencilRef ||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail !== stencilFail ||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tconst colorBuffer = new ColorBuffer();\n\tconst depthBuffer = new DepthBuffer();\n\tconst stencilBuffer = new StencilBuffer();\n\n\tlet enabledCapabilities = {};\n\n\tlet xrFramebuffer = null;\n\tlet currentBoundFramebuffers = {};\n\n\tlet currentProgram = null;\n\n\tlet currentBlendingEnabled = false;\n\tlet currentBlending = null;\n\tlet currentBlendEquation = null;\n\tlet currentBlendSrc = null;\n\tlet currentBlendDst = null;\n\tlet currentBlendEquationAlpha = null;\n\tlet currentBlendSrcAlpha = null;\n\tlet currentBlendDstAlpha = null;\n\tlet currentPremultipledAlpha = false;\n\n\tlet currentFlipSided = null;\n\tlet currentCullFace = null;\n\n\tlet currentLineWidth = null;\n\n\tlet currentPolygonOffsetFactor = null;\n\tlet currentPolygonOffsetUnits = null;\n\n\tconst maxTextures = gl.getParameter( 35661 );\n\n\tlet lineWidthAvailable = false;\n\tlet version = 0;\n\tconst glVersion = gl.getParameter( 7938 );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL ES (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tlet currentTextureSlot = null;\n\tlet currentBoundTextures = {};\n\n\tconst currentScissor = new Vector4( 0, 0, gl.canvas.width, gl.canvas.height );\n\tconst currentViewport = new Vector4( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tconst data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tconst texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, 10241, 9728 );\n\t\tgl.texParameteri( type, 10240, 9728 );\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tconst emptyTextures = {};\n\temptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );\n\temptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( 2929 );\n\tdepthBuffer.setFunc( LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( CullFaceBack );\n\tenable( 2884 );\n\n\tsetBlending( NoBlending );\n\n\t//\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction bindXRFramebuffer( framebuffer ) {\n\n\t\tif ( framebuffer !== xrFramebuffer ) {\n\n\t\t\tgl.bindFramebuffer( 36160, framebuffer );\n\n\t\t\txrFramebuffer = framebuffer;\n\n\t\t}\n\n\t}\n\n\tfunction bindFramebuffer( target, framebuffer ) {\n\n\t\tif ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t}\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tconst equationToGL = {\n\t\t[ AddEquation ]: 32774,\n\t\t[ SubtractEquation ]: 32778,\n\t\t[ ReverseSubtractEquation ]: 32779\n\t};\n\n\tif ( isWebGL2 ) {\n\n\t\tequationToGL[ MinEquation ] = 32775;\n\t\tequationToGL[ MaxEquation ] = 32776;\n\n\t} else {\n\n\t\tconst extension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tequationToGL[ MinEquation ] = extension.MIN_EXT;\n\t\t\tequationToGL[ MaxEquation ] = extension.MAX_EXT;\n\n\t\t}\n\n\t}\n\n\tconst factorToGL = {\n\t\t[ ZeroFactor ]: 0,\n\t\t[ OneFactor ]: 1,\n\t\t[ SrcColorFactor ]: 768,\n\t\t[ SrcAlphaFactor ]: 770,\n\t\t[ SrcAlphaSaturateFactor ]: 776,\n\t\t[ DstColorFactor ]: 774,\n\t\t[ DstAlphaFactor ]: 772,\n\t\t[ OneMinusSrcColorFactor ]: 769,\n\t\t[ OneMinusSrcAlphaFactor ]: 771,\n\t\t[ OneMinusDstColorFactor ]: 775,\n\t\t[ OneMinusDstAlphaFactor ]: 773\n\t};\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled === true ) {\n\n\t\t\t\tdisable( 3042 );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( currentBlendingEnabled === false ) {\n\n\t\t\tenable( 3042 );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( 32774 );\n\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 1, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 0, 769, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 768, 0, 770 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 770, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 770, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 769 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 768 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = null;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? disable( 2884 )\n\t\t\t: enable( 2884 );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? setBlending( NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tstencilBuffer.setTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( material.stencilWriteMask );\n\t\t\tstencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tstencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true\n\t\t\t? enable( 32926 )\n\t\t\t: disable( 32926 );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( 2304 );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( 2305 );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tenable( 2884 );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( 1029 );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( 1028 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( 1032 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 2884 );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( 32823 );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 32823 );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( 3089 );\n\n\t\t} else {\n\n\t\t\tdisable( 3089 );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\tactiveTexture();\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction unbindTexture() {\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\t// reset state\n\n\t\tgl.disable( 3042 );\n\t\tgl.disable( 2884 );\n\t\tgl.disable( 2929 );\n\t\tgl.disable( 32823 );\n\t\tgl.disable( 3089 );\n\t\tgl.disable( 2960 );\n\t\tgl.disable( 32926 );\n\n\t\tgl.blendEquation( 32774 );\n\t\tgl.blendFunc( 1, 0 );\n\t\tgl.blendFuncSeparate( 1, 0, 1, 0 );\n\n\t\tgl.colorMask( true, true, true, true );\n\t\tgl.clearColor( 0, 0, 0, 0 );\n\n\t\tgl.depthMask( true );\n\t\tgl.depthFunc( 513 );\n\t\tgl.clearDepth( 1 );\n\n\t\tgl.stencilMask( 0xffffffff );\n\t\tgl.stencilFunc( 519, 0, 0xffffffff );\n\t\tgl.stencilOp( 7680, 7680, 7680 );\n\t\tgl.clearStencil( 0 );\n\n\t\tgl.cullFace( 1029 );\n\t\tgl.frontFace( 2305 );\n\n\t\tgl.polygonOffset( 0, 0 );\n\n\t\tgl.activeTexture( 33984 );\n\n\t\tgl.bindFramebuffer( 36160, null );\n\n\t\tif ( isWebGL2 === true ) {\n\n\t\t\tgl.bindFramebuffer( 36009, null );\n\t\t\tgl.bindFramebuffer( 36008, null );\n\n\t\t}\n\n\t\tgl.useProgram( null );\n\n\t\tgl.lineWidth( 1 );\n\n\t\tgl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tgl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\t// reset internals\n\n\t\tenabledCapabilities = {};\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\txrFramebuffer = null;\n\t\tcurrentBoundFramebuffers = {};\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlendingEnabled = false;\n\t\tcurrentBlending = null;\n\t\tcurrentBlendEquation = null;\n\t\tcurrentBlendSrc = null;\n\t\tcurrentBlendDst = null;\n\t\tcurrentBlendEquationAlpha = null;\n\t\tcurrentBlendSrcAlpha = null;\n\t\tcurrentBlendDstAlpha = null;\n\t\tcurrentPremultipledAlpha = false;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcurrentLineWidth = null;\n\n\t\tcurrentPolygonOffsetFactor = null;\n\t\tcurrentPolygonOffsetUnits = null;\n\n\t\tcurrentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tcurrentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tenable: enable,\n\t\tdisable: disable,\n\n\t\tbindFramebuffer: bindFramebuffer,\n\t\tbindXRFramebuffer: bindXRFramebuffer,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tunbindTexture: unbindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\tconst maxTextures = capabilities.maxTextures;\n\tconst maxCubemapSize = capabilities.maxCubemapSize;\n\tconst maxTextureSize = capabilities.maxTextureSize;\n\tconst maxSamples = capabilities.maxSamples;\n\n\tconst _videoTextures = new WeakMap();\n\tlet _canvas;\n\n\t// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\tlet useOffscreenCanvas = false;\n\n\ttry {\n\n\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'\n\t\t\t&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;\n\n\t} catch ( err ) {\n\n\t\t// Ignore any errors\n\n\t}\n\n\tfunction createCanvas( width, height ) {\n\n\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\n\t\treturn useOffscreenCanvas ?\n\t\t\tnew OffscreenCanvas( width, height ) :\n\t\t\tdocument.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t}\n\n\tfunction resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {\n\n\t\tlet scale = 1;\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( image.width, image.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 || needsPowerOfTwo === true ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t\tconst floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;\n\n\t\t\t\tconst width = floor( scale * image.width );\n\t\t\t\tconst height = floor( scale * image.height );\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tconst canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( isWebGL2 ) return false;\n\n\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture, supportsMips ) {\n\n\t\treturn texture.generateMipmaps && supportsMips &&\n\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t}\n\n\tfunction generateMipmap( target, texture, width, height ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\ttextureProperties.__maxMipLevel = Math.log2( Math.max( width, height ) );\n\n\t}\n\n\tfunction getInternalFormat( internalFormatName, glFormat, glType ) {\n\n\t\tif ( isWebGL2 === false ) return glFormat;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === 6403 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 33326;\n\t\t\tif ( glType === 5131 ) internalFormat = 33325;\n\t\t\tif ( glType === 5121 ) internalFormat = 33321;\n\n\t\t}\n\n\t\tif ( glFormat === 6407 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34837;\n\t\t\tif ( glType === 5131 ) internalFormat = 34843;\n\t\t\tif ( glType === 5121 ) internalFormat = 32849;\n\n\t\t}\n\n\t\tif ( glFormat === 6408 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34836;\n\t\t\tif ( glType === 5131 ) internalFormat = 34842;\n\t\t\tif ( glType === 5121 ) internalFormat = 32856;\n\n\t\t}\n\n\t\tif ( internalFormat === 33325 || internalFormat === 33326 ||\n\t\t\tinternalFormat === 34842 || internalFormat === 34836 ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback( f ) {\n\n\t\tif ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {\n\n\t\t\treturn 9728;\n\n\t\t}\n\n\t\treturn 9729;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\t_videoTextures.delete( texture );\n\n\t\t}\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tconst renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\t\tif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );\n\n\t\t}\n\n\t\tproperties.remove( texture );\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\tlet textureUnits = 0;\n\n\tfunction resetTextureUnits() {\n\n\t\ttextureUnits = 0;\n\n\t}\n\n\tfunction allocateTextureUnit() {\n\n\t\tconst textureUnit = textureUnits;\n\n\t\tif ( textureUnit >= maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );\n\n\t\t}\n\n\t\ttextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\t//\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tconst image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 3553, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTexture2DArray( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 35866, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 32879, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadCubeTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\n\t}\n\n\tconst wrappingToGL = {\n\t\t[ RepeatWrapping ]: 10497,\n\t\t[ ClampToEdgeWrapping ]: 33071,\n\t\t[ MirroredRepeatWrapping ]: 33648\n\t};\n\n\tconst filterToGL = {\n\t\t[ NearestFilter ]: 9728,\n\t\t[ NearestMipmapNearestFilter ]: 9984,\n\t\t[ NearestMipmapLinearFilter ]: 9986,\n\n\t\t[ LinearFilter ]: 9729,\n\t\t[ LinearMipmapNearestFilter ]: 9985,\n\t\t[ LinearMipmapLinearFilter ]: 9987\n\t};\n\n\tfunction setTextureParameters( textureType, texture, supportsMips ) {\n\n\t\tif ( supportsMips ) {\n\n\t\t\t_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );\n\t\t\t_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );\n\n\t\t\tif ( textureType === 32879 || textureType === 35866 ) {\n\n\t\t\t\t_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );\n\t\t\t_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, 10242, 33071 );\n\t\t\t_gl.texParameteri( textureType, 10243, 33071 );\n\n\t\t\tif ( textureType === 32879 || textureType === 35866 ) {\n\n\t\t\t\t_gl.texParameteri( textureType, 32882, 33071 );\n\n\t\t\t}\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\t\t\tif ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initTexture( textureProperties, texture ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tlet textureType = 3553;\n\n\t\tif ( texture.isDataTexture2DArray ) textureType = 35866;\n\t\tif ( texture.isDataTexture3D ) textureType = 32879;\n\n\t\tinitTexture( textureProperties, texture );\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( 37440, texture.flipY );\n\t\t_gl.pixelStorei( 37441, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, texture.unpackAlignment );\n\t\t_gl.pixelStorei( 37443, 0 );\n\n\t\tconst needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;\n\t\tconst image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );\n\n\t\tconst supportsMips = isPowerOfTwo( image ) || isWebGL2,\n\t\t\tglFormat = utils.convert( texture.format );\n\n\t\tlet glType = utils.convert( texture.type ),\n\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\tsetTextureParameters( textureType, texture, supportsMips );\n\n\t\tlet mipmap;\n\t\tconst mipmaps = texture.mipmaps;\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tglInternalFormat = 6402;\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tglInternalFormat = 36012;\n\n\t\t\t\t} else if ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\tglInternalFormat = 33190;\n\n\t\t\t\t} else if ( texture.type === UnsignedInt248Type ) {\n\n\t\t\t\t\tglInternalFormat = 35056;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tconsole.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// validation checks for WebGL 1\n\n\t\t\tif ( texture.format === DepthFormat && glInternalFormat === 6402 ) {\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tglInternalFormat = 34041;\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t} else if ( texture.isDataTexture2DArray ) {\n\n\t\t\tstate.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t} else if ( texture.isDataTexture3D ) {\n\n\t\t\tstate.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\tgenerateMipmap( textureType, texture, image.width, image.height );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\tfunction uploadCubeTexture( textureProperties, texture, slot ) {\n\n\t\tif ( texture.image.length !== 6 ) return;\n\n\t\tinitTexture( textureProperties, texture );\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( 37440, texture.flipY );\n\t\t_gl.pixelStorei( 37441, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, texture.unpackAlignment );\n\t\t_gl.pixelStorei( 37443, 0 );\n\n\t\tconst isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );\n\t\tconst isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\tconst cubeImage = [];\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );\n\n\t\t\t} else {\n\n\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst image = cubeImage[ 0 ],\n\t\t\tsupportsMips = isPowerOfTwo( image ) || isWebGL2,\n\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\tglType = utils.convert( texture.type ),\n\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\tsetTextureParameters( 34067, texture, supportsMips );\n\n\t\tlet mipmaps;\n\n\t\tif ( isCompressed ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tmipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t} else {\n\n\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\t\t\tconst mipmapImage = mipmap.image[ i ].image;\n\n\t\t\t\t\t\tstate.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\tstate.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length;\n\n\t\t}\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t// We assume images for cube map have the same size.\n\t\t\tgenerateMipmap( 34067, texture, image.width, image.height );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst glFormat = utils.convert( texture.format );\n\t\tconst glType = utils.convert( texture.type );\n\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\tif ( textureTarget === 32879 || textureTarget === 35866 ) {\n\n\t\t\tstate.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );\n\n\t\t} else {\n\n\t\t\tstate.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( 36160, framebuffer );\n\t\t_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );\n\t\tstate.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( 36161, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = 33189;\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === FloatType ) {\n\n\t\t\t\t\t\tglInternalFormat = 36012;\n\n\t\t\t\t\t} else if ( depthTexture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\tglInternalFormat = 33190;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );\n\n\t\t} else {\n\n\t\t\tconst texture = renderTarget.texture;\n\n\t\t\tconst glFormat = utils.convert( texture.format );\n\t\t\tconst glType = utils.convert( texture.type );\n\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tconst isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\tstate.bindFramebuffer( 36160, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tconst webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );\n\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\ttextureProperties.__version = texture.version;\n\n\t\tinfo.memory.textures ++;\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\t\tconst isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );\n\t\tconst isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n\t\tconst supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;\n\n\t\t// Handles WebGL2 RGBFormat fallback - #18858\n\n\t\tif ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {\n\n\t\t\ttexture.format = RGBAFormat;\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );\n\n\t\t}\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );\n\n\t\t\t\t\tconst glFormat = utils.convert( texture.format );\n\t\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );\n\t\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\tstate.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.bindFramebuffer( 36160, null );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( 34067, texture, supportsMips );\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( 34067, texture, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 34067, null );\n\n\t\t} else {\n\n\t\t\tlet glTextureType = 3553;\n\n\t\t\tif ( isRenderTarget3D ) {\n\n\t\t\t\t// Render targets containing layers, i.e: Texture 3D and 2d arrays\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\tconst isTexture3D = texture.isDataTexture3D;\n\t\t\t\t\tglTextureType = isTexture3D ? 32879 : 35866;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( glTextureType, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( glTextureType, texture, supportsMips );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType );\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( 3553, texture, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 3553, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;\n\t\t\tconst webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\tgenerateMipmap( target, texture, renderTarget.width, renderTarget.height );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tstate.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\tstate.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tconst width = renderTarget.width;\n\t\t\t\tconst height = renderTarget.height;\n\t\t\t\tlet mask = 16384;\n\n\t\t\t\tif ( renderTarget.depthBuffer ) mask |= 256;\n\t\t\t\tif ( renderTarget.stencilBuffer ) mask |= 1024;\n\n\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );\n\n\t\t\t\tstate.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?\n\t\t\tMath.min( maxSamples, renderTarget.samples ) : 0;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures.get( texture ) !== frame ) {\n\n\t\t\t_videoTextures.set( texture, frame );\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\t// backwards compatibility\n\n\tlet warnedTexture2D = false;\n\tlet warnedTextureCube = false;\n\n\tfunction safeSetTexture2D( texture, slot ) {\n\n\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\tif ( warnedTexture2D === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\\'t use render targets as textures. Use their .texture property instead.' );\n\t\t\t\twarnedTexture2D = true;\n\n\t\t\t}\n\n\t\t\ttexture = texture.texture;\n\n\t\t}\n\n\t\tsetTexture2D( texture, slot );\n\n\t}\n\n\tfunction safeSetTextureCube( texture, slot ) {\n\n\t\tif ( texture && texture.isWebGLCubeRenderTarget ) {\n\n\t\t\tif ( warnedTextureCube === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\\'t use cube render targets as textures. Use their .texture property instead.' );\n\t\t\t\twarnedTextureCube = true;\n\n\t\t\t}\n\n\t\t\ttexture = texture.texture;\n\n\t\t}\n\n\n\t\tsetTextureCube( texture, slot );\n\n\t}\n\n\t//\n\n\tthis.allocateTextureUnit = allocateTextureUnit;\n\tthis.resetTextureUnits = resetTextureUnits;\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture2DArray = setTexture2DArray;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\n\tthis.safeSetTexture2D = safeSetTexture2D;\n\tthis.safeSetTextureCube = safeSetTextureCube;\n\n}\n\nfunction WebGLUtils( gl, extensions, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tfunction convert( p ) {\n\n\t\tlet extension;\n\n\t\tif ( p === UnsignedByteType ) return 5121;\n\t\tif ( p === UnsignedShort4444Type ) return 32819;\n\t\tif ( p === UnsignedShort5551Type ) return 32820;\n\t\tif ( p === UnsignedShort565Type ) return 33635;\n\n\t\tif ( p === ByteType ) return 5120;\n\t\tif ( p === ShortType ) return 5122;\n\t\tif ( p === UnsignedShortType ) return 5123;\n\t\tif ( p === IntType ) return 5124;\n\t\tif ( p === UnsignedIntType ) return 5125;\n\t\tif ( p === FloatType ) return 5126;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\tif ( isWebGL2 ) return 5131;\n\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.HALF_FLOAT_OES;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return 6406;\n\t\tif ( p === RGBFormat ) return 6407;\n\t\tif ( p === RGBAFormat ) return 6408;\n\t\tif ( p === LuminanceFormat ) return 6409;\n\t\tif ( p === LuminanceAlphaFormat ) return 6410;\n\t\tif ( p === DepthFormat ) return 6402;\n\t\tif ( p === DepthStencilFormat ) return 34041;\n\t\tif ( p === RedFormat ) return 6403;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedIntegerFormat ) return 36244;\n\t\tif ( p === RGFormat ) return 33319;\n\t\tif ( p === RGIntegerFormat ) return 33320;\n\t\tif ( p === RGBIntegerFormat ) return 36248;\n\t\tif ( p === RGBAIntegerFormat ) return 36249;\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||\n\t\t\tp === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\t// TODO Complete?\n\n\t\t\t\treturn p;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\t// TODO Complete?\n\n\t\t\t\treturn p;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\tif ( isWebGL2 ) return 34042;\n\n\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nArrayCamera.prototype.isArrayCamera = true;\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nGroup.prototype.isGroup = true;\n\nfunction WebXRController() {\n\n\tthis._targetRay = null;\n\tthis._grip = null;\n\tthis._hand = null;\n\n}\n\nObject.assign( WebXRController.prototype, {\n\n\tconstructor: WebXRController,\n\n\tgetHandSpace: function () {\n\n\t\tif ( this._hand === null ) {\n\n\t\t\tthis._hand = new Group();\n\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\tthis._hand.visible = false;\n\n\t\t\tthis._hand.joints = {};\n\t\t\tthis._hand.inputState = { pinching: false };\n\n\t\t}\n\n\t\treturn this._hand;\n\n\t},\n\n\tgetTargetRaySpace: function () {\n\n\t\tif ( this._targetRay === null ) {\n\n\t\t\tthis._targetRay = new Group();\n\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\treturn this._targetRay;\n\n\t},\n\n\tgetGripSpace: function () {\n\n\t\tif ( this._grip === null ) {\n\n\t\t\tthis._grip = new Group();\n\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\treturn this._grip;\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.dispatchEvent( event );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function ( inputSource ) {\n\n\t\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.visible = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdate: function ( inputSource, frame, referenceSpace ) {\n\n\t\tlet inputPose = null;\n\t\tlet gripPose = null;\n\t\tlet handPose = null;\n\n\t\tconst targetRay = this._targetRay;\n\t\tconst grip = this._grip;\n\t\tconst hand = this._hand;\n\n\t\tif ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {\n\n\t\t\tif ( targetRay !== null ) {\n\n\t\t\t\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hand && inputSource.hand ) {\n\n\t\t\t\thandPose = true;\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\tconst jointPose = frame.getJointPose( inputjoint, referenceSpace );\n\n\t\t\t\t\tif ( hand.joints[ inputjoint.jointName ] === undefined ) {\n\n\t\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\t\tconst joint = new Group();\n\t\t\t\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\t\t\t\tjoint.visible = false;\n\t\t\t\t\t\thand.joints[ inputjoint.jointName ] = joint;\n\t\t\t\t\t\t// ??\n\t\t\t\t\t\thand.add( joint );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst joint = hand.joints[ inputjoint.jointName ];\n\n\t\t\t\t\tif ( jointPose !== null ) {\n\n\t\t\t\t\t\tjoint.matrix.fromArray( jointPose.transform.matrix );\n\t\t\t\t\t\tjoint.matrix.decompose( joint.position, joint.rotation, joint.scale );\n\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tjoint.visible = jointPose !== null;\n\n\t\t\t\t}\n\n\t\t\t\t// Custom events\n\n\t\t\t\t// Check pinchz\n\t\t\t\tconst indexTip = hand.joints[ 'index-finger-tip' ];\n\t\t\t\tconst thumbTip = hand.joints[ 'thumb-tip' ];\n\t\t\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\n\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\tif ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( grip !== null && inputSource.gripSpace ) {\n\n\t\t\t\t\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\n\n\t\t\t\t\tif ( gripPose !== null ) {\n\n\t\t\t\t\t\tgrip.matrix.fromArray( gripPose.transform.matrix );\n\t\t\t\t\t\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( targetRay !== null ) {\n\n\t\t\ttargetRay.visible = ( inputPose !== null );\n\n\t\t}\n\n\t\tif ( grip !== null ) {\n\n\t\t\tgrip.visible = ( gripPose !== null );\n\n\t\t}\n\n\t\tif ( hand !== null ) {\n\n\t\t\thand.visible = ( handPose !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nfunction WebXRManager( renderer, gl ) {\n\n\tconst scope = this;\n\tconst state = renderer.state;\n\n\tlet session = null;\n\n\tlet framebufferScaleFactor = 1.0;\n\n\tlet referenceSpace = null;\n\tlet referenceSpaceType = 'local-floor';\n\n\tlet pose = null;\n\n\tconst controllers = [];\n\tconst inputSourcesMap = new Map();\n\n\t//\n\n\tconst cameraL = new PerspectiveCamera();\n\tcameraL.layers.enable( 1 );\n\tcameraL.viewport = new Vector4();\n\n\tconst cameraR = new PerspectiveCamera();\n\tcameraR.layers.enable( 2 );\n\tcameraR.viewport = new Vector4();\n\n\tconst cameras = [ cameraL, cameraR ];\n\n\tconst cameraVR = new ArrayCamera();\n\tcameraVR.layers.enable( 1 );\n\tcameraVR.layers.enable( 2 );\n\n\tlet _currentDepthNear = null;\n\tlet _currentDepthFar = null;\n\n\t//\n\n\tthis.enabled = false;\n\n\tthis.isPresenting = false;\n\n\tthis.getController = function ( index ) {\n\n\t\tlet controller = controllers[ index ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new WebXRController();\n\t\t\tcontrollers[ index ] = controller;\n\n\t\t}\n\n\t\treturn controller.getTargetRaySpace();\n\n\t};\n\n\tthis.getControllerGrip = function ( index ) {\n\n\t\tlet controller = controllers[ index ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new WebXRController();\n\t\t\tcontrollers[ index ] = controller;\n\n\t\t}\n\n\t\treturn controller.getGripSpace();\n\n\t};\n\n\tthis.getHand = function ( index ) {\n\n\t\tlet controller = controllers[ index ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new WebXRController();\n\t\t\tcontrollers[ index ] = controller;\n\n\t\t}\n\n\t\treturn controller.getHandSpace();\n\n\t};\n\n\t//\n\n\tfunction onSessionEvent( event ) {\n\n\t\tconst controller = inputSourcesMap.get( event.inputSource );\n\n\t\tif ( controller ) {\n\n\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t\t}\n\n\t}\n\n\tfunction onSessionEnd() {\n\n\t\tinputSourcesMap.forEach( function ( controller, inputSource ) {\n\n\t\t\tcontroller.disconnect( inputSource );\n\n\t\t} );\n\n\t\tinputSourcesMap.clear();\n\n\t\t_currentDepthNear = null;\n\t\t_currentDepthFar = null;\n\n\t\t// restore framebuffer/rendering state\n\n\t\tstate.bindXRFramebuffer( null );\n\t\trenderer.setRenderTarget( renderer.getRenderTarget() );\n\n\t\t//\n\n\t\tanimation.stop();\n\n\t\tscope.isPresenting = false;\n\n\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t}\n\n\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\tframebufferScaleFactor = value;\n\n\t\tif ( scope.isPresenting === true ) {\n\n\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t}\n\n\t};\n\n\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\treferenceSpaceType = value;\n\n\t\tif ( scope.isPresenting === true ) {\n\n\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\n\n\t\t}\n\n\t};\n\n\tthis.getReferenceSpace = function () {\n\n\t\treturn referenceSpace;\n\n\t};\n\n\tthis.getSession = function () {\n\n\t\treturn session;\n\n\t};\n\n\tthis.setSession = async function ( value ) {\n\n\t\tsession = value;\n\n\t\tif ( session !== null ) {\n\n\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\n\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\n\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\n\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\tconst attributes = gl.getContextAttributes();\n\n\t\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\t\tawait gl.makeXRCompatible();\n\n\t\t\t}\n\n\t\t\tconst layerInit = {\n\t\t\t\tantialias: attributes.antialias,\n\t\t\t\talpha: attributes.alpha,\n\t\t\t\tdepth: attributes.depth,\n\t\t\t\tstencil: attributes.stencil,\n\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line no-undef\n\t\t\tconst baseLayer = new XRWebGLLayer( session, gl, layerInit );\n\n\t\t\tsession.updateRenderState( { baseLayer: baseLayer } );\n\n\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\n\n\t\t\tanimation.setContext( session );\n\t\t\tanimation.start();\n\n\t\t\tscope.isPresenting = true;\n\n\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t}\n\n\t};\n\n\tfunction onInputSourcesChange( event ) {\n\n\t\tconst inputSources = session.inputSources;\n\n\t\t// Assign inputSources to available controllers\n\n\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\tinputSourcesMap.set( inputSources[ i ], controllers[ i ] );\n\n\t\t}\n\n\t\t// Notify disconnected\n\n\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\t\tconst inputSource = event.removed[ i ];\n\t\t\tconst controller = inputSourcesMap.get( inputSource );\n\n\t\t\tif ( controller ) {\n\n\t\t\t\tcontroller.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\t\t\t\tinputSourcesMap.delete( inputSource );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Notify connected\n\n\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\t\tconst inputSource = event.added[ i ];\n\t\t\tconst controller = inputSourcesMap.get( inputSource );\n\n\t\t\tif ( controller ) {\n\n\t\t\t\tcontroller.dispatchEvent( { type: 'connected', data: inputSource } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tconst cameraLPos = new Vector3();\n\tconst cameraRPos = new Vector3();\n\n\t/**\n\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t * the cameras' projection and world matrices have already been set.\n\t * And that near and far planes are identical for both cameras.\n\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t */\n\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\n\n\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\tconst projR = cameraR.projectionMatrix.elements;\n\n\t\t// VR systems will have identical far and near planes, and\n\t\t// most likely identical top and bottom frustum extents.\n\t\t// Use the left camera for these values.\n\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\t\tconst left = near * leftFov;\n\t\tconst right = near * rightFov;\n\n\t\t// Calculate the new camera's position offset from the\n\t\t// left camera. xOffset should be roughly half `ipd`.\n\t\tconst zOffset = ipd / ( - leftFov + rightFov );\n\t\tconst xOffset = zOffset * - leftFov;\n\n\t\t// TODO: Better way to apply this offset?\n\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\t\tcamera.translateX( xOffset );\n\t\tcamera.translateZ( zOffset );\n\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t// Find the union of the frustum values of the cameras and scale\n\t\t// the values so that the near plane's position does not change in world space,\n\t\t// although must now be relative to the new union camera.\n\t\tconst near2 = near + zOffset;\n\t\tconst far2 = far + zOffset;\n\t\tconst left2 = left - xOffset;\n\t\tconst right2 = right + ( ipd - xOffset );\n\t\tconst top2 = topFov * far / far2 * near2;\n\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\n\t}\n\n\tfunction updateCamera( camera, parent ) {\n\n\t\tif ( parent === null ) {\n\n\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t} else {\n\n\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t}\n\n\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t}\n\n\tthis.getCamera = function ( camera ) {\n\n\t\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\n\t\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\tif ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {\n\n\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\tsession.updateRenderState( {\n\t\t\t\tdepthNear: cameraVR.near,\n\t\t\t\tdepthFar: cameraVR.far\n\t\t\t} );\n\n\t\t\t_currentDepthNear = cameraVR.near;\n\t\t\t_currentDepthFar = cameraVR.far;\n\n\t\t}\n\n\t\tconst parent = camera.parent;\n\t\tconst cameras = cameraVR.cameras;\n\n\t\tupdateCamera( cameraVR, parent );\n\n\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t}\n\n\t\t// update camera and its children\n\n\t\tcamera.matrixWorld.copy( cameraVR.matrixWorld );\n\t\tcamera.matrix.copy( cameraVR.matrix );\n\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\n\t\tconst children = camera.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t\t// update projection matrix for proper view frustum culling\n\n\t\tif ( cameras.length === 2 ) {\n\n\t\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\n\n\t\t} else {\n\n\t\t\t// assume single camera setup (AR)\n\n\t\t\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t}\n\n\t\treturn cameraVR;\n\n\t};\n\n\t// Animation Loop\n\n\tlet onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tpose = frame.getViewerPose( referenceSpace );\n\n\t\tif ( pose !== null ) {\n\n\t\t\tconst views = pose.views;\n\t\t\tconst baseLayer = session.renderState.baseLayer;\n\n\t\t\tstate.bindXRFramebuffer( baseLayer.framebuffer );\n\n\t\t\tlet cameraVRNeedsUpdate = false;\n\n\t\t\t// check if it's necessary to rebuild cameraVR's camera list\n\n\t\t\tif ( views.length !== cameraVR.cameras.length ) {\n\n\t\t\t\tcameraVR.cameras.length = 0;\n\t\t\t\tcameraVRNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\t\tconst view = views[ i ];\n\t\t\t\tconst viewport = baseLayer.getViewport( view );\n\n\t\t\t\tconst camera = cameras[ i ];\n\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tcameraVR.matrix.copy( camera.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( cameraVRNeedsUpdate === true ) {\n\n\t\t\t\t\tcameraVR.cameras.push( camera );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst inputSources = session.inputSources;\n\n\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\tconst controller = controllers[ i ];\n\t\t\tconst inputSource = inputSources[ i ];\n\n\t\t\tcontroller.update( inputSource, frame, referenceSpace );\n\n\t\t}\n\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\n\n\t}\n\n\tconst animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\n\t};\n\n\tthis.dispose = function () {};\n\n}\n\nObject.assign( WebXRManager.prototype, EventDispatcher.prototype );\n\nfunction WebGLMaterials( properties ) {\n\n\tfunction refreshFogUniforms( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value.copy( fog.color );\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {\n\n\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsLambert( uniforms, material );\n\n\t\t} else if ( material.isMeshToonMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsToon( uniforms, material );\n\n\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsPhong( uniforms, material );\n\n\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( uniforms, material );\n\n\t\t\t} else {\n\n\t\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsMatcap( uniforms, material );\n\n\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDepth( uniforms, material );\n\n\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDistance( uniforms, material );\n\n\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsNormal( uniforms, material );\n\n\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\trefreshUniformsLine( uniforms, material );\n\n\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsDash( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\trefreshUniformsPoints( uniforms, material, pixelRatio, height );\n\n\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\trefreshUniformsSprites( uniforms, material );\n\n\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\tuniforms.color.value.copy( material.color );\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t} else if ( material.isShaderMaterial ) {\n\n\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value.copy( material.color );\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t}\n\n\t\tconst envMap = properties.get( material ).envMap;\n\n\t\tif ( envMap ) {\n\n\t\t\tuniforms.envMap.value = envMap;\n\n\t\t\tuniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\tconst maxMipLevel = properties.get( envMap ).__maxMipLevel;\n\n\t\t\tif ( maxMipLevel !== undefined ) {\n\n\t\t\t\tuniforms.maxMipLevel.value = maxMipLevel;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. displacementMap map\n\t\t// 4. normal map\n\t\t// 5. bump map\n\t\t// 6. roughnessMap map\n\t\t// 7. metalnessMap map\n\t\t// 8. alphaMap map\n\t\t// 9. emissiveMap map\n\t\t// 10. clearcoat map\n\t\t// 11. clearcoat normal map\n\t\t// 12. clearcoat roughnessMap map\n\n\t\tlet uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t} else if ( material.clearcoatMap ) {\n\n\t\t\tuvScaleMap = material.clearcoatMap;\n\n\t\t} else if ( material.clearcoatNormalMap ) {\n\n\t\t\tuvScaleMap = material.clearcoatNormalMap;\n\n\t\t} else if ( material.clearcoatRoughnessMap ) {\n\n\t\t\tuvScaleMap = material.clearcoatRoughnessMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities for uv2\n\t\t// 1. ao map\n\t\t// 2. light map\n\n\t\tlet uv2ScaleMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuv2ScaleMap = material.aoMap;\n\n\t\t} else if ( material.lightMap ) {\n\n\t\t\tuv2ScaleMap = material.lightMap;\n\n\t\t}\n\n\t\tif ( uv2ScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uv2ScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\tuv2ScaleMap = uv2ScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tif ( uv2ScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuv2ScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material, pixelRatio, height ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * pixelRatio;\n\t\tuniforms.scale.value = height * 0.5;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. alpha map\n\n\t\tlet uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. alpha map\n\n\t\tlet uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value.copy( material.specular );\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tconst envMap = properties.get( material ).envMap;\n\n\t\tif ( envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\t\tif ( material.sheen ) uniforms.sheen.value.copy( material.sheen );\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\n\t\t}\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tuniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );\n\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\n\t\t\t}\n\n\t\t}\n\n\t\tuniforms.transmission.value = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDepth( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tuniforms.referencePosition.value.copy( material.referencePosition );\n\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\tuniforms.farDistance.value = material.farDistance;\n\n\t}\n\n\tfunction refreshUniformsNormal( uniforms, material ) {\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\trefreshFogUniforms: refreshFogUniforms,\n\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t};\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nfunction WebGLRenderer( parameters ) {\n\n\tparameters = parameters || {};\n\n\tconst _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n\tlet currentRenderList = null;\n\tlet currentRenderState = null;\n\n\t// render() can be called from within a callback triggered by another render.\n\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\tconst renderListStack = [];\n\tconst renderStateStack = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\n\t// Debug configuration container\n\tthis.debug = {\n\n\t\t/**\n\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t * @type {boolean}\n\t\t */\n\t\tcheckShaderErrors: true\n\t};\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.outputEncoding = LinearEncoding;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = NoToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\n\t// internal properties\n\n\tconst _this = this;\n\n\tlet _isContextLost = false;\n\n\t// internal state cache\n\n\tlet _currentActiveCubeFace = 0;\n\tlet _currentActiveMipmapLevel = 0;\n\tlet _currentRenderTarget = null;\n\tlet _currentMaterialId = - 1;\n\n\tlet _currentCamera = null;\n\n\tconst _currentViewport = new Vector4();\n\tconst _currentScissor = new Vector4();\n\tlet _currentScissorTest = null;\n\n\t//\n\n\tlet _width = _canvas.width;\n\tlet _height = _canvas.height;\n\n\tlet _pixelRatio = 1;\n\tlet _opaqueSort = null;\n\tlet _transparentSort = null;\n\n\tconst _viewport = new Vector4( 0, 0, _width, _height );\n\tconst _scissor = new Vector4( 0, 0, _width, _height );\n\tlet _scissorTest = false;\n\n\t// frustum\n\n\tconst _frustum = new Frustum();\n\n\t// clipping\n\n\tlet _clippingEnabled = false;\n\tlet _localClippingEnabled = false;\n\n\t// camera matrices cache\n\n\tconst _projScreenMatrix = new Matrix4();\n\n\tconst _vector3 = new Vector3();\n\n\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\t// initialize\n\n\tlet _gl = _context;\n\n\tfunction getContext( contextNames, contextAttributes ) {\n\n\t\tfor ( let i = 0; i < contextNames.length; i ++ ) {\n\n\t\t\tconst contextName = contextNames[ i ];\n\t\t\tconst context = _canvas.getContext( contextName, contextAttributes );\n\t\t\tif ( context !== null ) return context;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\ttry {\n\n\t\tconst contextAttributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\tpowerPreference: _powerPreference,\n\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n\t\t};\n\n\t\t// event listeners must be registered before WebGL context is created, see #12753\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tconst contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];\n\n\t\t\tif ( _this.isWebGL1Renderer === true ) {\n\n\t\t\t\tcontextNames.shift();\n\n\t\t\t}\n\n\t\t\t_gl = getContext( contextNames, contextAttributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( getContext( contextNames ) ) {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\tthrow error;\n\n\t}\n\n\tlet extensions, capabilities, state, info;\n\tlet properties, textures, cubemaps, attributes, geometries, objects;\n\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\tlet utils, bindingStates;\n\n\tfunction initGLContext() {\n\n\t\textensions = new WebGLExtensions( _gl );\n\n\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\textensions.init( capabilities );\n\n\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\n\n\t\tstate = new WebGLState( _gl, extensions, capabilities );\n\n\t\tinfo = new WebGLInfo( _gl );\n\t\tproperties = new WebGLProperties();\n\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\tattributes = new WebGLAttributes( _gl, capabilities );\n\t\tbindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );\n\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\tmorphtargets = new WebGLMorphtargets( _gl );\n\t\tclipping = new WebGLClipping( properties );\n\t\tprogramCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );\n\t\tmaterials = new WebGLMaterials( properties );\n\t\trenderLists = new WebGLRenderLists( properties );\n\t\trenderStates = new WebGLRenderStates( extensions, capabilities );\n\t\tbackground = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );\n\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\n\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\n\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\n\n\t\tinfo.programs = programCache.programs;\n\n\t\t_this.capabilities = capabilities;\n\t\t_this.extensions = extensions;\n\t\t_this.properties = properties;\n\t\t_this.renderLists = renderLists;\n\t\t_this.shadowMap = shadowMap;\n\t\t_this.state = state;\n\t\t_this.info = info;\n\n\t}\n\n\tinitGLContext();\n\n\t// xr\n\n\tconst xr = new WebXRManager( _this, _gl );\n\n\tthis.xr = xr;\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t};\n\n\tthis.forceContextRestore = function () {\n\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.restoreContext();\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _width, _height, false );\n\n\t};\n\n\tthis.getSize = function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );\n\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.set( _width, _height );\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\tif ( xr.isPresenting ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = Math.floor( width * _pixelRatio );\n\t\t_canvas.height = Math.floor( height * _pixelRatio );\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );\n\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t};\n\n\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_pixelRatio = pixelRatio;\n\n\t\t_canvas.width = Math.floor( width * pixelRatio );\n\t\t_canvas.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getCurrentViewport = function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );\n\n\t\t\ttarget = new Vector4();\n\n\t\t}\n\n\t\treturn target.copy( _currentViewport );\n\n\t};\n\n\tthis.getViewport = function ( target ) {\n\n\t\treturn target.copy( _viewport );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_viewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissor = function ( target ) {\n\n\t\treturn target.copy( _scissor );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_scissor.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn _scissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\tthis.setOpaqueSort = function ( method ) {\n\n\t\t_opaqueSort = method;\n\n\t};\n\n\tthis.setTransparentSort = function ( method ) {\n\n\t\t_transparentSort = method;\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );\n\n\t\t\ttarget = new Color();\n\n\t\t}\n\n\t\treturn target.copy( background.getClearColor() );\n\n\t};\n\n\tthis.setClearColor = function () {\n\n\t\tbackground.setClearColor.apply( background, arguments );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn background.getClearAlpha();\n\n\t};\n\n\tthis.setClearAlpha = function () {\n\n\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tlet bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= 16384;\n\t\tif ( depth === undefined || depth ) bits |= 256;\n\t\tif ( stencil === undefined || stencil ) bits |= 1024;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\t//\n\n\tthis.dispose = function () {\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\trenderLists.dispose();\n\t\trenderStates.dispose();\n\t\tproperties.dispose();\n\t\tcubemaps.dispose();\n\t\tobjects.dispose();\n\t\tbindingStates.dispose();\n\n\t\txr.dispose();\n\n\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\tanimation.stop();\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t_isContextLost = true;\n\n\t}\n\n\tfunction onContextRestore( /* event */ ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t_isContextLost = false;\n\n\t\tconst infoAutoReset = info.autoReset;\n\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\tconst shadowMapType = shadowMap.type;\n\n\t\tinitGLContext();\n\n\t\tinfo.autoReset = infoAutoReset;\n\t\tshadowMap.enabled = shadowMapEnabled;\n\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\tshadowMap.type = shadowMapType;\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tconst material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReferences( material );\n\n\t\tproperties.remove( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\tconst programs = properties.get( material ).programs;\n\n\t\tif ( programs !== undefined ) {\n\n\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tfunction renderObjectImmediate( object, program ) {\n\n\t\tobject.render( function ( object ) {\n\n\t\t\t_this.renderBufferImmediate( object, program );\n\n\t\t} );\n\n\t}\n\n\tthis.renderBufferImmediate = function ( object, program ) {\n\n\t\tbindingStates.initAttributes();\n\n\t\tconst buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.position );\n\t\t\t_gl.bufferData( 34962, object.positionArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.position );\n\t\t\t_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.normal );\n\t\t\t_gl.bufferData( 34962, object.normalArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.normal );\n\t\t\t_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.uv );\n\t\t\t_gl.bufferData( 34962, object.uvArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.uv );\n\t\t\t_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.color );\n\t\t\t_gl.bufferData( 34962, object.colorArray, 35048 );\n\n\t\t\tbindingStates.enableAttribute( programAttributes.color );\n\t\t\t_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tbindingStates.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( 4, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tconst program = setProgram( camera, scene, material, object );\n\n\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t//\n\n\t\tlet index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\n\t\t//\n\n\t\tif ( index === null ) {\n\n\t\t\tif ( position === undefined || position.count === 0 ) return;\n\n\t\t} else if ( index.count === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tif ( material.morphTargets || material.morphNormals ) {\n\n\t\t\tmorphtargets.update( object, geometry, material, program );\n\n\t\t}\n\n\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\tlet attribute;\n\t\tlet renderer = bufferRenderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\tattribute = attributes.get( index );\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( attribute );\n\n\t\t}\n\n\t\t//\n\n\t\tconst dataCount = ( index !== null ) ? index.count : position.count;\n\n\t\tconst rangeStart = geometry.drawRange.start * rangeFactor;\n\t\tconst rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\tconst groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\tconst groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\tconst drawStart = Math.max( rangeStart, groupStart );\n\t\tconst drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tconst drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\t//\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( 4 );\n\n\t\t\t}\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\trenderer.setMode( 2 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( 3 );\n\n\t\t\t}\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\trenderer.setMode( 0 );\n\n\t\t} else if ( object.isSprite ) {\n\n\t\t\trenderer.setMode( 4 );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\tconst instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );\n\n\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\t// Compile\n\n\tthis.compile = function ( scene, camera ) {\n\n\t\tcurrentRenderState = renderStates.get( scene );\n\t\tcurrentRenderState.init();\n\n\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcurrentRenderState.setupLights();\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tconst material = object.material;\n\n\t\t\tif ( material ) {\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\tgetProgram( material2, scene, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t};\n\n\t// Animation Loop\n\n\tlet onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time ) {\n\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t}\n\n\tfunction onXRSessionStart() {\n\n\t\tanimation.stop();\n\n\t}\n\n\tfunction onXRSessionEnd() {\n\n\t\tanimation.start();\n\n\t}\n\n\tconst animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tif ( typeof window !== 'undefined' ) animation.setContext( window );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\t\txr.setAnimationLoop( callback );\n\n\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t};\n\n\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tlet renderTarget, forceClear;\n\n\t\tif ( arguments[ 2 ] !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );\n\t\t\trenderTarget = arguments[ 2 ];\n\n\t\t}\n\n\t\tif ( arguments[ 3 ] !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );\n\t\t\tforceClear = arguments[ 3 ];\n\n\t\t}\n\n\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( _isContextLost === true ) return;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\tcamera = xr.getCamera( camera );\n\n\t\t}\n\n\t\t//\n\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );\n\n\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\tcurrentRenderState.init();\n\n\t\trenderStateStack.push( currentRenderState );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\tcurrentRenderList.init();\n\n\t\trenderListStack.push( currentRenderList );\n\n\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\tcurrentRenderList.finish();\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\tcurrentRenderState.setupLights();\n\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t//\n\n\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\tif ( renderTarget !== undefined ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\t\tbackground.render( currentRenderList, scene, camera, forceClear );\n\n\t\t// render scene\n\n\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t//\n\n\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.buffers.depth.setTest( true );\n\t\tstate.buffers.depth.setMask( true );\n\t\tstate.buffers.color.setMask( true );\n\n\t\tstate.setPolygonOffset( false );\n\n\t\t// _gl.finish();\n\n\t\tbindingStates.resetDefaultState();\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\trenderStateStack.pop();\n\n\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t} else {\n\n\t\t\tcurrentRenderState = null;\n\n\t\t}\n\n\t\trenderListStack.pop();\n\n\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t} else {\n\n\t\t\tcurrentRenderList = null;\n\n\t\t}\n\n\t};\n\n\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t// update skeleton only once in a frame\n\n\t\t\t\t\tif ( object.skeleton.frame !== info.render.frame ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\t\t\t\t\t\tobject.skeleton.frame = info.render.frame;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\tconst object = renderItem.object;\n\t\t\tconst geometry = renderItem.geometry;\n\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\tconst group = renderItem.group;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tfor ( let j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tstate.viewport( _currentViewport.copy( camera2.viewport ) );\n\n\t\t\t\t\t\tcurrentRenderState.setupLightsView( camera2 );\n\n\t\t\t\t\t\trenderObject( object, scene, camera2, geometry, material, group );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\tconst program = setProgram( camera, scene, material, object );\n\n\t\t\tstate.setMaterial( material );\n\n\t\t\tbindingStates.reset();\n\n\t\t\trenderObjectImmediate( object, program );\n\n\t\t} else {\n\n\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t}\n\n\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t}\n\n\tfunction getProgram( material, scene, object ) {\n\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tconst lights = currentRenderState.state.lights;\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tconst lightsStateVersion = lights.state.version;\n\n\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\tlet programs = materialProperties.programs;\n\n\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\tmaterialProperties.fog = scene.fog;\n\t\tmaterialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );\n\n\t\tif ( programs === undefined ) {\n\n\t\t\t// new material\n\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tprograms = new Map();\n\t\t\tmaterialProperties.programs = programs;\n\n\t\t}\n\n\t\tlet program = programs.get( programCacheKey );\n\n\t\tif ( program !== undefined ) {\n\n\t\t\t// early out if program and light state is identical\n\n\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\treturn program;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t}\n\n\t\tconst uniforms = materialProperties.uniforms;\n\n\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t}\n\n\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t// store the light setup it was created for\n\n\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t}\n\n\t\tconst progUniforms = program.getUniforms();\n\t\tconst uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.currentProgram = program;\n\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\treturn program;\n\n\t}\n\n\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tmaterialProperties.outputEncoding = parameters.outputEncoding;\n\t\tmaterialProperties.instancing = parameters.instancing;\n\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\n\t}\n\n\tfunction setProgram( camera, scene, material, object ) {\n\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\ttextures.resetTextureUnits();\n\n\t\tconst fog = scene.fog;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\tconst encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\n\t\tconst envMap = cubemaps.get( material.envMap || environment );\n\t\tconst vertexAlphas = material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;\n\n\t\tconst materialProperties = properties.get( material );\n\t\tconst lights = currentRenderState.state.lights;\n\n\t\tif ( _clippingEnabled === true ) {\n\n\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\tconst useCache =\n\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet needsProgramChange = false;\n\n\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.outputEncoding !== encoding ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\tneedsProgramChange = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tneedsProgramChange = true;\n\t\t\tmaterialProperties.__version = material.version;\n\n\t\t}\n\n\t\t//\n\n\t\tlet program = materialProperties.currentProgram;\n\n\t\tif ( needsProgramChange === true ) {\n\n\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t}\n\n\t\tlet refreshProgram = false;\n\t\tlet refreshMaterial = false;\n\t\tlet refreshLights = false;\n\n\t\tconst p_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.envMap ) {\n\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\tmaterial.isShadowMaterial ||\n\t\t\t\tmaterial.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// otherwise textures used for skinning can take over texture units reserved for other material textures\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tconst skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tconst bones = skeleton.bones;\n\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === null ) {\n\n\t\t\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\t\t\t\tlet size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\t\t\tsize = MathUtils.ceilPowerOfTwo( size );\n\t\t\t\t\t\tsize = Math.max( size, 4 );\n\n\t\t\t\t\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\t\t\t\t\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\n\n\t\t\t\t\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\n\t\t\t\t\t\tskeleton.boneMatrices = boneMatrices;\n\t\t\t\t\t\tskeleton.boneTexture = boneTexture;\n\t\t\t\t\t\tskeleton.boneTextureSize = size;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\n\t\t}\n\n\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t}\n\n\t\t// common matrices\n\n\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\treturn program;\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\tfunction materialNeedsLights( material ) {\n\n\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t}\n\n\tthis.getActiveCubeFace = function () {\n\n\t\treturn _currentActiveCubeFace;\n\n\t};\n\n\tthis.getActiveMipmapLevel = function () {\n\n\t\treturn _currentActiveMipmapLevel;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tlet framebuffer = null;\n\t\tlet isCube = false;\n\t\tlet isRenderTarget3D = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tconst texture = renderTarget.texture;\n\n\t\t\tif ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {\n\n\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t}\n\n\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\t\t\t\tisCube = true;\n\n\t\t\t} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t} else {\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t}\n\n\t\tstate.bindFramebuffer( 36160, framebuffer );\n\n\t\tstate.viewport( _currentViewport );\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tif ( isCube ) {\n\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\tconst layer = activeCubeFace || 0;\n\t\t\t_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t}\n\n\t\tif ( framebuffer ) {\n\n\t\t\tstate.bindFramebuffer( 36160, framebuffer );\n\n\t\t\ttry {\n\n\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );\n\n\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t! halfFloatSupportedByExt ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\tstate.bindFramebuffer( 36160, framebuffer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.copyFramebufferToTexture = function ( position, texture, level = 0 ) {\n\n\t\tconst levelScale = Math.pow( 2, - level );\n\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\tconst height = Math.floor( texture.image.height * levelScale );\n\t\tconst glFormat = utils.convert( texture.format );\n\n\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {\n\n\t\tconst width = srcTexture.image.width;\n\t\tconst height = srcTexture.image.height;\n\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\tconst glType = utils.convert( dstTexture.type );\n\n\t\ttextures.setTexture2D( dstTexture, 0 );\n\n\t\t// As another texture upload may have changed pixelStorei\n\t\t// parameters, make sure they are correct for the dstTexture\n\t\t_gl.pixelStorei( 37440, dstTexture.flipY );\n\t\t_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, dstTexture.unpackAlignment );\n\n\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {\n\n\t\tif ( _this.isWebGL1Renderer ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { width, height, data } = srcTexture.image;\n\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\tconst glType = utils.convert( dstTexture.type );\n\t\tlet glTarget;\n\n\t\tif ( dstTexture.isDataTexture3D ) {\n\n\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\tglTarget = 32879;\n\n\t\t} else if ( dstTexture.isDataTexture2DArray ) {\n\n\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\tglTarget = 35866;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_gl.pixelStorei( 37440, dstTexture.flipY );\n\t\t_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, dstTexture.unpackAlignment );\n\n\t\tconst unpackRowLen = _gl.getParameter( 3314 );\n\t\tconst unpackImageHeight = _gl.getParameter( 32878 );\n\t\tconst unpackSkipPixels = _gl.getParameter( 3316 );\n\t\tconst unpackSkipRows = _gl.getParameter( 3315 );\n\t\tconst unpackSkipImages = _gl.getParameter( 32877 );\n\n\t\t_gl.pixelStorei( 3314, width );\n\t\t_gl.pixelStorei( 32878, height );\n\t\t_gl.pixelStorei( 3316, sourceBox.min.x );\n\t\t_gl.pixelStorei( 3315, sourceBox.min.y );\n\t\t_gl.pixelStorei( 32877, sourceBox.min.z );\n\n\t\t_gl.texSubImage3D(\n\t\t\tglTarget,\n\t\t\tlevel,\n\t\t\tposition.x,\n\t\t\tposition.y,\n\t\t\tposition.z,\n\t\t\tsourceBox.max.x - sourceBox.min.x + 1,\n\t\t\tsourceBox.max.y - sourceBox.min.y + 1,\n\t\t\tsourceBox.max.z - sourceBox.min.z + 1,\n\t\t\tglFormat,\n\t\t\tglType,\n\t\t\tdata\n\t\t);\n\n\t\t_gl.pixelStorei( 3314, unpackRowLen );\n\t\t_gl.pixelStorei( 32878, unpackImageHeight );\n\t\t_gl.pixelStorei( 3316, unpackSkipPixels );\n\t\t_gl.pixelStorei( 3315, unpackSkipRows );\n\t\t_gl.pixelStorei( 32877, unpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.initTexture = function ( texture ) {\n\n\t\ttextures.setTexture2D( texture, 0 );\n\n\t\tstate.unbindTexture();\n\n\t};\n\n\tthis.resetState = function () {\n\n\t\t_currentActiveCubeFace = 0;\n\t\t_currentActiveMipmapLevel = 0;\n\t\t_currentRenderTarget = null;\n\n\t\tstate.reset();\n\t\tbindingStates.reset();\n\n\t};\n\n\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\n\n\t}\n\n}\n\nclass WebGL1Renderer extends WebGLRenderer {}\n\nWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nFogExp2.prototype.isFogExp2 = true;\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nFog.prototype.isFog = true;\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nScene.prototype.isScene = true;\n\nfunction InterleavedBuffer( array, stride ) {\n\n\tthis.array = array;\n\tthis.stride = stride;\n\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\tthis.usage = StaticDrawUsage;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n\tthis.uuid = MathUtils.generateUUID();\n\n}\n\nObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nObject.assign( InterleavedBuffer.prototype, {\n\n\tisInterleavedBuffer: true,\n\n\tonUploadCallback: function () {},\n\n\tsetUsage: function ( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function ( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = MathUtils.generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new InterleavedBuffer( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t},\n\n\tonUpload: function ( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = MathUtils.generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n} );\n\nconst _vector$6 = new Vector3();\n\nfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\tthis.name = '';\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n\tthis.normalized = normalized === true;\n\n}\n\nObject.defineProperties( InterleavedBufferAttribute.prototype, {\n\n\tcount: {\n\n\t\tget: function () {\n\n\t\t\treturn this.data.count;\n\n\t\t}\n\n\t},\n\n\tarray: {\n\n\t\tget: function () {\n\n\t\t\treturn this.data.array;\n\n\t\t}\n\n\t},\n\n\tneedsUpdate: {\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.data.needsUpdate = value;\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( InterleavedBufferAttribute.prototype, {\n\n\tisInterleavedBufferAttribute: true,\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.x = this.getX( i );\n\t\t\t_vector$6.y = this.getY( i );\n\t\t\t_vector$6.z = this.getZ( i );\n\n\t\t\t_vector$6.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyNormalMatrix: function ( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.x = this.getX( i );\n\t\t\t_vector$6.y = this.getY( i );\n\t\t\t_vector$6.z = this.getZ( i );\n\n\t\t\t_vector$6.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttransformDirection: function ( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$6.x = this.getX( i );\n\t\t\t_vector$6.y = this.getY( i );\n\t\t\t_vector$6.z = this.getZ( i );\n\n\t\t\t_vector$6.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function ( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// deinterleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interlaved attribtue\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n * parameters = {\n *  color: <hex>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *  rotation: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nclass SpriteMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nSpriteMaterial.prototype.isSpriteMaterial = true;\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n\n\tconstructor( material ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nSprite.prototype.isSprite = true;\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = new Vector3();\n\nconst _skinIndex = new Vector4();\nconst _skinWeight = new Vector4();\n\nconst _vector$5 = new Vector3();\nconst _matrix = new Matrix4();\n\nfunction SkinnedMesh( geometry, material ) {\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = 'attached';\n\tthis.bindMatrix = new Matrix4();\n\tthis.bindMatrixInverse = new Matrix4();\n\n}\n\nSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: SkinnedMesh,\n\n\tisSkinnedMesh: true,\n\n\tcopy: function ( source ) {\n\n\t\tMesh.prototype.copy.call( this, source );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\treturn this;\n\n\t},\n\n\tbind: function ( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.x = skinWeight.getX( i );\n\t\t\tvector.y = skinWeight.getY( i );\n\t\t\tvector.z = skinWeight.getZ( i );\n\t\t\tvector.w = skinWeight.getW( i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tMesh.prototype.updateMatrixWorld.call( this, force );\n\n\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tboneTransform: function ( index, target ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );\n\n\t\ttarget.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\ttarget.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n} );\n\nfunction Bone() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Bone';\n\n}\n\nBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Bone,\n\n\tisBone: true\n\n} );\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\t\tthis.boneTextureSize = 0;\n\n\t\tthis.frame = - 1;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = new Matrix4();\nconst _instanceWorldMatrix = new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh = new Mesh();\n\nfunction InstancedMesh( geometry, material, count ) {\n\n\tMesh.call( this, geometry, material );\n\n\tthis.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );\n\tthis.instanceColor = null;\n\n\tthis.count = count;\n\n\tthis.frustumCulled = false;\n\n}\n\nInstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: InstancedMesh,\n\n\tisInstancedMesh: true,\n\n\tcopy: function ( source ) {\n\n\t\tMesh.prototype.copy.call( this, source );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\treturn this;\n\n\t},\n\n\tgetColorAt: function ( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t},\n\n\tgetMatrixAt: function ( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh.geometry = this.geometry;\n\t\t_mesh.material = this.material;\n\n\t\tif ( _mesh.material === undefined ) return;\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t},\n\n\tsetColorAt: function ( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t},\n\n\tsetMatrixAt: function ( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\nconst _start$1 = new Vector3();\nconst _end$1 = new Vector3();\nconst _inverseMatrix$1 = new Matrix4();\nconst _ray$1 = new Ray();\nconst _sphere$1 = new Sphere();\n\nfunction Line( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry;\n\tthis.material = material;\n\n\tthis.updateMorphTargets();\n\n}\n\nLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Line,\n\n\tisLine: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t_start$1.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t_end$1.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i ] += _start$1.distanceTo( _end$1 );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst vStart = new Vector3();\n\t\tconst vEnd = new Vector3();\n\t\tconst interSegment = new Vector3();\n\t\tconst interRay = new Vector3();\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, a );\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, b );\n\n\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nfunction LineSegments( geometry, material ) {\n\n\tLine.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n}\n\nLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\tconstructor: LineSegments,\n\n\tisLineSegments: true,\n\n\tcomputeLineDistances: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\tconst lineDistances = [];\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nclass LineLoop extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nLineLoop.prototype.isLineLoop = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n *\n *  morphTargets: <bool>\n * }\n */\n\nclass PointsMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t}\n\n}\n\nPointsMaterial.prototype.isPointsMaterial = true;\n\nconst _inverseMatrix = new Matrix4();\nconst _ray = new Ray();\nconst _sphere = new Sphere();\nconst _position$2 = new Vector3();\n\nfunction Points( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry;\n\tthis.material = material;\n\n\tthis.updateMorphTargets();\n\n}\n\nPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Points,\n\n\tisPoints: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass VideoTexture extends Texture {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.format = format !== undefined ? format : RGBFormat;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nVideoTexture.prototype.isVideoTexture = true;\n\nclass CompressedTexture extends Texture {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nCompressedTexture.prototype.isCompressedTexture = true;\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nCanvasTexture.prototype.isCanvasTexture = true;\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\n}\n\nDepthTexture.prototype.isDepthTexture = true;\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices, indices, radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n}\n\nconst _v0 = new Vector3();\nconst _v1$1 = new Vector3();\nconst _normal = new Vector3();\nconst _triangle = new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry, thresholdAngle ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\tconsole.error( 'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst precisionPoints = 4;\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\tconst thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\n\n\t\tconst indexAttr = geometry.getIndex();\n\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\tconst indexArr = [ 0, 0, 0 ];\n\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\tconst hashes = new Array( 3 );\n\n\t\tconst edgeData = {};\n\t\tconst vertices = [];\n\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t} else {\n\n\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = _triangle;\n\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t// create hashes for the edge from the vertices\n\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t// skip degenerate triangles\n\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// iterate over every edge\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\tfor ( const key in edgeData ) {\n\n\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.2)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim ) {\n\n\t\tdim = dim || 2;\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim );\n\t\t\ttriangles.push( ear.i / dim );\n\t\t\ttriangles.push( next.i / dim );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tlet p = ear.next.next;\n\n\twhile ( p !== ear.prev ) {\n\n\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\n\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\n\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\n\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( minTX, minTY, minX, minY, invSize ),\n\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n !== ear.prev && n !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\n\t\t\tarea( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n !== ear.prev && n !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\n\t\t\tarea( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim );\n\t\t\ttriangles.push( p.i / dim );\n\t\t\ttriangles.push( b.i / dim );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\teliminateHole( queue[ i ], outerNode );\n\t\touterNode = filterPoints( outerNode, outerNode.next );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\touterNode = findHoleBridge( hole, outerNode );\n\tif ( outerNode ) {\n\n\t\tconst b = splitPolygon( outerNode, hole );\n\n\t\t// filter collinear points around the cuts\n\t\tfilterPoints( outerNode, outerNode.next );\n\t\tfilterPoints( b, b.next );\n\n\t}\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode;\n\tconst hx = hole.x;\n\tconst hy = hole.y;\n\tlet qx = - Infinity, m;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tif ( x === hx ) {\n\n\t\t\t\t\tif ( hy === p.y ) return p;\n\t\t\t\t\tif ( hy === p.next.y ) return p.next;\n\n\t\t\t\t}\n\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\tif ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = 32767 * ( x - minX ) * invSize;\n\ty = 32767 * ( y - minY ) * invSize;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\n\t\t\t( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\n\t\t\t( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n\t\t( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n\t\t( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n\t\tequals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = null;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nconst ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n};\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes, options ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tlet depth = options.depth !== undefined ? options.depth : 100;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t// deprecated options\n\n\t\t\tif ( options.amount !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\n\t\t\t\tdepth = options.amount;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif ( phiLength === Math.PI * 2 ) {\n\n\t\t\tconst normals = this.attributes.normal.array;\n\t\t\tconst n1 = new Vector3();\n\t\t\tconst n2 = new Vector3();\n\t\t\tconst n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\n\t\t\tconst base = segments * points.length * 3;\n\n\t\t\tfor ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n}\n\n/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\n\nfunction ParametricGeometry( func, slices, stacks ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\t// buffers\n\n\tconst indices = [];\n\tconst vertices = [];\n\tconst normals = [];\n\tconst uvs = [];\n\n\tconst EPS = 0.00001;\n\n\tconst normal = new Vector3();\n\n\tconst p0 = new Vector3(), p1 = new Vector3();\n\tconst pu = new Vector3(), pv = new Vector3();\n\n\tif ( func.length < 3 ) {\n\n\t\tconsole.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\n\n\t}\n\n\t// generate vertices, normals and uvs\n\n\tconst sliceCount = slices + 1;\n\n\tfor ( let i = 0; i <= stacks; i ++ ) {\n\n\t\tconst v = i / stacks;\n\n\t\tfor ( let j = 0; j <= slices; j ++ ) {\n\n\t\t\tconst u = j / slices;\n\n\t\t\t// vertex\n\n\t\t\tfunc( u, v, p0 );\n\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t// normal\n\n\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( u, v );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( let i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( let j = 0; j < slices; j ++ ) {\n\n\t\t\tconst a = i * sliceCount + j;\n\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\tconst c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\tconst d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t// faces one and two\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nParametricGeometry.prototype = Object.create( BufferGeometry.prototype );\nParametricGeometry.prototype.constructor = ParametricGeometry;\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes, curveSegments = 12 ) {\n\n\t\tsuper();\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// incides\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy == 0 && thetaStart == 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy == heightSegments && thetaEnd == Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n}\n\n/**\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n *  bevelOffset: <float> // how far from text outline does bevel start\n * }\n */\n\nclass TextGeometry extends ExtrudeGeometry {\n\n\tconstructor( text, parameters = {} ) {\n\n\t\tconst font = parameters.font;\n\n\t\tif ( ! ( font && font.isFont ) ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new BufferGeometry();\n\n\t\t}\n\n\t\tconst shapes = font.generateShapes( text, parameters.size );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.depth = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tsuper( shapes, parameters );\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\ttoJSON() {\n\n\t\tconst data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry ) {\n\n\t\tsuper();\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\tconsole.error( 'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\n\t\t// helper variables\n\n\t\tconst edge = [ 0, 0 ], edges = {};\n\n\t\tconst vertex = new Vector3();\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// indexed BufferGeometry\n\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tconst indices = geometry.index;\n\t\t\tlet groups = geometry.groups;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t}\n\n\t\t\t// create a data structure that contains all eges without duplicates\n\n\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor ( let i = start, l = ( start + count ); i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tconst edge1 = indices.getX( i + j );\n\t\t\t\t\t\tconst edge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\t\tconst key = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate vertices\n\n\t\t\tfor ( const key in edges ) {\n\n\t\t\t\tconst e = edges[ key ];\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tBoxBufferGeometry: BoxGeometry,\n\tCircleGeometry: CircleGeometry,\n\tCircleBufferGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tConeBufferGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tCylinderBufferGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tDodecahedronBufferGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tExtrudeBufferGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tIcosahedronBufferGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tLatheBufferGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tOctahedronBufferGeometry: OctahedronGeometry,\n\tParametricGeometry: ParametricGeometry,\n\tParametricBufferGeometry: ParametricGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPlaneBufferGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tPolyhedronBufferGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tRingBufferGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tShapeBufferGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tSphereBufferGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTetrahedronBufferGeometry: TetrahedronGeometry,\n\tTextGeometry: TextGeometry,\n\tTextBufferGeometry: TextGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusBufferGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTorusKnotBufferGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tTubeBufferGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\n/**\n * parameters = {\n *  color: <THREE.Color>\n * }\n */\n\nclass ShadowMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\treturn this;\n\n\t}\n\n}\n\nShadowMaterial.prototype.isShadowMaterial = true;\n\nclass RawShaderMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *  flatShading: <bool>\n * }\n */\n\nfunction MeshStandardMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\tthis.roughness = 1.0;\n\tthis.metalness = 0.0;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.flatShading = false;\n\n\tthis.vertexTangents = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshStandardMaterial.prototype = Object.create( Material.prototype );\nMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\nMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.flatShading = source.flatShading;\n\n\tthis.vertexTangents = source.vertexTangents;\n\n\treturn this;\n\n};\n\n/**\n * parameters = {\n *  clearcoat: <float>,\n *  clearcoatMap: new THREE.Texture( <Image> ),\n *  clearcoatRoughness: <float>,\n *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),\n *  clearcoatNormalScale: <Vector2>,\n *  clearcoatNormalMap: new THREE.Texture( <Image> ),\n *\n *  reflectivity: <float>,\n *  ior: <float>,\n *\n *  sheen: <Color>,\n *\n *  transmission: <float>,\n *  transmissionMap: new THREE.Texture( <Image> )\n * }\n */\n\nfunction MeshPhysicalMaterial( parameters ) {\n\n\tMeshStandardMaterial.call( this );\n\n\tthis.defines = {\n\n\t\t'STANDARD': '',\n\t\t'PHYSICAL': ''\n\n\t};\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.clearcoat = 0.0;\n\tthis.clearcoatMap = null;\n\tthis.clearcoatRoughness = 0.0;\n\tthis.clearcoatRoughnessMap = null;\n\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\tthis.clearcoatNormalMap = null;\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tObject.defineProperty( this, 'ior', {\n\t\tget: function () {\n\n\t\t\treturn ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );\n\n\t\t},\n\t\tset: function ( ior ) {\n\n\t\t\tthis.reflectivity = MathUtils.clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );\n\n\t\t}\n\t} );\n\n\tthis.sheen = null; // null will disable sheen bsdf\n\n\tthis.transmission = 0.0;\n\tthis.transmissionMap = null;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\nMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\nMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = {\n\n\t\t'STANDARD': '',\n\t\t'PHYSICAL': ''\n\n\t};\n\n\tthis.clearcoat = source.clearcoat;\n\tthis.clearcoatMap = source.clearcoatMap;\n\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\tthis.reflectivity = source.reflectivity;\n\n\tif ( source.sheen ) {\n\n\t\tthis.sheen = ( this.sheen || new Color() ).copy( source.sheen );\n\n\t} else {\n\n\t\tthis.sheen = null;\n\n\t}\n\n\tthis.transmission = source.transmission;\n\tthis.transmissionMap = source.transmissionMap;\n\n\treturn this;\n\n};\n\n/**\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.MultiplyOperation,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshPhongMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *\n *  map: new THREE.Texture( <Image> ),\n *  gradientMap: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nclass MeshToonMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n/**\n * parameters = {\n *  opacity: <float>,\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshNormalMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nclass MeshLambertMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  matcap: new THREE.Texture( <Image> ),\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshMatcapMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nclass LineDashedMaterial extends LineBasicMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\nvar Materials = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tShadowMaterial: ShadowMaterial,\n\tSpriteMaterial: SpriteMaterial,\n\tRawShaderMaterial: RawShaderMaterial,\n\tShaderMaterial: ShaderMaterial,\n\tPointsMaterial: PointsMaterial,\n\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\tMeshStandardMaterial: MeshStandardMaterial,\n\tMeshPhongMaterial: MeshPhongMaterial,\n\tMeshToonMaterial: MeshToonMaterial,\n\tMeshNormalMaterial: MeshNormalMaterial,\n\tMeshLambertMaterial: MeshLambertMaterial,\n\tMeshDepthMaterial: MeshDepthMaterial,\n\tMeshDistanceMaterial: MeshDistanceMaterial,\n\tMeshBasicMaterial: MeshBasicMaterial,\n\tMeshMatcapMaterial: MeshMatcapMaterial,\n\tLineDashedMaterial: LineDashedMaterial,\n\tLineBasicMaterial: LineBasicMaterial,\n\tMaterial: Material\n});\n\nconst AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function ( array, from, to ) {\n\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function ( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function ( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function ( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tconst n = times.length;\n\t\tconst result = new Array( n );\n\t\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function ( values, stride, order ) {\n\n\t\tconst nValues = values.length;\n\t\tconst result = new values.constructor( nValues );\n\n\t\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tconst srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tlet i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tlet value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t},\n\n\tsubclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\t\tconst clip = sourceClip.clone();\n\n\t\tclip.name = name;\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tconst track = clip.tracks[ i ];\n\t\t\tconst valueSize = track.getValueSize();\n\n\t\t\tconst times = [];\n\t\t\tconst values = [];\n\n\t\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( times.length === 0 ) continue;\n\n\t\t\ttrack.times = AnimationUtils.convertArray( times, track.times.constructor );\n\t\t\ttrack.values = AnimationUtils.convertArray( values, track.values.constructor );\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\t// find minimum .times value across all tracks in the trimmed clip\n\n\t\tlet minStartTime = Infinity;\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// shift all tracks such that clip begins at t=0\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t\t}\n\n\t\tclip.resetDuration();\n\n\t\treturn clip;\n\n\t},\n\n\tmakeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\t\tif ( fps <= 0 ) fps = 30;\n\n\t\tconst numTracks = referenceClip.tracks.length;\n\t\tconst referenceTime = referenceFrame / fps;\n\n\t\t// Make each track's values relative to the values at the reference frame\n\t\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t\t// Skip this track if it's non-numeric\n\t\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t\t} );\n\n\t\t\tif ( targetTrack === undefined ) continue;\n\n\t\t\tlet referenceOffset = 0;\n\t\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t\t}\n\n\t\t\tlet targetOffset = 0;\n\t\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t\t}\n\n\t\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\t\tlet referenceValue;\n\n\t\t\t// Find the value to subtract out of the track\n\t\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t\t} else {\n\n\t\t\t\t// Interpolate to the reference value\n\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );\n\n\t\t\t}\n\n\t\t\t// Conjugate the quaternion\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t\t}\n\n\t\t\t// Subtract the reference value from all of the track values\n\n\t\t\tconst numTimes = targetTrack.times.length;\n\t\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart,\n\t\t\t\t\t\treferenceValue,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\t\treturn targetClip;\n\n\t}\n\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n}\n\nObject.assign( Interpolant.prototype, {\n\n\tevaluate: function ( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function () {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function ( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n} );\n\n// DECLARE ALIAS AFTER assign prototype\nObject.assign( Interpolant.prototype, {\n\n\t//( 0, t, t0 ), returns this.resultBuffer\n\tbeforeStart_: Interpolant.prototype.copySampleValue_,\n\n\t//( N-1, tN-1, t ), returns this.resultBuffer\n\tafterEnd_: Interpolant.prototype.copySampleValue_,\n\n} );\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = - 0;\n\tthis._offsetPrev = - 0;\n\tthis._weightNext = - 0;\n\tthis._offsetNext = - 0;\n\n}\n\nCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function ( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\nfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: LinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n */\n\nfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: DiscreteInterpolant,\n\n\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = AnimationUtils.arraySlice( this.times ),\n\t\t\tvalues = AnimationUtils.arraySlice( this.values ),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = AnimationUtils.arraySlice( this.times, 0 );\n\t\tconst values = AnimationUtils.arraySlice( this.values, 0 );\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: QuaternionLinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\tconst scope = this;\n\n\tlet isLoading = false;\n\tlet itemsLoaded = 0;\n\tlet itemsTotal = 0;\n\tlet urlModifier = undefined;\n\tconst handlers = [];\n\n\t// Refer to #5689 for the reason why we don't set .onStart\n\t// in the constructor\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n\tthis.resolveURL = function ( url ) {\n\n\t\tif ( urlModifier ) {\n\n\t\t\treturn urlModifier( url );\n\n\t\t}\n\n\t\treturn url;\n\n\t};\n\n\tthis.setURLModifier = function ( transform ) {\n\n\t\turlModifier = transform;\n\n\t\treturn this;\n\n\t};\n\n\tthis.addHandler = function ( regex, loader ) {\n\n\t\thandlers.push( regex, loader );\n\n\t\treturn this;\n\n\t};\n\n\tthis.removeHandler = function ( regex ) {\n\n\t\tconst index = handlers.indexOf( regex );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\thandlers.splice( index, 2 );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tthis.getHandler = function ( file ) {\n\n\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tconst regex = handlers[ i ];\n\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n}\n\nconst DefaultLoadingManager = new LoadingManager();\n\nfunction Loader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\tthis.crossOrigin = 'anonymous';\n\tthis.withCredentials = false;\n\tthis.path = '';\n\tthis.resourcePath = '';\n\tthis.requestHeader = {};\n\n}\n\nObject.assign( Loader.prototype, {\n\n\tload: function ( /* url, onLoad, onProgress, onError */ ) {},\n\n\tloadAsync: function ( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t},\n\n\tparse: function ( /* data */ ) {},\n\n\tsetCrossOrigin: function ( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t},\n\n\tsetResourcePath: function ( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t},\n\n\tsetRequestHeader: function ( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n} );\n\nconst loading = {};\n\nfunction FileLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nFileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: FileLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Check for data: URI\n\t\tconst dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\tconst dataUriRegexResult = url.match( dataUriRegex );\n\t\tlet request;\n\n\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\tif ( dataUriRegexResult ) {\n\n\t\t\tconst mimeType = dataUriRegexResult[ 1 ];\n\t\t\tconst isBase64 = !! dataUriRegexResult[ 2 ];\n\n\t\t\tlet data = dataUriRegexResult[ 3 ];\n\t\t\tdata = decodeURIComponent( data );\n\n\t\t\tif ( isBase64 ) data = atob( data );\n\n\t\t\ttry {\n\n\t\t\t\tlet response;\n\t\t\t\tconst responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\tconst view = new Uint8Array( data.length );\n\n\t\t\t\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tresponse = view.buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Initialise array for duplicate requests\n\n\t\t\tloading[ url ] = [];\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\trequest = new XMLHttpRequest();\n\n\t\t\trequest.open( 'GET', url, true );\n\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tconst response = this.response;\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tif ( this.status === 200 || this.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'abort', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\n\t\t\tfor ( const header in this.requestHeader ) {\n\n\t\t\t\trequest.setRequestHeader( header, this.requestHeader[ header ] );\n\n\t\t\t}\n\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetMimeType: function ( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n} );\n\nclass AnimationLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction CompressedTextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nCompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: CompressedTextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n} );\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction DataTextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nDataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: DataTextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tconst texData = scope.parse( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.encoding !== undefined ) {\n\n\t\t\t\ttexture.encoding = texData.encoding;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\nfunction TextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: TextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tconst isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nfunction Curve() {\n\n\tthis.type = 'Curve';\n\n\tthis.arcLengthDivisions = 200;\n\n}\n\nObject.assign( Curve.prototype, {\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function ( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t},\n\n\tgetTangentAt: function ( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t},\n\n\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\t\t\ttangents[ i ].normalize();\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n} );\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst point = optionalTarget || new Vector2();\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nEllipseCurve.prototype.isEllipseCurve = true;\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\nArcCurve.prototype.isArcCurve = true;\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = new Vector3();\nconst px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n/**\n * Bezier Curves formulas obtained from\n * http://en.wikipedia.org/wiki/Bézier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst tangent = optionalTarget || new Vector2();\n\n\t\ttangent.copy( this.v2 ).sub( this.v1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineCurve.prototype.isLineCurve = true;\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineCurve3';\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nSplineCurve.prototype.isSplineCurve = true;\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nLight.prototype.isLight = true;\n\nclass HemisphereLight extends Light {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nHemisphereLight.prototype.isHemisphereLight = true;\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nSpotLightShadow.prototype.isSpotLightShadow = true;\n\nclass SpotLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nSpotLight.prototype.isSpotLight = true;\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nPointLightShadow.prototype.isPointLightShadow = true;\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 1 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// intensity = power per solid angle.\n\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nPointLight.prototype.isPointLight = true;\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nOrthographicCamera.prototype.isOrthographicCamera = true;\n\nclass DirectionalLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n}\n\nDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\n\nclass DirectionalLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nDirectionalLight.prototype.isDirectionalLight = true;\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nAmbientLight.prototype.isAmbientLight = true;\n\nclass RectAreaLight extends Light {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\nRectAreaLight.prototype.isRectAreaLight = true;\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\n\nclass LightProbe extends Light {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nLightProbe.prototype.isLightProbe = true;\n\nclass MaterialLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = new Materials[ json.type ]();\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\tif ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\n\t\tif ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Deprecated\n\n\t\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n}\n\nconst LoaderUtils = {\n\n\tdecodeText: function ( array ) {\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t},\n\n\textractUrlBase: function ( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.substr( 0, index + 1 );\n\n\t}\n\n};\n\nfunction InstancedBufferGeometry() {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.instanceCount = Infinity;\n\n}\n\nInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\n\n\tconstructor: InstancedBufferGeometry,\n\n\tisInstancedBufferGeometry: true,\n\n\tcopy: function ( source ) {\n\n\t\tBufferGeometry.prototype.copy.call( this, source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n} );\n\nfunction InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {\n\n\tif ( typeof ( normalized ) === 'number' ) {\n\n\t\tmeshPerAttribute = normalized;\n\n\t\tnormalized = false;\n\n\t\tconsole.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );\n\n\t}\n\n\tBufferAttribute.call( this, array, itemSize, normalized );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n}\n\nInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\n\n\tconstructor: InstancedBufferAttribute,\n\n\tisInstancedBufferAttribute: true,\n\n\tcopy: function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ()\t{\n\n\t\tconst data = BufferAttribute.prototype.toJSON.call( this );\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n} );\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tif ( attribute.updateRange !== undefined ) {\n\n\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\n\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ] instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\t\tlet geometryShapes;\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TubeGeometry':\n\t\t\t\t\tcase 'TubeBufferGeometry':\n\n\t\t\t\t\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t\t\t\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.closed\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.vertices,\n\t\t\t\t\t\t\tdata.indices,\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.details\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\tcase 'ShapeBufferGeometry':\n\n\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\tdata.curveSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase 'ExtrudeGeometry':\n\t\t\t\t\tcase 'ExtrudeBufferGeometry':\n\n\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst extrudePath = data.options.extrudePath;\n\n\t\t\t\t\t\tif ( extrudePath !== undefined ) {\n\n\t\t\t\t\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\tdata.options\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Loading \"Geometry\" is not supported anymore.' );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.type === 'MultiMaterial' ) {\n\n\t\t\t\t\t// Deprecated\n\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor ( let j = 0; j < data.materials.length; j ++ ) {\n\n\t\t\t\t\t\tconst material = data.materials[ j ];\n\n\t\t\t\t\t\tif ( cache[ material.uuid ] === undefined ) {\n\n\t\t\t\t\t\t\tcache[ material.uuid ] = loader.parse( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push( cache[ material.uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = array;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\timages[ image.uuid ] = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timages[ image.uuid ].push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timages[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\n\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\timages[ image.uuid ] = deserializedImage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tlet texture;\n\t\t\t\tconst image = images[ data.image ];\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture( image );\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture( image.data, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture( image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.encoding !== undefined ) texture.encoding = data.encoding;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new BufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/* DEPRECATED */\n\n\tsetTexturePath( value ) {\n\n\t\tconsole.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );\n\t\treturn this.setResourcePath( value );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\tCubeUVRefractionMapping: CubeUVRefractionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nfunction ImageBitmapLoader( manager ) {\n\n\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t}\n\n\tif ( typeof fetch === 'undefined' ) {\n\n\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t}\n\n\tLoader.call( this, manager );\n\n\tthis.options = { premultiplyAlpha: 'none' };\n\n}\n\nImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: ImageBitmapLoader,\n\n\tisImageBitmapLoader: true,\n\n\tsetOptions: function setOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t},\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tfetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n} );\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW, noHoles ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tconst toChange = [];\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nclass Font {\n\n\tconstructor( data ) {\n\n\t\tthis.type = 'Font';\n\n\t\tthis.data = data;\n\n\t}\n\n\tgenerateShapes( text, size = 100 ) {\n\n\t\tconst shapes = [];\n\t\tconst paths = createPaths( text, size, this.data );\n\n\t\tfor ( let p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nfunction createPaths( text, size, data ) {\n\n\tconst chars = Array.from( text );\n\tconst scale = size / data.resolution;\n\tconst line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\tconst paths = [];\n\n\tlet offsetX = 0, offsetY = 0;\n\n\tfor ( let i = 0; i < chars.length; i ++ ) {\n\n\t\tconst char = chars[ i ];\n\n\t\tif ( char === '\\n' ) {\n\n\t\t\toffsetX = 0;\n\t\t\toffsetY -= line_height;\n\n\t\t} else {\n\n\t\t\tconst ret = createPath( char, scale, offsetX, offsetY, data );\n\t\t\toffsetX += ret.offsetX;\n\t\t\tpaths.push( ret.path );\n\n\t\t}\n\n\t}\n\n\treturn paths;\n\n}\n\nfunction createPath( char, scale, offsetX, offsetY, data ) {\n\n\tconst glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\tif ( ! glyph ) {\n\n\t\tconsole.error( 'THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.' );\n\n\t\treturn;\n\n\t}\n\n\tconst path = new ShapePath();\n\n\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\tif ( glyph.o ) {\n\n\t\tconst outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\tfor ( let i = 0, l = outline.length; i < l; ) {\n\n\t\t\tconst action = outline[ i ++ ];\n\n\t\t\tswitch ( action ) {\n\n\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { offsetX: glyph.ha * scale, path: path };\n\n}\n\nFont.prototype.isFont = true;\n\nclass FontLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tconst font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\treturn new Font( json );\n\n\t}\n\n}\n\nlet _context;\n\nconst AudioContext = {\n\n\tgetContext: function () {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t},\n\n\tsetContext: function ( value ) {\n\n\t\t_context = value;\n\n\t}\n\n};\n\nclass AudioLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n}\n\nclass HemisphereLightProbe extends LightProbe {\n\n\tconstructor( skyColor, groundColor, intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tconst color1 = new Color().set( skyColor );\n\t\tconst color2 = new Color().set( groundColor );\n\n\t\tconst sky = new Vector3( color1.r, color1.g, color1.b );\n\t\tconst ground = new Vector3( color2.r, color2.g, color2.b );\n\n\t\t// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\t\tconst c0 = Math.sqrt( Math.PI );\n\t\tconst c1 = c0 * Math.sqrt( 0.75 );\n\n\t\tthis.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );\n\t\tthis.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );\n\n\t}\n\n}\n\nHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\n\nclass AmbientLightProbe extends LightProbe {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tconst color1 = new Color().set( color );\n\n\t\t// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\t\tthis.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );\n\n\t}\n\n}\n\nAmbientLightProbe.prototype.isAmbientLightProbe = true;\n\nconst _eyeRight = new Matrix4();\nconst _eyeLeft = new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\tconst projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart ) {\n\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends Object3D {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tthis.source.stop();\n\t\tthis.source.onended = null;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.source.detune === undefined ) return; // only set detune when available\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends Audio {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\nfunction Composite( targetGroup, path, optionalParsedPath ) {\n\n\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n}\n\nObject.assign( Composite.prototype, {\n\n\tgetValue: function ( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function ( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function () {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function () {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n} );\n\n\nfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n}\n\nObject.assign( PropertyBinding, {\n\n\tComposite: Composite,\n\n\tcreate: function ( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tsanitizeNodeName: function ( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t},\n\n\tparseTrackName: function ( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t},\n\n\tfindNode: function ( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n} );\n\nObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function () {},\n\t_setValue_unavailable: function () {},\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tconst source = this.resolvedProperty;\n\n\t\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t],\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function () {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function () {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n} );\n\n// DECLARE ALIAS AFTER assign prototype\nObject.assign( PropertyBinding.prototype, {\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n} );\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\tInterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n}\n\nInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\n\n\tconstructor: InstancedInterleavedBuffer,\n\n\tisInstancedInterleavedBuffer: true,\n\n\tcopy: function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function ( data ) {\n\n\t\tconst ib = InterleavedBuffer.prototype.clone.call( this, data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t},\n\n\ttoJSON: function ( data ) {\n\n\t\tconst json = InterleavedBuffer.prototype.toJSON.call( this, data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n} );\n\nfunction GLBufferAttribute( buffer, type, itemSize, elementSize, count ) {\n\n\tthis.buffer = buffer;\n\tthis.type = type;\n\tthis.itemSize = itemSize;\n\tthis.elementSize = elementSize;\n\tthis.count = count;\n\n\tthis.version = 0;\n\n}\n\nObject.defineProperty( GLBufferAttribute.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nObject.assign( GLBufferAttribute.prototype, {\n\n\tisGLBufferAttribute: true,\n\n\tsetBuffer: function ( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t},\n\n\tsetType: function ( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t},\n\n\tsetItemSize: function ( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t},\n\n\tsetCount: function ( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t},\n\n} );\n\nfunction Raycaster( origin, direction, near = 0, far = Infinity ) {\n\n\tthis.ray = new Ray( origin, direction );\n\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\tthis.near = near;\n\tthis.far = far;\n\tthis.camera = null;\n\tthis.layers = new Layers();\n\n\tthis.params = {\n\t\tMesh: {},\n\t\tLine: { threshold: 1 },\n\t\tLOD: {},\n\t\tPoints: { threshold: 1 },\n\t\tSprite: {}\n\t};\n\n\tObject.defineProperties( this.params, {\n\t\tPointCloud: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\treturn this.Points;\n\n\t\t\t}\n\t\t}\n\t} );\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t}\n\n\tif ( recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Raycaster.prototype, {\n\n\tset: function ( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t},\n\n\tsetFromCamera: function ( coords, camera ) {\n\n\t\tif ( camera && camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera && camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t},\n\n\tintersectObject: function ( object, recursive = false, intersects = [] ) {\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t},\n\n\tintersectObjects: function ( objects, recursive = false, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n} );\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getCenter() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getSize() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getParameter() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst clampedPoint = _vector$4.copy( point ).clamp( this.min, this.max );\n\t\treturn clampedPoint.sub( point ).length();\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nBox2.prototype.isBox2 = true;\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .getCenter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .delta() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = MathUtils.clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction ImmediateRenderObject( material ) {\n\n\tObject3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( /* renderCallback */ ) {};\n\n\tthis.hasPositions = false;\n\tthis.hasNormals = false;\n\tthis.hasColors = false;\n\tthis.hasUvs = false;\n\n\tthis.positionArray = null;\n\tthis.normalArray = null;\n\tthis.colorArray = null;\n\tthis.uvArray = null;\n\n\tthis.count = 0;\n\n}\n\nImmediateRenderObject.prototype = Object.create( Object3D.prototype );\nImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends Object3D {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateMatrixWorld();\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends LineSegments {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'SkeletonHelper';\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object && object.isBone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends LineSegments {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n}\n\nclass PolarGridHelper extends LineSegments {\n\n\tconstructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the radials\n\n\t\tfor ( let i = 0; i <= radials; i ++ ) {\n\n\t\t\tconst v = ( i / radials ) * ( Math.PI * 2 );\n\n\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tvertices.push( x, 0, z );\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t}\n\n\t\t// create the circles\n\n\t\tfor ( let i = 0; i <= circles; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / circles * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2', colorFrustum );\n\t\taddLine( 'n2', 'n4', colorFrustum );\n\t\taddLine( 'n4', 'n3', colorFrustum );\n\t\taddLine( 'n3', 'n1', colorFrustum );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2', colorFrustum );\n\t\taddLine( 'f2', 'f4', colorFrustum );\n\t\taddLine( 'f4', 'f3', colorFrustum );\n\t\taddLine( 'f3', 'f1', colorFrustum );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1', colorFrustum );\n\t\taddLine( 'n2', 'f2', colorFrustum );\n\t\taddLine( 'n3', 'f3', colorFrustum );\n\t\taddLine( 'n4', 'f4', colorFrustum );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1', colorCone );\n\t\taddLine( 'p', 'n2', colorCone );\n\t\taddLine( 'p', 'n3', colorCone );\n\t\taddLine( 'p', 'n4', colorCone );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2', colorUp );\n\t\taddLine( 'u2', 'u3', colorUp );\n\t\taddLine( 'u3', 'u1', colorUp );\n\n\t\t// target\n\n\t\taddLine( 'c', 't', colorTarget );\n\t\taddLine( 'p', 'c', colorCross );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2', colorCross );\n\t\taddLine( 'cn3', 'cn4', colorCross );\n\n\t\taddLine( 'cf1', 'cf2', colorCross );\n\t\taddLine( 'cf3', 'cf4', colorCross );\n\n\t\tfunction addLine( a, b, color ) {\n\n\t\t\taddPoint( a, color );\n\t\t\taddPoint( b, color );\n\n\t\t}\n\n\t\tfunction addPoint( id, color ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends LineSegments {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tLineSegments.prototype.copy.call( this, source );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Box3Helper extends LineSegments {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\nclass PlaneHelper extends Line {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tlet scale = - this.plane.constant;\n\n\t\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\n\n\t\tthis.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends Object3D {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n}\n\nconst _floatView = new Float32Array( 1 );\nconst _int32View = new Int32Array( _floatView.buffer );\n\nconst DataUtils = {\n\n\t// Converts float32 to float16 (stored as uint16 value).\n\n\ttoHalfFloat: function ( val ) {\n\n\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t* used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t* by James Tursa?s half-precision code. */\n\n\t\t_floatView[ 0 ] = val;\n\t\tconst x = _int32View[ 0 ];\n\n\t\tlet bits = ( x >> 16 ) & 0x8000; /* Get the sign */\n\t\tlet m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */\n\t\tconst e = ( x >> 23 ) & 0xff; /* Using int is faster here */\n\n\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t* half, return signed zero. */\n\t\tif ( e < 103 ) return bits;\n\n\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\t\tif ( e > 142 ) {\n\n\t\t\tbits |= 0x7c00;\n\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t* not Inf, so make sure we set one mantissa bit too. */\n\t\t\tbits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );\n\t\t\treturn bits;\n\n\t\t}\n\n\t\t/* If exponent underflows but not too much, return a denormal */\n\t\tif ( e < 113 ) {\n\n\t\t\tm |= 0x0800;\n\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t* to 1, which is OK. */\n\t\t\tbits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );\n\t\t\treturn bits;\n\n\t\t}\n\n\t\tbits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );\n\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t* the exponent, which is OK. */\n\t\tbits += m & 1;\n\t\treturn bits;\n\n\t}\n\n};\n\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow( 2, LOD_MAX );\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst ENCODINGS = {\n\t[ LinearEncoding ]: 0,\n\t[ sRGBEncoding ]: 1,\n\t[ RGBEEncoding ]: 2,\n\t[ RGBM7Encoding ]: 3,\n\t[ RGBM16Encoding ]: 4,\n\t[ RGBDEncoding ]: 5,\n\t[ GammaEncoding ]: 6\n};\n\nconst backgroundMaterial = new MeshBasicMaterial( {\n\tside: BackSide,\n\tdepthWrite: false,\n\tdepthTest: false,\n} );\nconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nfunction convertLinearToRGBE( color ) {\n\n\tconst maxComponent = Math.max( color.r, color.g, color.b );\n\tconst fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );\n\tcolor.multiplyScalar( Math.pow( 2.0, - fExp ) );\n\n\tconst alpha = ( fExp + 128.0 ) / 255.0;\n\treturn alpha;\n\n}\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._blurMaterial = _getBlurShader( MAX_SAMPLES );\n\t\tthis._equirectShader = null;\n\t\tthis._cubemapShader = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular ) {\n\n\t\treturn this._fromTexture( equirectangular );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap ) {\n\n\t\treturn this._fromTexture( cubemap );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapShader === null ) {\n\n\t\t\tthis._cubemapShader = _getCubemapShader();\n\t\t\tthis._compileMaterial( this._cubemapShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectShader === null ) {\n\n\t\t\tthis._equirectShader = _getEquirectShader();\n\t\t\tthis._compileMaterial( this._equirectShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._blurMaterial.dispose();\n\n\t\tif ( this._cubemapShader !== null ) this._cubemapShader.dispose();\n\t\tif ( this._equirectShader !== null ) this._equirectShader.dispose();\n\n\t\tfor ( let i = 0; i < _lodPlanes.length; i ++ ) {\n\n\t\t\t_lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._pingPongRenderTarget.dispose();\n\t\tthis._renderer.setRenderTarget( _oldTarget );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets( texture );\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets( texture ) { // warning: null texture is valid\n\n\t\tconst params = {\n\t\t\tmagFilter: NearestFilter,\n\t\t\tminFilter: NearestFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: UnsignedByteType,\n\t\t\tformat: RGBEFormat,\n\t\t\tencoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( params );\n\t\tcubeUVRenderTarget.depthBuffer = texture ? false : true;\n\t\tthis._pingPongRenderTarget = _createRenderTarget( params );\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( _lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst outputEncoding = renderer.outputEncoding;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputEncoding = LinearEncoding;\n\t\trenderer.autoClear = false;\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background ).convertSRGBToLinear();\n\t\t\t\tscene.background = null;\n\n\t\t\t\tconst alpha = convertLinearToRGBE( backgroundMaterial.color );\n\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor ).convertSRGBToLinear();\n\n\t\t\tconst alpha = convertLinearToRGBE( backgroundMaterial.color );\n\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\t\t\tif ( col == 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col == 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\t_setViewport( cubeUVRenderTarget,\n\t\t\t\tcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputEncoding = outputEncoding;\n\t\trenderer.autoClear = originalAutoClear;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( this._cubemapShader == null ) {\n\n\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectShader == null ) {\n\n\t\t\t\tthis._equirectShader = _getEquirectShader();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n\t\tconst mesh = new Mesh( _lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tif ( ! texture.isCubeTexture ) {\n\n\t\t\tuniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );\n\n\t\t}\n\n\t\tuniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\t\tuniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tfor ( let i = 1; i < TOTAL_LODS; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = _sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i == 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;\n\t\tblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\t\tblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\n\t\tconst outputSize = _sizeLods[ lodOut ];\n\t\tconst x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );\n\t\tconst y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _isLDR( texture ) {\n\n\tif ( texture === undefined || texture.type !== UnsignedByteType ) return false;\n\n\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n\n}\n\nfunction _createPlanes() {\n\n\tconst _lodPlanes = [];\n\tconst _sizeLods = [];\n\tconst _sigmas = [];\n\n\tlet lod = LOD_MAX;\n\n\tfor ( let i = 0; i < TOTAL_LODS; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\t_sizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > LOD_MAX - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];\n\n\t\t} else if ( i == 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\t_sigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 1 );\n\t\tconst min = - texelSize / 2;\n\t\tconst max = 1 + texelSize / 2;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\t_lodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { _lodPlanes, _sizeLods, _sigmas };\n\n}\n\nfunction _createRenderTarget( params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( maxSamples ) {\n\n\tconst weights = new Float32Array( maxSamples );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: { 'n': maxSamples },\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectShader() {\n\n\tconst texelSize = new Vector2( 1, 1 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'texelSize': { value: texelSize },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCubemapShader() {\n\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction _getEncodings() {\n\n\treturn /* glsl */`\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`;\n\n}\n\nconst LineStrip = 0;\nconst LinePieces = 1;\nconst NoColors = 0;\nconst FaceColors = 1;\nconst VertexColors = 2;\n\nfunction MeshFaceMaterial( materials ) {\n\n\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\n\treturn materials;\n\n}\n\nfunction MultiMaterial( materials = [] ) {\n\n\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\n\tmaterials.isMultiMaterial = true;\n\tmaterials.materials = materials;\n\tmaterials.clone = function () {\n\n\t\treturn materials.slice();\n\n\t};\n\n\treturn materials;\n\n}\n\nfunction PointCloud( geometry, material ) {\n\n\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction Particle( material ) {\n\n\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\n\treturn new Sprite( material );\n\n}\n\nfunction ParticleSystem( geometry, material ) {\n\n\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction PointCloudMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleBasicMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleSystemMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction Vertex( x, y, z ) {\n\n\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\treturn new Vector3( x, y, z );\n\n}\n\n//\n\nfunction DynamicBufferAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );\n\treturn new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );\n\n}\n\nfunction Int8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\n\treturn new Int8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\n\treturn new Uint8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\n\treturn new Uint8ClampedBufferAttribute( array, itemSize );\n\n}\n\nfunction Int16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\n\treturn new Int16BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\n\treturn new Uint16BufferAttribute( array, itemSize );\n\n}\n\nfunction Int32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\n\treturn new Int32BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\n\treturn new Uint32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\n\treturn new Float32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float64Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\n\treturn new Float64BufferAttribute( array, itemSize );\n\n}\n\n//\n\nCurve.create = function ( construct, getPoint ) {\n\n\tconsole.log( 'THREE.Curve.create() has been deprecated' );\n\n\tconstruct.prototype = Object.create( Curve.prototype );\n\tconstruct.prototype.constructor = construct;\n\tconstruct.prototype.getPoint = getPoint;\n\n\treturn construct;\n\n};\n\n//\n\nPath.prototype.fromPoints = function ( points ) {\n\n\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\n\treturn this.setFromPoints( points );\n\n};\n\n//\n\nfunction AxisHelper( size ) {\n\n\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\n\treturn new AxesHelper( size );\n\n}\n\nfunction BoundingBoxHelper( object, color ) {\n\n\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\n\treturn new BoxHelper( object, color );\n\n}\n\nfunction EdgesHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\nGridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\nSkeletonHelper.prototype.update = function () {\n\n\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\n\n};\n\nfunction WireframeHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\n//\n\nLoader.prototype.extractUrlBase = function ( url ) {\n\n\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\n\treturn LoaderUtils.extractUrlBase( url );\n\n};\n\nLoader.Handlers = {\n\n\tadd: function ( /* regex, loader */ ) {\n\n\t\tconsole.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );\n\n\t},\n\n\tget: function ( /* file */ ) {\n\n\t\tconsole.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );\n\n\t}\n\n};\n\nfunction XHRLoader( manager ) {\n\n\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\n\treturn new FileLoader( manager );\n\n}\n\nfunction BinaryTextureLoader( manager ) {\n\n\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\n\treturn new DataTextureLoader( manager );\n\n}\n\n//\n\nBox2.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\nBox2.prototype.empty = function () {\n\n\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\treturn this.isEmpty();\n\n};\n\nBox2.prototype.isIntersectionBox = function ( box ) {\n\n\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\treturn this.intersectsBox( box );\n\n};\n\nBox2.prototype.size = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\treturn this.getSize( optionalTarget );\n\n};\n\n//\n\nBox3.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\nBox3.prototype.empty = function () {\n\n\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\treturn this.isEmpty();\n\n};\n\nBox3.prototype.isIntersectionBox = function ( box ) {\n\n\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\treturn this.intersectsBox( box );\n\n};\n\nBox3.prototype.isIntersectionSphere = function ( sphere ) {\n\n\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\treturn this.intersectsSphere( sphere );\n\n};\n\nBox3.prototype.size = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\treturn this.getSize( optionalTarget );\n\n};\n\n//\n\nSphere.prototype.empty = function () {\n\n\tconsole.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );\n\treturn this.isEmpty();\n\n};\n\n//\n\nFrustum.prototype.setFromMatrix = function ( m ) {\n\n\tconsole.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );\n\treturn this.setFromProjectionMatrix( m );\n\n};\n\n//\n\nLine3.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\n//\n\nMathUtils.random16 = function () {\n\n\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\n\treturn Math.random();\n\n};\n\nMathUtils.nearestPowerOfTwo = function ( value ) {\n\n\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\n\treturn MathUtils.floorPowerOfTwo( value );\n\n};\n\nMathUtils.nextPowerOfTwo = function ( value ) {\n\n\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\n\treturn MathUtils.ceilPowerOfTwo( value );\n\n};\n\n//\n\nMatrix3.prototype.flattenToArrayOffset = function ( array, offset ) {\n\n\tconsole.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );\n\treturn this.toArray( array, offset );\n\n};\n\nMatrix3.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\treturn vector.applyMatrix3( this );\n\n};\n\nMatrix3.prototype.multiplyVector3Array = function ( /* a */ ) {\n\n\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\n\n};\n\nMatrix3.prototype.applyToBufferAttribute = function ( attribute ) {\n\n\tconsole.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );\n\treturn attribute.applyMatrix3( this );\n\n};\n\nMatrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {\n\n\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\n\n};\n\nMatrix3.prototype.getInverse = function ( matrix ) {\n\n\tconsole.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );\n\treturn this.copy( matrix ).invert();\n\n};\n\n//\n\nMatrix4.prototype.extractPosition = function ( m ) {\n\n\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\treturn this.copyPosition( m );\n\n};\n\nMatrix4.prototype.flattenToArrayOffset = function ( array, offset ) {\n\n\tconsole.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );\n\treturn this.toArray( array, offset );\n\n};\n\nMatrix4.prototype.getPosition = function () {\n\n\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\treturn new Vector3().setFromMatrixColumn( this, 3 );\n\n};\n\nMatrix4.prototype.setRotationFromQuaternion = function ( q ) {\n\n\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\treturn this.makeRotationFromQuaternion( q );\n\n};\n\nMatrix4.prototype.multiplyToArray = function () {\n\n\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\n\n};\n\nMatrix4.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\treturn vector.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.multiplyVector4 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\treturn vector.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.multiplyVector3Array = function ( /* a */ ) {\n\n\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateAxis = function ( v ) {\n\n\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\tv.transformDirection( this );\n\n};\n\nMatrix4.prototype.crossVector = function ( vector ) {\n\n\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\treturn vector.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.translate = function () {\n\n\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateX = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateY = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateZ = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\n};\n\nMatrix4.prototype.rotateByAxis = function () {\n\n\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\n};\n\nMatrix4.prototype.applyToBufferAttribute = function ( attribute ) {\n\n\tconsole.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );\n\treturn attribute.applyMatrix4( this );\n\n};\n\nMatrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {\n\n\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\n\n};\n\nMatrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {\n\n\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\n\treturn this.makePerspective( left, right, top, bottom, near, far );\n\n};\n\nMatrix4.prototype.getInverse = function ( matrix ) {\n\n\tconsole.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );\n\treturn this.copy( matrix ).invert();\n\n};\n\n//\n\nPlane.prototype.isIntersectionLine = function ( line ) {\n\n\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\treturn this.intersectsLine( line );\n\n};\n\n//\n\nQuaternion.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\treturn vector.applyQuaternion( this );\n\n};\n\nQuaternion.prototype.inverse = function ( ) {\n\n\tconsole.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );\n\treturn this.invert();\n\n};\n\n//\n\nRay.prototype.isIntersectionBox = function ( box ) {\n\n\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\treturn this.intersectsBox( box );\n\n};\n\nRay.prototype.isIntersectionPlane = function ( plane ) {\n\n\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\treturn this.intersectsPlane( plane );\n\n};\n\nRay.prototype.isIntersectionSphere = function ( sphere ) {\n\n\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\treturn this.intersectsSphere( sphere );\n\n};\n\n//\n\nTriangle.prototype.area = function () {\n\n\tconsole.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );\n\treturn this.getArea();\n\n};\n\nTriangle.prototype.barycoordFromPoint = function ( point, target ) {\n\n\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\treturn this.getBarycoord( point, target );\n\n};\n\nTriangle.prototype.midpoint = function ( target ) {\n\n\tconsole.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );\n\treturn this.getMidpoint( target );\n\n};\n\nTriangle.prototypenormal = function ( target ) {\n\n\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\treturn this.getNormal( target );\n\n};\n\nTriangle.prototype.plane = function ( target ) {\n\n\tconsole.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );\n\treturn this.getPlane( target );\n\n};\n\nTriangle.barycoordFromPoint = function ( point, a, b, c, target ) {\n\n\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\treturn Triangle.getBarycoord( point, a, b, c, target );\n\n};\n\nTriangle.normal = function ( a, b, c, target ) {\n\n\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\treturn Triangle.getNormal( a, b, c, target );\n\n};\n\n//\n\nShape.prototype.extractAllPoints = function ( divisions ) {\n\n\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\n\treturn this.extractPoints( divisions );\n\n};\n\nShape.prototype.extrude = function ( options ) {\n\n\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\treturn new ExtrudeGeometry( this, options );\n\n};\n\nShape.prototype.makeGeometry = function ( options ) {\n\n\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\treturn new ShapeGeometry( this, options );\n\n};\n\n//\n\nVector2.prototype.fromAttribute = function ( attribute, index, offset ) {\n\n\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\treturn this.fromBufferAttribute( attribute, index, offset );\n\n};\n\nVector2.prototype.distanceToManhattan = function ( v ) {\n\n\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\treturn this.manhattanDistanceTo( v );\n\n};\n\nVector2.prototype.lengthManhattan = function () {\n\n\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\n\treturn this.manhattanLength();\n\n};\n\n//\n\nVector3.prototype.setEulerFromRotationMatrix = function () {\n\n\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\n};\n\nVector3.prototype.setEulerFromQuaternion = function () {\n\n\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\n};\n\nVector3.prototype.getPositionFromMatrix = function ( m ) {\n\n\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\treturn this.setFromMatrixPosition( m );\n\n};\n\nVector3.prototype.getScaleFromMatrix = function ( m ) {\n\n\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\treturn this.setFromMatrixScale( m );\n\n};\n\nVector3.prototype.getColumnFromMatrix = function ( index, matrix ) {\n\n\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\treturn this.setFromMatrixColumn( matrix, index );\n\n};\n\nVector3.prototype.applyProjection = function ( m ) {\n\n\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\n\treturn this.applyMatrix4( m );\n\n};\n\nVector3.prototype.fromAttribute = function ( attribute, index, offset ) {\n\n\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\treturn this.fromBufferAttribute( attribute, index, offset );\n\n};\n\nVector3.prototype.distanceToManhattan = function ( v ) {\n\n\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\treturn this.manhattanDistanceTo( v );\n\n};\n\nVector3.prototype.lengthManhattan = function () {\n\n\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\n\treturn this.manhattanLength();\n\n};\n\n//\n\nVector4.prototype.fromAttribute = function ( attribute, index, offset ) {\n\n\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\treturn this.fromBufferAttribute( attribute, index, offset );\n\n};\n\nVector4.prototype.lengthManhattan = function () {\n\n\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\n\treturn this.manhattanLength();\n\n};\n\n//\n\nObject3D.prototype.getChildByName = function ( name ) {\n\n\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\treturn this.getObjectByName( name );\n\n};\n\nObject3D.prototype.renderDepth = function () {\n\n\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\n};\n\nObject3D.prototype.translate = function ( distance, axis ) {\n\n\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\treturn this.translateOnAxis( axis, distance );\n\n};\n\nObject3D.prototype.getWorldRotation = function () {\n\n\tconsole.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );\n\n};\n\nObject3D.prototype.applyMatrix = function ( matrix ) {\n\n\tconsole.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );\n\treturn this.applyMatrix4( matrix );\n\n};\n\nObject.defineProperties( Object3D.prototype, {\n\n\teulerOrder: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t}\n\t}\n\n} );\n\nMesh.prototype.setDrawMode = function () {\n\n\tconsole.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );\n\n};\n\nObject.defineProperties( Mesh.prototype, {\n\n\tdrawMode: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );\n\t\t\treturn TrianglesDrawMode;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );\n\n\t\t}\n\t}\n\n} );\n\nSkinnedMesh.prototype.initBones = function () {\n\n\tconsole.error( 'THREE.SkinnedMesh: initBones() has been removed.' );\n\n};\n\nObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\n\n\tget: function () {\n\n\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\treturn this.arcLengthDivisions;\n\n\t},\n\tset: function ( value ) {\n\n\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\tthis.arcLengthDivisions = value;\n\n\t}\n\n} );\n\n//\n\nPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +\n\t\t\t'Use .setFocalLength and .filmGauge for a photographic setup.' );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( Light.prototype, {\n\tonlyShadow: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( BufferAttribute.prototype, {\n\n\tlength: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\n\t\t\treturn this.array.length;\n\n\t\t}\n\t},\n\tdynamic: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );\n\t\t\treturn this.usage === DynamicDrawUsage;\n\n\t\t},\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );\n\t\t\tthis.setUsage( DynamicDrawUsage );\n\n\t\t}\n\t}\n\n} );\n\nBufferAttribute.prototype.setDynamic = function ( value ) {\n\n\tconsole.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );\n\tthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );\n\treturn this;\n\n};\n\nBufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {\n\n\tconsole.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );\n\n},\n\nBufferAttribute.prototype.setArray = function ( /* array */ ) {\n\n\tconsole.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );\n\n};\n\n//\n\nBufferGeometry.prototype.addIndex = function ( index ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\tthis.setIndex( index );\n\n};\n\nBufferGeometry.prototype.addAttribute = function ( name, attribute ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );\n\n\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\treturn this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t}\n\n\tif ( name === 'index' ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\tthis.setIndex( attribute );\n\n\t\treturn this;\n\n\t}\n\n\treturn this.setAttribute( name, attribute );\n\n};\n\nBufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {\n\n\tif ( indexOffset !== undefined ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\n\t}\n\n\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\tthis.addGroup( start, count );\n\n};\n\nBufferGeometry.prototype.clearDrawCalls = function () {\n\n\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\tthis.clearGroups();\n\n};\n\nBufferGeometry.prototype.computeOffsets = function () {\n\n\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\n};\n\nBufferGeometry.prototype.removeAttribute = function ( name ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );\n\n\treturn this.deleteAttribute( name );\n\n};\n\nBufferGeometry.prototype.applyMatrix = function ( matrix ) {\n\n\tconsole.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );\n\treturn this.applyMatrix4( matrix );\n\n};\n\nObject.defineProperties( BufferGeometry.prototype, {\n\n\tdrawcalls: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( InstancedBufferGeometry.prototype, {\n\n\tmaxInstancedCount: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );\n\t\t\treturn this.instanceCount;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );\n\t\t\tthis.instanceCount = value;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( Raycaster.prototype, {\n\n\tlinePrecision: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );\n\t\t\treturn this.params.Line.threshold;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );\n\t\t\tthis.params.Line.threshold = value;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( InterleavedBuffer.prototype, {\n\n\tdynamic: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );\n\t\t\treturn this.usage === DynamicDrawUsage;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );\n\t\t\tthis.setUsage( value );\n\n\t\t}\n\t}\n\n} );\n\nInterleavedBuffer.prototype.setDynamic = function ( value ) {\n\n\tconsole.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );\n\tthis.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );\n\treturn this;\n\n};\n\nInterleavedBuffer.prototype.setArray = function ( /* array */ ) {\n\n\tconsole.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );\n\n};\n\n//\n\nExtrudeGeometry.prototype.getArrays = function () {\n\n\tconsole.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );\n\n};\n\nExtrudeGeometry.prototype.addShapeList = function () {\n\n\tconsole.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );\n\n};\n\nExtrudeGeometry.prototype.addShape = function () {\n\n\tconsole.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );\n\n};\n\n//\n\nScene.prototype.dispose = function () {\n\n\tconsole.error( 'THREE.Scene: .dispose() has been removed.' );\n\n};\n\n//\n\nUniform.prototype.onUpdate = function () {\n\n\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\treturn this;\n\n};\n\n//\n\nObject.defineProperties( Material.prototype, {\n\n\twrapAround: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t}\n\t},\n\n\toverdraw: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t}\n\t},\n\n\twrapRGB: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\n\t\t\treturn new Color();\n\n\t\t}\n\t},\n\n\tshading: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\tthis.flatShading = ( value === FlatShading );\n\n\t\t}\n\t},\n\n\tstencilMask: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );\n\t\t\treturn this.stencilFuncMask;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );\n\t\t\tthis.stencilFuncMask = value;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( MeshPhysicalMaterial.prototype, {\n\n\ttransparency: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );\n\t\t\treturn this.transmission;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );\n\t\t\tthis.transmission = value;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( ShaderMaterial.prototype, {\n\n\tderivatives: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nWebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );\n\tthis.setRenderTarget( renderTarget );\n\tthis.clear( color, depth, stencil );\n\n};\n\nWebGLRenderer.prototype.animate = function ( callback ) {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );\n\tthis.setAnimationLoop( callback );\n\n};\n\nWebGLRenderer.prototype.getCurrentRenderTarget = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\n\treturn this.getRenderTarget();\n\n};\n\nWebGLRenderer.prototype.getMaxAnisotropy = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\n\treturn this.capabilities.getMaxAnisotropy();\n\n};\n\nWebGLRenderer.prototype.getPrecision = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\n\treturn this.capabilities.precision;\n\n};\n\nWebGLRenderer.prototype.resetGLState = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\n\treturn this.state.reset();\n\n};\n\nWebGLRenderer.prototype.supportsFloatTextures = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\treturn this.extensions.get( 'OES_texture_float' );\n\n};\n\nWebGLRenderer.prototype.supportsHalfFloatTextures = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\treturn this.extensions.get( 'OES_texture_half_float' );\n\n};\n\nWebGLRenderer.prototype.supportsStandardDerivatives = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\treturn this.extensions.get( 'OES_standard_derivatives' );\n\n};\n\nWebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n};\n\nWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n};\n\nWebGLRenderer.prototype.supportsBlendMinMax = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\treturn this.extensions.get( 'EXT_blend_minmax' );\n\n};\n\nWebGLRenderer.prototype.supportsVertexTextures = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\n\treturn this.capabilities.vertexTextures;\n\n};\n\nWebGLRenderer.prototype.supportsInstancedArrays = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\n};\n\nWebGLRenderer.prototype.enableScissorTest = function ( boolean ) {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\tthis.setScissorTest( boolean );\n\n};\n\nWebGLRenderer.prototype.initMaterial = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.addPrePlugin = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.addPostPlugin = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.updateShadowMap = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setFaceCulling = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.allocTextureUnit = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setTexture = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setTexture2D = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.setTextureCube = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );\n\n};\n\nWebGLRenderer.prototype.getActiveMipMapLevel = function () {\n\n\tconsole.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );\n\treturn this.getActiveMipmapLevel();\n\n};\n\nObject.defineProperties( WebGLRenderer.prototype, {\n\n\tshadowMapEnabled: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.enabled;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\tcontext: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );\n\t\t\treturn this.getContext();\n\n\t\t}\n\t},\n\tvr: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );\n\t\t\treturn this.xr;\n\n\t\t}\n\t},\n\tgammaInput: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );\n\t\t\treturn false;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );\n\n\t\t}\n\t},\n\tgammaOutput: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );\n\t\t\treturn false;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );\n\t\t\tthis.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;\n\n\t\t}\n\t},\n\ttoneMappingWhitePoint: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );\n\t\t\treturn 1.0;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );\n\n\t\t}\n\t},\n\n} );\n\nObject.defineProperties( WebGLShadowMap.prototype, {\n\n\tcullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* cullFace */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderReverseSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderSingleSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t}\n\n} );\n\nfunction WebGLRenderTargetCube( width, height, options ) {\n\n\tconsole.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );\n\treturn new WebGLCubeRenderTarget( width, options );\n\n}\n\n//\n\nObject.defineProperties( WebGLRenderTarget.prototype, {\n\n\twrapS: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nAudio.prototype.load = function ( file ) {\n\n\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\n\tconst scope = this;\n\tconst audioLoader = new AudioLoader();\n\taudioLoader.load( file, function ( buffer ) {\n\n\t\tscope.setBuffer( buffer );\n\n\t} );\n\treturn this;\n\n};\n\n\nAudioAnalyser.prototype.getData = function () {\n\n\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\treturn this.getFrequencyData();\n\n};\n\n//\n\nCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\n\n\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\n\treturn this.update( renderer, scene );\n\n};\n\nCubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {\n\n\tconsole.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );\n\treturn this.renderTarget.clear( renderer, color, depth, stencil );\n\n};\n\nImageUtils.crossOrigin = undefined;\n\nImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\tconst loader = new TextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tconst texture = loader.load( url, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\tconst loader = new CubeTextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tconst texture = loader.load( urls, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadCompressedTexture = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\nImageUtils.loadCompressedTextureCube = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\n//\n\nfunction CanvasRenderer() {\n\n\tconsole.error( 'THREE.CanvasRenderer has been removed' );\n\n}\n\n//\n\nfunction JSONLoader() {\n\n\tconsole.error( 'THREE.JSONLoader has been removed.' );\n\n}\n\n//\n\nconst SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( /* geometry, materials */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\n\n\t},\n\n\tdetach: function ( /* child, parent, scene */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\n\n\t},\n\n\tattach: function ( /* child, scene, parent */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );\n\n\t}\n\n};\n\n//\n\nfunction LensFlare() {\n\n\tconsole.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );\n\n}\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t/* eslint-disable no-undef */\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\t/* eslint-enable no-undef */\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/three/build/three.module.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _lib_stats_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/stats.module.js */ \"./src/lib/stats.module.js\");\n/* harmony import */ var pepjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pepjs */ \"./node_modules/pepjs/dist/pep.js\");\n/* harmony import */ var pepjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pepjs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/GLTFLoader.js */ \"./src/lib/GLTFLoader.js\");\n/* harmony import */ var _assets_boy_glb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assets/boy.glb */ \"./assets/boy.glb\");\n/* harmony import */ var _assets_Cop_glb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../assets/Cop.glb */ \"./assets/Cop.glb\");\n/* harmony import */ var _assets_NormalCar1_glb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../assets/NormalCar1.glb */ \"./assets/NormalCar1.glb\");\n/* harmony import */ var _assets_NormalCar2_glb__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../assets/NormalCar2.glb */ \"./assets/NormalCar2.glb\");\n/* harmony import */ var _assets_SportsCar_glb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../assets/SportsCar.glb */ \"./assets/SportsCar.glb\");\n/* harmony import */ var _assets_SportsCar2_glb__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../assets/SportsCar2.glb */ \"./assets/SportsCar2.glb\");\n/* harmony import */ var _assets_SUV_glb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../assets/SUV.glb */ \"./assets/SUV.glb\");\n/* harmony import */ var _assets_Taxi_glb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../assets/Taxi.glb */ \"./assets/Taxi.glb\");\n/* harmony import */ var _shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./shaders/fragment.glsl */ \"./src/shaders/fragment.glsl\");\n/* harmony import */ var _shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./shaders/vertex.glsl */ \"./src/shaders/vertex.glsl\");\n/* harmony import */ var _shaders_explosion_png__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./shaders/explosion.png */ \"./src/shaders/explosion.png\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst cars = [\r\n    {id:0, weight:9, model: _assets_NormalCar1_glb__WEBPACK_IMPORTED_MODULE_6__[\"default\"]},\r\n    {id:1, weight:9, model: _assets_NormalCar2_glb__WEBPACK_IMPORTED_MODULE_7__[\"default\"]},\r\n    {id:2, weight:9, model: _assets_SUV_glb__WEBPACK_IMPORTED_MODULE_10__[\"default\"]},\r\n    {id:3, weight:3, model: _assets_SportsCar_glb__WEBPACK_IMPORTED_MODULE_8__[\"default\"]},\r\n    {id:4, weight:3, model: _assets_SportsCar2_glb__WEBPACK_IMPORTED_MODULE_9__[\"default\"]},\r\n    {id:5, weight:1, model: _assets_Cop_glb__WEBPACK_IMPORTED_MODULE_5__[\"default\"]},\r\n    {id:6, weight:1, model: _assets_Taxi_glb__WEBPACK_IMPORTED_MODULE_11__[\"default\"]},\r\n];\r\n\r\nconst container = document.getElementById('container');\r\n\r\nlet debugLevel = 0;\r\n\r\nlet scene;\r\nlet heroInstance, obstacleInstance, ground, fireball, ui;\r\n\r\nconst worldHalfWidth = 2.3; // reachable world halfWidth in three.js units\r\nconst INITIAL_SPAWN_DELAY = 3;\r\nconst INITIAL_SCROLL_SPEED = 2;\r\nlet obstacleSpawnDelay = INITIAL_SPAWN_DELAY; // Use space between instead?\r\nlet scrollSpeed = 0;\r\nconst worldHalfLength = 8;\r\nconst MAX_INACTIVITY = 18; // Seconds\r\nconst BUILD_VERSION = '1.0';\r\n\r\nlet playable;\r\n\r\nwindow.addEventListener('load', onWindowLoad);\r\n\r\nfunction onWindowLoad() {\r\n    if (typeof mraid !== 'undefined') { // MRAID (Unity)\r\n        if (mraid.getState() === 'loading') {\r\n            mraid.addEventListener('ready', onMRAIDReady);\r\n        } else {\r\n            onMRAIDReady();\r\n        }\r\n    } else { // Facebook or debug\r\n        // playGame();\r\n    }\r\n}\r\n\r\nfunction onMRAIDReady() {\r\n    // console.log(\"MRAID ready\");\r\n    // mraid.addEventListener('viewableChange', onViewableChange);\r\n    // Wait for the ad to become viewable for the first time\r\n    if (mraid.isViewable()) {\r\n        // playGame()\r\n    }\r\n}\r\n\r\nclass Playable {\r\n    constructor() {\r\n        console.log(\"Version: \" + BUILD_VERSION);\r\n        this.renderer = new three__WEBPACK_IMPORTED_MODULE_0__[\"WebGL1Renderer\"]({ antialias: true });\r\n        this.renderer.setPixelRatio(window.devicePixelRatio);\r\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n        this.renderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_0__[\"sRGBEncoding\"];\r\n        this.renderer.shadowMap.enabled = true;\r\n        container.appendChild(this.renderer.domElement);\r\n\r\n        let ratio = window.innerWidth / window.innerHeight;\r\n        this.camera = new three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"](\r\n            50, ratio, 1, 100\r\n        );\r\n        this.camera.position.set(0, 7, -5);\r\n        this.camera.lookAt(0, 0, 0);\r\n\r\n        this.clock = new three__WEBPACK_IMPORTED_MODULE_0__[\"Clock\"]();\r\n        this.tapCount = 0;\r\n        this.lastTap = 0;\r\n        this.tapDuration = 0.5;\r\n\r\n        scene = new three__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]();\r\n        scene.background = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0x11422a);\r\n\r\n        const hemiLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"HemisphereLight\"](0xffffff, 0x444444, 1);\r\n        hemiLight.position.set(0, 20, 0);\r\n        scene.add(hemiLight);\r\n\r\n        const dirLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"DirectionalLight\"](0xffffff, 1);\r\n        dirLight.position.set(-7, 15, -7);\r\n        dirLight.castShadow = true;\r\n        dirLight.shadow.camera.top = 8;\r\n        dirLight.shadow.camera.bottom = -8;\r\n        dirLight.shadow.camera.left = -8;\r\n        dirLight.shadow.camera.right = 8;\r\n        dirLight.shadow.camera.near = 0.1;\r\n        dirLight.shadow.camera.far = 40;\r\n        scene.add(dirLight);\r\n\r\n        ground = new Ground();\r\n\r\n        this.pointer = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n        this.raycaster = new three__WEBPACK_IMPORTED_MODULE_0__[\"Raycaster\"]();\r\n\r\n        const loader = new _lib_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_3__[\"GLTFLoader\"]();\r\n\r\n        heroInstance = new Hero(loader, this);\r\n        obstacleInstance = new Obstacles(loader);\r\n        fireball = new Fireball();\r\n        ui = new UI(this);\r\n        this.registerPointerEvents(container);\r\n\r\n        if (debugLevel) {\r\n            this.stats = new _lib_stats_module_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n            container.appendChild(this.stats.dom);\r\n\r\n            if (debugLevel > 1) this.addHelpers();\r\n        }\r\n\r\n        this.interactionStarted = false;\r\n\r\n        this.step = 1 / 60;\r\n        this.acc = 0;\r\n        this.updateIndex = 0;\r\n        this.startInactivityTimer();\r\n\r\n        window.addEventListener('resize', this.onWindowResize.bind(this));\r\n    }\r\n\r\n    // Render loop\r\n    animate() {\r\n        requestAnimationFrame(this.animate.bind(this));\r\n\r\n        let mixerUpdateDelta = this.clock.getDelta();\r\n        // if (mixerUpdateDelta > 1) console.warn(\"Delta time > 1 sec\")\r\n\r\n        if (!this.isFinished) {\r\n            if (this.interactionStarted) {\r\n                obstacleInstance.sinceSpawn += mixerUpdateDelta;\r\n                this.runTime = this.clock.getElapsedTime() - this.runStartTime;\r\n                ui.updateTimer(Math.floor(this.runTime));\r\n            } else {\r\n                this.sinceStart += mixerUpdateDelta;\r\n                if (this.sinceStart > MAX_INACTIVITY) {\r\n                    ui.hideInfo();\r\n                    this.gameOver();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.acc += mixerUpdateDelta;\r\n        while (this.acc > this.step) {\r\n            this.acc -= this.step;\r\n            this.isFinished ? fireball.updateTimers(this.step) : this.updateLogic(this.step);\r\n            this.updateIndex++;\r\n        }\r\n        this.updateIndex = 0;\r\n\r\n        if (!this.isFinished) heroInstance.mixer.update(mixerUpdateDelta);\r\n\r\n        if (debugLevel) {\r\n            // hero.bboxHelper.update();\r\n            this.stats.update();\r\n        }\r\n\r\n        if (this.isFinished) {\r\n            fireball.update();\r\n        }\r\n\r\n\r\n        this.renderer.render(scene, this.camera);\r\n    }\r\n\r\n    // Logic loop\r\n    updateLogic(deltaSec) {\r\n        heroInstance.update(deltaSec);\r\n        obstacleInstance.update(deltaSec);\r\n        ground.update(deltaSec);\r\n    }\r\n\r\n    setTarget(domElement, event) {\r\n        this.pointer.x = (event.clientX / domElement.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (event.clientY / domElement.clientHeight) * 2 + 1;\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersects = this.raycaster.intersectObject(ground.mesh);\r\n        if (intersects[0]) {\r\n            let pointX = intersects[0].point.x;\r\n            heroInstance.targetX = pointX < 0 ? Math.max(pointX, -worldHalfWidth - 0.3) : Math.min(pointX, worldHalfWidth + 0.3);\r\n        }\r\n        else {\r\n            heroInstance.targetX = this.pointer.x > 0 ? -worldHalfWidth - 0.3 : worldHalfWidth + 0.3;\r\n        }\r\n    }\r\n\r\n    moveTarget(domElement, event) {\r\n        this.pointer.x = (event.clientX / domElement.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (event.clientY / domElement.clientHeight) * 2 + 1;\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersects = this.raycaster.intersectObject(ground.mesh);\r\n        if (intersects[0]) {\r\n            let pointX = intersects[0].point.x;\r\n            heroInstance.targetX = pointX < 0 ? Math.max(pointX, -worldHalfWidth - 0.3) : Math.min(pointX, worldHalfWidth + 0.3);\r\n        }\r\n        else {\r\n            heroInstance.targetX = this.pointer.x > 0 ? -worldHalfWidth - 0.3 : worldHalfWidth + 0.3;\r\n        }\r\n    }\r\n\r\n    // ToDo: rename addCharacterControls? Or split. Register events here, define event handlers (controls somewhere else)\r\n    registerPointerEvents(domElement) {\r\n        domElement.addEventListener('pointerdown', (event) => {\r\n            event.preventDefault();\r\n            if (!this.isFinished && event.isPrimary) {\r\n                if (!this.interactionStarted) {\r\n                    this.interactionStarted = true;\r\n                    this.runStartTime = this.clock.getElapsedTime();\r\n                    scrollSpeed = INITIAL_SCROLL_SPEED;\r\n                    ui.hideInfo();\r\n                }\r\n\r\n                let doubleTap = false;\r\n                if (this.clock.getElapsedTime() - this.lastTap < this.tapDuration) {\r\n                    doubleTap = true;\r\n                }\r\n                this.lastTap = this.clock.getElapsedTime();\r\n\r\n                if (doubleTap) {\r\n                    if (!heroInstance.isJumping) {\r\n                        heroInstance.isJumping = true;\r\n                        heroInstance.jumpUp();\r\n                    }\r\n                } else {\r\n                    if (!heroInstance.isMoving && !heroInstance.isJumping) {\r\n                        heroInstance.isMoving = true;\r\n                        this.setTarget(domElement, event);\r\n                        heroInstance.startRunning();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        domElement.addEventListener('pointerup', (event) => {\r\n            event.preventDefault();\r\n            if (!this.isFinished && event.isPrimary) {\r\n                heroInstance.isMoving = false;\r\n                heroInstance.targetX = heroInstance.model.position.x;\r\n            }\r\n        });\r\n        domElement.addEventListener('pointermove', (event) => {\r\n            event.preventDefault();\r\n            if (heroInstance.isMoving && event.isPrimary)\r\n                this.moveTarget(domElement, event);\r\n        });\r\n    }\r\n\r\n    addHelpers() {\r\n        // console.warn(\"Helper are for debug use only. Remove for production!\");\r\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](0.1, 0.1, 0.1);\r\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({ color: 0x00ff00 });\r\n        const cube = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\r\n        cube.position.x = 1;\r\n        scene.add(cube);\r\n\r\n        const gridHelper = new three__WEBPACK_IMPORTED_MODULE_0__[\"GridHelper\"](10, 10);\r\n        scene.add(gridHelper);\r\n\r\n        const axesHelper = new three__WEBPACK_IMPORTED_MODULE_0__[\"AxesHelper\"](1);\r\n        scene.add(axesHelper);\r\n    }\r\n\r\n    gameOver() {\r\n        this.isFinished = true;\r\n        fireball.show();\r\n        ui.showFinalScreen();\r\n    }\r\n\r\n    resetGame() {\r\n        ui.reset();\r\n        fireball.hide();\r\n        obstacleInstance.resetAll();\r\n        heroInstance.reset();\r\n        scrollSpeed = 0;\r\n        obstacleSpawnDelay = INITIAL_SPAWN_DELAY;\r\n        playable.isFinished = false;\r\n        playable.interactionStarted = false;\r\n        playable.startInactivityTimer();\r\n        ui.showInfo();\r\n    }\r\n\r\n    startInactivityTimer() {\r\n        this.startTime = this.clock.getElapsedTime();\r\n        this.sinceStart = 0;\r\n    }\r\n\r\n    increaseDifficulty() {\r\n        obstacleSpawnDelay = Math.max(obstacleSpawnDelay - 0.1, 0.6);\r\n        heroInstance.jumpDuration = Math.max(heroInstance.jumpDuration - 0.05, 1);\r\n        heroInstance.halfJump = heroInstance.jumpDuration / 2;\r\n        scrollSpeed += 0.1;\r\n    }\r\n\r\n    openStore() {\r\n        if (typeof mraid !== 'undefined') { // MRAID (Unity)\r\n            const ios = `https://apps.apple.com/us/app/hop-race-3d/id1472738854`;\r\n            mraid.open(ios);\r\n        } else {\r\n            alert('Hop Race 3D');\r\n        }\r\n    }\r\n\r\n    onWindowResize() {\r\n        this.camera.aspect = window.innerWidth / window.innerHeight;\r\n        this.camera.updateProjectionMatrix();\r\n\r\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n    }\r\n}\r\n\r\nclass Ground {\r\n    constructor() {\r\n        this.mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneGeometry\"](6, 20),\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhongMaterial\"]({ color: 0x111016, depthWrite: false })\r\n        );\r\n        this.mesh.rotation.x = - Math.PI / 2;\r\n        this.mesh.receiveShadow = true;\r\n        scene.add(this.mesh);\r\n\r\n        this.addRoadMarks();\r\n    }\r\n\r\n    addRoadMarks() {\r\n        const lineLeft = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneGeometry\"](0.15, 20), new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhongMaterial\"]({ color: 0x888888, depthWrite: false }));\r\n        lineLeft.rotation.x = - Math.PI / 2;\r\n        lineLeft.position.x = 2.75;\r\n        lineLeft.receiveShadow = true;\r\n        scene.add(lineLeft);\r\n\r\n        const lineRight = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneGeometry\"](0.15, 20), new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhongMaterial\"]({ color: 0x888888, depthWrite: false }));\r\n        lineRight.rotation.x = - Math.PI / 2;\r\n        lineRight.position.x = -2.75;\r\n        lineRight.receiveShadow = true;\r\n        scene.add(lineRight);\r\n\r\n        this.marks = [];\r\n        const marksTotal = 20;\r\n        for (let i = 0; i < marksTotal; i++) {\r\n            const mark = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneGeometry\"](0.15, 0.5), new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhongMaterial\"]({ color: 0xb39b00, depthWrite: false }));\r\n            mark.rotation.x = - Math.PI / 2;\r\n            mark.position.z = i - (marksTotal / 2);\r\n            mark.receiveShadow = true;\r\n            scene.add(mark);\r\n            this.marks.push(mark);\r\n        }\r\n    }\r\n\r\n    update(deltaSec) {\r\n        for (const mark of this.marks) {\r\n            mark.position.z -= scrollSpeed * deltaSec;\r\n            if (mark.position.z < -worldHalfLength) {\r\n                mark.position.z = worldHalfLength;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass Obstacles {\r\n    constructor(loader) {\r\n        this.pool = []; // array of arrays; one for each model id;\r\n        this.sinceSpawn = 0;\r\n        let that = this;\r\n        for (const car of cars) {\r\n            this.pool[car.id] = [];\r\n            loader.load(car.model, gltf => {\r\n                let model = gltf.scene;\r\n                model.traverse(function (object) {\r\n                    if (object.isMesh) object.castShadow = true;\r\n                });\r\n\r\n                const scale = 0.7;\r\n                model.scale.set(scale, scale, scale);\r\n\r\n                let models = [model, model.clone(), model.clone(), model.clone()];\r\n                for (const m of models) {\r\n                    this.instantiateModel(m, car.id);\r\n                    this.setRandomPosition(m);\r\n                    // m.visible = true;\r\n                }\r\n            });\r\n        }\r\n        if (debugLevel > 1) {\r\n            for (const bucket of this.pool) {\r\n                for (const model of bucket) {\r\n                    if (model.visible)\r\n                        model.bboxHelper.update();\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        this.spawnProbs = {};\r\n        let sumWeight = 0;\r\n        for (const item of cars) {\r\n            sumWeight += item.weight;\r\n        }\r\n        for (const item of cars) {\r\n            this.spawnProbs[item.id] = item.weight/sumWeight;\r\n        }\r\n    }\r\n\r\n    instantiateModel(model, id) {\r\n        scene.add(model);\r\n        this.pool[id].push(model);\r\n        model.visible = false;\r\n        model.bbox = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"]();\r\n        model.oldBB = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"]();\r\n\r\n        if (debugLevel > 1) {\r\n            model.bboxHelper = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxHelper\"](model, 0xffff00);\r\n            scene.add(model.bboxHelper);\r\n        }\r\n    }\r\n\r\n    setRandomPosition(model) {\r\n        model.position.x = (Math.random() * 2 - 1) * (worldHalfWidth - 0.5);\r\n        model.position.z = worldHalfLength;\r\n        let angles = [0, Math.PI, Math.PI/2, -Math.PI/2];\r\n        model.rotation.y = angles[Math.floor(Math.random()*4)];\r\n    }\r\n\r\n    weightedRandom(prob) {\r\n        let i, sum=0, r=Math.random();\r\n        for (i in prob) {\r\n          sum += prob[i];\r\n          if (r <= sum) return i;\r\n        }\r\n      }\r\n\r\n    update(deltaSec) {\r\n        if (this.sinceSpawn >= obstacleSpawnDelay) {\r\n            this.sinceSpawn = 0;\r\n            let id = this.weightedRandom(this.spawnProbs);\r\n            this.spawnFromPool(id);\r\n            playable.increaseDifficulty();\r\n        }\r\n\r\n        heroInstance.bbox.setFromCenterAndSize(heroInstance.model.position.clone().add(heroInstance.bboxOffset), heroInstance.manualSize);\r\n        for (const bucket of this.pool) {\r\n            for (const model of bucket) {\r\n                if (model.visible) {\r\n                    // Check for collisions\r\n                    model.bbox.setFromObject(model);\r\n                    if (heroInstance.bbox.intersectsBox(model.bbox)) {\r\n                        if (debugLevel > 1) model.bboxHelper.visible = false;\r\n                        playable.gameOver();\r\n                    }\r\n\r\n                    // Scroll\r\n                    model.position.z -= scrollSpeed * deltaSec;\r\n                    if (debugLevel > 1) model.bboxHelper.update();\r\n                    if (model.position.z < -worldHalfLength) {\r\n                        model.visible = false;\r\n                        if (debugLevel > 1) model.bboxHelper.visible = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    resetAll() {\r\n        for (const bucket of this.pool) {\r\n            for (const model of bucket) {\r\n                model.visible = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    spawnFromPool(id) {\r\n        let spawned = false;\r\n        for (const model of this.pool[id]) {\r\n            if (!model.visible) {\r\n                // console.log('spawning obstacle from pool');\r\n                this.setRandomPosition(model);\r\n                model.visible = true;\r\n                model.passed = false;\r\n                if (debugLevel > 1) model.bboxHelper.visible = true;\r\n                spawned = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!spawned) { // No objects left in pool\r\n            // console.log('spawning new obstacle, not pooled yet');\r\n            let model = this.pool[id][0].clone();\r\n            this.instantiateModel(model, id);\r\n            model.visible = true;\r\n            model.passed = false;\r\n            if (debugLevel > 1) model.bboxHelper.visible = true;\r\n            this.setRandomPosition(model);\r\n        }\r\n    }\r\n}\r\n\r\nclass Hero {\r\n    constructor(loader, game) {\r\n        this.speed = 2; // three.js units per second\r\n        this.bbox = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"]();\r\n        this.oldBB = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"]();\r\n        this.manualSize = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0.5, 1, 0.3);\r\n        this.jumpDuration = 2;\r\n        this.jumpHeight = 2;\r\n        this.halfJump = this.jumpDuration / 2;\r\n        this.jumpElapsed = 0;\r\n        this.bboxOffset = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0);\r\n\r\n        this.game = game;\r\n\r\n        loader.load(_assets_boy_glb__WEBPACK_IMPORTED_MODULE_4__[\"default\"], this.onLoad.bind(this));\r\n    }\r\n\r\n    onLoad(gltf) {\r\n        this.model = gltf.scene;\r\n        scene.add(this.model);\r\n        this.model.traverse(function (object) {\r\n            if (object.isMesh) object.castShadow = true;\r\n        });\r\n        if (debugLevel > 1) {\r\n            this.skeleton = new three__WEBPACK_IMPORTED_MODULE_0__[\"SkeletonHelper\"](this.model);\r\n            this.skeleton.visible = true;\r\n            scene.add(this.skeleton);\r\n        }\r\n        const animations = gltf.animations;\r\n        this.mixer = new three__WEBPACK_IMPORTED_MODULE_0__[\"AnimationMixer\"](this.model);\r\n        this.idle = this.mixer.clipAction(animations[0]);\r\n        this.jump = this.mixer.clipAction(animations[1]);\r\n        this.run = this.mixer.clipAction(animations[2]);\r\n        this.targetX = this.model.position.x;\r\n        if (debugLevel > 1) {\r\n            this.bboxHelper = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3Helper\"](this.bbox, 0xffff00);\r\n            scene.add(this.bboxHelper);\r\n        }\r\n        this.idle.play();\r\n        this.game.animate();\r\n        ui.showInfo();\r\n    }\r\n\r\n    jumpUp() {\r\n        this.idle.stop();\r\n        this.run.stop();\r\n        this.jump.setLoop(three__WEBPACK_IMPORTED_MODULE_0__[\"LoopOnce\"]);\r\n        this.jump.clampWhenFinished = true;\r\n        this.jump.play();\r\n    }\r\n\r\n    startRunning() {\r\n        this.idle.stop();\r\n        this.run.play();\r\n    }\r\n\r\n    update(deltaSec) {\r\n        if (!this.isJumping) { // Move hero\r\n            let dx = deltaSec * this.speed;\r\n            let diff = this.targetX - this.model.position.x;\r\n            if (Math.abs(diff) > dx) {\r\n                this.model.position.x += dx * diff / Math.abs(diff);\r\n            } else {\r\n                this.model.position.x = this.targetX;\r\n            }\r\n        } else { // Hero jumps\r\n            this.jumpElapsed += deltaSec;\r\n            if (this.jumpElapsed >= this.jumpDuration) { // Jump finished\r\n                this.isJumping = false;\r\n                this.jump.stop();\r\n                this.run.play();\r\n                this.jumpElapsed = 0;\r\n                this.model.position.y = 0;\r\n            } else {\r\n                if (this.jumpElapsed < this.halfJump) { // rise\r\n                    this.model.position.y = this.jumpHeight * Math.sqrt(1 - Math.pow((this.jumpElapsed - this.halfJump) / this.halfJump, 2)); // quadratic\r\n                } else { // fall\r\n                    let progress = (this.jumpElapsed - this.halfJump) / this.halfJump;\r\n                    this.model.position.y = this.jumpHeight * (1 - Math.pow(progress, 3)); // cubic\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    reset() {\r\n        this.isMoving = false;\r\n        this.isJumping = false;\r\n        this.speed = 2; // three.js units per second\r\n        this.jumpElapsed = 0;\r\n        this.jumpDuration = 2;\r\n        this.halfJump = this.jumpDuration / 2;\r\n        this.jump.stop();\r\n        this.run.stop();\r\n        this.idle.play();\r\n        this.model.position.set(0, 0, 0);\r\n        this.targetX = 0;\r\n    }\r\n}\r\n\r\nclass Fireball {\r\n    constructor() {\r\n        this.material = new three__WEBPACK_IMPORTED_MODULE_0__[\"ShaderMaterial\"]({\r\n            fragmentShader: _shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\r\n            vertexShader: _shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\r\n            uniforms: {\r\n                tExplosion: {\r\n                    type: \"t\",\r\n                    value: three__WEBPACK_IMPORTED_MODULE_0__[\"ImageUtils\"].loadTexture(_shaders_explosion_png__WEBPACK_IMPORTED_MODULE_14__[\"default\"])\r\n                },\r\n                time: {\r\n                    type: \"f\",\r\n                    value: 0.0\r\n                },\r\n                weight: { type: \"f\", value: 10.0 }\r\n            }\r\n        });\r\n        this.mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](new three__WEBPACK_IMPORTED_MODULE_0__[\"IcosahedronGeometry\"](20, 40), this.material);\r\n        this.mesh.visible = false;\r\n        scene.add(this.mesh);\r\n\r\n        this.fbTime = 0;\r\n        this.shaderTime = 0;\r\n        this.fbScale = 0;\r\n    }\r\n\r\n    show() {\r\n        this.fbTime = 0;\r\n        this.shaderTime = 0;\r\n        this.fbScale = 0;\r\n        this.mesh.scale.set(0, 0, 0);\r\n        this.mesh.visible = true;\r\n        this.mesh.position.x = heroInstance.model.position.x;\r\n        this.mesh.position.y = heroInstance.model.position.y;\r\n        this.mesh.position.z = 1;\r\n    }\r\n\r\n    hide() {\r\n        this.mesh.visible = false;\r\n    }\r\n\r\n    update() {\r\n        this.material.uniforms['time'].value = this.shaderTime;\r\n        this.fbScale = this.fbTime < 1 ? Math.sin(this.fbTime) / 5 : this.fbScale;\r\n        this.mesh.scale.set(this.fbScale, this.fbScale, this.fbScale);\r\n    }\r\n\r\n    updateTimers(step) {\r\n        this.fbTime += step;\r\n        this.shaderTime = this.fbTime < 1 ? 1.1 - (1 - this.fbTime) * (1 - this.fbTime) : this.shaderTime + step * 0.1;\r\n    }\r\n}\r\n\r\nclass UI {\r\n    constructor(game) {\r\n        this.curtain = document.getElementById(\"curtain\");\r\n        this.restart = document.getElementById('btn2');\r\n        this.restart.onclick = game.resetGame;\r\n        this.install = document.getElementById('btn3');\r\n        this.install.onclick = game.openStore;\r\n        this.info = document.getElementById('intro-text');\r\n        this.progress = document.getElementById('progress-counter');\r\n    }\r\n\r\n    showFinalScreen() { // Life it seems will fade away...\r\n        this.curtain.classList.remove(\"hidden\");\r\n        this.curtain.classList.remove(\"screen-change\");\r\n        this.curtain.classList.add(\"screen-change\");\r\n\r\n        this.restart.classList.remove('hidden');\r\n        this.restart.classList.add('visible');\r\n\r\n        this.install.classList.remove('hidden');\r\n        this.install.classList.add('visible');\r\n    }\r\n\r\n    showInfo() {\r\n        this.info.classList.remove('hidden');\r\n        this.info.classList.add('visible');\r\n        this.progress.classList.add('visible');\r\n    }\r\n\r\n    hideInfo() {\r\n        this.info.classList.remove('visible');\r\n        this.info.classList.add('hidden');\r\n    }\r\n\r\n    updateTimer(time) {\r\n        if (this.prevTime == time) return;\r\n        this.prevTime = time;\r\n        let sec = time % 60;\r\n        let min = Math.floor(time/60);\r\n        min = min < 10 ? '0' + min : '' + min;\r\n        sec = sec < 10 ? '0' + sec : '' + sec;\r\n        this.progress.innerHTML = min + ':' + sec;\r\n    }\r\n\r\n    reset() {\r\n        this.restart.classList.add('hidden');\r\n        this.restart.classList.remove('visible');\r\n\r\n        this.install.classList.add('hidden');\r\n        this.install.classList.remove('visible');\r\n        this.updateTimer(0);\r\n        this.curtain.classList.add(\"hidden\");\r\n    }\r\n}\r\n\r\nplayable = new Playable();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lib/GLTFLoader.js":
/*!*******************************!*\
  !*** ./src/lib/GLTFLoader.js ***!
  \*******************************/
/*! exports provided: GLTFLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GLTFLoader\", function() { return GLTFLoader; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\r\n\r\nvar GLTFLoader = ( function () {\r\n\r\n\tfunction GLTFLoader( manager ) {\r\n\r\n\t\tthree__WEBPACK_IMPORTED_MODULE_0__[\"Loader\"].call( this, manager );\r\n\r\n\t\tthis.dracoLoader = null;\r\n\t\tthis.ktx2Loader = null;\r\n\t\tthis.meshoptDecoder = null;\r\n\r\n\t\tthis.pluginCallbacks = [];\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureWebPExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFLightsExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMeshoptCompression( parser );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tGLTFLoader.prototype = Object.assign( Object.create( three__WEBPACK_IMPORTED_MODULE_0__[\"Loader\"].prototype ), {\r\n\r\n\t\tconstructor: GLTFLoader,\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar resourcePath;\r\n\r\n\t\t\tif ( this.resourcePath !== '' ) {\r\n\r\n\t\t\t\tresourcePath = this.resourcePath;\r\n\r\n\t\t\t} else if ( this.path !== '' ) {\r\n\r\n\t\t\t\tresourcePath = this.path;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresourcePath = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].extractUrlBase( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\r\n\t\t\t// the model is fully loaded. This means the count of items loaded will\r\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\r\n\t\t\tthis.manager.itemStart( url );\r\n\r\n\t\t\tvar _onError = function ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar loader = new three__WEBPACK_IMPORTED_MODULE_0__[\"FileLoader\"]( this.manager );\r\n\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\r\n\r\n\t\t\t\t\t\tonLoad( gltf );\r\n\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t\t}, _onError );\r\n\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\t_onError( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, _onError );\r\n\r\n\t\t},\r\n\r\n\t\tsetDRACOLoader: function ( dracoLoader ) {\r\n\r\n\t\t\tthis.dracoLoader = dracoLoader;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetDDSLoader: function () {\r\n\r\n\t\t\tthrow new Error(\r\n\r\n\t\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\r\n\r\n\t\t\t);\r\n\r\n\t\t},\r\n\r\n\t\tsetKTX2Loader: function ( ktx2Loader ) {\r\n\r\n\t\t\tthis.ktx2Loader = ktx2Loader;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetMeshoptDecoder: function ( meshoptDecoder ) {\r\n\r\n\t\t\tthis.meshoptDecoder = meshoptDecoder;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tregister: function ( callback ) {\r\n\r\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\r\n\r\n\t\t\t\tthis.pluginCallbacks.push( callback );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tunregister: function ( callback ) {\r\n\r\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\r\n\r\n\t\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( data, path, onLoad, onError ) {\r\n\r\n\t\t\tvar content;\r\n\t\t\tvar extensions = {};\r\n\t\t\tvar plugins = {};\r\n\r\n\t\t\tif ( typeof data === 'string' ) {\r\n\r\n\t\t\t\tcontent = data;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar magic = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText( new Uint8Array( data, 0, 4 ) );\r\n\r\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\r\n\r\n\t\t\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t\t\tif ( onError ) onError( error );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcontent = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText( new Uint8Array( data ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar json = JSON.parse( content );\r\n\r\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\r\n\r\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parser = new GLTFParser( json, {\r\n\r\n\t\t\t\tpath: path || this.resourcePath || '',\r\n\t\t\t\tcrossOrigin: this.crossOrigin,\r\n\t\t\t\trequestHeader: this.requestHeader,\r\n\t\t\t\tmanager: this.manager,\r\n\t\t\t\tktx2Loader: this.ktx2Loader,\r\n\t\t\t\tmeshoptDecoder: this.meshoptDecoder\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\r\n\r\n\t\t\tfor ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {\r\n\r\n\t\t\t\tvar plugin = this.pluginCallbacks[ i ]( parser );\r\n\t\t\t\tplugins[ plugin.name ] = plugin;\r\n\r\n\t\t\t\t// Workaround to avoid determining as unknown extension\r\n\t\t\t\t// in addUnknownExtensionsToUserData().\r\n\t\t\t\t// Remove this workaround if we move all the existing\r\n\t\t\t\t// extension handlers to plugin system\r\n\t\t\t\textensions[ plugin.name ] = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.extensionsUsed ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\r\n\r\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\r\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\r\n\r\n\t\t\t\t\tswitch ( extensionName ) {\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser.setExtensions( extensions );\r\n\t\t\tparser.setPlugins( plugins );\r\n\t\t\tparser.parse( onLoad, onError );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t/* GLTFREGISTRY */\r\n\r\n\tfunction GLTFRegistry() {\r\n\r\n\t\tvar objects = {};\r\n\r\n\t\treturn\t{\r\n\r\n\t\t\tget: function ( key ) {\r\n\r\n\t\t\t\treturn objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tadd: function ( key, object ) {\r\n\r\n\t\t\t\tobjects[ key ] = object;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremove: function ( key ) {\r\n\r\n\t\t\t\tdelete objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremoveAll: function () {\r\n\r\n\t\t\t\tobjects = {};\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/*********************************/\r\n\t/********** EXTENSIONS ***********/\r\n\t/*********************************/\r\n\r\n\tvar EXTENSIONS = {\r\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\r\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\r\n\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\r\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\r\n\t\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\r\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\r\n\t\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\r\n\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\r\n\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\r\n\t\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\r\n\t\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\r\n\t};\r\n\r\n\t/**\r\n\t * Punctual Lights Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n\t */\r\n\tfunction GLTFLightsExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.cache = { refs: {}, uses: {} };\r\n\r\n\t}\r\n\r\n\tGLTFLightsExtension.prototype._markDefs = function () {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar nodeDefs = this.parser.json.nodes || [];\r\n\r\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.extensions\r\n\t\t\t\t&& nodeDef.extensions[ this.name ]\r\n\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\r\n\r\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tGLTFLightsExtension.prototype._loadLight = function ( lightIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar cacheKey = 'light:' + lightIndex;\r\n\t\tvar dependency = parser.cache.get( cacheKey );\r\n\r\n\t\tif ( dependency ) return dependency;\r\n\r\n\t\tvar json = parser.json;\r\n\t\tvar extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\r\n\t\tvar lightDefs = extensions.lights || [];\r\n\t\tvar lightDef = lightDefs[ lightIndex ];\r\n\t\tvar lightNode;\r\n\r\n\t\tvar color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]( 0xffffff );\r\n\r\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\r\n\r\n\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n\t\tswitch ( lightDef.type ) {\r\n\r\n\t\t\tcase 'directional':\r\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__[\"DirectionalLight\"]( color );\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'point':\r\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__[\"PointLight\"]( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'spot':\r\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__[\"SpotLight\"]( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\t// Handle spotlight properties.\r\n\t\t\t\tlightDef.spot = lightDef.spot || {};\r\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\r\n\r\n\t\t}\r\n\r\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\r\n\t\t// here, because node-level parsing will only override position if explicitly specified.\r\n\t\tlightNode.position.set( 0, 0, 0 );\r\n\r\n\t\tlightNode.decay = 2;\r\n\r\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\r\n\r\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\r\n\r\n\t\tdependency = Promise.resolve( lightNode );\r\n\r\n\t\tparser.cache.add( cacheKey, dependency );\r\n\r\n\t\treturn dependency;\r\n\r\n\t};\r\n\r\n\tGLTFLightsExtension.prototype.createNodeAttachment = function ( nodeIndex ) {\r\n\r\n\t\tvar self = this;\r\n\t\tvar parser = this.parser;\r\n\t\tvar json = parser.json;\r\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\r\n\t\tvar lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\r\n\t\tvar lightIndex = lightDef.light;\r\n\r\n\t\tif ( lightIndex === undefined ) return null;\r\n\r\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\r\n\r\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Unlit Materials Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n\t */\r\n\tfunction GLTFMaterialsUnlitExtension() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n\r\n\t}\r\n\r\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\r\n\r\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"];\r\n\r\n\t};\r\n\r\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]( 1.0, 1.0, 1.0 );\r\n\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\r\n\r\n\t\tif ( metallicRoughness ) {\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Clearcoat Materials Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n\t */\r\n\tfunction GLTFMaterialsClearcoatExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\r\n\r\n\t}\r\n\r\n\tGLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( materialIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhysicalMaterial\"];\r\n\r\n\t};\r\n\r\n\tGLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tvar extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.clearcoatFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\r\n\r\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tvar scale = extension.clearcoatNormalTexture.scale;\r\n\r\n\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\t\tmaterialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]( scale, - scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Transmission Materials Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n\t * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n\t */\r\n\tfunction GLTFMaterialsTransmissionExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\r\n\r\n\t}\r\n\r\n\tGLTFMaterialsTransmissionExtension.prototype.getMaterialType = function ( materialIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhysicalMaterial\"];\r\n\r\n\t};\r\n\r\n\tGLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tvar extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.transmissionFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.transmissionTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * BasisU Texture Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n\t */\r\n\tfunction GLTFTextureBasisUExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\r\n\r\n\t}\r\n\r\n\tGLTFTextureBasisUExtension.prototype.loadTexture = function ( textureIndex ) {\r\n\r\n\t\tvar parser = this.parser;\r\n\t\tvar json = parser.json;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar extension = textureDef.extensions[ this.name ];\r\n\t\tvar source = json.images[ extension.source ];\r\n\t\tvar loader = parser.options.ktx2Loader;\r\n\r\n\t\tif ( ! loader ) {\r\n\r\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * WebP Texture Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n\t */\r\n\tfunction GLTFTextureWebPExtension( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\r\n\t\tthis.isSupported = null;\r\n\r\n\t}\r\n\r\n\tGLTFTextureWebPExtension.prototype.loadTexture = function ( textureIndex ) {\r\n\r\n\t\tvar name = this.name;\r\n\t\tvar parser = this.parser;\r\n\t\tvar json = parser.json;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar extension = textureDef.extensions[ name ];\r\n\t\tvar source = json.images[ extension.source ];\r\n\r\n\t\tvar loader = parser.textureLoader;\r\n\t\tif ( source.uri ) {\r\n\r\n\t\t\tvar handler = parser.options.manager.getHandler( source.uri );\r\n\t\t\tif ( handler !== null ) loader = handler;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.detectSupport().then( function ( isSupported ) {\r\n\r\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Fall back to PNG or JPEG.\r\n\t\t\treturn parser.loadTexture( textureIndex );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFTextureWebPExtension.prototype.detectSupport = function () {\r\n\r\n\t\tif ( ! this.isSupported ) {\r\n\r\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tvar image = new Image();\r\n\r\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\r\n\t\t\t\t// WebP images, unfortunately.\r\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\r\n\r\n\t\t\t\timage.onload = image.onerror = function () {\r\n\r\n\t\t\t\t\tresolve( image.height === 1 );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isSupported;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t* meshopt BufferView Compression Extension\r\n\t*\r\n\t* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n\t*/\r\n\tfunction GLTFMeshoptCompression( parser ) {\r\n\r\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\r\n\t\tthis.parser = parser;\r\n\r\n\t}\r\n\r\n\tGLTFMeshoptCompression.prototype.loadBufferView = function ( index ) {\r\n\r\n\t\tvar json = this.parser.json;\r\n\t\tvar bufferView = json.bufferViews[ index ];\r\n\r\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\r\n\r\n\t\t\tvar extensionDef = bufferView.extensions[ this.name ];\r\n\r\n\t\t\tvar buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\r\n\t\t\tvar decoder = this.parser.options.meshoptDecoder;\r\n\r\n\t\t\tif ( ! decoder || ! decoder.supported ) {\r\n\r\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\r\n\r\n\t\t\t\tvar byteOffset = extensionDef.byteOffset || 0;\r\n\t\t\t\tvar byteLength = extensionDef.byteLength || 0;\r\n\r\n\t\t\t\tvar count = extensionDef.count;\r\n\t\t\t\tvar stride = extensionDef.byteStride;\r\n\r\n\t\t\t\tvar result = new ArrayBuffer( count * stride );\r\n\t\t\t\tvar source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\r\n\r\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t/* BINARY EXTENSION */\r\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\r\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\r\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\r\n\r\n\tfunction GLTFBinaryExtension( data ) {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n\t\tthis.content = null;\r\n\t\tthis.body = null;\r\n\r\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\r\n\r\n\t\tthis.header = {\r\n\t\t\tmagic: three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\r\n\t\t\tversion: headerView.getUint32( 4, true ),\r\n\t\t\tlength: headerView.getUint32( 8, true )\r\n\t\t};\r\n\r\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\r\n\r\n\t\t} else if ( this.header.version < 2.0 ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\r\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\r\n\t\tvar chunkIndex = 0;\r\n\r\n\t\twhile ( chunkIndex < chunkContentsLength ) {\r\n\r\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\r\n\r\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\r\n\t\t\t\tthis.content = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText( contentArray );\r\n\r\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\r\n\r\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Clients must ignore chunks with unknown types.\r\n\r\n\t\t\tchunkIndex += chunkLength;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.content === null ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * DRACO Mesh Compression Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n\t */\r\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\r\n\r\n\t\tif ( ! dracoLoader ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n\t\tthis.json = json;\r\n\t\tthis.dracoLoader = dracoLoader;\r\n\t\tthis.dracoLoader.preload();\r\n\r\n\t}\r\n\r\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar dracoLoader = this.dracoLoader;\r\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\r\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\r\n\t\tvar threeAttributeMap = {};\r\n\t\tvar attributeNormalizedMap = {};\r\n\t\tvar attributeTypeMap = {};\r\n\r\n\t\tfor ( var attributeName in gltfAttributeMap ) {\r\n\r\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( attributeName in primitive.attributes ) {\r\n\r\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\r\n\r\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\r\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\r\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\r\n\r\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\r\n\r\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\r\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\r\n\r\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresolve( geometry );\r\n\r\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Texture Transform Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n\t */\r\n\tfunction GLTFTextureTransformExtension() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\r\n\r\n\t}\r\n\r\n\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\r\n\r\n\t\ttexture = texture.clone();\r\n\r\n\t\tif ( transform.offset !== undefined ) {\r\n\r\n\t\t\ttexture.offset.fromArray( transform.offset );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.rotation !== undefined ) {\r\n\r\n\t\t\ttexture.rotation = transform.rotation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.scale !== undefined ) {\r\n\r\n\t\t\ttexture.repeat.fromArray( transform.scale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.texCoord !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\r\n\r\n\t\t}\r\n\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specular-Glossiness Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n\t */\r\n\r\n\t/**\r\n\t * A sub class of StandardMaterial with some of the functionality\r\n\t * changed via the `onBeforeCompile` callback\r\n\t * @pailhead\r\n\t */\r\n\r\n\tfunction GLTFMeshStandardSGMaterial( params ) {\r\n\r\n\t\tthree__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"].call( this );\r\n\r\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\r\n\r\n\t\t//various chunks that need replacing\r\n\t\tvar specularMapParsFragmentChunk = [\r\n\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t'\tuniform sampler2D specularMap;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar glossinessMapParsFragmentChunk = [\r\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t'\tuniform sampler2D glossinessMap;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar specularMapFragmentChunk = [\r\n\t\t\t'vec3 specularFactor = specular;',\r\n\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\r\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\r\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar glossinessMapFragmentChunk = [\r\n\t\t\t'float glossinessFactor = glossiness;',\r\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\r\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar lightPhysicalFragmentChunk = [\r\n\t\t\t'PhysicalMaterial material;',\r\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\r\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\r\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\r\n\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\r\n\t\t\t'material.specularRoughness += geometryRoughness;',\r\n\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\r\n\t\t\t'material.specularColor = specularFactor;',\r\n\t\t].join( '\\n' );\r\n\r\n\t\tvar uniforms = {\r\n\t\t\tspecular: { value: new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]().setHex( 0xffffff ) },\r\n\t\t\tglossiness: { value: 1 },\r\n\t\t\tspecularMap: { value: null },\r\n\t\t\tglossinessMap: { value: null }\r\n\t\t};\r\n\r\n\t\tthis._extraUniforms = uniforms;\r\n\r\n\t\tthis.onBeforeCompile = function ( shader ) {\r\n\r\n\t\t\tfor ( var uniformName in uniforms ) {\r\n\r\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshader.fragmentShader = shader.fragmentShader\r\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\r\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\r\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\r\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\r\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\r\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\r\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\r\n\r\n\t\t};\r\n\r\n\t\tObject.defineProperties( this, {\r\n\r\n\t\t\tspecular: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.specular.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.specular.value = v;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tspecularMap: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.specularMap.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.specularMap.value = v;\r\n\r\n\t\t\t\t\tif ( v ) {\r\n\r\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tglossiness: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.glossiness.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.glossiness.value = v;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tglossinessMap: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.glossinessMap.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.glossinessMap.value = v;\r\n\r\n\t\t\t\t\tif ( v ) {\r\n\r\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\r\n\t\t\t\t\t\tthis.defines.USE_UV = '';\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\r\n\t\t\t\t\t\tdelete this.defines.USE_UV;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tdelete this.metalness;\r\n\t\tdelete this.roughness;\r\n\t\tdelete this.metalnessMap;\r\n\t\tdelete this.roughnessMap;\r\n\r\n\t\tthis.setValues( params );\r\n\r\n\t}\r\n\r\n\tGLTFMeshStandardSGMaterial.prototype = Object.create( three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"].prototype );\r\n\tGLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\r\n\r\n\tGLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {\r\n\r\n\t\tthree__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"].prototype.copy.call( this, source );\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\tthis.specular.copy( source.specular );\r\n\t\tthis.glossinessMap = source.glossinessMap;\r\n\t\tthis.glossiness = source.glossiness;\r\n\t\tdelete this.metalness;\r\n\t\tdelete this.roughness;\r\n\t\tdelete this.metalnessMap;\r\n\t\tdelete this.roughnessMap;\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\r\n\r\n\t\treturn {\r\n\r\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\r\n\r\n\t\t\tspecularGlossinessParams: [\r\n\t\t\t\t'color',\r\n\t\t\t\t'map',\r\n\t\t\t\t'lightMap',\r\n\t\t\t\t'lightMapIntensity',\r\n\t\t\t\t'aoMap',\r\n\t\t\t\t'aoMapIntensity',\r\n\t\t\t\t'emissive',\r\n\t\t\t\t'emissiveIntensity',\r\n\t\t\t\t'emissiveMap',\r\n\t\t\t\t'bumpMap',\r\n\t\t\t\t'bumpScale',\r\n\t\t\t\t'normalMap',\r\n\t\t\t\t'normalMapType',\r\n\t\t\t\t'displacementMap',\r\n\t\t\t\t'displacementScale',\r\n\t\t\t\t'displacementBias',\r\n\t\t\t\t'specularMap',\r\n\t\t\t\t'specular',\r\n\t\t\t\t'glossinessMap',\r\n\t\t\t\t'glossiness',\r\n\t\t\t\t'alphaMap',\r\n\t\t\t\t'envMap',\r\n\t\t\t\t'envMapIntensity',\r\n\t\t\t\t'refractionRatio',\r\n\t\t\t],\r\n\r\n\t\t\tgetMaterialType: function () {\r\n\r\n\t\t\t\treturn GLTFMeshStandardSGMaterial;\r\n\r\n\t\t\t},\r\n\r\n\t\t\textendParams: function ( materialParams, materialDef, parser ) {\r\n\r\n\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\r\n\r\n\t\t\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]( 1.0, 1.0, 1.0 );\r\n\t\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\t\tvar pending = [];\r\n\r\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\r\n\r\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\r\n\r\n\t\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\r\n\r\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]( 0.0, 0.0, 0.0 );\r\n\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\r\n\t\t\t\tmaterialParams.specular = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]( 1.0, 1.0, 1.0 );\r\n\r\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\r\n\r\n\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\r\n\r\n\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\r\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\r\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.all( pending );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tcreateMaterial: function ( materialParams ) {\r\n\r\n\t\t\t\tvar material = new GLTFMeshStandardSGMaterial( materialParams );\r\n\t\t\t\tmaterial.fog = true;\r\n\r\n\t\t\t\tmaterial.color = materialParams.color;\r\n\r\n\t\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\r\n\r\n\t\t\t\tmaterial.lightMap = null;\r\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\r\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.emissive = materialParams.emissive;\r\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\r\n\t\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\r\n\r\n\t\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\r\n\t\t\t\tmaterial.bumpScale = 1;\r\n\r\n\t\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\r\n\t\t\t\tmaterial.normalMapType = three__WEBPACK_IMPORTED_MODULE_0__[\"TangentSpaceNormalMap\"];\r\n\r\n\t\t\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\r\n\r\n\t\t\t\tmaterial.displacementMap = null;\r\n\t\t\t\tmaterial.displacementScale = 1;\r\n\t\t\t\tmaterial.displacementBias = 0;\r\n\r\n\t\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\r\n\t\t\t\tmaterial.specular = materialParams.specular;\r\n\r\n\t\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\r\n\t\t\t\tmaterial.glossiness = materialParams.glossiness;\r\n\r\n\t\t\t\tmaterial.alphaMap = null;\r\n\r\n\t\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\r\n\t\t\t\tmaterial.envMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.refractionRatio = 0.98;\r\n\r\n\t\t\t\treturn material;\r\n\r\n\t\t\t},\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Mesh Quantization Extension\r\n\t *\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n\t */\r\n\tfunction GLTFMeshQuantizationExtension() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\r\n\r\n\t}\r\n\r\n\t/*********************************/\r\n\t/********** INTERPOLATION ********/\r\n\t/*********************************/\r\n\r\n\t// Spline Interpolation\r\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\t\tthree__WEBPACK_IMPORTED_MODULE_0__[\"Interpolant\"].call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\t}\r\n\r\n\tGLTFCubicSplineInterpolant.prototype = Object.create( three__WEBPACK_IMPORTED_MODULE_0__[\"Interpolant\"].prototype );\r\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\r\n\r\n\t\t// Copies a sample value to the result buffer. See description of glTF\r\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tvalueSize = this.valueSize,\r\n\t\t\toffset = index * valueSize * 3 + valueSize;\r\n\r\n\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer;\r\n\t\tvar values = this.sampleValues;\r\n\t\tvar stride = this.valueSize;\r\n\r\n\t\tvar stride2 = stride * 2;\r\n\t\tvar stride3 = stride * 3;\r\n\r\n\t\tvar td = t1 - t0;\r\n\r\n\t\tvar p = ( t - t0 ) / td;\r\n\t\tvar pp = p * p;\r\n\t\tvar ppp = pp * p;\r\n\r\n\t\tvar offset1 = i1 * stride3;\r\n\t\tvar offset0 = offset1 - stride3;\r\n\r\n\t\tvar s2 = - 2 * ppp + 3 * pp;\r\n\t\tvar s3 = ppp - pp;\r\n\t\tvar s0 = 1 - s2;\r\n\t\tvar s1 = s3 - pp + p;\r\n\r\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\r\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\r\n\r\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\r\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\r\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\r\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\t/*********************************/\r\n\t/********** INTERNALS ************/\r\n\t/*********************************/\r\n\r\n\t/* CONSTANTS */\r\n\r\n\tvar WEBGL_CONSTANTS = {\r\n\t\tFLOAT: 5126,\r\n\t\t//FLOAT_MAT2: 35674,\r\n\t\tFLOAT_MAT3: 35675,\r\n\t\tFLOAT_MAT4: 35676,\r\n\t\tFLOAT_VEC2: 35664,\r\n\t\tFLOAT_VEC3: 35665,\r\n\t\tFLOAT_VEC4: 35666,\r\n\t\tLINEAR: 9729,\r\n\t\tREPEAT: 10497,\r\n\t\tSAMPLER_2D: 35678,\r\n\t\tPOINTS: 0,\r\n\t\tLINES: 1,\r\n\t\tLINE_LOOP: 2,\r\n\t\tLINE_STRIP: 3,\r\n\t\tTRIANGLES: 4,\r\n\t\tTRIANGLE_STRIP: 5,\r\n\t\tTRIANGLE_FAN: 6,\r\n\t\tUNSIGNED_BYTE: 5121,\r\n\t\tUNSIGNED_SHORT: 5123\r\n\t};\r\n\r\n\tvar WEBGL_COMPONENT_TYPES = {\r\n\t\t5120: Int8Array,\r\n\t\t5121: Uint8Array,\r\n\t\t5122: Int16Array,\r\n\t\t5123: Uint16Array,\r\n\t\t5125: Uint32Array,\r\n\t\t5126: Float32Array\r\n\t};\r\n\r\n\tvar WEBGL_FILTERS = {\r\n\t\t9728: three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"],\r\n\t\t9729: three__WEBPACK_IMPORTED_MODULE_0__[\"LinearFilter\"],\r\n\t\t9984: three__WEBPACK_IMPORTED_MODULE_0__[\"NearestMipmapNearestFilter\"],\r\n\t\t9985: three__WEBPACK_IMPORTED_MODULE_0__[\"LinearMipmapNearestFilter\"],\r\n\t\t9986: three__WEBPACK_IMPORTED_MODULE_0__[\"NearestMipmapLinearFilter\"],\r\n\t\t9987: three__WEBPACK_IMPORTED_MODULE_0__[\"LinearMipmapLinearFilter\"]\r\n\t};\r\n\r\n\tvar WEBGL_WRAPPINGS = {\r\n\t\t33071: three__WEBPACK_IMPORTED_MODULE_0__[\"ClampToEdgeWrapping\"],\r\n\t\t33648: three__WEBPACK_IMPORTED_MODULE_0__[\"MirroredRepeatWrapping\"],\r\n\t\t10497: three__WEBPACK_IMPORTED_MODULE_0__[\"RepeatWrapping\"]\r\n\t};\r\n\r\n\tvar WEBGL_TYPE_SIZES = {\r\n\t\t'SCALAR': 1,\r\n\t\t'VEC2': 2,\r\n\t\t'VEC3': 3,\r\n\t\t'VEC4': 4,\r\n\t\t'MAT2': 4,\r\n\t\t'MAT3': 9,\r\n\t\t'MAT4': 16\r\n\t};\r\n\r\n\tvar ATTRIBUTES = {\r\n\t\tPOSITION: 'position',\r\n\t\tNORMAL: 'normal',\r\n\t\tTANGENT: 'tangent',\r\n\t\tTEXCOORD_0: 'uv',\r\n\t\tTEXCOORD_1: 'uv2',\r\n\t\tCOLOR_0: 'color',\r\n\t\tWEIGHTS_0: 'skinWeight',\r\n\t\tJOINTS_0: 'skinIndex',\r\n\t};\r\n\r\n\tvar PATH_PROPERTIES = {\r\n\t\tscale: 'scale',\r\n\t\ttranslation: 'position',\r\n\t\trotation: 'quaternion',\r\n\t\tweights: 'morphTargetInfluences'\r\n\t};\r\n\r\n\tvar INTERPOLATION = {\r\n\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\r\n\t\tLINEAR: three__WEBPACK_IMPORTED_MODULE_0__[\"InterpolateLinear\"],\r\n\t\tSTEP: three__WEBPACK_IMPORTED_MODULE_0__[\"InterpolateDiscrete\"]\r\n\t};\r\n\r\n\tvar ALPHA_MODES = {\r\n\t\tOPAQUE: 'OPAQUE',\r\n\t\tMASK: 'MASK',\r\n\t\tBLEND: 'BLEND'\r\n\t};\r\n\r\n\t/* UTILITY FUNCTIONS */\r\n\r\n\tfunction resolveURL( url, path ) {\r\n\r\n\t\t// Invalid URL\r\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\r\n\r\n\t\t// Host Relative URL\r\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\r\n\r\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\r\n\r\n\t\t}\r\n\r\n\t\t// Absolute URL http://,https://,//\r\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\r\n\r\n\t\t// Data URI\r\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\r\n\r\n\t\t// Blob URL\r\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\r\n\r\n\t\t// Relative URL\r\n\t\treturn path + url;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n\t */\r\n\tfunction createDefaultMaterial( cache ) {\r\n\r\n\t\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\r\n\r\n\t\t\tcache[ 'DefaultMaterial' ] = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"]( {\r\n\t\t\t\tcolor: 0xFFFFFF,\r\n\t\t\t\temissive: 0x000000,\r\n\t\t\t\tmetalness: 1,\r\n\t\t\t\troughness: 1,\r\n\t\t\t\ttransparent: false,\r\n\t\t\t\tdepthTest: true,\r\n\t\t\t\tside: three__WEBPACK_IMPORTED_MODULE_0__[\"FrontSide\"]\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn cache[ 'DefaultMaterial' ];\r\n\r\n\t}\r\n\r\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\r\n\r\n\t\t// Add unknown glTF extensions to an object's userData.\r\n\r\n\t\tfor ( var name in objectDef.extensions ) {\r\n\r\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\r\n\r\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Object3D|Material|BufferGeometry} object\r\n\t * @param {GLTF.definition} gltfDef\r\n\t */\r\n\tfunction assignExtrasToUserData( object, gltfDef ) {\r\n\r\n\t\tif ( gltfDef.extras !== undefined ) {\r\n\r\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\r\n\r\n\t\t\t\tObject.assign( object.userData, gltfDef.extras );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n\t *\r\n\t * @param {BufferGeometry} geometry\r\n\t * @param {Array<GLTF.Target>} targets\r\n\t * @param {GLTFParser} parser\r\n\t * @return {Promise<BufferGeometry>}\r\n\t */\r\n\tfunction addMorphTargets( geometry, targets, parser ) {\r\n\r\n\t\tvar hasMorphPosition = false;\r\n\t\tvar hasMorphNormal = false;\r\n\r\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\r\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\r\n\r\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\r\n\r\n\t\tvar pendingPositionAccessors = [];\r\n\t\tvar pendingNormalAccessors = [];\r\n\r\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\tif ( hasMorphPosition ) {\r\n\r\n\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\r\n\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\r\n\t\t\t\t\t: geometry.attributes.position;\r\n\r\n\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasMorphNormal ) {\r\n\r\n\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\r\n\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\r\n\t\t\t\t\t: geometry.attributes.normal;\r\n\r\n\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( [\r\n\t\t\tPromise.all( pendingPositionAccessors ),\r\n\t\t\tPromise.all( pendingNormalAccessors )\r\n\t\t] ).then( function ( accessors ) {\r\n\r\n\t\t\tvar morphPositions = accessors[ 0 ];\r\n\t\t\tvar morphNormals = accessors[ 1 ];\r\n\r\n\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\r\n\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\r\n\t\t\tgeometry.morphTargetsRelative = true;\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Mesh} mesh\r\n\t * @param {GLTF.Mesh} meshDef\r\n\t */\r\n\tfunction updateMorphTargets( mesh, meshDef ) {\r\n\r\n\t\tmesh.updateMorphTargets();\r\n\r\n\t\tif ( meshDef.weights !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\r\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\r\n\r\n\t\t\tvar targetNames = meshDef.extras.targetNames;\r\n\r\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\r\n\r\n\t\t\t\tmesh.morphTargetDictionary = {};\r\n\r\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createPrimitiveKey( primitiveDef ) {\r\n\r\n\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\r\n\t\tvar geometryKey;\r\n\r\n\t\tif ( dracoExtension ) {\r\n\r\n\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\r\n\t\t\t\t+ ':' + dracoExtension.indices\r\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\r\n\r\n\t\t}\r\n\r\n\t\treturn geometryKey;\r\n\r\n\t}\r\n\r\n\tfunction createAttributesKey( attributes ) {\r\n\r\n\t\tvar attributesKey = '';\r\n\r\n\t\tvar keys = Object.keys( attributes ).sort();\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\r\n\r\n\t\t}\r\n\r\n\t\treturn attributesKey;\r\n\r\n\t}\r\n\r\n\t/* GLTF PARSER */\r\n\r\n\tfunction GLTFParser( json, options ) {\r\n\r\n\t\tthis.json = json || {};\r\n\t\tthis.extensions = {};\r\n\t\tthis.plugins = {};\r\n\t\tthis.options = options || {};\r\n\r\n\t\t// loader object cache\r\n\t\tthis.cache = new GLTFRegistry();\r\n\r\n\t\t// associations between Three.js objects and glTF elements\r\n\t\tthis.associations = new Map();\r\n\r\n\t\t// BufferGeometry caching\r\n\t\tthis.primitiveCache = {};\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.meshCache = { refs: {}, uses: {} };\r\n\t\tthis.cameraCache = { refs: {}, uses: {} };\r\n\t\tthis.lightCache = { refs: {}, uses: {} };\r\n\r\n\t\t// Track node names, to ensure no duplicates\r\n\t\tthis.nodeNamesUsed = {};\r\n\r\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\r\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\r\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {\r\n\r\n\t\t\tthis.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__[\"ImageBitmapLoader\"]( this.options.manager );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"]( this.options.manager );\r\n\r\n\t\t}\r\n\r\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\r\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\r\n\r\n\t\tthis.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__[\"FileLoader\"]( this.options.manager );\r\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\r\n\r\n\t\t\tthis.fileLoader.setWithCredentials( true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tGLTFParser.prototype.setExtensions = function ( extensions ) {\r\n\r\n\t\tthis.extensions = extensions;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.setPlugins = function ( plugins ) {\r\n\r\n\t\tthis.plugins = plugins;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\r\n\t\t// Clear the loader cache\r\n\t\tthis.cache.removeAll();\r\n\r\n\t\t// Mark the special nodes/meshes in json for efficient parse\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext._markDefs && ext._markDefs();\r\n\r\n\t\t} );\r\n\r\n\t\tPromise.all( this._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\r\n\r\n\t\t} ) ).then( function () {\r\n\r\n\t\t\treturn Promise.all( [\r\n\r\n\t\t\t\tparser.getDependencies( 'scene' ),\r\n\t\t\t\tparser.getDependencies( 'animation' ),\r\n\t\t\t\tparser.getDependencies( 'camera' ),\r\n\r\n\t\t\t] );\r\n\r\n\t\t} ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar result = {\r\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\r\n\t\t\t\tscenes: dependencies[ 0 ],\r\n\t\t\t\tanimations: dependencies[ 1 ],\r\n\t\t\t\tcameras: dependencies[ 2 ],\r\n\t\t\t\tasset: json.asset,\r\n\t\t\t\tparser: parser,\r\n\t\t\t\tuserData: {}\r\n\t\t\t};\r\n\r\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\r\n\r\n\t\t\tassignExtrasToUserData( result, json );\r\n\r\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\r\n\r\n\t\t\t} ) ).then( function () {\r\n\r\n\t\t\t\tonLoad( result );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).catch( onError );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Marks the special nodes/meshes in json for efficient parse.\r\n\t */\r\n\tGLTFParser.prototype._markDefs = function () {\r\n\r\n\t\tvar nodeDefs = this.json.nodes || [];\r\n\t\tvar skinDefs = this.json.skins || [];\r\n\t\tvar meshDefs = this.json.meshes || [];\r\n\r\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\r\n\t\t// Object3D. Use the skins' joint references to mark bones.\r\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\r\n\r\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\r\n\r\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Iterate over all nodes, marking references to shared resources,\r\n\t\t// as well as skeleton joints.\r\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\r\n\r\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\r\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\r\n\t\t\t\t// to mark SkinnedMesh if node has skin.\r\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\r\n\r\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Counts references to shared node / Object3D resources. These resources\r\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\r\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n\t * Textures) can be reused directly and are not marked here.\r\n\t *\r\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n\t */\r\n\tGLTFParser.prototype._addNodeRef = function ( cache, index ) {\r\n\r\n\t\tif ( index === undefined ) return;\r\n\r\n\t\tif ( cache.refs[ index ] === undefined ) {\r\n\r\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\tcache.refs[ index ] ++;\r\n\r\n\t};\r\n\r\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\r\n\tGLTFParser.prototype._getNodeRef = function ( cache, index, object ) {\r\n\r\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\r\n\r\n\t\tvar ref = object.clone();\r\n\r\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\r\n\r\n\t\treturn ref;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype._invokeOne = function ( func ) {\r\n\r\n\t\tvar extensions = Object.values( this.plugins );\r\n\t\textensions.push( this );\r\n\r\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tvar result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) return result;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype._invokeAll = function ( func ) {\r\n\r\n\t\tvar extensions = Object.values( this.plugins );\r\n\t\textensions.unshift( this );\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tvar result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) pending.push( result );\r\n\r\n\t\t}\r\n\r\n\t\treturn pending;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Requests the specified dependency asynchronously, with caching.\r\n\t * @param {string} type\r\n\t * @param {number} index\r\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\r\n\t */\r\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\r\n\r\n\t\tvar cacheKey = type + ':' + index;\r\n\t\tvar dependency = this.cache.get( cacheKey );\r\n\r\n\t\tif ( ! dependency ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'scene':\r\n\t\t\t\t\tdependency = this.loadScene( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'node':\r\n\t\t\t\t\tdependency = this.loadNode( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'mesh':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'accessor':\r\n\t\t\t\t\tdependency = this.loadAccessor( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bufferView':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'buffer':\r\n\t\t\t\t\tdependency = this.loadBuffer( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'material':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'texture':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'skin':\r\n\t\t\t\t\tdependency = this.loadSkin( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'animation':\r\n\t\t\t\t\tdependency = this.loadAnimation( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'camera':\r\n\t\t\t\t\tdependency = this.loadCamera( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cache.add( cacheKey, dependency );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependency;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Requests all dependencies of the specified type asynchronously, with caching.\r\n\t * @param {string} type\r\n\t * @return {Promise<Array<Object>>}\r\n\t */\r\n\tGLTFParser.prototype.getDependencies = function ( type ) {\r\n\r\n\t\tvar dependencies = this.cache.get( type );\r\n\r\n\t\tif ( ! dependencies ) {\r\n\r\n\t\t\tvar parser = this;\r\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\r\n\r\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\r\n\r\n\t\t\t\treturn parser.getDependency( type, index );\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t\tthis.cache.add( type, dependencies );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependencies;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t * @param {number} bufferIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\r\n\r\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\r\n\t\tvar loader = this.fileLoader;\r\n\r\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\t// If present, GLB container is required to be the first buffer.\r\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\r\n\r\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\r\n\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\r\n\r\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t * @param {number} bufferViewIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\r\n\r\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\r\n\r\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\r\n\r\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\r\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n\t * @param {number} accessorIndex\r\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\r\n\t */\r\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\r\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\r\n\r\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\r\n\r\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\r\n\t\t\t// information about attributes coming from another source (e.g. Draco\r\n\t\t\t// compression extension).\r\n\t\t\treturn Promise.resolve( null );\r\n\r\n\t\t}\r\n\r\n\t\tvar pendingBufferViews = [];\r\n\r\n\t\tif ( accessorDef.bufferView !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tpendingBufferViews.push( null );\r\n\r\n\t\t}\r\n\r\n\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\r\n\r\n\t\t\tvar bufferView = bufferViews[ 0 ];\r\n\r\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\r\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n\t\t\tvar itemBytes = elementBytes * itemSize;\r\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\r\n\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\r\n\t\t\tvar normalized = accessorDef.normalized === true;\r\n\t\t\tvar array, bufferAttribute;\r\n\r\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\r\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\r\n\r\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\r\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\r\n\t\t\t\tvar ibSlice = Math.floor( byteOffset / byteStride );\r\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\r\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\r\n\r\n\t\t\t\tif ( ! ib ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\r\n\r\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\r\n\t\t\t\t\tib = new three__WEBPACK_IMPORTED_MODULE_0__[\"InterleavedBuffer\"]( array, byteStride / elementBytes );\r\n\r\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"InterleavedBufferAttribute\"]( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( bufferView === null ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"]( array, itemSize, normalized );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n\t\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\r\n\r\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n\r\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\r\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\r\n\r\n\t\t\t\tif ( bufferView !== null ) {\r\n\r\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n\t\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"]( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar index = sparseIndices[ i ];\r\n\r\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\r\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\r\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\r\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\r\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bufferAttribute;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n\t * @param {number} textureIndex\r\n\t * @return {Promise<THREE.Texture>}\r\n\t */\r\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar options = this.options;\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\t\tvar source = json.images[ textureDef.source ];\r\n\r\n\t\tvar loader = this.textureLoader;\r\n\r\n\t\tif ( source.uri ) {\r\n\r\n\t\t\tvar handler = options.manager.getHandler( source.uri );\r\n\t\t\tif ( handler !== null ) loader = handler;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadTextureImage = function ( textureIndex, source, loader ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar options = this.options;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tvar URL = self.URL || self.webkitURL;\r\n\r\n\t\tvar sourceURI = source.uri;\r\n\t\tvar isObjectURL = false;\r\n\t\tvar hasAlpha = true;\r\n\r\n\t\tif ( source.mimeType === 'image/jpeg' ) hasAlpha = false;\r\n\r\n\t\tif ( source.bufferView !== undefined ) {\r\n\r\n\t\t\t// Load binary image data from bufferView, if provided.\r\n\r\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\r\n\r\n\t\t\t\tif ( source.mimeType === 'image/png' ) {\r\n\r\n\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\r\n\t\t\t\t\t// alpha channel. This check is conservative — the image could have an alpha\r\n\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\r\n\t\t\t\t\t// sometimes contains alpha.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\r\n\t\t\t\t\tvar colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );\r\n\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tisObjectURL = true;\r\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\r\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\r\n\t\t\t\treturn sourceURI;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else if ( source.uri === undefined ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\t\tvar onLoad = resolve;\r\n\r\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\r\n\r\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\r\n\r\n\t\t\t\t\t\tresolve( new three__WEBPACK_IMPORTED_MODULE_0__[\"CanvasTexture\"]( imageBitmap ) );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).then( function ( texture ) {\r\n\r\n\t\t\t// Clean up resources and configure Texture.\r\n\r\n\t\t\tif ( isObjectURL === true ) {\r\n\r\n\t\t\t\tURL.revokeObjectURL( sourceURI );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.flipY = false;\r\n\r\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\r\n\r\n\t\t\t// When there is definitely no alpha channel in the texture, set RGBFormat to save space.\r\n\t\t\tif ( ! hasAlpha ) texture.format = three__WEBPACK_IMPORTED_MODULE_0__[\"RGBFormat\"];\r\n\r\n\t\t\tvar samplers = json.samplers || {};\r\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\r\n\r\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three__WEBPACK_IMPORTED_MODULE_0__[\"LinearFilter\"];\r\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three__WEBPACK_IMPORTED_MODULE_0__[\"LinearMipmapLinearFilter\"];\r\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three__WEBPACK_IMPORTED_MODULE_0__[\"RepeatWrapping\"];\r\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three__WEBPACK_IMPORTED_MODULE_0__[\"RepeatWrapping\"];\r\n\r\n\t\t\tparser.associations.set( texture, {\r\n\t\t\t\ttype: 'textures',\r\n\t\t\t\tindex: textureIndex\r\n\t\t\t} );\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Asynchronously assigns a texture to the given material parameters.\r\n\t * @param {Object} materialParams\r\n\t * @param {string} mapName\r\n\t * @param {Object} mapDef\r\n\t * @return {Promise}\r\n\t */\r\n\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\r\n\r\n\t\tvar parser = this;\r\n\r\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\r\n\r\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\r\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\r\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\r\n\r\n\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\r\n\r\n\t\t\t\tif ( transform ) {\r\n\r\n\t\t\t\t\tvar gltfReference = parser.associations.get( texture );\r\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\r\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams[ mapName ] = texture;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\r\n\t * already has a material (generated from the glTF material options alone)\r\n\t * but reuse of the same glTF material may require multiple threejs materials\r\n\t * to accommodate different primitive types, defines, etc. New materials will\r\n\t * be created if necessary, and reused from a cache.\r\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\r\n\t */\r\n\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\r\n\r\n\t\tvar geometry = mesh.geometry;\r\n\t\tvar material = mesh.material;\r\n\r\n\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\r\n\t\tvar useVertexColors = geometry.attributes.color !== undefined;\r\n\t\tvar useFlatShading = geometry.attributes.normal === undefined;\r\n\t\tvar useSkinning = mesh.isSkinnedMesh === true;\r\n\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\r\n\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\r\n\r\n\t\tif ( mesh.isPoints ) {\r\n\r\n\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\r\n\r\n\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! pointsMaterial ) {\r\n\r\n\t\t\t\tpointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"PointsMaterial\"]();\r\n\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__[\"Material\"].prototype.copy.call( pointsMaterial, material );\r\n\t\t\t\tpointsMaterial.color.copy( material.color );\r\n\t\t\t\tpointsMaterial.map = material.map;\r\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = pointsMaterial;\r\n\r\n\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\r\n\r\n\t\t\tvar lineMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! lineMaterial ) {\r\n\r\n\t\t\t\tlineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineBasicMaterial\"]();\r\n\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__[\"Material\"].prototype.copy.call( lineMaterial, material );\r\n\t\t\t\tlineMaterial.color.copy( material.color );\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = lineMaterial;\r\n\r\n\t\t}\r\n\r\n\t\t// Clone the material if it will be modified\r\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\r\n\r\n\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\r\n\r\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\r\n\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\r\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\r\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\r\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\r\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\r\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\r\n\r\n\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! cachedMaterial ) {\r\n\r\n\t\t\t\tcachedMaterial = material.clone();\r\n\r\n\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\r\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\r\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\r\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\r\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\r\n\r\n\t\t\t\tif ( useVertexTangents ) {\r\n\r\n\t\t\t\t\tcachedMaterial.vertexTangents = true;\r\n\r\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\r\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\r\n\r\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\t// workarounds for mesh and geometry\r\n\r\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\r\n\r\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\r\n\r\n\t\t}\r\n\r\n\t\tmesh.material = material;\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {\r\n\r\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"];\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n\t * @param {number} materialIndex\r\n\t * @return {Promise<Material>}\r\n\t */\r\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar materialDef = json.materials[ materialIndex ];\r\n\r\n\t\tvar materialType;\r\n\t\tvar materialParams = {};\r\n\t\tvar materialExtensions = materialDef.extensions || {};\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\r\n\r\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\r\n\t\t\tmaterialType = sgExtension.getMaterialType();\r\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\r\n\r\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\r\n\t\t\tmaterialType = kmuExtension.getMaterialType();\r\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Specification:\r\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n\r\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n\r\n\t\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]( 1.0, 1.0, 1.0 );\r\n\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\r\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\r\n\r\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\r\n\r\n\t\t\t} ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.doubleSided === true ) {\r\n\r\n\t\t\tmaterialParams.side = three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"];\r\n\r\n\t\t}\r\n\r\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\r\n\r\n\t\t\tmaterialParams.transparent = true;\r\n\r\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\r\n\t\t\tmaterialParams.depthWrite = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialParams.transparent = false;\r\n\r\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\r\n\r\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"] ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\r\n\r\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\tmaterialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]( 1, - 1 );\r\n\r\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"] ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\r\n\r\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"] ) {\r\n\r\n\t\t\tmaterialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]().fromArray( materialDef.emissiveFactor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"] ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\tvar material;\r\n\r\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\r\n\r\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = new materialType( materialParams );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\r\n\r\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\r\n\t\t\tif ( material.map ) material.map.encoding = three__WEBPACK_IMPORTED_MODULE_0__[\"sRGBEncoding\"];\r\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__[\"sRGBEncoding\"];\r\n\r\n\t\t\tassignExtrasToUserData( material, materialDef );\r\n\r\n\t\t\tparser.associations.set( material, { type: 'materials', index: materialIndex } );\r\n\r\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/** When Object3D instances are targeted by animation, they need unique names. */\r\n\tGLTFParser.prototype.createUniqueName = function ( originalName ) {\r\n\r\n\t\tvar sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__[\"PropertyBinding\"].sanitizeNodeName( originalName || '' );\r\n\r\n\t\tvar name = sanitizedName;\r\n\r\n\t\tfor ( var i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\r\n\r\n\t\t\tname = sanitizedName + '_' + i;\r\n\r\n\t\t}\r\n\r\n\t\tthis.nodeNamesUsed[ name ] = true;\r\n\r\n\t\treturn name;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * @param {BufferGeometry} geometry\r\n\t * @param {GLTF.Primitive} primitiveDef\r\n\t * @param {GLTFParser} parser\r\n\t */\r\n\tfunction computeBounds( geometry, primitiveDef, parser ) {\r\n\r\n\t\tvar attributes = primitiveDef.attributes;\r\n\r\n\t\tvar box = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"]();\r\n\r\n\t\tif ( attributes.POSITION !== undefined ) {\r\n\r\n\t\t\tvar accessor = parser.json.accessors[ attributes.POSITION ];\r\n\r\n\t\t\tvar min = accessor.min;\r\n\t\t\tvar max = accessor.max;\r\n\r\n\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\t\tbox.set(\r\n\t\t\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]( min[ 0 ], min[ 1 ], min[ 2 ] ),\r\n\t\t\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]( max[ 0 ], max[ 1 ], max[ 2 ] ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar targets = primitiveDef.targets;\r\n\r\n\t\tif ( targets !== undefined ) {\r\n\r\n\t\t\tvar maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\t\t\tvar vector = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\t\tif ( target.POSITION !== undefined ) {\r\n\r\n\t\t\t\t\tvar accessor = parser.json.accessors[ target.POSITION ];\r\n\t\t\t\t\tvar min = accessor.min;\r\n\t\t\t\t\tvar max = accessor.max;\r\n\r\n\t\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\t\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\r\n\t\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\r\n\t\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\r\n\t\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\r\n\r\n\t\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\r\n\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\r\n\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\r\n\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\r\n\t\t\t\t\t\tmaxDisplacement.max( vector );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\r\n\t\t\tbox.expandByVector( maxDisplacement );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.boundingBox = box;\r\n\r\n\t\tvar sphere = new three__WEBPACK_IMPORTED_MODULE_0__[\"Sphere\"]();\r\n\r\n\t\tbox.getCenter( sphere.center );\r\n\t\tsphere.radius = box.min.distanceTo( box.max ) / 2;\r\n\r\n\t\tgeometry.boundingSphere = sphere;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {BufferGeometry} geometry\r\n\t * @param {GLTF.Primitive} primitiveDef\r\n\t * @param {GLTFParser} parser\r\n\t * @return {Promise<BufferGeometry>}\r\n\t */\r\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\r\n\r\n\t\tvar attributes = primitiveDef.attributes;\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\r\n\r\n\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\r\n\t\t\t\t.then( function ( accessor ) {\r\n\r\n\t\t\t\t\tgeometry.setAttribute( attributeName, accessor );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var gltfAttributeName in attributes ) {\r\n\r\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\r\n\r\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\r\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\r\n\r\n\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\r\n\r\n\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\r\n\r\n\t\t\t\tgeometry.setIndex( accessor );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tpending.push( accessor );\r\n\r\n\t\t}\r\n\r\n\t\tassignExtrasToUserData( geometry, primitiveDef );\r\n\r\n\t\tcomputeBounds( geometry, primitiveDef, parser );\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\treturn primitiveDef.targets !== undefined\r\n\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\r\n\t\t\t\t: geometry;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {BufferGeometry} geometry\r\n\t * @param {Number} drawMode\r\n\t * @return {BufferGeometry}\r\n\t */\r\n\tfunction toTrianglesDrawMode( geometry, drawMode ) {\r\n\r\n\t\tvar index = geometry.getIndex();\r\n\r\n\t\t// generate index if not present\r\n\r\n\t\tif ( index === null ) {\r\n\r\n\t\t\tvar indices = [];\r\n\r\n\t\t\tvar position = geometry.getAttribute( 'position' );\r\n\r\n\t\t\tif ( position !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\r\n\r\n\t\t\t\t\tindices.push( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setIndex( indices );\r\n\t\t\t\tindex = geometry.getIndex();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar numberOfTriangles = index.count - 2;\r\n\t\tvar newIndices = [];\r\n\r\n\t\tif ( drawMode === three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleFanDrawMode\"] ) {\r\n\r\n\t\t\t// gl.TRIANGLE_FAN\r\n\r\n\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\r\n\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// gl.TRIANGLE_STRIP\r\n\r\n\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tif ( i % 2 === 0 ) {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\r\n\r\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\r\n\r\n\t\t}\r\n\r\n\t\t// build final geometry\r\n\r\n\t\tvar newGeometry = geometry.clone();\r\n\t\tnewGeometry.setIndex( newIndices );\r\n\r\n\t\treturn newGeometry;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n\t *\r\n\t * Creates BufferGeometries from primitives.\r\n\t *\r\n\t * @param {Array<GLTF.Primitive>} primitives\r\n\t * @return {Promise<Array<BufferGeometry>>}\r\n\t */\r\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar cache = this.primitiveCache;\r\n\r\n\t\tfunction createDracoPrimitive( primitive ) {\r\n\r\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\r\n\t\t\t\t.decodePrimitive( primitive, parser )\r\n\t\t\t\t.then( function ( geometry ) {\r\n\r\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar primitive = primitives[ i ];\r\n\t\t\tvar cacheKey = createPrimitiveKey( primitive );\r\n\r\n\t\t\t// See if we've already created this geometry\r\n\t\t\tvar cached = cache[ cacheKey ];\r\n\r\n\t\t\tif ( cached ) {\r\n\r\n\t\t\t\t// Use the cached geometry if it exists\r\n\t\t\t\tpending.push( cached.promise );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar geometryPromise;\r\n\r\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\r\n\r\n\t\t\t\t\t// Use DRACO geometry if available\r\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Otherwise create a new geometry\r\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"](), primitive, parser );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cache this geometry\r\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\r\n\r\n\t\t\t\tpending.push( geometryPromise );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n\t * @param {number} meshIndex\r\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\r\n\t */\r\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\r\n\t\tvar meshDef = json.meshes[ meshIndex ];\r\n\t\tvar primitives = meshDef.primitives;\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar material = primitives[ i ].material === undefined\r\n\t\t\t\t? createDefaultMaterial( this.cache )\r\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\r\n\r\n\t\t\tpending.push( material );\r\n\r\n\t\t}\r\n\r\n\t\tpending.push( parser.loadGeometries( primitives ) );\r\n\r\n\t\treturn Promise.all( pending ).then( function ( results ) {\r\n\r\n\t\t\tvar materials = results.slice( 0, results.length - 1 );\r\n\t\t\tvar geometries = results[ results.length - 1 ];\r\n\r\n\t\t\tvar meshes = [];\r\n\r\n\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar geometry = geometries[ i ];\r\n\t\t\t\tvar primitive = primitives[ i ];\r\n\r\n\t\t\t\t// 1. create Mesh\r\n\r\n\t\t\t\tvar mesh;\r\n\r\n\t\t\t\tvar material = materials[ i ];\r\n\r\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\r\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\r\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\r\n\t\t\t\t\tprimitive.mode === undefined ) {\r\n\r\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\r\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\r\n\t\t\t\t\t\t? new three__WEBPACK_IMPORTED_MODULE_0__[\"SkinnedMesh\"]( geometry, material )\r\n\t\t\t\t\t\t: new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]( geometry, material );\r\n\r\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\r\n\r\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\r\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\r\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleStripDrawMode\"] );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleFanDrawMode\"] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\r\n\r\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"]( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\r\n\r\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Line\"]( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\r\n\r\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineLoop\"]( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\r\n\r\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Points\"]( geometry, material );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\r\n\r\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\r\n\r\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\r\n\r\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\r\n\r\n\t\t\t\tparser.assignFinalMaterial( mesh );\r\n\r\n\t\t\t\tmeshes.push( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( meshes.length === 1 ) {\r\n\r\n\t\t\t\treturn meshes[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar group = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\r\n\r\n\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup.add( meshes[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn group;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n\t * @param {number} cameraIndex\r\n\t * @return {Promise<THREE.Camera>}\r\n\t */\r\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\r\n\r\n\t\tvar camera;\r\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\r\n\t\tvar params = cameraDef[ cameraDef.type ];\r\n\r\n\t\tif ( ! params ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.type === 'perspective' ) {\r\n\r\n\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"]( three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\r\n\r\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\r\n\r\n\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"]( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\r\n\r\n\t\tassignExtrasToUserData( camera, cameraDef );\r\n\r\n\t\treturn Promise.resolve( camera );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n\t * @param {number} skinIndex\r\n\t * @return {Promise<Object>}\r\n\t */\r\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\r\n\r\n\t\tvar skinDef = this.json.skins[ skinIndex ];\r\n\r\n\t\tvar skinEntry = { joints: skinDef.joints };\r\n\r\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\r\n\r\n\t\t\treturn Promise.resolve( skinEntry );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\r\n\r\n\t\t\tskinEntry.inverseBindMatrices = accessor;\r\n\r\n\t\t\treturn skinEntry;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\t * @param {number} animationIndex\r\n\t * @return {Promise<AnimationClip>}\r\n\t */\r\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\tvar animationDef = json.animations[ animationIndex ];\r\n\r\n\t\tvar pendingNodes = [];\r\n\t\tvar pendingInputAccessors = [];\r\n\t\tvar pendingOutputAccessors = [];\r\n\t\tvar pendingSamplers = [];\r\n\t\tvar pendingTargets = [];\r\n\r\n\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar channel = animationDef.channels[ i ];\r\n\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\r\n\t\t\tvar target = channel.target;\r\n\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\r\n\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\r\n\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\r\n\r\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\r\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\r\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\r\n\t\t\tpendingSamplers.push( sampler );\r\n\t\t\tpendingTargets.push( target );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( [\r\n\r\n\t\t\tPromise.all( pendingNodes ),\r\n\t\t\tPromise.all( pendingInputAccessors ),\r\n\t\t\tPromise.all( pendingOutputAccessors ),\r\n\t\t\tPromise.all( pendingSamplers ),\r\n\t\t\tPromise.all( pendingTargets )\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar nodes = dependencies[ 0 ];\r\n\t\t\tvar inputAccessors = dependencies[ 1 ];\r\n\t\t\tvar outputAccessors = dependencies[ 2 ];\r\n\t\t\tvar samplers = dependencies[ 3 ];\r\n\t\t\tvar targets = dependencies[ 4 ];\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar node = nodes[ i ];\r\n\t\t\t\tvar inputAccessor = inputAccessors[ i ];\r\n\t\t\t\tvar outputAccessor = outputAccessors[ i ];\r\n\t\t\t\tvar sampler = samplers[ i ];\r\n\t\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\t\tif ( node === undefined ) continue;\r\n\r\n\t\t\t\tnode.updateMatrix();\r\n\t\t\t\tnode.matrixAutoUpdate = true;\r\n\r\n\t\t\t\tvar TypedKeyframeTrack;\r\n\r\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__[\"NumberKeyframeTrack\"];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__[\"QuaternionKeyframeTrack\"];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.position:\r\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__[\"VectorKeyframeTrack\"];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\r\n\r\n\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three__WEBPACK_IMPORTED_MODULE_0__[\"InterpolateLinear\"];\r\n\r\n\t\t\t\tvar targetNames = [];\r\n\r\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\r\n\r\n\t\t\t\t\t// Node may be a Group (glTF mesh with several primitives) or a Mesh.\r\n\t\t\t\t\tnode.traverse( function ( object ) {\r\n\r\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\r\n\r\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetNames.push( targetName );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar outputArray = outputAccessor.array;\r\n\r\n\t\t\t\tif ( outputAccessor.normalized ) {\r\n\r\n\t\t\t\t\tvar scale;\r\n\r\n\t\t\t\t\tif ( outputArray.constructor === Int8Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 127;\r\n\r\n\t\t\t\t\t} else if ( outputArray.constructor === Uint8Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 255;\r\n\r\n\t\t\t\t\t} else if ( outputArray.constructor == Int16Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 32767;\r\n\r\n\t\t\t\t\t} else if ( outputArray.constructor === Uint16Array ) {\r\n\r\n\t\t\t\t\t\tscale = 1 / 65535;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar scaled = new Float32Array( outputArray.length );\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutputArray = scaled;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar track = new TypedKeyframeTrack(\r\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\r\n\t\t\t\t\t\tinputAccessor.array,\r\n\t\t\t\t\t\toutputArray,\r\n\t\t\t\t\t\tinterpolation\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Override interpolation with custom factory method.\r\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\r\n\r\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\r\n\r\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\r\n\r\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\r\n\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\r\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( track );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\r\n\r\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__[\"AnimationClip\"]( name, undefined, tracks );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n\t * @param {number} nodeIndex\r\n\t * @return {Promise<Object3D>}\r\n\t */\r\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar parser = this;\r\n\r\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\r\n\t\tvar nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\r\n\r\n\t\treturn ( function () {\r\n\r\n\t\t\tvar pending = [];\r\n\r\n\t\t\tif ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\r\n\r\n\t\t\t\t\tvar node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\r\n\r\n\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\r\n\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\r\n\r\n\t\t\t\t\t\tnode.traverse( function ( o ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t} ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\r\n\r\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\r\n\r\n\t\t\t\t} ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\r\n\r\n\t\t\t} ).forEach( function ( promise ) {\r\n\r\n\t\t\t\tpending.push( promise );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn Promise.all( pending );\r\n\r\n\t\t}() ).then( function ( objects ) {\r\n\r\n\t\t\tvar node;\r\n\r\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\r\n\t\t\tif ( nodeDef.isBone === true ) {\r\n\r\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__[\"Bone\"]();\r\n\r\n\t\t\t} else if ( objects.length > 1 ) {\r\n\r\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\r\n\r\n\t\t\t} else if ( objects.length === 1 ) {\r\n\r\n\t\t\t\tnode = objects[ 0 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node !== objects[ 0 ] ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tnode.add( objects[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.name ) {\r\n\r\n\t\t\t\tnode.userData.name = nodeDef.name;\r\n\t\t\t\tnode.name = nodeName;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tassignExtrasToUserData( node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.matrix !== undefined ) {\r\n\r\n\t\t\t\tvar matrix = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\r\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\r\n\t\t\t\tnode.applyMatrix4( matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\r\n\r\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser.associations.set( node, { type: 'nodes', index: nodeIndex } );\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n\t * @param {number} sceneIndex\r\n\t * @return {Promise<Group>}\r\n\t */\r\n\tGLTFParser.prototype.loadScene = function () {\r\n\r\n\t\t// scene node hierachy builder\r\n\r\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\r\n\r\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\r\n\r\n\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\r\n\r\n\t\t\t\tif ( nodeDef.skin === undefined ) return node;\r\n\r\n\t\t\t\t// build skeleton here as well\r\n\r\n\t\t\t\tvar skinEntry;\r\n\r\n\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\r\n\r\n\t\t\t\t\tskinEntry = skin;\r\n\r\n\t\t\t\t\tvar pendingJoints = [];\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn Promise.all( pendingJoints );\r\n\r\n\t\t\t\t} ).then( function ( jointNodes ) {\r\n\r\n\t\t\t\t\tnode.traverse( function ( mesh ) {\r\n\r\n\t\t\t\t\t\tif ( ! mesh.isMesh ) return;\r\n\r\n\t\t\t\t\t\tvar bones = [];\r\n\t\t\t\t\t\tvar boneInverses = [];\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( jointNode ) {\r\n\r\n\t\t\t\t\t\t\t\tbones.push( jointNode );\r\n\r\n\t\t\t\t\t\t\t\tvar mat = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\r\n\r\n\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tboneInverses.push( mat );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmesh.bind( new three__WEBPACK_IMPORTED_MODULE_0__[\"Skeleton\"]( bones, boneInverses ), mesh.matrixWorld );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} ).then( function ( node ) {\r\n\r\n\t\t\t\t// build node hierachy\r\n\r\n\t\t\t\tparentObject.add( node );\r\n\r\n\t\t\t\tvar pending = [];\r\n\r\n\t\t\t\tif ( nodeDef.children ) {\r\n\r\n\t\t\t\t\tvar children = nodeDef.children;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar child = children[ i ];\r\n\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.all( pending );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn function loadScene( sceneIndex ) {\r\n\r\n\t\t\tvar json = this.json;\r\n\t\t\tvar extensions = this.extensions;\r\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\r\n\t\t\tvar parser = this;\r\n\r\n\t\t\t// Loader returns Group, not Scene.\r\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\r\n\t\t\tvar scene = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\r\n\t\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\r\n\r\n\t\t\tassignExtrasToUserData( scene, sceneDef );\r\n\r\n\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\r\n\r\n\t\t\tvar nodeIds = sceneDef.nodes || [];\r\n\r\n\t\t\tvar pending = [];\r\n\r\n\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\t\treturn scene;\r\n\r\n\t\t\t} );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\treturn GLTFLoader;\r\n\r\n} )();\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/lib/GLTFLoader.js?");

/***/ }),

/***/ "./src/lib/stats.module.js":
/*!*********************************!*\
  !*** ./src/lib/stats.module.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar Stats = function () {\r\n\r\n\tvar mode = 0;\r\n\r\n\tvar container = document.createElement( 'div' );\r\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\r\n\tcontainer.addEventListener( 'click', function ( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\t\tshowPanel( ++ mode % container.children.length );\r\n\r\n\t}, false );\r\n\r\n\t//\r\n\r\n\tfunction addPanel( panel ) {\r\n\r\n\t\tcontainer.appendChild( panel.dom );\r\n\t\treturn panel;\r\n\r\n\t}\r\n\r\n\tfunction showPanel( id ) {\r\n\r\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\r\n\r\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\r\n\r\n\t\t}\r\n\r\n\t\tmode = id;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\r\n\r\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\r\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\r\n\r\n\tif ( self.performance && self.performance.memory ) {\r\n\r\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\r\n\r\n\t}\r\n\r\n\tshowPanel( 0 );\r\n\r\n\treturn {\r\n\r\n\t\tREVISION: 16,\r\n\r\n\t\tdom: container,\r\n\r\n\t\taddPanel: addPanel,\r\n\t\tshowPanel: showPanel,\r\n\r\n\t\tbegin: function () {\r\n\r\n\t\t\tbeginTime = ( performance || Date ).now();\r\n\r\n\t\t},\r\n\r\n\t\tend: function () {\r\n\r\n\t\t\tframes ++;\r\n\r\n\t\t\tvar time = ( performance || Date ).now();\r\n\r\n\t\t\tmsPanel.update( time - beginTime, 200 );\r\n\r\n\t\t\tif ( time >= prevTime + 1000 ) {\r\n\r\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\r\n\r\n\t\t\t\tprevTime = time;\r\n\t\t\t\tframes = 0;\r\n\r\n\t\t\t\tif ( memPanel ) {\r\n\r\n\t\t\t\t\tvar memory = performance.memory;\r\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn time;\r\n\r\n\t\t},\r\n\r\n\t\tupdate: function () {\r\n\r\n\t\t\tbeginTime = this.end();\r\n\r\n\t\t},\r\n\r\n\t\t// Backwards Compatibility\r\n\r\n\t\tdomElement: container,\r\n\t\tsetMode: showPanel\r\n\r\n\t};\r\n\r\n};\r\n\r\nStats.Panel = function ( name, fg, bg ) {\r\n\r\n\tvar min = Infinity, max = 0, round = Math.round;\r\n\tvar PR = round( window.devicePixelRatio || 1 );\r\n\r\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\r\n\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\r\n\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\r\n\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\r\n\r\n\tvar canvas = document.createElement( 'canvas' );\r\n\tcanvas.width = WIDTH;\r\n\tcanvas.height = HEIGHT;\r\n\tcanvas.style.cssText = 'width:80px;height:48px';\r\n\r\n\tvar context = canvas.getContext( '2d' );\r\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\r\n\tcontext.textBaseline = 'top';\r\n\r\n\tcontext.fillStyle = bg;\r\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\r\n\r\n\tcontext.fillStyle = fg;\r\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\r\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\r\n\r\n\tcontext.fillStyle = bg;\r\n\tcontext.globalAlpha = 0.9;\r\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\r\n\r\n\treturn {\r\n\r\n\t\tdom: canvas,\r\n\r\n\t\tupdate: function ( value, maxValue ) {\r\n\r\n\t\t\tmin = Math.min( min, value );\r\n\t\t\tmax = Math.max( max, value );\r\n\r\n\t\t\tcontext.fillStyle = bg;\r\n\t\t\tcontext.globalAlpha = 1;\r\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\r\n\t\t\tcontext.fillStyle = fg;\r\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\r\n\r\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\r\n\r\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\r\n\r\n\t\t\tcontext.fillStyle = bg;\r\n\t\t\tcontext.globalAlpha = 0.9;\r\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Stats);\r\n\n\n//# sourceURL=webpack:///./src/lib/stats.module.js?");

/***/ }),

/***/ "./src/shaders/explosion.png":
/*!***********************************!*\
  !*** ./src/shaders/explosion.png ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:image/png;base64,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\");\n\n//# sourceURL=webpack:///./src/shaders/explosion.png?");

/***/ }),

/***/ "./src/shaders/fragment.glsl":
/*!***********************************!*\
  !*** ./src/shaders/fragment.glsl ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"varying vec2 vUv;\\r\\nvarying float noise;\\r\\nuniform sampler2D tExplosion;\\r\\n\\r\\nfloat random( vec3 scale, float seed ){\\r\\n  return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n  float r = .01 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\\r\\n  vec2 tPos = vec2( 0, 1.3 * noise + r );\\r\\n  vec4 color = texture2D( tExplosion, tPos );\\r\\n  gl_FragColor = vec4( color.rgb, 1.0 );\\r\\n\\r\\n}\");\n\n//# sourceURL=webpack:///./src/shaders/fragment.glsl?");

/***/ }),

/***/ "./src/shaders/vertex.glsl":
/*!*********************************!*\
  !*** ./src/shaders/vertex.glsl ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"//\\r\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\r\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\r\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\r\\n// Version: 2011-10-11\\r\\n//\\r\\n// Many thanks to Ian McEwan of Ashima Arts for the\\r\\n// ideas for permutation and gradient selection.\\r\\n//\\r\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\r\\n// Distributed under the MIT license. See LICENSE file.\\r\\n// https://github.com/ashima/webgl-noise\\r\\n//\\r\\n\\r\\nvec3 mod289(vec3 x)\\r\\n{\\r\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\r\\n}\\r\\n\\r\\nvec4 mod289(vec4 x)\\r\\n{\\r\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\r\\n}\\r\\n\\r\\nvec4 permute(vec4 x)\\r\\n{\\r\\n  return mod289(((x*34.0)+1.0)*x);\\r\\n}\\r\\n\\r\\nvec4 taylorInvSqrt(vec4 r)\\r\\n{\\r\\n  return 1.79284291400159 - 0.85373472095314 * r;\\r\\n}\\r\\n\\r\\nvec3 fade(vec3 t) {\\r\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\r\\n}\\r\\n\\r\\n// Classic Perlin noise\\r\\nfloat cnoise(vec3 P)\\r\\n{\\r\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\r\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\r\\n  Pi0 = mod289(Pi0);\\r\\n  Pi1 = mod289(Pi1);\\r\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\r\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\r\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\r\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\r\\n  vec4 iz0 = Pi0.zzzz;\\r\\n  vec4 iz1 = Pi1.zzzz;\\r\\n\\r\\n  vec4 ixy = permute(permute(ix) + iy);\\r\\n  vec4 ixy0 = permute(ixy + iz0);\\r\\n  vec4 ixy1 = permute(ixy + iz1);\\r\\n\\r\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\r\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\r\\n  gx0 = fract(gx0);\\r\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\r\\n  vec4 sz0 = step(gz0, vec4(0.0));\\r\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\r\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\r\\n\\r\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\r\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\r\\n  gx1 = fract(gx1);\\r\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\r\\n  vec4 sz1 = step(gz1, vec4(0.0));\\r\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\r\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\r\\n\\r\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\r\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\r\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\r\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\r\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\r\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\r\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\r\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\r\\n\\r\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\r\\n  g000 *= norm0.x;\\r\\n  g010 *= norm0.y;\\r\\n  g100 *= norm0.z;\\r\\n  g110 *= norm0.w;\\r\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\r\\n  g001 *= norm1.x;\\r\\n  g011 *= norm1.y;\\r\\n  g101 *= norm1.z;\\r\\n  g111 *= norm1.w;\\r\\n\\r\\n  float n000 = dot(g000, Pf0);\\r\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\r\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\r\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\r\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\r\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\r\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\r\\n  float n111 = dot(g111, Pf1);\\r\\n\\r\\n  vec3 fade_xyz = fade(Pf0);\\r\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\r\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\r\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\r\\n  return 2.2 * n_xyz;\\r\\n}\\r\\n\\r\\n// Classic Perlin noise, periodic variant\\r\\nfloat pnoise(vec3 P, vec3 rep)\\r\\n{\\r\\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\r\\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\r\\n  Pi0 = mod289(Pi0);\\r\\n  Pi1 = mod289(Pi1);\\r\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\r\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\r\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\r\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\r\\n  vec4 iz0 = Pi0.zzzz;\\r\\n  vec4 iz1 = Pi1.zzzz;\\r\\n\\r\\n  vec4 ixy = permute(permute(ix) + iy);\\r\\n  vec4 ixy0 = permute(ixy + iz0);\\r\\n  vec4 ixy1 = permute(ixy + iz1);\\r\\n\\r\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\r\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\r\\n  gx0 = fract(gx0);\\r\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\r\\n  vec4 sz0 = step(gz0, vec4(0.0));\\r\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\r\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\r\\n\\r\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\r\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\r\\n  gx1 = fract(gx1);\\r\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\r\\n  vec4 sz1 = step(gz1, vec4(0.0));\\r\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\r\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\r\\n\\r\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\r\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\r\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\r\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\r\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\r\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\r\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\r\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\r\\n\\r\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\r\\n  g000 *= norm0.x;\\r\\n  g010 *= norm0.y;\\r\\n  g100 *= norm0.z;\\r\\n  g110 *= norm0.w;\\r\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\r\\n  g001 *= norm1.x;\\r\\n  g011 *= norm1.y;\\r\\n  g101 *= norm1.z;\\r\\n  g111 *= norm1.w;\\r\\n\\r\\n  float n000 = dot(g000, Pf0);\\r\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\r\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\r\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\r\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\r\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\r\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\r\\n  float n111 = dot(g111, Pf1);\\r\\n\\r\\n  vec3 fade_xyz = fade(Pf0);\\r\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\r\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\r\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\r\\n  return 2.2 * n_xyz;\\r\\n}\\r\\n\\r\\n// Include the Ashima code here!\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying float noise;\\r\\nuniform float time;\\r\\n\\r\\nfloat turbulence( vec3 p ) {\\r\\n  float w = 100.0;\\r\\n  float t = -.5;\\r\\n  for (float f = 1.0 ; f <= 10.0 ; f++ ){\\r\\n    float power = pow( 2.0, f );\\r\\n    t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\\r\\n  }\\r\\n  return t;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n  vUv = uv;\\r\\n\\r\\n  noise = 10.0 *  -.10 * turbulence( .5 * normal + time );\\r\\n  float b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );\\r\\n  float displacement = - 10. * noise + b;\\r\\n\\r\\n  vec3 newPosition = position + normal * displacement;\\r\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\\r\\n\\r\\n}\");\n\n//# sourceURL=webpack:///./src/shaders/vertex.glsl?");

/***/ })

/******/ });</script></body>
</html>