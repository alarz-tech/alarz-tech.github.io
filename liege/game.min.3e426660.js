(()=>{var __webpack_modules__={1106:module=>{"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack:///../node_modules/earcut/src/earcut.js?")},6659:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack:///../node_modules/eventemitter3/index.js?")},7981:module=>{eval("\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n\n\n//# sourceURL=webpack:///../node_modules/parse-svg-path/index.js?")},860:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "I": () => (/* binding */ gameApp)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(497);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/environment-browser/browserExt.mjs\n\n\n"use strict";\nconst browserExt = {\n  extension: {\n    type: Extensions/* ExtensionType.Environment */.nw.Environment,\n    name: "browser",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(375), __webpack_require__.e(321)]).then(__webpack_require__.bind(__webpack_require__, 2321));\n  }\n};\n\n\n//# sourceMappingURL=browserExt.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs\n\n\n"use strict";\nconst webworkerExt = {\n  extension: {\n    type: Extensions/* ExtensionType.Environment */.nw.Environment,\n    name: "webworker",\n    priority: 0\n  },\n  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(375), __webpack_require__.e(673)]).then(__webpack_require__.bind(__webpack_require__, 3673));\n  }\n};\n\n\n//# sourceMappingURL=webworkerExt.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/init.mjs + 5 modules\nvar init = __webpack_require__(7764);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/spritesheet/init.mjs + 2 modules\nvar spritesheet_init = __webpack_require__(7736);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(4598);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs + 1 modules\nvar AbstractRenderer = __webpack_require__(2687);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs\n\n\n\n"use strict";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat */.I.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!adapter/* DOMAdapter.get */.z.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = adapter/* DOMAdapter.get */.z.get().createCanvas();\n      let gl = canvas.getContext("webgl", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension("WEBGL_lose_context");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\n\n//# sourceMappingURL=isWebGLSupported.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs\n\n\n"use strict";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = adapter/* DOMAdapter.get */.z.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\n\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs\n\n\n\n\n"use strict";\nconst renderPriority = ["webgl", "webgpu", "canvas"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === "webgpu" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await Promise.all(/* import() */[__webpack_require__.e(289), __webpack_require__.e(961)]).then(__webpack_require__.bind(__webpack_require__, 5961));\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === "webgl" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat */.I.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await Promise.all(/* import() */[__webpack_require__.e(289), __webpack_require__.e(513)]).then(__webpack_require__.bind(__webpack_require__, 9513));\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === "canvas") {\n      finalOptions = { ...options };\n      throw new Error("CanvasRenderer is not yet implemented");\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  if (!RendererClass) {\n    throw new Error("No available renderer for the current environment");\n  }\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\n\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(4383);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/global/globalHooks.mjs\nvar globalHooks = __webpack_require__(3587);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(9885);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/app/Application.mjs\n\n\n\n\n\n\n"use strict";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that\'s rendered. */\n    this.stage = new Container/* Container */.W2();\n    if (args[0] !== void 0) {\n      (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "Application constructor options are deprecated, please use Application.init() instead.");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "Application.view is deprecated, please use Application.canvas instead.");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nExtensions/* extensions.handleByList */.Rw.handleByList(Extensions/* ExtensionType.Application */.nw.Application, Application._plugins);\nExtensions/* extensions.add */.Rw.add(globalHooks/* ApplicationInitHook */.l);\n\n\n//# sourceMappingURL=Application.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(9032);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(4154);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(7381);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(4860);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(1775);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs\nvar AbstractBitmapFont = __webpack_require__(9442);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs + 2 modules\nvar BitmapFontManager = __webpack_require__(9159);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs\n\n\n\n\n\n"use strict";\nclass BitmapFont extends AbstractBitmapFont/* AbstractBitmapFont */.M {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const {\n        frame: textureFrame,\n        source: textureSource\n      } = textures[charData.page];\n      const frameReal = new Rectangle/* Rectangle */.A(\n        charData.x + textureFrame.x,\n        charData.y + textureFrame.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture/* Texture */.x({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: "none",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from \'pixi.js\';\n   *\n   * BitmapFont.install(\'TitleFont\', {\n   *     fontFamily: \'Arial\',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: \'purple\',\n   * });\n   *\n   * const title = new BitmapText({ text: \'This is the title\', fontFamily: \'TitleFont\' });\n   */\n  static install(options) {\n    BitmapFontManager/* BitmapFontManager.install */.W.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager/* BitmapFontManager.uninstall */.W.uninstall(name);\n  }\n}\n\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs\n\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === "string" && data.startsWith("info face=");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("=");\n        const key = split[0];\n        const strValue = split[1].replace(/"/gm, "");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs\n\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName("info")[0];\n    const common = xml.getElementsByTagName("common")[0];\n    const distanceField = xml.getElementsByTagName("distanceField")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute("fieldType"),\n        range: parseInt(distanceField.getAttribute("distanceRange"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName("page");\n    const char = xml.getElementsByTagName("char");\n    const kerning = xml.getElementsByTagName("kerning");\n    data.fontSize = parseInt(info.getAttribute("size"), 10);\n    data.fontFamily = info.getAttribute("face");\n    data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute("id"), 10);\n      let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute("page"), 10) || 0,\n        x: parseInt(charNode.getAttribute("x"), 10),\n        y: parseInt(charNode.getAttribute("y"), 10),\n        width: parseInt(charNode.getAttribute("width"), 10),\n        height: parseInt(charNode.getAttribute("height"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute("xoffset"), 10),\n        yOffset: parseInt(charNode.getAttribute("yoffset"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute("first"), 10);\n      const second = parseInt(kerning[i].getAttribute("second"), 10);\n      const amount = parseInt(kerning[i].getAttribute("amount"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs\n\n\n\n"use strict";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === "string" && data.includes("<font>")) {\n      return bitmapFontXMLParser.test(adapter/* DOMAdapter.get */.z.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(adapter/* DOMAdapter.get */.z.get().parseXML(data));\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validExtensions = [".xml", ".fnt"];\nconst bitmapFontCachePlugin = {\n  extension: {\n    type: Extensions/* ExtensionType.CacheParser */.nw.CacheParser,\n    name: "cacheBitmapFont"\n  },\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n      out[`${key}-bitmap`] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority.Normal */.Q.Normal\n  },\n  name: "loadBitmapFont",\n  test(url) {\n    return validExtensions.includes(path/* path.extname */.E.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    const textureOptions = bitmapFontData.distanceField ? {\n      scaleMode: "linear",\n      alphaMode: "premultiply-alpha-on-upload",\n      autoGenerateMipmaps: false,\n      resolution: 1\n    } : {};\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path/* path.join */.E.join(path/* path.dirname */.E.dirname(src), pageFile);\n      imagePath = (0,copySearchParams/* copySearchParams */.u)(imagePath, src);\n      textureUrls.push({\n        src: imagePath,\n        data: textureOptions\n      });\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url.src]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await adapter/* DOMAdapter.get */.z.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(6576);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/BackgroundLoader.mjs\n\nclass BackgroundLoader {\n  /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose) {\n      console.log("[BackgroundLoader] assets: ", this._assetList);\n    }\n    if (this._isActive && !this._isLoading) {\n      void this._next();\n    }\n  }\n  /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      void this._next();\n    }\n  }\n  /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      void this._next();\n    }\n  }\n}\n\n\n//# sourceMappingURL=BackgroundLoader.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(1778);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs\n\n\n\n"use strict";\nconst cacheTextureArray = {\n  extension: {\n    type: Extensions/* ExtensionType.CacheParser */.nw.CacheParser,\n    name: "cacheTextureArray"\n  },\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture/* Texture */.x),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? "" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\n\n\n//# sourceMappingURL=cacheTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs\n\nasync function testImageFormat(imageData) {\n  if ("Image" in globalThis) {\n    return new Promise((resolve) => {\n      const image = new Image();\n      image.onload = () => {\n        resolve(true);\n      };\n      image.onerror = () => {\n        resolve(false);\n      };\n      image.src = imageData;\n    });\n  }\n  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {\n    try {\n      const blob = await (await fetch(imageData)).blob();\n      await createImageBitmap(blob);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\n\n//# sourceMappingURL=testImageFormat.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs\n\n\n\n"use strict";\nconst detectAvif = {\n  extension: {\n    type: Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 1\n  },\n  test: async () => testImageFormat(\n    // eslint-disable-next-line max-len\n    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="\n  ),\n  add: async (formats) => [...formats, "avif"],\n  remove: async (formats) => formats.filter((f) => f !== "avif")\n};\n\n\n//# sourceMappingURL=detectAvif.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs\n\n\n"use strict";\nconst imageFormats = ["png", "jpg", "jpeg"];\nconst detectDefaults = {\n  extension: {\n    type: Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\n\n\n//# sourceMappingURL=detectDefaults.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs\n\nconst inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction testVideoFormat(mimeType) {\n  if (inWorker) {\n    return false;\n  }\n  const video = document.createElement("video");\n  return video.canPlayType(mimeType) !== "";\n}\n\n\n//# sourceMappingURL=testVideoFormat.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs\n\n\n\n"use strict";\nconst detectMp4 = {\n  extension: {\n    type: Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/mp4"),\n  add: async (formats) => [...formats, "mp4", "m4v"],\n  remove: async (formats) => formats.filter((f) => f !== "mp4" && f !== "m4v")\n};\n\n\n//# sourceMappingURL=detectMp4.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs\n\n\n\n"use strict";\nconst detectOgv = {\n  extension: {\n    type: Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/ogg"),\n  add: async (formats) => [...formats, "ogv"],\n  remove: async (formats) => formats.filter((f) => f !== "ogv")\n};\n\n\n//# sourceMappingURL=detectOgv.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs\n\n\n\n"use strict";\nconst detectWebm = {\n  extension: {\n    type: Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/webm"),\n  add: async (formats) => [...formats, "webm"],\n  remove: async (formats) => formats.filter((f) => f !== "webm")\n};\n\n\n//# sourceMappingURL=detectWebm.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs\n\n\n\n"use strict";\nconst detectWebp = {\n  extension: {\n    type: Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testImageFormat(\n    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="\n  ),\n  add: async (formats) => [...formats, "webp"],\n  remove: async (formats) => formats.filter((f) => f !== "webp")\n};\n\n\n//# sourceMappingURL=detectWebp.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/utils/convertToList.mjs\nvar convertToList = __webpack_require__(3268);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs\nvar isSingleItem = __webpack_require__(2847);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/Loader.mjs\n\n\n\n\n\n"use strict";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          (0,warn/* warn */.Z)(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          (0,warn/* warn */.Z)(`[Assets] ${url} could not be loaded as we don\'t know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(assetsToLoadIn);\n    const assetsToLoad = (0,convertToList/* convertToList */.S)(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item,\n      data: {}\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = path/* path.toAbsolute */.E.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load(\'cool.png\');\n   *\n   * await Loader.unload(\'cool.png\');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = (0,convertToList/* convertToList */.S)(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = path/* path.toAbsolute */.E.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        (0,warn/* warn */.Z)(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        (0,warn/* warn */.Z)(`[Assets] loadParser name conflict "${parser.name}"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\n\n//# sourceMappingURL=Loader.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs\n\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\n\n//# sourceMappingURL=checkDataUrl.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/utils/checkExtension.mjs\n\n\n"use strict";\nfunction checkExtension(url, extension) {\n  const tempURL = url.split("?")[0];\n  const ext = path/* path.extname */.E.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\n\n//# sourceMappingURL=checkExtension.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs\n\n\n\n\n\n\n"use strict";\nconst validJSONExtension = ".json";\nconst validJSONMIME = "application/json";\nconst loadJson = {\n  extension: {\n    type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority.Low */.Q.Low\n  },\n  name: "loadJson",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await adapter/* DOMAdapter.get */.z.get().fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\n\n\n//# sourceMappingURL=loadJson.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs\n\n\n\n\n\n\n"use strict";\nconst validTXTExtension = ".txt";\nconst validTXTMIME = "text/plain";\nconst loadTxt = {\n  name: "loadTxt",\n  extension: {\n    type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority.Low */.Q.Low,\n    name: "loadTxt"\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await adapter/* DOMAdapter.get */.z.get().fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\n\n\n//# sourceMappingURL=loadTxt.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validWeights = [\n  "normal",\n  "bold",\n  "100",\n  "200",\n  "300",\n  "400",\n  "500",\n  "600",\n  "700",\n  "800",\n  "900"\n];\nconst validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];\nconst validFontMIMEs = [\n  "font/ttf",\n  "font/otf",\n  "font/woff",\n  "font/woff2"\n];\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = path/* path.extname */.E.extname(url);\n  const name = path/* path.basename */.E.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, " ");\n  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens) {\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = false;\n      break;\n    }\n  }\n  let fontFamilyName = nameTokens.join(" ");\n  if (!valid) {\n    fontFamilyName = `"${fontFamilyName.replace(/[\\\\"]/g, "\\\\$&")}"`;\n  }\n  return fontFamilyName;\n}\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&\'()\\*\\+,;=\\-._~]*$/;\nfunction encodeURIWhenNeeded(uri) {\n  if (validURICharactersRegex.test(uri)) {\n    return uri;\n  }\n  return encodeURI(uri);\n}\nconst loadWebFont = {\n  extension: {\n    type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority.Low */.Q.Low\n  },\n  name: "loadWebFont",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = adapter/* DOMAdapter.get */.z.get().getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      Cache/* Cache.set */.C.set(`${name}-and-url`, {\n        url,\n        fontFaces\n      });\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    (0,warn/* warn */.Z)("[loadWebFont] FontFace API is not supported. Skipping loading font");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => {\n      Cache/* Cache.remove */.C.remove(t.family);\n      adapter/* DOMAdapter.get */.z.get().getFontFaceSet().delete(t);\n    });\n  }\n};\n\n\n//# sourceMappingURL=loadWebFont.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(8360);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs + 15 modules\nvar GraphicsContext = __webpack_require__(5986);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/resolver/Resolver.mjs + 1 modules\nvar Resolver = __webpack_require__(8783);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs\n\n\n"use strict";\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = Resolver/* Resolver.RETINA_PREFIX */.H.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\n\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs\n\n\n\n\n"use strict";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  source._sourceOrigin = url;\n  const texture = new Texture/* Texture */.x({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache/* Cache.has */.C.has(url)) {\n      Cache/* Cache.remove */.C.remove(url);\n    }\n  };\n  texture.source.once("destroy", () => {\n    if (loader.promiseCache[url]) {\n      (0,warn/* warn */.Z)("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");\n      unload();\n    }\n  });\n  texture.once("destroy", () => {\n    if (!source.destroyed) {\n      (0,warn/* warn */.Z)("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");\n      unload();\n    }\n  });\n  return texture;\n}\n\n\n//# sourceMappingURL=createTexture.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validSVGExtension = ".svg";\nconst validSVGMIME = "image/svg+xml";\nconst loadSvg = {\n  extension: {\n    type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority.Low */.Q.Low,\n    name: "loadSVG"\n  },\n  name: "loadSVG",\n  config: {\n    crossOrigin: "anonymous",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await adapter/* DOMAdapter.get */.z.get().fetch(url);\n  const blob = await response.blob();\n  const blobUrl = URL.createObjectURL(blob);\n  const image = new Image();\n  image.src = blobUrl;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  URL.revokeObjectURL(blobUrl);\n  const canvas = document.createElement("canvas");\n  const context = canvas.getContext("2d");\n  const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  canvas.width = width * resolution;\n  canvas.height = height * resolution;\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n  const base = new ImageSource/* ImageSource */.c({\n    resource: canvas,\n    alphaMode: "premultiply-alpha-on-upload",\n    resolution,\n    ...rest\n  });\n  return createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await adapter/* DOMAdapter.get */.z.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext/* GraphicsContext */.g();\n  context.svg(svgSource);\n  return context;\n}\n\n\n//# sourceMappingURL=loadSVG.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs\nconst WORKER_CODE = "(function () {\\n    \'use strict\';\\n\\n    const WHITE_PNG = \\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\"function\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: \'application/javascript\' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\n\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs\nconst loadImageBitmap_worker_WORKER_CODE = "(function () {\\n    \'use strict\';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\"premultiplied-alpha\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\"none\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n";\nlet loadImageBitmap_worker_WORKER_URL = null;\nclass loadImageBitmap_worker_WorkerInstance\n{\n    constructor()\n    {\n        if (!loadImageBitmap_worker_WORKER_URL)\n        {\n            loadImageBitmap_worker_WORKER_URL = URL.createObjectURL(new Blob([loadImageBitmap_worker_WORKER_CODE], { type: \'application/javascript\' }));\n        }\n        this.worker = new Worker(loadImageBitmap_worker_WORKER_URL);\n    }\n}\nloadImageBitmap_worker_WorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (loadImageBitmap_worker_WORKER_URL)\n    {\n        URL.revokeObjectURL(loadImageBitmap_worker_WORKER_URL);\n        loadImageBitmap_worker_WORKER_URL = null;\n    }\n};\n\n\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs\n\n\n\n"use strict";\nlet UUID = 0;\nlet MAX_WORKERS;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this._workerPool = [];\n    this._queue = [];\n    this._resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const { worker } = new WorkerInstance();\n      worker.addEventListener("message", (event) => {\n        worker.terminate();\n        WorkerInstance.revokeObjectURL();\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src, asset) {\n    return this._run("loadImageBitmap", [src, asset?.data?.alphaMode]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  _getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this._workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      this._createdWorkers++;\n      worker = new loadImageBitmap_worker_WorkerInstance().worker;\n      worker.addEventListener("message", (event) => {\n        this._complete(event.data);\n        this._returnWorker(event.target);\n        this._next();\n      });\n    }\n    return worker;\n  }\n  _returnWorker(worker) {\n    this._workerPool.push(worker);\n  }\n  _complete(data) {\n    if (data.error !== void 0) {\n      this._resolveHash[data.uuid].reject(data.error);\n    } else {\n      this._resolveHash[data.uuid].resolve(data.data);\n    }\n    this._resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({ id, arguments: args, resolve, reject });\n    });\n    this._next();\n    return promise;\n  }\n  _next() {\n    if (!this._queue.length)\n      return;\n    const worker = this._getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this._queue.pop();\n    const id = toDo.id;\n    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\n\n//# sourceMappingURL=WorkerManager.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];\nconst validImageMIMEs = [\n  "image/jpeg",\n  "image/png",\n  "image/webp",\n  "image/avif"\n];\nasync function loadImageBitmap(url, asset) {\n  const response = await adapter/* DOMAdapter.get */.z.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  return asset?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n}\nconst loadTextures = {\n  name: "loadTextures",\n  extension: {\n    type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority.High */.Q.High,\n    name: "loadTextures"\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: "anonymous"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url, asset);\n      } else {\n        src = await loadImageBitmap(url, asset);\n      }\n    } else {\n      src = await new Promise((resolve) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new ImageSource/* ImageSource */.c({\n      resource: src,\n      alphaMode: "premultiply-alpha-on-upload",\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\n\n//# sourceMappingURL=loadTextures.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs\nvar VideoSource = __webpack_require__(4625);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs\nvar detectVideoAlphaMode = __webpack_require__(6886);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith("data:")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener("canplaythrough", loaded);\n    element.addEventListener("error", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener("canplaythrough", loaded);\n      element.removeEventListener("error", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith("data:")) {\n    return "";\n  }\n  loc = loc || globalThis.location;\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return "anonymous";\n  }\n  return "";\n}\nconst loadVideoTextures = {\n  name: "loadVideo",\n  extension: {\n    type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n    name: "loadVideo"\n  },\n  test(url) {\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource/* VideoSource.defaultOptions */.L.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await (0,detectVideoAlphaMode/* detectVideoAlphaMode */.D)(),\n      ...asset.data\n    };\n    const videoElement = document.createElement("video");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? "auto" : void 0,\n      "webkit-playsinline": options.playsinline !== false ? "" : void 0,\n      playsinline: options.playsinline !== false ? "" : void 0,\n      muted: options.muted === true ? "" : void 0,\n      loop: options.loop === true ? "" : void 0,\n      autoplay: options.autoPlay !== false ? "" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement("source");\n    let mime;\n    if (url.startsWith("data:")) {\n      mime = url.slice(5, url.indexOf(";"));\n    } else if (!url.startsWith("blob:")) {\n      const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();\n      mime = VideoSource/* VideoSource.MIME_TYPES */.L.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource/* VideoSource */.L({ ...options, resource: videoElement });\n        videoElement.removeEventListener("canplay", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      videoElement.addEventListener("canplay", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\n\n//# sourceMappingURL=loadVideoTextures.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs\n\n\n\n\n"use strict";\nconst resolveTextureUrl = {\n  extension: {\n    type: Extensions/* ExtensionType.ResolveParser */.nw.ResolveParser,\n    name: "resolveTexture"\n  },\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(Resolver/* Resolver.RETINA_PREFIX.exec */.H.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n    format: value.split(".").pop(),\n    src: value\n  })\n};\n\n\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs\n\n\n\n\n"use strict";\nconst resolveJsonUrl = {\n  extension: {\n    type: Extensions/* ExtensionType.ResolveParser */.nw.ResolveParser,\n    priority: -2,\n    name: "resolveJson"\n  },\n  test: (value) => Resolver/* Resolver.RETINA_PREFIX.test */.H.RETINA_PREFIX.test(value) && value.endsWith(".json"),\n  parse: resolveTextureUrl.parse\n};\n\n\n//# sourceMappingURL=resolveJsonUrl.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/Assets.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver/* Resolver */.H();\n    this.loader = new Loader();\n    this.cache = Cache/* Cache */.C;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      (0,warn/* warn */.Z)("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === "string") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Simple\n   * Assets.add({alias: \'bunnyBooBoo\', src: \'bunny.png\'});\n   * const bunny = await Assets.load(\'bunnyBooBoo\');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: [\'burger\', \'chicken\'], src: \'bunny.png\'});\n   *\n   * const bunny = await Assets.load(\'burger\');\n   * const bunny2 = await Assets.load(\'chicken\');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: \'bunnyBooBooSmooth\',\n   *     src: \'bunny{png,webp}\',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: \'bunnyBooBoo\', src: \'bunny{png,webp}\'});\n   *\n   * Assets.add({\n   *     alias: \'bunnyBooBoo\',\n   *     src: [\n   *         \'bunny.png\',\n   *         \'bunny.webp\',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load(\'bunnyBooBoo\'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(urls);\n    const urlArray = (0,convertToList/* convertToList */.S)(urls).map((url) => {\n      if (typeof url !== "string") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.addBundle(\'animals\', [\n   *  { alias: \'bunny\', src: \'bunny.png\' },\n   *  { alias: \'chicken\', src: \'chicken.png\' },\n   *  { alias: \'thumper\', src: \'thumper.png\' },\n   * ]);\n   * // or\n   * Assets.addBundle(\'animals\', {\n   *     bunny: \'bunny.png\',\n   *     chicken: \'chicken.png\',\n   *     thumper: \'thumper.png\',\n   * });\n   *\n   * const assets = await Assets.loadBundle(\'animals\');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: \'load-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'background\',\n   *                     src: \'sunset.png\',\n   *                 },\n   *                 {\n   *                     alias: \'bar\',\n   *                     src: \'load-bar.{png,webp}\',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: \'game-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'character\',\n   *                     src: \'robot.png\',\n   *                 },\n   *                 {\n   *                     alias: \'enemy\',\n   *                     src: \'bad-guy.png\',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle(\'load-screen\');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle(\'game-screen\');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === "string") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your initial load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.backgroundLoad(\'bunny.png\');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle(\'bunny.png\'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === "string") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: \'load-screen\',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle(\'load-screen\');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle(\'load-screen\'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === "string") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === "string") {\n      return Cache/* Cache.get */.C.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache/* Cache.get */.C.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache/* Cache.set */.C.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it\'s up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won\'t break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load(\'http://some.url.com/image.png\'); // => returns a texture\n   *\n   * await Assets.unload(\'http://some.url.com/image.png\')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload([\'thumper\', \'chicko\']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = (0,convertToList/* convertToList */.S)(urls).map((url) => typeof url !== "string" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.addBundle({\n   *     \'thumper\': \'http://some.url.com/thumper.png\',\n   * })\n   *\n   * const assets = await Assets.loadBundle(\'thumper\');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle(\'thumper\');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = (0,convertToList/* convertToList */.S)(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache/* Cache.remove */.C.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nExtensions/* extensions.handleByList */.Rw.handleByList(Extensions/* ExtensionType.LoadParser */.nw.LoadParser, Assets.loader.parsers).handleByList(Extensions/* ExtensionType.ResolveParser */.nw.ResolveParser, Assets.resolver.parsers).handleByList(Extensions/* ExtensionType.CacheParser */.nw.CacheParser, Assets.cache.parsers).handleByList(Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser, Assets.detections);\nExtensions/* extensions.add */.Rw.add(\n  cacheTextureArray,\n  detectDefaults,\n  detectAvif,\n  detectWebp,\n  detectMp4,\n  detectOgv,\n  detectWebm,\n  loadJson,\n  loadTxt,\n  loadWebFont,\n  loadSvg,\n  loadTextures,\n  loadVideoTextures,\n  loadBitmapFont,\n  bitmapFontCachePlugin,\n  resolveTextureUrl,\n  resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n  resolver: Extensions/* ExtensionType.ResolveParser */.nw.ResolveParser,\n  cache: Extensions/* ExtensionType.CacheParser */.nw.CacheParser,\n  detection: Extensions/* ExtensionType.DetectionParser */.nw.DetectionParser\n};\nExtensions/* extensions.handle */.Rw.handle(Extensions/* ExtensionType.Asset */.nw.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => Extensions/* extensions.add */.Rw.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it\'s own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => Extensions/* extensions.remove */.Rw.remove(ref[key]));\n});\n\n\n//# sourceMappingURL=Assets.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 1 modules\nvar TextureSource = __webpack_require__(608);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4762);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nvar Graphics = __webpack_require__(8401);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(7259);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs\nvar ObservablePoint = __webpack_require__(5446);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/view/ViewContainer.mjs\nvar ViewContainer = __webpack_require__(1372);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text/AbstractText.mjs\n\n\n\n\n"use strict";\nclass AbstractText extends ViewContainer/* ViewContainer */.$ {\n  constructor(options, styleClass) {\n    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n    super({\n      ...rest\n    });\n    this.batched = true;\n    this._resolution = null;\n    this._autoResolution = true;\n    this._didTextUpdate = true;\n    this._styleClass = styleClass;\n    this.text = text ?? "";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint/* ObservablePoint */.A(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text\'s origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text\'s origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text\'s origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from \'pixi.js\';\n   *\n   * const text = new Text(\'hello world\');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** Set the copy for the text object. To split a line you can use \'\\n\'. */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value)\n      return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   * @default 1\n   */\n  set resolution(value) {\n    this._autoResolution = value === null;\n    this._resolution = value;\n    this.onViewUpdate();\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */\n  set style(style) {\n    style = style || {};\n    this._style?.off("update", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on("update", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The local bounds of the Text.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === "object") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this.bounds.width);\n    height !== void 0 && this._setHeight(height, this.bounds.height);\n  }\n  /**\n   * Adds the bounds of this text to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(\n      _bounds.minX,\n      _bounds.minY,\n      _bounds.maxX,\n      _bounds.maxY\n    );\n  }\n  /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.width;\n    const height = this.bounds.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    this._boundsDirty = true;\n    if (!this.didViewUpdate)\n      this._didTextUpdate = true;\n    super.onViewUpdate();\n  }\n  _getKey() {\n    return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === "boolean" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === "string" || args[1]) {\n    (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, `use new ${name}({ text: "hi!", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\n\n\n//# sourceMappingURL=AbstractText.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(6858);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(2624);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text/Text.mjs\n\n\n\n\n"use strict";\nclass Text extends AbstractText {\n  constructor(...args) {\n    const options = ensureOptions(args, "Text");\n    super(options, TextStyle/* TextStyle */.p);\n    this.renderPipeId = "text";\n  }\n  _updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const canvasMeasurement = CanvasTextMetrics/* CanvasTextMetrics.measureText */.c.measureText(\n      this._text,\n      this._style\n    );\n    const { width, height } = canvasMeasurement;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\n\n//# sourceMappingURL=Text.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(3806);\n// EXTERNAL MODULE: ../node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(1106);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions.add */.Rw.add(browserExt, webworkerExt);\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./ts/model/realm.ts\n\r\nvar RealmTag;\r\n(function (RealmTag) {\r\n    RealmTag["NorthWest"] = "Kingdom of Northwest";\r\n    RealmTag["SouthEast"] = "Kingdom of Southeast";\r\n})(RealmTag || (RealmTag = {}));\r\nclass Realm {\r\n    constructor(tag) {\r\n        this.tag = tag;\r\n        this.fiefs = [];\r\n        this.armies = [];\r\n        this.wars = [];\r\n    }\r\n    static get2LineName(tag) {\r\n        switch (tag) {\r\n            case RealmTag.NorthWest:\r\n                return "Kingdom of\\nNorthwest";\r\n            case RealmTag.SouthEast:\r\n                return "Kingdom of\\nSoutheast";\r\n            default:\r\n                return "Kingdom\\nUNKNOWN";\r\n        }\r\n    }\r\n    static getName(tag) {\r\n        switch (tag) {\r\n            case RealmTag.NorthWest:\r\n                return "Kingdom of Northwest";\r\n            case RealmTag.SouthEast:\r\n                return "Kingdom of Southeast";\r\n            default:\r\n                return "Unknown kingdom";\r\n        }\r\n    }\r\n    static getRealmColor(tag) {\r\n        switch (tag) {\r\n            case RealmTag.NorthWest:\r\n                return PALETTE.SKYBLUE;\r\n            case RealmTag.SouthEast:\r\n                return PALETTE.RED;\r\n            default:\r\n                return PALETTE.GRAY;\r\n        }\r\n    }\r\n    static getRealmPalette(tag) {\r\n        const NW_COLORS = [\r\n            PALETTE.CLOUDBLUE,\r\n            PALETTE.SKYBLUE,\r\n            PALETTE.SEABLUE,\r\n            PALETTE.NIGHTBLUE,\r\n        ];\r\n        const SE_COLORS = [\r\n            PALETTE.RED,\r\n            PALETTE.MEAT,\r\n            PALETTE.ORANGE,\r\n            PALETTE.BROWN,\r\n            PALETTE.DARKBROWN,\r\n        ];\r\n        switch (tag) {\r\n            case RealmTag.NorthWest:\r\n                return NW_COLORS;\r\n            case RealmTag.SouthEast:\r\n                return SE_COLORS;\r\n            default:\r\n                return [PALETTE.WHITE];\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/mechanisms/logger.ts\n\r\nclass Logger {\r\n    constructor() {\r\n        this.captures = [];\r\n        this.armies = [];\r\n    }\r\n    logArmyCreation(army) {\r\n        this.armies.push([\r\n            `On day ${army.world.getDays()} `,\r\n            { msg: army.home.owner, color: Realm.getRealmColor(army.home.owner) },\r\n            " hired an army led by ",\r\n            this.getAgentNameData(army),\r\n        ]);\r\n    }\r\n    logArmyDecisionCapture(army, location) {\r\n        this.armies.push([\r\n            `On day ${army.world.getDays()} army of `,\r\n            { msg: army.home.owner, color: Realm.getRealmColor(army.home.owner) },\r\n            " led by ",\r\n            this.getAgentNameData(army),\r\n            "\\n",\r\n            `having ${army.power} power decided to capture `,\r\n            { msg: location.name, color: location.color },\r\n            " of ",\r\n            { msg: location.owner, color: Realm.getRealmColor(location.owner) },\r\n        ]);\r\n    }\r\n    logArmyDecisionRest(army) {\r\n        this.armies.push([\r\n            `On day ${army.world.getDays()} army of `,\r\n            { msg: army.home.owner, color: Realm.getRealmColor(army.home.owner) },\r\n            " led by ",\r\n            this.getAgentNameData(army),\r\n            "\\n",\r\n            `having ${army.power} power decided to return home`,\r\n        ]);\r\n    }\r\n    logLocationCapture(location, army) {\r\n        this.captures.push([\r\n            { msg: location.name, color: location.color },\r\n            " of ",\r\n            { msg: location.owner, color: Realm.getRealmColor(location.owner) },\r\n            " captured by ",\r\n            { msg: army.home.owner, color: Realm.getRealmColor(army.home.owner) },\r\n            ` at tick ${army.world.tick}`,\r\n        ]);\r\n        this.armies.push([\r\n            `On day ${army.world.getDays()} army of `,\r\n            { msg: army.home.owner, color: Realm.getRealmColor(army.home.owner) },\r\n            " led by ",\r\n            this.getAgentNameData(army),\r\n            "\\n",\r\n            "captured ",\r\n            { msg: location.name, color: location.color },\r\n            " of ",\r\n            { msg: location.owner, color: Realm.getRealmColor(location.owner) },\r\n            ` and lost ${location.defense} power`,\r\n        ]);\r\n    }\r\n    logArmyRest(army) {\r\n        this.armies.push([\r\n            `On day ${army.world.getDays()} army of `,\r\n            { msg: army.home.owner, color: Realm.getRealmColor(army.home.owner) },\r\n            " led by ",\r\n            this.getAgentNameData(army),\r\n            "\\n",\r\n            `finished resting and has ${army.power} power `,\r\n        ]);\r\n    }\r\n    getAgentNameData(agent) {\r\n        return { msg: agent.info.name, color: agent.info.appearance.tint };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/globals.ts\n\r\n\r\nconst // canvas: 768x576 (16 tiles * 48px x 12 tiles * 48px),\r\n// outer 4px border is css\r\nSRC_SIZE = 16, // Each tile is 16x16 pixels\r\nglobals_SCALE = 3, //3 // x3 scaling means each tile is 48x48 px\r\nSTEP_SIZE = SRC_SIZE * globals_SCALE, \r\n// 48px tiles with 3px border grid between them could use\r\n// width - 14 tiles: 768 = 15 tiles * 51px + 3px (or 13 tiles with 25px offsets)\r\n// height - 11 tiles: 576 = 11 tiles * 51px + 3px + 12px (6px offsets or 10 tiles with 31px offsets)\r\nFULL_WIDTH = 48 / globals_SCALE, //16, // Tiles\r\nVIEW_WIDTH = 36 / globals_SCALE, //12, // Tiles\r\nVIEW_HEIGHT = 36 / globals_SCALE, //12, // Tiles\r\nglobals_SPACED_STEP = (SRC_SIZE + 1) * globals_SCALE, WAIT_DURATION = 10, TURN_DURATION = 10; // \'ticks\', abstract atomic units of time\r\n// Workaround for missing vsc/ts quick fix (code action) to declare missing properties on object literals\r\n// interface LOG_SETTINGS {\r\n//     npcActions: boolean;\r\n//     logTime: boolean;\r\n//     heroMovement: boolean,\r\n// }\r\nconst LOG_SETTINGS /*: LOG_SETTINGS */ = {\r\n    logTime: false,\r\n    heroMovement: false,\r\n    npcActions: false,\r\n    npcTravel: false,\r\n    adjacent: false,\r\n};\r\nconst PALETTE = {\r\n    // http://androidarts.com/palette/16pal.htm\r\n    MEAT: 0xe06f8b,\r\n    DARKBROWN: 0x493c2b,\r\n    BROWN: 0xa46422,\r\n    ORANGE: 0xeb8931,\r\n    YELLOW: 0xf7e26b,\r\n    DARKGREEN: 0x2f484e,\r\n    GREEN: 0x44891a,\r\n    SLIMEGREEN: 0xa3ce27,\r\n    NIGHTBLUE: 0x1b2632,\r\n    SEABLUE: 0x005784,\r\n    SKYBLUE: 0x31a2f2,\r\n    CLOUDBLUE: 0xb2dcef,\r\n    GRAY: 0x9d9d9d,\r\n    RED: 0xbe2633,\r\n    WHITE: 0xffffff,\r\n    VOID: 0x000000,\r\n};\r\nconst fontStyleLeft = {\r\n    fontFamily: "Silkscreen",\r\n    fontSize: 16,\r\n    fill: PALETTE.GRAY,\r\n    align: "left",\r\n};\r\nconst fontStyleCenter = {\r\n    fontFamily: "Silkscreen",\r\n    fontSize: 16,\r\n    fill: PALETTE.GRAY,\r\n    align: "center",\r\n};\r\nconst fontStyleRight = {\r\n    fontFamily: "Silkscreen",\r\n    fontSize: 16,\r\n    fill: PALETTE.GRAY,\r\n    align: "right",\r\n};\r\nconst RESOURCE_TYPES = [\r\n    "Linen",\r\n    "Leather",\r\n    "Iron",\r\n    "Bronze",\r\n    "Stone",\r\n    "Wood",\r\n    "Grain",\r\n    "Fish",\r\n];\r\nconst RES_TILES = {\r\n    // [Resource.AMBER]: { type: Resource.AMBER, id: 0, color: PALETTE.ORANGE },\r\n    // [Resource.QUARTZ]: { type: Resource.QUARTZ, id: 1, color: PALETTE.SEABLUE },\r\n    Linen: { type: "Linen", id: 2, color: PALETTE.GRAY },\r\n    Leather: { type: "Leather", id: 3, color: PALETTE.BROWN },\r\n    Iron: { type: "Iron", id: 4, color: PALETTE.GRAY },\r\n    Bronze: { type: "Bronze", id: 4, color: PALETTE.BROWN },\r\n    Stone: { type: "Stone", id: 6, color: PALETTE.GRAY },\r\n    Wood: { type: "Wood", id: 7, color: PALETTE.BROWN },\r\n    Grain: { type: "Grain", id: 8, color: PALETTE.ORANGE },\r\n    Fish: { type: "Fish", id: 9, color: PALETTE.SEABLUE },\r\n};\r\n// Loading tilesets\r\nlet globals_battleset;\r\nlet tileset;\r\nlet boardset;\r\nlet resourceset;\r\nfunction initTilesets() {\r\n    globals_battleset = getBattleIcons();\r\n    tileset = getTiles();\r\n    boardset = getBoardgameIcons();\r\n    resourceset = getResourceIcons();\r\n}\r\nconst logger = new Logger();\r\nconst EventBus = new eventemitter3/* default */.Z();\r\nfunction getTilesetByID(tilesetID) {\r\n    switch (tilesetID) {\r\n        case 0:\r\n            return getTiles();\r\n        default:\r\n            return getTiles();\r\n    }\r\n}\r\nfunction getTexture(tileID) {\r\n    return tileset[tileID];\r\n}\r\n// Load main tileset\r\nfunction getTiles() {\r\n    const base = Assets.get("tileset_clear");\r\n    const offsetX = 0;\r\n    const offsetY = 0;\r\n    const spacingX = 0;\r\n    const spacingY = 0;\r\n    const TILES_TOTAL = 60;\r\n    const tileTexs = [];\r\n    for (let idx = 0; idx < TILES_TOTAL; idx++) {\r\n        const SET_WIDTH = 11;\r\n        const x = offsetX + (spacingX + 16) * (idx % SET_WIDTH);\r\n        const y = offsetY + (spacingY + 16) * Math.floor(idx / SET_WIDTH);\r\n        tileTexs.push(new Texture/* Texture */.x({\r\n            source: base,\r\n            frame: new Rectangle/* Rectangle */.A(x, y, 16, 16),\r\n        }));\r\n    }\r\n    return tileTexs;\r\n}\r\nfunction getResourceIcons() {\r\n    const base = Assets.get("resourceset");\r\n    const tileTexs = [];\r\n    for (let idx = 0; idx < 10; idx++) {\r\n        const SET_WIDTH = 5;\r\n        const x = (idx % SET_WIDTH) * 16;\r\n        const y = Math.floor(idx / SET_WIDTH) * 16;\r\n        tileTexs.push(new Texture/* Texture */.x({\r\n            source: base,\r\n            frame: new Rectangle/* Rectangle */.A(x, y, 16, 16),\r\n        }));\r\n    }\r\n    return tileTexs;\r\n}\r\n// Load battle icons tileset\r\nfunction getBattleIcons() {\r\n    const base = Assets.get("battleset");\r\n    const tileTexs = [];\r\n    for (let idx = 0; idx < 8; idx++) {\r\n        const x = idx * 18;\r\n        tileTexs.push(new Texture/* Texture */.x({\r\n            source: base,\r\n            frame: new Rectangle/* Rectangle */.A(x, 0, 18, 18),\r\n        }));\r\n    }\r\n    return tileTexs;\r\n}\r\nfunction getBoardgameIcons() {\r\n    const base = Assets.get("boardset");\r\n    const tileTexs = [];\r\n    for (let idx = 0; idx < 14; idx++) {\r\n        const SET_WIDTH = 7;\r\n        const x = (idx % SET_WIDTH) * 18;\r\n        const y = Math.floor(idx / SET_WIDTH) * 18;\r\n        tileTexs.push(new Texture/* Texture */.x({\r\n            source: base,\r\n            frame: new Rectangle/* Rectangle */.A(x, y, 18, 18),\r\n        }));\r\n    }\r\n    return tileTexs;\r\n}\r\nfunction getRandomIntFromRange(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}\r\nfunction getRandomInt(max) {\r\n    return Math.floor(Math.random() * Math.floor(max));\r\n}\r\nfunction getRandomElement(arr) {\r\n    return arr[getRandomInt(arr.length)];\r\n}\r\nfunction getRandomColor(palette) {\r\n    return getRandomElement(palette);\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/assets.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nconst manifest = {\r\n    bundles: [\r\n        {\r\n            name: "main",\r\n            assets: {\r\n                tileset_clear: "./assets/tileset_clear.png",\r\n                resourceset: "./assets/resourceset.png",\r\n                battleset: "./assets/battleset.png",\r\n                boardset: "./assets/boardset.png",\r\n                silkscreen: "./assets/fonts/silkscreen.ttf",\r\n            },\r\n        },\r\n        {\r\n            name: "audio",\r\n            assets: {\r\n            // sounds: "./assets/sounds/sounds.mp3",\r\n            // music: "./assets/music/music.mp3",\r\n            },\r\n        },\r\n    ],\r\n};\r\nfunction loadAssets() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        TextureSource/* TextureSource.defaultOptions.scaleMode */.p.defaultOptions.scaleMode = "nearest";\r\n        yield Assets.init({ manifest: manifest });\r\n        yield Assets.loadBundle("main");\r\n        yield Assets.loadBundle("audio");\r\n        initTilesets();\r\n        console.log("Assets: loading finished", Assets.cache);\r\n    });\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/configs/world_data.ts\nconst WORLD_WIDTH = 45;\r\nconst WORLD_HEIGHT = 36;\r\nconst WORLD_DATA = [\r\n    27, 26, 27, 27, 27, 27, 27, 26, 27, 28, 4, 6, 4, 6, 4, 6, 6, 11, 5, 5, 4, 5,\r\n    6, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 28, 22, 22, 22, 22, 22, 22,\r\n    27, 27, 10, 14, 14, 27, 14, 27, 27, 27, 27, 14, 27, 6, 6, 4, 5, 6, 5, 6, 5, 4,\r\n    5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 28, 22, 22, 22, 22, 22, 22,\r\n    27, 26, 21, 27, 27, 28, 14, 24, 14, 14, 14, 27, 28, 27, 28, 28, 28, 4, 11, 11,\r\n    11, 5, 11, 23, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 28, 22, 22, 22, 22, 22,\r\n    22, 22, 26, 27, 3, 3, 14, 28, 3, 3, 14, 6, 14, 27, 27, 27, 27, 27, 28, 0, 26,\r\n    0, 11, 5, 11, 5, 5, 11, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5, 28, 22, 22, 22, 22,\r\n    22, 22, 22, 27, 27, 27, 3, 3, 14, 3, 28, 4, 6, 6, 27, 14, 28, 14, 27, 27, 26,\r\n    26, 27, 26, 0, 11, 5, 11, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 28, 22, 22, 22,\r\n    22, 22, 22, 22, 27, 26, 27, 14, 3, 3, 3, 4, 26, 6, 26, 25, 27, 27, 28, 26, 27,\r\n    27, 27, 27, 26, 27, 0, 11, 11, 11, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 28, 22,\r\n    22, 22, 22, 22, 22, 22, 27, 4, 4, 0, 3, 14, 6, 4, 0, 26, 3, 3, 26, 27, 14, 27,\r\n    26, 27, 22, 26, 27, 27, 26, 5, 11, 11, 11, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 4,\r\n    22, 22, 22, 22, 22, 22, 22, 4, 26, 4, 0, 3, 3, 6, 0, 6, 3, 3, 4, 11, 14, 27,\r\n    14, 6, 27, 27, 22, 27, 27, 26, 14, 0, 11, 11, 11, 11, 5, 5, 5, 5, 5, 4, 5, 5,\r\n    28, 22, 22, 22, 22, 22, 22, 22, 4, 4, 6, 0, 0, 3, 0, 0, 3, 3, 11, 5, 26, 4,\r\n    14, 4, 6, 14, 27, 22, 26, 27, 27, 14, 11, 11, 0, 11, 11, 5, 5, 4, 5, 5, 5, 5,\r\n    5, 28, 22, 22, 22, 22, 22, 22, 22, 4, 6, 6, 26, 0, 3, 0, 0, 3, 6, 11, 5, 6, 6,\r\n    4, 6, 4, 14, 14, 14, 22, 26, 26, 14, 26, 0, 11, 11, 11, 5, 5, 5, 4, 5, 5, 5,\r\n    4, 28, 22, 22, 22, 22, 22, 22, 22, 6, 4, 6, 29, 26, 3, 3, 3, 3, 5, 5, 6, 5, 6,\r\n    5, 6, 6, 14, 4, 6, 11, 22, 28, 26, 0, 0, 11, 0, 11, 11, 11, 5, 5, 5, 4, 5, 5,\r\n    28, 22, 22, 22, 22, 22, 22, 22, 6, 28, 28, 28, 28, 0, 10, 3, 3, 0, 4, 5, 4, 4,\r\n    6, 4, 24, 6, 5, 11, 5, 32, 22, 28, 0, 0, 0, 0, 0, 11, 11, 11, 11, 5, 5, 11,\r\n    11, 28, 22, 22, 22, 22, 22, 22, 22, 28, 22, 22, 28, 28, 7, 19, 9, 3, 0, 0, 37,\r\n    37, 37, 4, 0, 3, 3, 3, 3, 3, 3, 30, 3, 3, 3, 3, 3, 3, 0, 11, 11, 11, 11, 11,\r\n    11, 11, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 28, 28, 3, 3, 3, 3, 0,\r\n    37, 37, 37, 29, 0, 3, 3, 5, 5, 11, 22, 22, 3, 5, 28, 0, 28, 3, 3, 0, 0, 0, 0,\r\n    11, 11, 11, 28, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 28, 28, 0,\r\n    3, 3, 3, 3, 3, 3, 3, 3, 14, 4, 4, 11, 22, 22, 3, 3, 4, 6, 4, 4, 3, 3, 0, 6, 0,\r\n    0, 0, 11, 11, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 28, 0,\r\n    37, 37, 37, 3, 39, 39, 39, 0, 0, 6, 5, 11, 22, 22, 28, 3, 3, 18, 4, 6, 4, 3,\r\n    6, 0, 11, 6, 6, 0, 11, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n    28, 4, 37, 37, 37, 3, 39, 39, 39, 0, 4, 6, 11, 22, 22, 22, 28, 14, 3, 3, 6, 6,\r\n    6, 3, 6, 6, 11, 11, 0, 6, 0, 28, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n    22, 28, 6, 4, 6, 5, 4, 3, 6, 5, 6, 4, 6, 4, 11, 22, 22, 22, 6, 6, 4, 6, 4, 4,\r\n    4, 3, 6, 0, 6, 6, 6, 11, 6, 11, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n    22, 28, 28, 6, 0, 6, 6, 3, 6, 6, 6, 6, 6, 28, 22, 22, 22, 22, 6, 6, 6, 6, 6,\r\n    3, 3, 3, 11, 4, 5, 5, 5, 6, 28, 6, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n    22, 22, 28, 28, 6, 4, 6, 3, 3, 6, 4, 6, 6, 22, 22, 22, 28, 22, 22, 6, 4, 6, 6,\r\n    3, 4, 6, 5, 5, 11, 6, 6, 6, 4, 28, 4, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n    22, 22, 22, 28, 0, 6, 6, 11, 3, 3, 6, 4, 6, 22, 22, 28, 10, 22, 22, 5, 11, 11,\r\n    5, 3, 6, 11, 11, 6, 6, 11, 6, 11, 28, 4, 4, 6, 28, 22, 22, 22, 22, 22, 22, 22,\r\n    22, 22, 22, 22, 22, 28, 28, 11, 11, 11, 3, 3, 6, 6, 22, 22, 26, 21, 14, 22,\r\n    11, 4, 6, 6, 3, 6, 6, 5, 6, 5, 5, 6, 5, 5, 6, 6, 28, 28, 28, 22, 22, 22, 22,\r\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 28, 28, 28, 0, 3, 3, 11, 22, 22, 11, 3,\r\n    11, 22, 0, 0, 0, 6, 3, 6, 6, 5, 4, 6, 11, 10, 11, 6, 11, 6, 0, 28, 28, 22, 22,\r\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 28, 28, 28, 3, 3, 31, 31,\r\n    3, 3, 3, 30, 3, 3, 3, 3, 3, 5, 0, 0, 0, 0, 7, 19, 9, 4, 6, 6, 6, 0, 28, 28,\r\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 28, 28, 28,\r\n    22, 22, 5, 4, 3, 22, 28, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 0, 0, 29, 6, 4, 0,\r\n    28, 28, 22, 22, 22, 22, 28, 28, 28, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n    28, 22, 22, 22, 0, 4, 3, 22, 28, 29, 11, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\r\n    3, 3, 0, 28, 28, 22, 22, 22, 28, 28, 11, 28, 28, 22, 22, 22, 22, 22, 22, 22,\r\n    22, 22, 22, 22, 22, 22, 28, 4, 3, 22, 22, 6, 6, 11, 3, 3, 0, 0, 0, 3, 3, 3, 3,\r\n    39, 39, 39, 3, 3, 28, 22, 22, 22, 28, 28, 11, 11, 11, 28, 28, 22, 28, 28, 28,\r\n    22, 22, 22, 22, 22, 22, 22, 28, 4, 5, 3, 22, 22, 4, 6, 11, 11, 3, 0, 0, 0, 4,\r\n    6, 0, 3, 39, 39, 39, 6, 3, 28, 22, 22, 22, 28, 28, 11, 6, 4, 6, 28, 28, 4, 6,\r\n    6, 28, 28, 22, 22, 22, 22, 22, 28, 11, 5, 3, 3, 22, 5, 5, 6, 6, 3, 3, 0, 18,\r\n    6, 4, 6, 3, 5, 5, 0, 6, 3, 28, 22, 22, 22, 28, 28, 11, 4, 6, 6, 6, 6, 6, 6, 6,\r\n    6, 28, 22, 22, 22, 22, 22, 5, 5, 5, 14, 3, 22, 22, 5, 5, 6, 6, 3, 3, 3, 5, 5,\r\n    3, 3, 4, 5, 6, 6, 3, 28, 28, 22, 22, 28, 28, 11, 22, 6, 4, 6, 6, 11, 3, 3, 6,\r\n    28, 22, 22, 22, 28, 28, 5, 4, 4, 26, 3, 22, 22, 22, 28, 5, 4, 4, 6, 3, 3, 3,\r\n    3, 5, 5, 11, 6, 6, 3, 3, 28, 4, 22, 28, 11, 11, 3, 3, 4, 3, 3, 3, 3, 28, 28,\r\n    22, 22, 22, 22, 28, 4, 5, 11, 5, 3, 3, 11, 22, 22, 22, 28, 6, 4, 4, 6, 5, 5,\r\n    3, 11, 11, 6, 4, 6, 10, 3, 3, 6, 22, 28, 28, 11, 11, 3, 3, 3, 28, 28, 28, 28,\r\n    22, 22, 22, 22, 28, 28, 4, 5, 14, 11, 3, 7, 8, 9, 22, 22, 22, 5, 6, 6, 5, 5,\r\n    6, 3, 4, 5, 6, 6, 4, 21, 4, 3, 6, 22, 22, 28, 28, 11, 11, 11, 28, 28, 22, 22,\r\n    22, 22, 22, 22, 22, 28, 4, 5, 5, 5, 4, 3, 3, 3, 0, 11, 22, 22, 22, 4, 6, 4, 3,\r\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 22, 22, 22, 28, 28, 28, 28, 28, 22, 22, 22,\r\n    22, 22, 22, 22, 28, 28, 5, 4, 4, 5, 11, 5, 0, 3, 3, 3, 31, 31, 31, 3, 3, 3, 3,\r\n    4, 5, 6, 11, 11, 6, 6, 6, 6, 4, 6, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\r\n    22, 22, 22, 22, 28, 5, 11, 11, 11, 5, 5, 4, 5, 5, 6, 6, 22, 22, 22, 6, 5, 5,\r\n    5, 6, 4, 5, 6, 5, 6, 4, 6, 4, 6, 6,\r\n];\r\n\n;// CONCATENATED MODULE: ./ts/mechanisms/controls.ts\n//Capture the keyboard arrow keys\r\nconst controls = {\r\n    left: keyboard("ArrowLeft"),\r\n    up: keyboard("ArrowUp"),\r\n    right: keyboard("ArrowRight"),\r\n    down: keyboard("ArrowDown"),\r\n    a: keyboard("a"),\r\n    w: keyboard("w"),\r\n    d: keyboard("d"),\r\n    s: keyboard("s"),\r\n    space: keyboard(" "),\r\n    enter: keyboard("Enter"),\r\n    esc: keyboard("Escape"),\r\n    tab: keyboard("Tab"),\r\n    ctrl: keyboard("Control"),\r\n    shift: keyboard("Shift"),\r\n    e: keyboard("e"),\r\n    f: keyboard("f"),\r\n    g: keyboard("g"),\r\n    i: keyboard("i"),\r\n    j: keyboard("j"),\r\n    l: keyboard("l"),\r\n    m: keyboard("m"),\r\n    q: keyboard("q"),\r\n    t: keyboard("t"),\r\n};\r\nfunction keyboard(value) {\r\n    const key = {\r\n        value: value,\r\n        isDown: false,\r\n        isUp: true,\r\n        press: undefined,\r\n        release: undefined,\r\n        downHandler: undefined,\r\n        upHandler: undefined,\r\n        unsubscribe: undefined,\r\n    };\r\n    //The `downHandler`\r\n    key.downHandler = (event) => {\r\n        if (event.key === key.value) {\r\n            if (key.isUp && key.press)\r\n                key.press();\r\n            key.isDown = true;\r\n            key.isUp = false;\r\n            event.preventDefault();\r\n        }\r\n    };\r\n    //The `upHandler`\r\n    key.upHandler = (event) => {\r\n        if (event.key === key.value) {\r\n            if (key.isDown && key.release)\r\n                key.release();\r\n            key.isDown = false;\r\n            key.isUp = true;\r\n            event.preventDefault();\r\n        }\r\n    };\r\n    //Attach event listeners\r\n    const downListener = key.downHandler.bind(key);\r\n    const upListener = key.upHandler.bind(key);\r\n    window.addEventListener("keydown", downListener, false);\r\n    window.addEventListener("keyup", upListener, false);\r\n    // Detach event listeners\r\n    key.unsubscribe = () => {\r\n        window.removeEventListener("keydown", downListener);\r\n        window.removeEventListener("keyup", upListener);\r\n    };\r\n    return key;\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/mechanisms/scene_manager.ts\n\r\nvar SceneEvents;\r\n(function (SceneEvents) {\r\n    SceneEvents["Close"] = "close_scene";\r\n    SceneEvents["Open"] = "open_scene";\r\n})(SceneEvents || (SceneEvents = {}));\r\nclass SceneManager {\r\n    constructor(renderContainer, controls) {\r\n        this.renderContainer = renderContainer;\r\n        this.controls = controls;\r\n        EventBus.on(SceneEvents.Close, () => this.closeScene());\r\n        EventBus.on(SceneEvents.Open, (scene) => this.openScene(scene));\r\n    }\r\n    setRoot(rootScene) {\r\n        this.renderContainer.addChild(rootScene);\r\n        this.root = rootScene;\r\n        this.currentScene = rootScene;\r\n    }\r\n    openScene(scene) {\r\n        this.currentScene.addChild(scene);\r\n        this.currentScene = scene;\r\n        scene.assignControls(this.controls);\r\n        console.log("Scene opened:", scene.name);\r\n    }\r\n    closeScene() {\r\n        if (this.currentScene !== this.root) {\r\n            const oldScene = this.currentScene;\r\n            this.currentScene = oldScene.parent;\r\n            this.currentScene.removeChild(oldScene);\r\n            this.currentScene.assignControls(this.controls);\r\n            console.log("Scene closed:", oldScene.name);\r\n        }\r\n        else {\r\n            console.warn("Root scene cannot be closed");\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/configs/tiles_data.ts\n\r\nvar TileId;\r\n(function (TileId) {\r\n    TileId[TileId["Empty"] = 0] = "Empty";\r\n    TileId[TileId["Road"] = 3] = "Road";\r\n    TileId[TileId["TreeDead"] = 4] = "TreeDead";\r\n    TileId[TileId["TreeDeciduous"] = 5] = "TreeDeciduous";\r\n    TileId[TileId["TreeConiferous"] = 6] = "TreeConiferous";\r\n    TileId[TileId["CityTowerLeft"] = 7] = "CityTowerLeft";\r\n    TileId[TileId["TownGate"] = 8] = "TownGate";\r\n    TileId[TileId["CityTowerRight"] = 9] = "CityTowerRight";\r\n    TileId[TileId["TowerTop"] = 10] = "TowerTop";\r\n    TileId[TileId["Grass"] = 11] = "Grass";\r\n    TileId[TileId["HillsA"] = 14] = "HillsA";\r\n    TileId[TileId["Fort"] = 18] = "Fort";\r\n    TileId[TileId["CityGate"] = 19] = "CityGate";\r\n    TileId[TileId["TowerBase"] = 21] = "TowerBase";\r\n    TileId[TileId["Water"] = 22] = "Water";\r\n    TileId[TileId["Hut"] = 23] = "Hut";\r\n    TileId[TileId["Mine"] = 24] = "Mine";\r\n    TileId[TileId["Quarry"] = 25] = "Quarry";\r\n    TileId[TileId["HillsB"] = 26] = "HillsB";\r\n    TileId[TileId["MountainsA"] = 27] = "MountainsA";\r\n    TileId[TileId["Shore"] = 28] = "Shore";\r\n    TileId[TileId["House"] = 29] = "House";\r\n    TileId[TileId["WoodenBridge"] = 30] = "WoodenBridge";\r\n    TileId[TileId["StoneBridge"] = 31] = "StoneBridge";\r\n    TileId[TileId["HouseWaterWheel"] = 32] = "HouseWaterWheel";\r\n    TileId[TileId["Selection"] = 33] = "Selection";\r\n    TileId[TileId["Seeds"] = 37] = "Seeds";\r\n    TileId[TileId["Sprouts"] = 38] = "Sprouts";\r\n    TileId[TileId["FieldGrown"] = 39] = "FieldGrown";\r\n    TileId[TileId["MountainsB"] = 43] = "MountainsB";\r\n})(TileId || (TileId = {}));\r\nconst TILES_DATA = {\r\n    [TileId.Empty]: {\r\n        name: "Ground",\r\n        spriteId: 3,\r\n        tint: PALETTE.DARKGREEN,\r\n    },\r\n    [TileId.Road]: {\r\n        name: "Road",\r\n        spriteId: 3,\r\n        tint: PALETTE.DARKBROWN,\r\n    },\r\n    [TileId.TreeDead]: {\r\n        name: "Dead trees",\r\n        spriteId: 4,\r\n        tint: PALETTE.ORANGE,\r\n    },\r\n    [TileId.TreeDeciduous]: {\r\n        name: "Deciduous forest",\r\n        spriteId: 5,\r\n        tint: PALETTE.GREEN,\r\n    },\r\n    [TileId.TreeConiferous]: {\r\n        name: "Coniferous forest",\r\n        spriteId: 6,\r\n        tint: PALETTE.DARKGREEN,\r\n    },\r\n    [TileId.CityTowerLeft]: {\r\n        name: "City, western tower",\r\n        spriteId: 7,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.TownGate]: {\r\n        name: "Town gate",\r\n        spriteId: 8,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.CityTowerRight]: {\r\n        name: "City, eastern tower",\r\n        spriteId: 9,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.TowerTop]: {\r\n        name: "Tower top",\r\n        spriteId: 10,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.Grass]: {\r\n        name: "Grass field",\r\n        spriteId: 11,\r\n        tint: PALETTE.GREEN,\r\n    },\r\n    [TileId.HillsA]: {\r\n        name: "Hills",\r\n        spriteId: 14,\r\n        tint: PALETTE.DARKGREEN,\r\n    },\r\n    [TileId.HillsB]: {\r\n        name: "Hills",\r\n        spriteId: 26,\r\n        tint: PALETTE.DARKGREEN,\r\n    },\r\n    [TileId.Fort]: {\r\n        name: "Fort",\r\n        spriteId: 18,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.CityGate]: {\r\n        name: "City gate",\r\n        spriteId: 19,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.TowerBase]: {\r\n        name: "Tower ground floor",\r\n        spriteId: 21,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.Water]: {\r\n        name: "Water",\r\n        spriteId: 22,\r\n        tint: PALETTE.SEABLUE,\r\n    },\r\n    [TileId.Hut]: {\r\n        name: "Hut",\r\n        spriteId: 23,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.Mine]: {\r\n        name: "Mine",\r\n        spriteId: 24,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.Quarry]: {\r\n        name: "Quarry",\r\n        spriteId: 25,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.MountainsA]: {\r\n        name: "Mountains",\r\n        spriteId: 27,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.MountainsB]: {\r\n        name: "Mountains",\r\n        spriteId: 43,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.Shore]: {\r\n        name: "Shore",\r\n        spriteId: 28,\r\n        tint: PALETTE.ORANGE,\r\n    },\r\n    [TileId.House]: {\r\n        name: "House",\r\n        spriteId: 29,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.WoodenBridge]: {\r\n        name: "Wooden bridge",\r\n        spriteId: 30,\r\n        tint: PALETTE.DARKBROWN,\r\n    },\r\n    [TileId.StoneBridge]: {\r\n        name: "Stone bridge",\r\n        spriteId: 31,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.HouseWaterWheel]: {\r\n        name: "Sawmill",\r\n        spriteId: 32,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.Selection]: {\r\n        name: "Selection frame",\r\n        spriteId: 33,\r\n        tint: PALETTE.GRAY,\r\n    },\r\n    [TileId.Seeds]: {\r\n        name: "Grain field",\r\n        spriteId: 37,\r\n        tint: PALETTE.ORANGE,\r\n    },\r\n    [TileId.Sprouts]: {\r\n        name: "Grain field",\r\n        spriteId: 38,\r\n        tint: PALETTE.ORANGE,\r\n    },\r\n    [TileId.FieldGrown]: {\r\n        name: "Grain field",\r\n        spriteId: 39,\r\n        tint: PALETTE.ORANGE,\r\n    },\r\n};\r\n\n;// CONCATENATED MODULE: ./ts/model/context.ts\nvar Context;\r\n(function (Context) {\r\n    Context[Context["World"] = 0] = "World";\r\n    Context[Context["Battle"] = 1] = "Battle";\r\n    Context[Context["Location"] = 2] = "Location";\r\n    Context[Context["Dialogue"] = 3] = "Dialogue";\r\n    Context[Context["Message"] = 4] = "Message";\r\n    Context[Context["GameOver"] = 5] = "GameOver";\r\n})(Context || (Context = {}));\r\n\n;// CONCATENATED MODULE: ./ts/ui.ts\n\r\n\r\n\r\n\r\nconst LINE_HEIGHT = 20;\r\nconst LOCATION_NOT_IMPLEMENTED = "Location not\\nimplemented yet";\r\nconst LOCATION_HINT = "Space to enter\\n\\n";\r\nconst DEFAULT_HINT = "Arrows to move\\naround. Shift\\nto toggle sprint\\n\\n";\r\nconst INSTRUCTION_TEXT_DEFAULT = "Up/Down to select, Space to confirm, Esc to leave";\r\nfunction getVerticalCursor() {\r\n    const cursor = new PIXI.Sprite(battleset[6]);\r\n    cursor.scale.set(SCALE);\r\n    cursor.rotation = -Math.PI / 2;\r\n    return cursor;\r\n}\r\nfunction getEmptySlot() {\r\n    const slot = new PIXI.Sprite(battleset[5]);\r\n    slot.scale.set(SCALE);\r\n    return slot;\r\n}\r\nfunction getSelectionBorder() {\r\n    const border = new PIXI.Sprite(battleset[7]);\r\n    border.scale.set(SCALE);\r\n    return border;\r\n}\r\nclass UI extends Container/* Container */.W2 {\r\n    constructor(fullWidth, viewWidth, viewHeight) {\r\n        super();\r\n        const g = new Graphics/* Graphics */.T();\r\n        // UI panel background\r\n        g.rect(viewWidth * STEP_SIZE, 0, (fullWidth - viewWidth) * STEP_SIZE, viewHeight * STEP_SIZE);\r\n        g.fill(PALETTE.VOID);\r\n        // UI panel left border\r\n        g.rect(viewWidth * STEP_SIZE, 0, 4, viewHeight * STEP_SIZE);\r\n        g.fill(PALETTE.DARKGREEN);\r\n        this.addChild(g);\r\n        this.ticksText = new Text("DAY: 0", fontStyleLeft);\r\n        this.ticksText.position.set(STEP_SIZE * viewWidth + 8, 6);\r\n        this.addChild(this.ticksText);\r\n        this.goldText = new Text("MONEY: 0" /*${hero.inv.money}*/, fontStyleLeft);\r\n        this.goldText.position.set(STEP_SIZE * viewWidth + 8, STEP_SIZE);\r\n        this.addChild(this.goldText);\r\n        this.hintText = new Text(DEFAULT_HINT, fontStyleLeft);\r\n        this.hintText.position.set(STEP_SIZE * viewWidth + 8, STEP_SIZE * 3);\r\n        this.addChild(this.hintText);\r\n        this.statusText = new Text("", fontStyleLeft);\r\n        this.statusText.position.set(STEP_SIZE * viewWidth + 8, STEP_SIZE * 5 - 12);\r\n        this.addChild(this.statusText);\r\n        this.contextText = new Text("", fontStyleLeft);\r\n        this.contextText.position.set(STEP_SIZE * viewWidth + 8, STEP_SIZE * 6 - 12);\r\n        this.addChild(this.contextText);\r\n        this.extraHintText = new Text(" I: inventory\\nJ: journal\\n\\n", fontStyleLeft);\r\n        this.extraHintText.position.set(STEP_SIZE * viewWidth + 8, STEP_SIZE * 7);\r\n        this.addChild(this.extraHintText);\r\n        this.cellText = new Text("", fontStyleLeft);\r\n        this.cellText.position.set(STEP_SIZE * viewWidth + 8, STEP_SIZE * 10);\r\n        this.addChild(this.cellText);\r\n    }\r\n    updateInvTexts(inventory) {\r\n        this.goldText.text = "Money: " + inventory.money;\r\n    }\r\n    updateDay(day) {\r\n        this.ticksText.text = "DAY: " + day;\r\n    }\r\n    updateContextText(contexts) {\r\n        // console.log(\'updating context\', desc)\r\n        this.contextText.text = "";\r\n        if (contexts.length > 2) {\r\n            this.contextText.text = "Space to interact";\r\n        }\r\n        else if (contexts.length > 1) {\r\n            switch (contexts[1]) {\r\n                case Context.Dialogue:\r\n                    this.contextText.text = "Space to talk";\r\n                    break;\r\n                case Context.Location:\r\n                    this.contextText.text = "Space to enter";\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    updateStatusText(hero) {\r\n        if (hero.isSprinting) {\r\n            this.statusText.text = `Sprinting\\nStamina: ${hero.stamina.current}/${hero.stamina.max}\\n`;\r\n        }\r\n        else {\r\n            this.statusText.text = "";\r\n        }\r\n    }\r\n    prependHintText(hero, text) {\r\n        this.hintText.text =\r\n            (text ? `\\n${text}` : "") + this.getMountText(hero) + DEFAULT_HINT;\r\n    }\r\n    replaceHintText(text) {\r\n        this.hintText.text = text;\r\n    }\r\n    updateHint(contexts) {\r\n        this.hintText.text = "Arrows to move\\n\\nShift to toggle\\nsprinting";\r\n    }\r\n    getMountText(hero) {\r\n        if (hero.activeMount) {\r\n            return "M to dismount\\n\\n";\r\n        }\r\n        else if (hero.inv.mount) {\r\n            return "M to mount\\n\\n";\r\n        }\r\n        return "";\r\n    }\r\n    updateCellInfo(cell, hero) {\r\n        let tileType = "";\r\n        if (hero) {\r\n            const tile = hero.memorizedTiles.find((t) => t.pos.tx == cell.pos.tx && t.pos.ty == cell.pos.ty);\r\n            tileType = tile ? TILES_DATA[tile.typeId].name : "";\r\n        }\r\n        else {\r\n            tileType = TILES_DATA[cell.typeId].name;\r\n        }\r\n        this.cellText.text = `x: ${cell.pos.tx} y: ${cell.pos.ty}\\n${tileType}`;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/utils.ts\n\r\nvar Utils;\r\n(function (Utils) {\r\n    function arrangeInGrid(objects, parent, gap) {\r\n        const grid = new Container/* Container */.W2();\r\n        let xPos = 0;\r\n        let yPos = 0;\r\n        objects.forEach((obj) => {\r\n            grid.addChild(obj);\r\n            obj.position.set(xPos, yPos);\r\n            xPos += obj.width + gap;\r\n            if (xPos + obj.width >= parent.width) {\r\n                xPos = 0;\r\n                yPos += obj.height + gap;\r\n            }\r\n        });\r\n        return grid;\r\n    }\r\n    Utils.arrangeInGrid = arrangeInGrid;\r\n    function alignCenterHoriz(objects) {\r\n        const minY = Math.min(...objects.map((o) => o.y));\r\n        const maxHeight = Math.max(...objects.map((o) => o.height));\r\n        objects.forEach((o) => {\r\n            o.y = Math.round(minY + (maxHeight - o.height) / 2);\r\n        });\r\n    }\r\n    Utils.alignCenterHoriz = alignCenterHoriz;\r\n    function spaceHoriz(objects, spacing) {\r\n        let offsetX = objects[0].x;\r\n        for (const o of objects) {\r\n            o.x = offsetX;\r\n            offsetX += o.width + spacing;\r\n        }\r\n    }\r\n    Utils.spaceHoriz = spaceHoriz;\r\n    function alignCenterVert(objects) {\r\n        const minX = Math.min(...objects.map((o) => o.x));\r\n        const maxWidth = Math.max(...objects.map((o) => o.width));\r\n        objects.forEach((o) => {\r\n            o.x = Math.round(minX + (maxWidth - o.width) / 2);\r\n        });\r\n    }\r\n    Utils.alignCenterVert = alignCenterVert;\r\n    function spaceVert(objects, spacing) {\r\n        let offsetY = objects[0].y;\r\n        for (const o of objects) {\r\n            o.y = offsetY;\r\n            offsetY += o.height + spacing;\r\n        }\r\n    }\r\n    Utils.spaceVert = spaceVert;\r\n    function alignRight(objects) {\r\n        const rightmostX = Math.max(...objects.map((o) => o.x + o.width));\r\n        for (const o of objects) {\r\n            o.x = rightmostX - o.width;\r\n        }\r\n    }\r\n    Utils.alignRight = alignRight;\r\n    function alignLeft(objects) {\r\n        const leftmostX = Math.min(...objects.map((o) => o.x));\r\n        for (const o of objects) {\r\n            o.x = leftmostX;\r\n        }\r\n    }\r\n    Utils.alignLeft = alignLeft;\r\n    function centerHoriz(object, parent) {\r\n        object.x = (parent.width - object.width) / 2;\r\n    }\r\n    Utils.centerHoriz = centerHoriz;\r\n})(Utils || (Utils = {}));\r\n\n;// CONCATENATED MODULE: ./ts/views/components/scroll_list.ts\n\r\n\r\n\r\n/**\r\n * Doesn\'t add entries as children, rather controls their visibility\r\n * based on provided boundary positions.\r\n * Supports entries with different height within the same entry list.\r\n */\r\nclass ScrollList extends Container/* Container */.W2 {\r\n    constructor(entries, upperBoundY, lowerBoundY) {\r\n        super();\r\n        this.upperBoundY = upperBoundY;\r\n        this.lowerBoundY = lowerBoundY;\r\n        this.entries = entries;\r\n        this.arrowUp = this.getArrow();\r\n        this.arrowDown = this.getArrow();\r\n        this.arrowUp.angle = -90;\r\n        this.arrowDown.angle = -90;\r\n        this.arrowDown.scale.x = -this.arrowDown.scale.x;\r\n        this.arrowDown.y += STEP_SIZE;\r\n        this.addChild(this.arrowUp);\r\n        this.addChild(this.arrowDown);\r\n        this.entries.forEach((e) => this.updateEntryVisibility(e));\r\n        this.updateArrowsVisibility();\r\n    }\r\n    updateArrowsVisibility() {\r\n        if (this.entries.length > 0) {\r\n            this.arrowDown.visible = !this.entries[this.entries.length - 1].visible;\r\n            this.arrowUp.visible = !this.entries[0].visible;\r\n        }\r\n        else {\r\n            this.arrowDown.visible = false;\r\n            this.arrowUp.visible = false;\r\n        }\r\n    }\r\n    positionArrows(container) {\r\n        Utils.centerHoriz(this.arrowDown, container);\r\n        Utils.centerHoriz(this.arrowUp, container);\r\n        this.arrowUp.y = this.upperBoundY - this.arrowUp.height / 2;\r\n        this.arrowUp.x += this.arrowUp.width / 2;\r\n        this.arrowDown.y = this.lowerBoundY + this.arrowDown.height / 2;\r\n        this.arrowDown.x += this.arrowDown.width / 2;\r\n    }\r\n    getArrow() {\r\n        const sprite = new Sprite/* Sprite */.j(tileset[2]);\r\n        sprite.scale.set(globals_SCALE);\r\n        sprite.tint = PALETTE.ORANGE;\r\n        sprite.anchor.set(0.5);\r\n        sprite.x += sprite.width / 2;\r\n        sprite.y += sprite.height / 2;\r\n        return sprite;\r\n    }\r\n    // Scroll arrow up means entries go down\r\n    scrollUp() {\r\n        if (this.entries[0].position.y < this.upperBoundY) {\r\n            // How many pixels to scroll to have new entry fully visible\r\n            const topVisibleEntry = this.entries.find((e) => e.position.y == this.upperBoundY);\r\n            const prevEntry = this.entries[this.entries.indexOf(topVisibleEntry) - 1];\r\n            const pixelsToScroll = topVisibleEntry.position.y - prevEntry.position.y;\r\n            for (const entry of this.entries) {\r\n                entry.position.y += pixelsToScroll;\r\n                this.updateEntryVisibility(entry);\r\n            }\r\n        }\r\n        this.updateArrowsVisibility();\r\n    }\r\n    // Scroll arrow down means entries go up\r\n    scrollDown() {\r\n        const bottomEntry = this.entries[this.entries.length - 1];\r\n        if (bottomEntry.position.y + bottomEntry.height > this.lowerBoundY) {\r\n            // How many pixels to scroll to have new entry fully visible\r\n            const topEntry = this.entries.find((e) => e.position.y == this.upperBoundY);\r\n            const nextEntry = this.entries[this.entries.indexOf(topEntry) + 1];\r\n            const pixelsToScroll = nextEntry.position.y - topEntry.position.y;\r\n            for (const entry of this.entries) {\r\n                entry.position.y -= pixelsToScroll;\r\n                this.updateEntryVisibility(entry);\r\n            }\r\n        }\r\n        this.updateArrowsVisibility();\r\n    }\r\n    updateEntryVisibility(entry) {\r\n        entry.visible =\r\n            entry.position.y >= this.upperBoundY &&\r\n                entry.position.y + entry.height <= this.lowerBoundY;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/styled_text.ts\n\r\n\r\n\r\nclass StyledText extends Container/* Container */.W2 {\r\n    constructor(entry, style) {\r\n        super();\r\n        this.lineCount = 1;\r\n        this.load(entry, style);\r\n    }\r\n    load(entry, style) {\r\n        this.lineCount = 1;\r\n        this.caret = { x: 0, y: 0 };\r\n        let i = 0;\r\n        let lineContainer = new Container/* Container */.W2();\r\n        while (i < entry.length) {\r\n            const group = entry[i];\r\n            const text = new Text("", style);\r\n            lineContainer.addChild(text);\r\n            if (typeof group == "string") {\r\n                text.text = group;\r\n            }\r\n            else {\r\n                const groupStyle = Object.assign({}, style, { fill: group.color });\r\n                text.text = group.msg;\r\n                text.style = groupStyle;\r\n            }\r\n            text.position.x = this.caret.x;\r\n            lineContainer.y = this.caret.y;\r\n            this.caret.x += text.width;\r\n            if (text.text == "\\n" || i == entry.length - 1) {\r\n                this.caret.x = 0;\r\n                this.caret.y += LINE_HEIGHT;\r\n                this.lineCount++;\r\n                this.addChild(lineContainer);\r\n                // this.debugLine(lineContainer)\r\n                lineContainer = new Container/* Container */.W2();\r\n            }\r\n            i++;\r\n        }\r\n        for (const line of this.children) {\r\n            if (style.align == "center") {\r\n                line.position.x = (this.width - line.width) / 2;\r\n            }\r\n        }\r\n    }\r\n    debugLine(lineContainer) {\r\n        const bg = new Graphics/* Graphics */.T();\r\n        bg.beginFill(getRandomColor(Object.values(PALETTE)));\r\n        bg.drawRect(0, 0, lineContainer.width, lineContainer.height);\r\n        bg.endFill();\r\n        lineContainer.addChildAt(bg, 0);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/base_game_view.ts\n\r\n\r\n\r\n\r\n// Abstract game view, other views extend this.\r\n// Other views enhance its behavior by adding reusable components and custom logic.\r\nclass BaseGameView extends Container/* Container */.W2 {\r\n    constructor(viewName) {\r\n        super();\r\n        this.label = viewName;\r\n        this.boundsArea = new Rectangle/* Rectangle */.A(0, 0, gameApp.screen.width, gameApp.screen.height);\r\n    }\r\n    clearControls(controls) {\r\n        for (const key of Object.values(controls)) {\r\n            key.press = () => { };\r\n        }\r\n    }\r\n    assignControls(controls) {\r\n        this.controls = controls;\r\n    }\r\n    closeScene() {\r\n        this.controls = null;\r\n        EventBus.emit(SceneEvents.Close);\r\n    }\r\n    openScene(scene) {\r\n        EventBus.emit(SceneEvents.Open, scene);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/background.ts\n\r\n\r\nclass Background extends Graphics/* Graphics */.T {\r\n    constructor(addToParent) {\r\n        super();\r\n        this.rect(0, 0, gameApp.renderer.width, gameApp.renderer.height);\r\n        this.fill(0x000000);\r\n        if (addToParent) {\r\n            addToParent.addChild(this);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/message.ts\n\r\n\r\n\r\n\r\nclass Message extends Container/* Container */.W2 {\r\n    // ToDo: common interface for components with addToParent behaviour\r\n    constructor(addToParent, defaultY) {\r\n        super();\r\n        this.defaultY = defaultY || gameApp.renderer.height / 3;\r\n        this.caretY = this.defaultY;\r\n        if (addToParent) {\r\n            addToParent.addChild(this);\r\n        }\r\n    }\r\n    clear() {\r\n        this.removeChildren();\r\n        this.caretY = this.defaultY;\r\n    }\r\n    addText(msg, style, y) {\r\n        const text = new StyledText(msg, style);\r\n        text.position.set(gameApp.renderer.width / 2 - text.width / 2, y || this.caretY);\r\n        this.addChild(text);\r\n        this.caretY += text.height + LINE_HEIGHT;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/instructions.ts\n\r\n\r\nconst DEFAULT_Y = 11 * STEP_SIZE;\r\nclass Instructions extends Message {\r\n    constructor(msg, addToParent, yOffset) {\r\n        super(addToParent, yOffset || DEFAULT_Y);\r\n        this.addText([msg], fontStyleCenter);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/selection.ts\n\r\n\r\n\r\nclass Selection extends Sprite/* Sprite */.j {\r\n    constructor(texture, tint) {\r\n        super(texture || tileset[TileId.Selection + 3]);\r\n        this.row = 0;\r\n        this.col = 0;\r\n        this.scale.set(globals_SCALE);\r\n        this.tint = tint || PALETTE.ORANGE;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/scene.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Scene extends BaseGameView {\r\n    constructor(initialMessage, defaultY) {\r\n        super("Generic scene");\r\n        new Background(this);\r\n        // Main text\r\n        this.mainText = new Message(this, defaultY);\r\n        // Available actions\r\n        this.optionTexts = [];\r\n        // Cursor to navigate between options (actions)\r\n        this.optionSelector = new Selection();\r\n        this.addChild(this.optionSelector);\r\n        this.loadMessage(initialMessage);\r\n        // Controls hint\r\n        this.instructions = new Instructions(INSTRUCTION_TEXT_DEFAULT, this);\r\n    }\r\n    loadMessage(message) {\r\n        this.mainText.clear();\r\n        this.mainText.addText([message.text || ""], fontStyleCenter);\r\n        this.message = message;\r\n        for (const t of this.optionTexts) {\r\n            this.removeChild(t);\r\n            this.optionTexts = [];\r\n        }\r\n        for (const option of this.message.options) {\r\n            if (!option.disabled) {\r\n                this.addOption(option.action, this.message.options\r\n                    .filter((option) => !option.disabled)\r\n                    .indexOf(option));\r\n            }\r\n        }\r\n        this.optionSelector.row = 0;\r\n        this.repositionCursor();\r\n    }\r\n    addOption(msg, index) {\r\n        const text = new Text(msg, fontStyleCenter);\r\n        text.position.set(gameApp.renderer.width / 2 - text.width / 2, STEP_SIZE * (7 + index));\r\n        this.optionTexts.push(text);\r\n        this.addChild(text);\r\n        console.log("option added", msg);\r\n    }\r\n    assignControls(controls) {\r\n        this.clearControls(controls);\r\n        controls.up.press = () => {\r\n            this.cursorUp();\r\n        };\r\n        controls.down.press = () => {\r\n            this.cursorDown();\r\n        };\r\n        controls.w.press = () => {\r\n            this.cursorUp();\r\n        };\r\n        controls.s.press = () => {\r\n            this.cursorDown();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n    cursorUp() {\r\n        if (!this.message)\r\n            return;\r\n        this.optionSelector.row--;\r\n        if (this.optionSelector.row < 0) {\r\n            this.optionSelector.row =\r\n                this.message.options.filter((option) => !option.disabled).length - 1;\r\n        }\r\n        this.repositionCursor();\r\n    }\r\n    cursorDown() {\r\n        if (!this.message)\r\n            return;\r\n        this.optionSelector.row++;\r\n        if (this.optionSelector.row >=\r\n            this.message.options.filter((option) => !option.disabled).length) {\r\n            this.optionSelector.row = 0;\r\n        }\r\n        this.repositionCursor();\r\n    }\r\n    repositionCursor() {\r\n        if (this.optionTexts.length <= 0) {\r\n            this.optionSelector.visible = false;\r\n            return;\r\n        }\r\n        const line = this.optionTexts[this.optionSelector.row];\r\n        this.optionSelector.x = line.x - line.width / 2;\r\n        this.optionSelector.y = STEP_SIZE * (7 + this.optionSelector.row) - 20;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/game_over.ts\n\r\n\r\n\r\n\r\n\r\nconst LEFTMOST = STEP_SIZE;\r\nconst TOPMOST = 260;\r\nconst MAX_DISPLAYED_LINES = 11;\r\nclass GameOver extends Scene {\r\n    constructor(world, capturedCapital) {\r\n        const hero = world.getHero();\r\n        const winner = capturedCapital.owner;\r\n        console.log("winner", winner, "same as hero home owner?", hero.info.allegiance == winner);\r\n        let playersResult = "And that didn\'t affect you in any meaningful way";\r\n        if (hero.home) {\r\n            playersResult =\r\n                hero.info.allegiance == winner ? "And you won too" : "But you lost";\r\n        }\r\n        const result = "The game is over\\n\\n" +\r\n            "Time taken: " +\r\n            world.getDays() +\r\n            " days" +\r\n            "\\n\\n" +\r\n            winner +\r\n            " won" +\r\n            "\\n\\n" +\r\n            playersResult;\r\n        const initialMessage = { text: result, options: [] };\r\n        super(initialMessage, STEP_SIZE * 2);\r\n        // this.arrowUp.position.x = ((FULL_WIDTH * STEP_SIZE) - this.arrowUp.width) / 2\r\n        // this.arrowUp.position.y = TOPMOST + 10\r\n        // this.arrowDown.position.x = ((FULL_WIDTH * STEP_SIZE) - this.arrowDown.width) / 2 + 2\r\n        // this.arrowDown.position.y = TOPMOST + MAX_DISPLAYED_LINES * LINE_HEIGHT + 20\r\n        const entries = [];\r\n        let yOffset = TOPMOST;\r\n        for (const text of logger.armies) {\r\n            const entry = new StyledText(text, fontStyleCenter);\r\n            entry.position.set(LEFTMOST, yOffset);\r\n            yOffset += entry.height + LINE_HEIGHT;\r\n            entries.push(entry);\r\n            this.addChild(...entries);\r\n        }\r\n        this.scroll = new ScrollList(entries, TOPMOST, TOPMOST + MAX_DISPLAYED_LINES * LINE_HEIGHT);\r\n        this.scroll.positionArrows(this);\r\n        this.addChild(this.scroll);\r\n    }\r\n    assignControls(controls) {\r\n        super.assignControls(controls);\r\n        controls.up.press = () => {\r\n            this.scroll.scrollUp();\r\n        };\r\n        controls.down.press = () => {\r\n            this.scroll.scrollDown();\r\n        };\r\n        controls.w.press = () => {\r\n            this.scroll.scrollUp();\r\n        };\r\n        controls.s.press = () => {\r\n            this.scroll.scrollDown();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/intro.ts\n\r\n\r\n\r\n\r\n\r\nconst INTRO_MESSAGE_1 = [\r\n    `Welcome to the land of Eilal, adventurer!`,\r\n    "\\n",\r\n    `Your past is shrouded in mystery. Your future is inevitable.`,\r\n    "\\n",\r\n    `What matters now is the path that will connect them.`,\r\n];\r\nconst INTRO_MESSAGE_2 = [`And it is of your choice.`];\r\nclass Intro extends BaseGameView {\r\n    constructor() {\r\n        super("Intro");\r\n        new Background(this);\r\n        const message = new Message(this);\r\n        message.addText(INTRO_MESSAGE_1, fontStyleCenter);\r\n        message.addText(INTRO_MESSAGE_2, fontStyleCenter);\r\n        message.addText(["Press Space to begin your journey"], fontStyleCenter, gameApp.renderer.height - gameApp.renderer.height / 6);\r\n        console.log("Intro scene created");\r\n    }\r\n    assignControls(controls) {\r\n        this.clearControls(controls);\r\n        controls.space.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/agent_sprite.ts\n\r\n\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction["Left"] = 0] = "Left";\r\n    Direction[Direction["Right"] = 1] = "Right";\r\n})(Direction || (Direction = {}));\r\nclass AgentSprite extends Sprite/* Sprite */.j {\r\n    constructor(spriteId, direction = Direction.Left, tint) {\r\n        super(tileset[spriteId]);\r\n        // ToDo: needs a better name; it\'s kind of a \'dirty\' flag do mark sprites that need to be hidden on current view update\r\n        // See world_view updateDisplay()\r\n        this.needToDisplay = false;\r\n        this.spriteId = spriteId;\r\n        this.setDirection(direction);\r\n        this.tint = tint;\r\n        this.interactive = true;\r\n        this.on("click", () => {\r\n            console.log("click on", this);\r\n        });\r\n    }\r\n    updateTexture(spriteId) {\r\n        if (this.spriteId != spriteId) {\r\n            this.texture = tileset[spriteId];\r\n            this.spriteId = spriteId;\r\n        }\r\n    }\r\n    setDirection(facing) {\r\n        switch (facing) {\r\n            case Direction.Left:\r\n                this.anchor.set(1, 0);\r\n                this.scale.set(-globals_SCALE, globals_SCALE);\r\n                break;\r\n            case Direction.Right:\r\n                this.anchor.set(0);\r\n                this.scale.set(globals_SCALE);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/inventory.ts\n\r\nvar Item;\r\n(function (Item) {\r\n    Item["Staff"] = "Staff";\r\n    Item["Knife"] = "Knife";\r\n    Item["Axe"] = "Axe";\r\n    Item["Pickaxe"] = "Pickaxe";\r\n    Item["Pitchfork"] = "Pitchfork";\r\n})(Item || (Item = {}));\r\nclass AgentInventory {\r\n    constructor() {\r\n        this.money = 0;\r\n        this.rations = 5;\r\n        this.mount = undefined;\r\n        this.items = [];\r\n        this.res = {};\r\n        for (const resType of RESOURCE_TYPES) {\r\n            this.res[resType] = {\r\n                amount: 0,\r\n            };\r\n        }\r\n    }\r\n    static transferResource(resType, from, to) {\r\n        to.res[resType].amount += from.res[resType].amount;\r\n        from.res[resType].amount = 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/configs/quests.ts\nconst QUESTS = [\r\n    {\r\n        description: "I should learn more about these lands.",\r\n    },\r\n    {\r\n        description: "Basics first. Find a way to replenish my rations.",\r\n    },\r\n    {\r\n        description: "Build a shelter. Just need some tools and a suitable place.",\r\n    },\r\n];\r\n\n;// CONCATENATED MODULE: ./ts/model/journal.ts\n\r\n// A [LocationNameString] exists [World] // "There is some place i\'ve heard of"\r\n// A [Location] has name [LocationNameString] //"That place is called"\r\n// A [Location] placed at [GridCoords] //"That place can be found there"\r\n// A [LocationNameString] placed at [GridCoords] //"The place called X can be found there"\r\n// A [Location] type is [LocationType] //"That place is a LocationType"\r\n// A [Location] is owned by [Agent]\r\n// A [Location] is a home for [Agent]\r\n// A [Location] stores [Inventory]\r\n// An [Agent] exists [World]\r\n// An [Agent] lives in [Location]\r\n// An [Agent] owns [Possessions]\r\n// An [Agent] has ambitions [Ambition]\r\n// An [Agent] is doing [Routine]\r\n// A [Possesion] belongs to [Agent]\r\nvar Predicate;\r\n(function (Predicate) {\r\n    Predicate[Predicate["LocatedAt"] = 0] = "LocatedAt";\r\n})(Predicate || (Predicate = {}));\r\nclass Journal {\r\n    constructor() {\r\n        this.facts = [];\r\n        this.locationsSeen = [];\r\n        this.locationsVisited = [];\r\n        this.agents = new Map();\r\n        this.locations = new Map();\r\n        this.quests = QUESTS;\r\n    }\r\n    getAgentInfo(agent) {\r\n        const knownInfo = this.agents.get(agent);\r\n        if (!knownInfo) {\r\n            const info = {\r\n                name: "a person",\r\n                occupation: "",\r\n                appearance: {\r\n                    type: agent.info.appearance.type,\r\n                    tint: agent.info.appearance.tint,\r\n                },\r\n                home: null,\r\n            };\r\n            this.agents.set(agent, info);\r\n            return info;\r\n        }\r\n        return knownInfo;\r\n    }\r\n    getLocationInfo(location) {\r\n        const knownInfo = this.locations.get(location);\r\n        if (!knownInfo) {\r\n            const info = {\r\n                name: location.name,\r\n                owner: location.owner,\r\n                dwellers: null,\r\n                pos: { tx: location.pos.tx, ty: location.pos.ty },\r\n            };\r\n            this.locations.set(location, info);\r\n            return info;\r\n        }\r\n        return knownInfo;\r\n    }\r\n    addFact(fact) {\r\n        this.facts.push(fact);\r\n    }\r\n    didSeeLocation(location) {\r\n        return this.locationsSeen.includes(location);\r\n    }\r\n    seeLocation(location) {\r\n        this.locationsSeen.push(location);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/agent.ts\n\r\n\r\n\r\n\r\n\r\nconst names = [\r\n    // https://www.britishbabynames.com/blog/2012/06/medieval-favourites.html\r\n    "Adam",\r\n    "Alan",\r\n    "Alexander",\r\n    "Andrew",\r\n    "Arnold",\r\n    "Bartholomew",\r\n    "Benedict",\r\n    "Clement",\r\n    "David",\r\n    "Denis",\r\n    "Edmund",\r\n    "Edward",\r\n    "Ellis",\r\n    "Eustace",\r\n    "Everard",\r\n    "Fulco",\r\n    "Geoffrey",\r\n    "George",\r\n    "Gerard",\r\n    "Gervase",\r\n    "Gilbert",\r\n    "Giles",\r\n    "Gregory",\r\n    "Godfrey",\r\n    "Guy",\r\n    "Henry",\r\n    "Hugh",\r\n    "Humphrey",\r\n    "James",\r\n    "John",\r\n    "Jordan",\r\n    "Laurence",\r\n    "Luke",\r\n    "Martin",\r\n    "Matthew",\r\n    "Maurice",\r\n    "Michael",\r\n    "Nicholas",\r\n    "Peter",\r\n    "Philip",\r\n    "Ralph",\r\n    "Randolph",\r\n    "Reginald",\r\n    "Reynold",\r\n    "Richard",\r\n    "Robert",\r\n    "Roger",\r\n    "Simon",\r\n    "Solomon",\r\n    "Stephen",\r\n    "Thomas",\r\n    "Warin",\r\n    "Walter",\r\n    "William",\r\n];\r\nvar ACTIONS;\r\n(function (ACTIONS) {\r\n    ACTIONS[ACTIONS["Wait"] = 0] = "Wait";\r\n    ACTIONS[ACTIONS["Travel"] = 1] = "Travel";\r\n    ACTIONS[ACTIONS["Produce"] = 2] = "Produce";\r\n    ACTIONS[ACTIONS["Gather"] = 3] = "Gather";\r\n    ACTIONS[ACTIONS["Store"] = 4] = "Store";\r\n    ACTIONS[ACTIONS["Retrieve"] = 5] = "Retrieve";\r\n    ACTIONS[ACTIONS["ChangeRoutine"] = 6] = "ChangeRoutine";\r\n    ACTIONS[ACTIONS["ChooseRoutine"] = 7] = "ChooseRoutine";\r\n    ACTIONS[ACTIONS["Spawn"] = 8] = "Spawn";\r\n    ACTIONS[ACTIONS["Capture"] = 9] = "Capture";\r\n    ACTIONS[ACTIONS["RestorePower"] = 10] = "RestorePower";\r\n    ACTIONS[ACTIONS["TransformTile"] = 11] = "TransformTile";\r\n})(ACTIONS || (ACTIONS = {}));\r\nclass Agent {\r\n    constructor(world, type, tint) {\r\n        this.facing = Direction.Left;\r\n        this.world = world;\r\n        this.type = type;\r\n        this.info = {\r\n            name: names[getRandomInt(names.length)],\r\n            occupation: AGENTS_DATA[type].occupation,\r\n            appearance: {\r\n                type: type,\r\n                // RED, WHITE, VOID(BLACK) colors are reserved\r\n                tint: tint || getRandomColor(Object.values(PALETTE).slice(0, -3)),\r\n            },\r\n            home: null,\r\n            allegiance: null,\r\n        };\r\n        this.pos = { tx: 0, ty: 0 };\r\n        this.inv = new AgentInventory();\r\n        this.satiety = 40 + getRandomInt(20);\r\n        this.energy = 0;\r\n        this.journal = new Journal();\r\n        this.currentActionIdx = 0;\r\n    }\r\n    getDefaultRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel to random location",\r\n                actionBuilder: () => {\r\n                    const dest = getRandomElement(this.world.locations.flatMap((l) => l.gates));\r\n                    if (LOG_SETTINGS.npcTravel)\r\n                        console.log(this.info.occupation, this.info.name, "heading out to", dest);\r\n                    return this.actionTravel(dest);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Wait,\r\n                desc: "Wait for some time",\r\n                actionBuilder: () => this.actionWait(getRandomInt(4) + 3),\r\n            },\r\n        ];\r\n    }\r\n    getResourceTransferRoutine(resourceTypes) {\r\n        return [\r\n            {\r\n                type: ACTIONS.Retrieve,\r\n                desc: "Retrieve all stored resources from home location",\r\n                actionBuilder: () => {\r\n                    return this.actionRetrieveAll(resourceTypes, this.home);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel to the capital",\r\n                actionBuilder: () => {\r\n                    const dest = this.world.getCapitalOf(this.home.owner);\r\n                    return this.actionTravel(dest.pos);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Store,\r\n                desc: "Store gathered resources",\r\n                actionBuilder: () => {\r\n                    //ToDo: make sure this is the same place that we traveled to\r\n                    //Home owner might change if enemies capture home while npc travels\r\n                    const dest = this.world.getCapitalOf(this.home.owner);\r\n                    return this.actionStoreAll(resourceTypes, dest);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel home",\r\n                actionBuilder: () => {\r\n                    const dest = this.home.gates[0];\r\n                    return this.actionTravel(dest);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.ChangeRoutine,\r\n                desc: "Change currently executing routine to another one",\r\n                actionBuilder: () => {\r\n                    return this.actionChangeRoutine(this.getDefaultRoutine());\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    operate(dt) {\r\n        if (!this.action) {\r\n            this.chooseNextAction();\r\n        }\r\n        this.processHunger();\r\n        this.action.advance();\r\n    }\r\n    processHunger() {\r\n        this.satiety--;\r\n        if (this.satiety < getRandomInt(49) + 1) {\r\n            this.consumeRation();\r\n        }\r\n        if (this.satiety < 0) {\r\n            console.warn(`Agent ${this.info.name} ${this.info.occupation} is malnourished`);\r\n        }\r\n    }\r\n    consumeRation() {\r\n        if (this.inv.rations > 0) {\r\n            this.inv.rations--;\r\n            this.satiety += 10;\r\n            console.log(`Agent ${this.info.name} consumed ration. Left: ${this.inv.rations}, new satiety: ${this.satiety}`);\r\n        }\r\n        else {\r\n            console.log(`Agent ${this.info.name} has no rations to consume. Satiety: ${this.satiety}`);\r\n        }\r\n    }\r\n    updateVision() {\r\n        console.log("Updating agent vision", this.info.name);\r\n    }\r\n    chooseNextAction() {\r\n        this.action = this.routine[this.currentActionIdx].actionBuilder();\r\n        if (LOG_SETTINGS.npcActions)\r\n            console.log(this.info.occupation, this.info.name, "got new action", this.action);\r\n        this.currentActionIdx++;\r\n        if (this.currentActionIdx >= this.routine.length) {\r\n            this.currentActionIdx = 0;\r\n        }\r\n    }\r\n    actionTravel(destination) {\r\n        const action = {\r\n            type: ACTIONS.Travel,\r\n            destination: destination,\r\n            desc: "Travelling",\r\n            route: this.world.getNewRoute(this, destination),\r\n            advance: () => {\r\n                console.log("farmer travel advance");\r\n            },\r\n        };\r\n        action.advance = () => {\r\n            if (action.route.step < action.route.path.length) {\r\n                this.moveAlongRoute(action.route);\r\n            }\r\n            else {\r\n                if (LOG_SETTINGS.npcTravel)\r\n                    console.log(this.info.occupation, this.info.name, "arrived at", this.pos, destination);\r\n                this.chooseNextAction();\r\n            }\r\n        };\r\n        return action;\r\n    }\r\n    moveAlongRoute(route) {\r\n        const newPos = route.path[route.step];\r\n        this.updateFacing(newPos);\r\n        this.world.setAgentPosition(this, newPos);\r\n        route.step++;\r\n    }\r\n    updateFacing(newPos) {\r\n        if (newPos.tx > this.pos.tx) {\r\n            this.facing = Direction.Right;\r\n        }\r\n        else if (newPos.tx < this.pos.tx) {\r\n            this.facing = Direction.Left;\r\n        }\r\n    }\r\n    actionWait(turns) {\r\n        const action = {\r\n            type: ACTIONS.Wait,\r\n            timeout: turns,\r\n            waited: 0,\r\n            advance: () => {\r\n                console.log("farmer wait");\r\n            },\r\n        };\r\n        action.advance = () => {\r\n            action.waited++;\r\n            if (action.waited > action.timeout) {\r\n                this.chooseNextAction();\r\n            }\r\n        };\r\n        return action;\r\n    }\r\n    actionRetrieveAll(resTypes, location) {\r\n        return {\r\n            type: ACTIONS.Retrieve,\r\n            advance: () => {\r\n                for (const resType of resTypes) {\r\n                    AgentInventory.transferResource(resType, location.inv, this.inv);\r\n                }\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionStoreAll(resTypes, location) {\r\n        return {\r\n            type: ACTIONS.Store,\r\n            advance: () => {\r\n                // console.log(location.name, \'before storing\', location.inv)\r\n                for (const resType of resTypes) {\r\n                    AgentInventory.transferResource(resType, this.inv, location.inv);\r\n                }\r\n                // console.log(location.name, \'after storing\', location.inv)\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionStore(resType, location) {\r\n        return {\r\n            type: ACTIONS.Store,\r\n            advance: () => {\r\n                AgentInventory.transferResource(resType, this.inv, location.inv);\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionRetrieveResource(resType, location) {\r\n        return {\r\n            type: ACTIONS.Retrieve,\r\n            advance: () => {\r\n                AgentInventory.transferResource(resType, location.inv, this.inv);\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionChangeRoutine(routine, condition) {\r\n        return {\r\n            type: ACTIONS.ChangeRoutine,\r\n            desc: "Changing routine if condition allows",\r\n            advance: () => {\r\n                if (!condition || condition()) {\r\n                    this.routine = routine;\r\n                    this.currentActionIdx = 0;\r\n                }\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    getHomeRealm() {\r\n        return this.world.realms[this.home.owner];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/location.ts\n\r\n\r\n\r\n\r\n\r\nclass Location {\r\n    constructor(type, pos) {\r\n        this.type = type;\r\n        this.pos = pos;\r\n        this.areas = [];\r\n        this.cells = new Set();\r\n        this.gates = [];\r\n        this.owner = Location.decideOwner(pos);\r\n        this.name = LOCATIONS_CONFIG[type].name;\r\n        this.desc = Location.buildDescription(this.type, this.owner);\r\n        this.hint = LOCATION_HINT;\r\n        this.defense = LOCATIONS_CONFIG[type].defense;\r\n        this.color = getRandomColor(Realm.getRealmPalette(this.owner)); // ToDo: make colors within location type unique\r\n        this.inv = new AgentInventory();\r\n        this.info = {\r\n            name: this.name,\r\n            owner: this.owner,\r\n            dwellers: new Set(),\r\n            pos: { tx: this.pos.tx, ty: this.pos.ty },\r\n        };\r\n    }\r\n    static buildDescription(type, owner) {\r\n        return LOCATIONS_CONFIG[type].name + "\\n" + Realm.get2LineName(owner);\r\n    }\r\n    static decideOwner(pos) {\r\n        return pos.tx < 22 ? RealmTag.NorthWest : RealmTag.SouthEast;\r\n    }\r\n    linkCells(world, cells) {\r\n        const mainCell = world.getCell(this.pos, cells);\r\n        this.cells.add(mainCell);\r\n    }\r\n    createGatesAndLinkToCells(world) {\r\n        this.gates = [];\r\n        const adjacent = world.getAdjacentCoords(this.pos);\r\n        for (const coords of adjacent) {\r\n            // ToDo: get triggers from location definitions\r\n            if (coords) {\r\n                const cell = world.getCell(coords);\r\n                if (cell && cell.typeId == 3) {\r\n                    this.gates.push(coords);\r\n                    cell.tileGates.add(this);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setOwner(newOwner) {\r\n        this.owner = newOwner;\r\n        this.desc = Location.buildDescription(this.type, this.owner);\r\n        this.info.owner = newOwner;\r\n    }\r\n    getTotalResourceAmount() {\r\n        let sum = 0;\r\n        for (const res of Object.values(this.inv.res)) {\r\n            sum += res.amount;\r\n        }\r\n        return sum;\r\n    }\r\n    getProducedResourceTypes() {\r\n        return [];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/locations/capital.ts\n\r\n\r\nclass Capital extends Location {\r\n    constructor(type, pos) {\r\n        super(type, pos);\r\n        this.inv = {\r\n            money: 10000,\r\n            res: {},\r\n        };\r\n        for (const res of RESOURCE_TYPES) {\r\n            this.inv.res[res] = {\r\n                amount: 100,\r\n                buy: 100,\r\n                sell: 150,\r\n            };\r\n        }\r\n    }\r\n    linkCells(world) {\r\n        const mainCell = world.getCell(this.pos);\r\n        this.cells.add(mainCell);\r\n        const topCell = world.getCell({ tx: this.pos.tx, ty: this.pos.ty - 1 });\r\n        this.cells.add(topCell);\r\n        const leftCell = world.getCell({ tx: this.pos.tx - 1, ty: this.pos.ty });\r\n        this.cells.add(leftCell);\r\n        const rightCell = world.getCell({ tx: this.pos.tx + 1, ty: this.pos.ty });\r\n        this.cells.add(rightCell);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/locations/mine.ts\n\r\nclass Mine extends Location {\r\n    constructor(type, pos) {\r\n        super(type, pos);\r\n    }\r\n    produceResource() {\r\n        this.inv.res[Math.random() > 0.8 ? "Iron" : "Bronze"].amount += 10;\r\n    }\r\n    getProducedResourceTypes() {\r\n        return ["Iron", "Bronze"];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/locations/quarry.ts\n\r\nclass Quarry extends Location {\r\n    constructor(type, pos) {\r\n        super(type, pos);\r\n    }\r\n    produceResource() {\r\n        this.inv.res.Stone.amount += 10;\r\n    }\r\n    getProducedResourceTypes() {\r\n        return ["Stone"];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/locations/sawmill.ts\n\r\nclass Sawmill extends Location {\r\n    constructor(type, pos) {\r\n        super(type, pos);\r\n    }\r\n    getProducedResourceTypes() {\r\n        return ["Wood"];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/configs/locations_data.ts\n\r\n\r\n\r\n\r\nvar LocationType;\r\n(function (LocationType) {\r\n    LocationType[LocationType["Town"] = 8] = "Town";\r\n    LocationType[LocationType["Fort"] = 18] = "Fort";\r\n    LocationType[LocationType["City"] = 19] = "City";\r\n    LocationType[LocationType["Tower"] = 21] = "Tower";\r\n    LocationType[LocationType["Hut"] = 23] = "Hut";\r\n    LocationType[LocationType["Mine"] = 24] = "Mine";\r\n    LocationType[LocationType["Quarry"] = 25] = "Quarry";\r\n    LocationType[LocationType["House"] = 29] = "House";\r\n    LocationType[LocationType["Sawmill"] = 32] = "Sawmill";\r\n})(LocationType || (LocationType = {}));\r\nconst LOCATIONS_CONFIG = {\r\n    [LocationType.Tower]: {\r\n        name: "Tower",\r\n        spawns: ["wizard"],\r\n        defense: 100,\r\n    },\r\n    [LocationType.City]: {\r\n        name: "City",\r\n        spawns: ["ruler", "guard"],\r\n        defense: 400,\r\n        ctor: Capital,\r\n    },\r\n    [LocationType.Town]: {\r\n        name: "Town",\r\n        spawns: ["trader"],\r\n        defense: 200,\r\n    },\r\n    [LocationType.Fort]: {\r\n        name: "Fort",\r\n        spawns: ["bandit"],\r\n        defense: 150,\r\n    },\r\n    [LocationType.Mine]: {\r\n        name: "Mine",\r\n        spawns: ["miner"],\r\n        defense: 100,\r\n        ctor: Mine,\r\n    },\r\n    [LocationType.Quarry]: {\r\n        name: "Quarry",\r\n        spawns: ["miner"],\r\n        defense: 100,\r\n        ctor: Quarry,\r\n    },\r\n    [LocationType.Hut]: {\r\n        name: "Hut",\r\n        spawns: ["wizard"],\r\n        defense: 10,\r\n    },\r\n    [LocationType.House]: {\r\n        name: "House",\r\n        spawns: ["farmer"],\r\n        defense: 20,\r\n    },\r\n    [LocationType.Sawmill]: {\r\n        name: "Sawmill",\r\n        spawns: ["woodcutter"],\r\n        defense: 50,\r\n        ctor: Sawmill,\r\n    },\r\n};\r\n\n;// CONCATENATED MODULE: ./ts/model/world_cell.ts\n\r\nvar VisualPerceptionState;\r\n(function (VisualPerceptionState) {\r\n    VisualPerceptionState["NeverSeen"] = "NeverSeen";\r\n    VisualPerceptionState["Memorized"] = "Memorized";\r\n    VisualPerceptionState["BeingSeen"] = "BeingSeen";\r\n})(VisualPerceptionState || (VisualPerceptionState = {}));\r\n// indices of tiles which are passable by every human entity\r\nconst PASSABLE = [\r\n    0,\r\n    3,\r\n    11,\r\n    28,\r\n    30,\r\n    31,\r\n    37,\r\n    39, // Seeds, Grown field\r\n];\r\nclass WorldCell {\r\n    constructor(typeId, coords) {\r\n        this.typeId = typeId;\r\n        this.pos = coords;\r\n        this.agents = new Set();\r\n        this.tileGates = new Set();\r\n        this.isPassable = PASSABLE.includes(typeId);\r\n    }\r\n    setVisibility(value) {\r\n        if (this.visibility != value) {\r\n            this.visibility =\r\n                WorldView.VISIBILITY_MODE == VisibilityMode.Default\r\n                    ? value\r\n                    : VisualPerceptionState.BeingSeen;\r\n            this.updateEntitiesVisibilty(this.visibility);\r\n            this.needsDisplayUpdate = true;\r\n        }\r\n    }\r\n    updateEntitiesVisibilty(value) {\r\n        for (const e of this.agents) {\r\n            e.visibility = value;\r\n        }\r\n    }\r\n    changeType(newTypeId) {\r\n        this.typeId = newTypeId;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/world.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * This is the heart of the game: a model / game world simulation.\r\n * It contains systems / behaviours that make the game alive.\r\n *\r\n * Note: it shouldn\'t know anything about the view / renderer,\r\n * which is presenting world state to the player.\r\n *\r\n * It stores the following:\r\n *  world\'s territory, an array of tiles and locations\r\n *   populated on initialization, based on level data\r\n *  realms\r\n *  agents (hero and NPCs)\r\n *\r\n * We\'re mostly using tile grid positions (GridCoord),\r\n * an object {tx: valX, ty: valY} holding a pair of tile coordinates\r\n * Linear indexes are used as unique tile ids\r\n */\r\n// indices of tree tiles\r\nconst TREES = [4, 5, 6];\r\nvar WorldEvents;\r\n(function (WorldEvents) {\r\n    WorldEvents["CapitalCaptured"] = "capital_captured";\r\n    WorldEvents["LocationCaptured"] = "location_captured";\r\n    WorldEvents["UpdateRequested"] = "world_update_requested";\r\n    WorldEvents["Updated"] = "world_updated";\r\n})(WorldEvents || (WorldEvents = {}));\r\nvar MapAreaType;\r\n(function (MapAreaType) {\r\n    MapAreaType[MapAreaType["ArableLand"] = 0] = "ArableLand";\r\n})(MapAreaType || (MapAreaType = {}));\r\nconst HERO_INITIAL_POS = { tx: 24, ty: 23 };\r\n// const HERO_INITIAL_POS = { tx: 35, ty: 24 };\r\n/**\r\n * Let\'s have a bunch of arrays (data)\r\n * And do stuff with them using a bunch of procedures\r\n * And possibly group those procedures into subsystems/managers\r\n * But no hardcore OOP\r\n */\r\n// ToDo: split into WorldBuilder (init logic) and World itself?\r\nclass World {\r\n    constructor(tileData) {\r\n        // TimeManager\r\n        this.tick = 0; // amount of abstract atomic time units passed since the game start\r\n        this.timedEffects = [];\r\n        this.updateTimeLeftover = 0;\r\n        this.cells = this.createCells(tileData);\r\n        this.locations = this.createLocations(tileData);\r\n        this.areas = this.createAreas();\r\n        this.realms = this.createRealms();\r\n        this.linkCellsToLocations(this.locations, this.cells);\r\n        this.createLocationGatesAndLinkToCells();\r\n        this.linkLocationsToRealms(this.realms, this.locations);\r\n        this.linkAreasToLocations(this.areas, this.locations);\r\n        this.startWars(this.realms);\r\n        this.agents = this.spawnAgents();\r\n        this.initState();\r\n        // ToDo: give control of hero agent to the player\r\n        console.log("World created");\r\n    }\r\n    createCells(levelData) {\r\n        const cells = [];\r\n        for (let linearId = 0; linearId < levelData.length; linearId++) {\r\n            const gridX = linearId % WORLD_WIDTH;\r\n            const gridY = Math.floor(linearId / WORLD_WIDTH);\r\n            const cell = new WorldCell(levelData[linearId], { tx: gridX, ty: gridY });\r\n            cells[linearId] = cell;\r\n        }\r\n        return cells;\r\n    }\r\n    createLocations(levelData) {\r\n        const locations = [];\r\n        for (let i = 0; i < levelData.length; i++) {\r\n            if (levelData[i] in LocationType) {\r\n                // One of our locations\r\n                const locationType = levelData[i];\r\n                const LocationConstructor = LOCATIONS_CONFIG[locationType].ctor || Location;\r\n                const location = new LocationConstructor(locationType, this.idxToPos(i));\r\n                locations.push(location);\r\n            }\r\n        }\r\n        console.log("Locations created", locations);\r\n        return locations;\r\n    }\r\n    createAreas() {\r\n        return [\r\n            {\r\n                type: MapAreaType.ArableLand,\r\n                data: [\r\n                    { tx: 37, ty: 26 },\r\n                    { tx: 38, ty: 26 },\r\n                    { tx: 39, ty: 26 },\r\n                    { tx: 37, ty: 27 },\r\n                    { tx: 38, ty: 27 },\r\n                    { tx: 39, ty: 27 },\r\n                ],\r\n            },\r\n        ];\r\n    }\r\n    createRealms() {\r\n        return {\r\n            [RealmTag.NorthWest]: new Realm(RealmTag.NorthWest),\r\n            [RealmTag.SouthEast]: new Realm(RealmTag.SouthEast),\r\n        };\r\n    }\r\n    linkCellsToLocations(locations, cells) {\r\n        for (const location of locations) {\r\n            location.linkCells(this, cells);\r\n        }\r\n    }\r\n    createLocationGatesAndLinkToCells() {\r\n        for (const l of this.locations) {\r\n            l.createGatesAndLinkToCells(this);\r\n        }\r\n    }\r\n    linkLocationsToRealms(realms, locations) {\r\n        for (const location of locations) {\r\n            realms[location.owner].fiefs.push(location);\r\n            if (location.type == LocationType.City) {\r\n                realms[location.owner].capital = location;\r\n            }\r\n        }\r\n    }\r\n    linkAreasToLocations(areas, locations) {\r\n        for (const a of areas) {\r\n            switch (a.type) {\r\n                case MapAreaType.ArableLand: {\r\n                    const location = this.findNearestLocation(a.data[0], locations.filter((l) => l.type == LocationType.House)).loc;\r\n                    if (!location) {\r\n                        console.error("No location found for", a.data[0]);\r\n                    }\r\n                    location.areas.push(a);\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    startWars(realms) {\r\n        const tags = Object.values(RealmTag);\r\n        for (const key of tags) {\r\n            const others = tags.filter((tag) => tag != key);\r\n            realms[key].wars.push(...others);\r\n        }\r\n        console.log("Wars started", realms);\r\n    }\r\n    spawnAgents() {\r\n        const agents = [];\r\n        const hero = this.spawnHomelessAgent("adventurer", this, HERO_INITIAL_POS, PALETTE.RED);\r\n        agents.push(hero);\r\n        this.hero = hero;\r\n        for (const location of this.locations) {\r\n            const locationData = LOCATIONS_CONFIG[location.type] || LOCATIONS_CONFIG[LocationType.House];\r\n            if (location.gates[0]) {\r\n                for (const npcType of locationData.spawns) {\r\n                    const agent = this.spawnAgentAtHome(npcType, this, location);\r\n                    agents.push(agent);\r\n                }\r\n            }\r\n        }\r\n        return agents;\r\n    }\r\n    spawnAgentAtHome(type, world, home) {\r\n        const agent = this.spawnHomelessAgent(type, world, home.gates[0]);\r\n        agent.home = home;\r\n        agent.info.home = home;\r\n        agent.routine = agent.getDefaultRoutine();\r\n        return agent;\r\n    }\r\n    spawnHomelessAgent(type, world, pos, tint) {\r\n        const data = AGENTS_DATA[type];\r\n        //ToDo: game can run with broken agent code because of this. Bad!\r\n        const agent = new data.class(this, type, tint);\r\n        this.setAgentPosition(agent, { tx: pos.tx, ty: pos.ty });\r\n        agent.world = world;\r\n        return agent;\r\n    }\r\n    // End of init procedures\r\n    getAvailableContexts(agent) {\r\n        const availableContexts = [\r\n            { context: Context.World, data: this },\r\n        ];\r\n        const matchedLocations = this.findMatchedLocations(agent);\r\n        for (const l of matchedLocations) {\r\n            availableContexts.push({ context: Context.Location, data: l });\r\n        }\r\n        const agentsToInteract = this.findNeighbours(agent);\r\n        if (agentsToInteract.length > 0) {\r\n            for (const agent of agentsToInteract) {\r\n                availableContexts.push({ context: Context.Dialogue, data: agent });\r\n            }\r\n        }\r\n        return availableContexts;\r\n    }\r\n    findMatchedLocations(agent) {\r\n        const locations = [];\r\n        for (const location of this.locations) {\r\n            for (const gate of location.gates) {\r\n                if (agent.pos.tx == gate.tx && agent.pos.ty == gate.ty) {\r\n                    locations.push(location);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return locations;\r\n    }\r\n    changeLocationOwner(location, newOwner) {\r\n        const oldRealm = this.realms[location.owner];\r\n        const newRealm = this.realms[newOwner];\r\n        console.log("Fiefs before ownership change", [...oldRealm.fiefs], [...newRealm.fiefs]);\r\n        location.setOwner(newOwner);\r\n        newRealm.fiefs.push(...oldRealm.fiefs.splice(oldRealm.fiefs.indexOf(location), 1));\r\n        console.log("Fiefs after ownership change", [...oldRealm.fiefs], [...newRealm.fiefs]);\r\n    }\r\n    /**\r\n     * This is some kind of a core game loop.\r\n     */\r\n    advanceState(timeStep) {\r\n        console.log(`Advancing world state by ${timeStep} ticks`);\r\n        this.advanceTime(timeStep);\r\n        EventBus.emit(WorldEvents.Updated);\r\n    }\r\n    initState() {\r\n        this.updateAgents(0);\r\n    }\r\n    advanceTime(deltaTicks) {\r\n        let dt = deltaTicks + this.updateTimeLeftover;\r\n        while (dt >= TURN_DURATION) {\r\n            dt -= TURN_DURATION;\r\n            this.tick += TURN_DURATION;\r\n            this.updateAgents(TURN_DURATION);\r\n            this.updateTimedEffects(TURN_DURATION);\r\n        }\r\n        this.updateTimeLeftover = dt;\r\n    }\r\n    getDays() {\r\n        return Math.round(this.tick / 10) + 1;\r\n    }\r\n    updateAgents(deltaTicks) {\r\n        this.agents[0].operate(deltaTicks); // updating hero\r\n        for (const npc of this.agents.slice(1)) {\r\n            npc.operate(deltaTicks);\r\n        }\r\n        this.agents[0].updateVision(); // updating hero vision\r\n    }\r\n    updateTimedEffects(deltaTicks) {\r\n        for (const t of this.timedEffects) {\r\n            t.timePassed += deltaTicks;\r\n            if (t.timePassed >= t.duration)\r\n                t.effect();\r\n        }\r\n        this.timedEffects = this.timedEffects.filter((t) => t.timePassed < t.duration);\r\n    }\r\n    /**\r\n     * For a given position, get all adjacent tiles and their adjacent tiles\r\n     * Might get invalid coords (null) and same coords multiple times\r\n     */\r\n    getVisionArea(pos) {\r\n        const area = new Set();\r\n        for (const t of this.getAdjacentTiles(pos)) {\r\n            area.add(t);\r\n        }\r\n        this.getAdjacentCoords(pos).forEach((coords) => {\r\n            if (coords) {\r\n                this.getAdjacentTiles(coords).forEach((t) => area.add(t));\r\n            }\r\n        });\r\n        return Array.from(area);\r\n    }\r\n    /**\r\n     * Set given visual perception state for each tile of an area\r\n     */\r\n    setAreaVisibility(area, state) {\r\n        for (const coords of area) {\r\n            if (coords)\r\n                this.getCell(coords).setVisibility(state);\r\n        }\r\n    }\r\n    memorizeTiles(area) {\r\n        this.setAreaVisibility(area, VisualPerceptionState.Memorized);\r\n    }\r\n    showTiles(area) {\r\n        this.setAreaVisibility(area, VisualPerceptionState.BeingSeen);\r\n    }\r\n    seeAllCells() {\r\n        this.setAreaVisibility(this.cells.map((c) => c.pos), VisualPerceptionState.BeingSeen);\r\n    }\r\n    unseeAllCells() {\r\n        this.setAreaVisibility(this.cells.map((c) => c.pos), VisualPerceptionState.NeverSeen);\r\n    }\r\n    // get player-controlled agent\r\n    // ToDo: make sure it returns correct object\r\n    getHero() {\r\n        return this.agents[0];\r\n    }\r\n    addTimedEffect(duration, effect) {\r\n        this.timedEffects.push({\r\n            duration: duration,\r\n            timePassed: 0,\r\n            effect: effect,\r\n        });\r\n    }\r\n    getCell(pos, cells) {\r\n        cells = cells || this.cells;\r\n        const result = cells[this.posToIdx(pos)];\r\n        if (!result) {\r\n            console.error("No cell found for position", pos);\r\n        }\r\n        return result;\r\n    }\r\n    // Returns an array of 4 positions ({tx:, ty:} pairs), any of which could be null\r\n    getAdjacentCoords(pos) {\r\n        if (this.isValidPos(pos)) {\r\n            return [\r\n                pos.ty > 0 ? { tx: pos.tx, ty: pos.ty - 1 } : null,\r\n                pos.tx < WORLD_WIDTH - 1 ? { tx: pos.tx + 1, ty: pos.ty } : null,\r\n                pos.ty < WORLD_HEIGHT - 1 ? { tx: pos.tx, ty: pos.ty + 1 } : null,\r\n                pos.tx > 0 ? { tx: pos.tx - 1, ty: pos.ty } : null, // W\r\n            ];\r\n        }\r\n        console.warn("Incorrect tile position", pos);\r\n        return [null, null, null, null];\r\n    }\r\n    getAdjacentTiles(pos) {\r\n        const coords = this.getAdjacentCoords(pos).filter((c) => c != null);\r\n        return coords.map((c) => this.getCell(c));\r\n    }\r\n    findNeighbours(agent) {\r\n        const adjacentAgents = [];\r\n        const adjacentTiles = this.getAdjacentCoords(agent.pos);\r\n        for (const gridCoords of adjacentTiles) {\r\n            for (const npc of this.agents) {\r\n                if (npc.pos.tx == gridCoords.tx && npc.pos.ty == gridCoords.ty) {\r\n                    adjacentAgents.push(npc);\r\n                }\r\n            }\r\n        }\r\n        return adjacentAgents;\r\n    }\r\n    getNewRoute(npc, destination) {\r\n        return {\r\n            path: this.findRoute(npc.pos, destination),\r\n            step: 0,\r\n        };\r\n    }\r\n    findRoute(start, destination) {\r\n        // console.log(\'Route: start, destination\', start, destination);\r\n        const frontier = [];\r\n        frontier.push(this.posToIdx(start));\r\n        const parent = [];\r\n        parent[this.posToIdx(start)] = null;\r\n        while (frontier.length > 0) {\r\n            const current = this.idxToPos(frontier.shift());\r\n            if (current.tx == destination.tx && current.ty == destination.ty) {\r\n                break;\r\n            }\r\n            for (const next of this.getAdjacentCoords(current)) {\r\n                if (next) {\r\n                    const nextIdx = this.posToIdx(next);\r\n                    if (!parent[nextIdx] &&\r\n                        (this.isPassablePos(next) || nextIdx === this.posToIdx(destination))) {\r\n                        frontier.push(nextIdx);\r\n                        parent[nextIdx] = this.posToIdx(current);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(\'Route search finished\');\r\n        let current = destination;\r\n        const path = [];\r\n        let i = 0;\r\n        while (current && !(current.tx == start.tx && current.ty == start.ty)) {\r\n            path.push(current);\r\n            current = this.idxToPos(parent[this.posToIdx(current)]);\r\n            i++;\r\n            if (i > 99) {\r\n                console.error("Route too long, abort!");\r\n                return path;\r\n            }\r\n        }\r\n        return path.reverse();\r\n    }\r\n    findNearestTree(from) {\r\n        const fromIdx = this.posToIdx(from);\r\n        const frontier = [fromIdx];\r\n        const reached = [fromIdx];\r\n        while (frontier.length > 0) {\r\n            const current = this.idxToPos(frontier.shift());\r\n            const cell = this.getCell(current);\r\n            if (TREES.includes(cell.typeId)) {\r\n                return cell;\r\n            }\r\n            for (const next of this.getAdjacentCoords(current)) {\r\n                if (next && !reached.includes(this.posToIdx(next))) {\r\n                    const nextIdx = this.posToIdx(next);\r\n                    frontier.push(nextIdx);\r\n                    reached.push(nextIdx);\r\n                }\r\n            }\r\n        }\r\n        return this.cells[0];\r\n    }\r\n    findNearestLocation(pos, locations) {\r\n        const result = {\r\n            route: null,\r\n            loc: null,\r\n        };\r\n        for (const loc of locations) {\r\n            if (loc.gates[0]) {\r\n                const route = this.findRoute(pos, loc.gates[0]);\r\n                if (!result.route || route.length < result.route.length) {\r\n                    result.route = route;\r\n                    result.loc = loc;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    findNearestCell(pos, cells) {\r\n        let route;\r\n        for (const p of cells) {\r\n            const newRoute = this.findRoute(pos, p.pos);\r\n            if (!route || newRoute.length < route.length) {\r\n                route = newRoute;\r\n            }\r\n        }\r\n        if (route) {\r\n            const coords = route[route.length - 1];\r\n            const t = this.getCell(coords);\r\n            return t;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    // Assumes pos has corresponding Tile in the world\r\n    setAgentPosition(agent, pos) {\r\n        const oldTile = this.getCell(agent.pos);\r\n        agent.pos.tx = pos.tx;\r\n        agent.pos.ty = pos.ty;\r\n        if (oldTile.agents.has(agent)) {\r\n            oldTile.agents.delete(agent);\r\n        }\r\n        const newCell = this.getCell(pos);\r\n        agent.cell = newCell;\r\n        newCell.agents.add(agent);\r\n        // ToDo: update sprite posiiton and visibility\r\n    }\r\n    getCapitalOf(realmTag) {\r\n        return this.realms[realmTag].capital;\r\n    }\r\n    //#region Utility functions to check whether the tile exists and could be passed over\r\n    isValidToMoveTo(pos) {\r\n        return this.isValidPos(pos) && this.isPassablePos(pos);\r\n    }\r\n    isValidPos(pos) {\r\n        return (pos.tx >= 0 &&\r\n            pos.tx < WORLD_WIDTH &&\r\n            pos.ty >= 0 &&\r\n            pos.ty < WORLD_HEIGHT);\r\n    }\r\n    isPassablePos(pos) {\r\n        return this.getCell(pos).isPassable;\r\n    }\r\n    //#endregion\r\n    //#region Utility functions to convert between linear tile indices and { tx, ty } coordinate pairs\r\n    posToIdx(pos) {\r\n        return pos.ty * WORLD_WIDTH + pos.tx;\r\n    }\r\n    idxToPos(idx) {\r\n        return { tx: idx % WORLD_WIDTH, ty: Math.floor(idx / WORLD_WIDTH) };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/agents/army.ts\n\r\n\r\n\r\n\r\nconst DEFAULT_POWER = 505;\r\nclass Army extends Agent {\r\n    constructor(world, type) {\r\n        super(world, type);\r\n    }\r\n    getDefaultRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.ChooseRoutine,\r\n                desc: "Choose between war and regaining power",\r\n                actionBuilder: () => {\r\n                    return this.actionChooseBetweenWarAndResting();\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    getWarRoutine(target) {\r\n        return [\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel to the enemy location",\r\n                actionBuilder: () => {\r\n                    this.captureTarget = target;\r\n                    return this.actionTravel(target.gates[0]);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Capture,\r\n                desc: "Capture enemy location",\r\n                actionBuilder: () => {\r\n                    return this.actionCapture(this.captureTarget);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.ChooseRoutine,\r\n                desc: "Back to choosing between war and regaining power",\r\n                actionBuilder: () => {\r\n                    return this.actionChooseBetweenWarAndResting();\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    getRegainPowerRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel to the enemy location",\r\n                actionBuilder: () => {\r\n                    return this.actionTravel(this.home.pos);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.RestorePower,\r\n                desc: "Restore army power",\r\n                actionBuilder: () => {\r\n                    return this.actionRestorePower();\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.ChooseRoutine,\r\n                desc: "Back to choosing between war and regaining power",\r\n                actionBuilder: () => {\r\n                    return this.actionChooseBetweenWarAndResting();\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    // Capturable location means\r\n    // location owner is at war with home owner\r\n    // and location defense is less than this army power\r\n    findCapturableLocation() {\r\n        const realm = this.getHomeRealm();\r\n        const enemyLocations = this.world.realms[realm.wars[0]].fiefs.filter((l) => l.defense < this.power);\r\n        const res = this.world.findNearestLocation(this.pos, enemyLocations);\r\n        if (!res.loc)\r\n            console.log("no capturable locations found", this);\r\n        return res.loc;\r\n    }\r\n    actionCapture(location) {\r\n        return {\r\n            type: ACTIONS.Capture,\r\n            advance: () => {\r\n                this.power -= location.defense;\r\n                logger.logLocationCapture(location, this);\r\n                this.world.changeLocationOwner(location, this.home.owner);\r\n                console.log("capturing location");\r\n                EventBus.emit(WorldEvents.LocationCaptured, location);\r\n                if (location.type == LocationType.City) {\r\n                    console.log("capturing capital");\r\n                    EventBus.emit(WorldEvents.CapitalCaptured, location);\r\n                }\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionRestorePower() {\r\n        return {\r\n            type: ACTIONS.RestorePower,\r\n            advance: () => {\r\n                this.power = DEFAULT_POWER;\r\n                // console.log(\'Army power restored\', this)\r\n                logger.logArmyRest(this);\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionChooseBetweenWarAndResting() {\r\n        return {\r\n            type: ACTIONS.ChooseRoutine,\r\n            advance: () => {\r\n                const maybeTarget = this.findCapturableLocation();\r\n                if (maybeTarget) {\r\n                    // console.log(this.occupation, this.name, this.home.owner, \'chooses to capture\', maybeTarget.name, maybeTarget)\r\n                    logger.logArmyDecisionCapture(this, maybeTarget);\r\n                    this.actionChangeRoutine(this.getWarRoutine(maybeTarget)).advance();\r\n                }\r\n                else {\r\n                    // console.log(this.occupation, this.name, this.home.owner, \'chooses to return home and regain power\', this.power, this.home)\r\n                    logger.logArmyDecisionRest(this);\r\n                    this.actionChangeRoutine(this.getRegainPowerRoutine()).advance();\r\n                }\r\n            },\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/agents/farmer.ts\n\r\n\r\n\r\n\r\nconst GRAIN_GROWTH_DURATION_TURNS = 9;\r\nvar AgriculturalCycleStage;\r\n(function (AgriculturalCycleStage) {\r\n    AgriculturalCycleStage["Sowing"] = "Sowing";\r\n    AgriculturalCycleStage["Growing"] = "Growing";\r\n    AgriculturalCycleStage["Reaping"] = "Reaping";\r\n    AgriculturalCycleStage["Trading"] = "Trading";\r\n})(AgriculturalCycleStage || (AgriculturalCycleStage = {}));\r\nclass Farmer extends Agent {\r\n    constructor(world, type) {\r\n        super(world, type);\r\n        this.inv.items = [Item.Pitchfork];\r\n        this.cycleStage = AgriculturalCycleStage.Sowing;\r\n    }\r\n    getDefaultRoutine() {\r\n        // ,     ,    \r\n        if (this.home.areas[0] &&\r\n            this.home.areas[0].type === MapAreaType.ArableLand) {\r\n            return [\r\n                {\r\n                    type: ACTIONS.ChooseRoutine,\r\n                    desc: "Choose next routine: sow grain, wait till it grows, reap grain or transfer it",\r\n                    actionBuilder: () => {\r\n                        // return this.actionSelectFarmerRoutine()\r\n                        switch (this.cycleStage) {\r\n                            case AgriculturalCycleStage.Sowing:\r\n                                this.cycleStage = AgriculturalCycleStage.Growing;\r\n                                return this.actionChangeRoutine(this.getGrainGrowingRoutine());\r\n                            case AgriculturalCycleStage.Growing:\r\n                                this.cycleStage = AgriculturalCycleStage.Reaping;\r\n                                return this.actionChangeRoutine(this.getGrainReapingRoutine());\r\n                            case AgriculturalCycleStage.Reaping:\r\n                                this.cycleStage = AgriculturalCycleStage.Trading;\r\n                                return this.actionChangeRoutine(this.getResourceTransferRoutine(["Grain"]));\r\n                            case AgriculturalCycleStage.Trading:\r\n                                this.cycleStage = AgriculturalCycleStage.Sowing;\r\n                                return this.actionChangeRoutine(this.getGrainSowingRoutine());\r\n                            default:\r\n                                break;\r\n                        }\r\n                    },\r\n                },\r\n            ];\r\n        }\r\n        else {\r\n            return super.getDefaultRoutine();\r\n        }\r\n    }\r\n    get cycleStage() {\r\n        return this._cycleStage;\r\n    }\r\n    set cycleStage(v) {\r\n        this._cycleStage = v;\r\n    }\r\n    actionChangeRoutine(routine, condition) {\r\n        return {\r\n            type: ACTIONS.ChangeRoutine,\r\n            desc: "Changing routine if condition allows",\r\n            advance: () => {\r\n                if (!condition || condition()) {\r\n                    this.routine = routine;\r\n                    this.currentActionIdx = 0;\r\n                }\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    getGrainSowingRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel to cultivated area",\r\n                actionBuilder: () => {\r\n                    //          \r\n                    // findNearestTile()      travel\r\n                    const satisfyingTiles = this.getSatisfyingTiles(this.home.areas[0], (t) => t.typeId === TileId.Seeds);\r\n                    const areaTile = this.world.findNearestCell(this.pos, satisfyingTiles);\r\n                    if (areaTile) {\r\n                        return this.actionTravel(areaTile.pos);\r\n                    }\r\n                    else {\r\n                        this.cycleStage = AgriculturalCycleStage.Growing;\r\n                        return this.actionTravel(this.home.pos);\r\n                    }\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.ChangeRoutine,\r\n                desc: "Start growing routine if sowing is finished and we are back home",\r\n                actionBuilder: () => {\r\n                    return this.actionChangeRoutine(this.getGrainGrowingRoutine(), () => this.cycleStage == AgriculturalCycleStage.Growing);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.TransformTile,\r\n                desc: "Sow grain on current tile",\r\n                actionBuilder: () => this.actionSow(),\r\n            },\r\n        ];\r\n    }\r\n    getGrainGrowingRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.ChangeRoutine,\r\n                desc: "Start growing routine if sowing is finished and we are back home",\r\n                actionBuilder: () => {\r\n                    const canHarvest = this.getSatisfyingTiles(this.home.areas[0], (t) => t.typeId === TileId.FieldGrown).length > 0;\r\n                    if (canHarvest) {\r\n                        this.cycleStage == AgriculturalCycleStage.Reaping;\r\n                        return this.actionChangeRoutine(this.getGrainReapingRoutine());\r\n                    }\r\n                    else {\r\n                        return this.actionWait(1);\r\n                    }\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Wait,\r\n                desc: "Wait till grain grows",\r\n                actionBuilder: () => this.actionWait(GRAIN_GROWTH_DURATION_TURNS),\r\n            },\r\n        ];\r\n    }\r\n    getGrainReapingRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel to cultivated area",\r\n                actionBuilder: () => {\r\n                    //          \r\n                    // findNearestTile()      travel\r\n                    const satisfyingTiles = this.getSatisfyingTiles(this.home.areas[0], (t) => t.typeId === TileId.FieldGrown);\r\n                    const areaTile = this.world.findNearestCell(this.pos, satisfyingTiles);\r\n                    if (areaTile) {\r\n                        return this.actionTravel(areaTile.pos);\r\n                    }\r\n                    else {\r\n                        this.cycleStage = AgriculturalCycleStage.Trading;\r\n                        return this.actionTravel(this.home.pos);\r\n                    }\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.ChangeRoutine,\r\n                desc: "Start trading routine if reaping is finished and we are back home",\r\n                actionBuilder: () => {\r\n                    return this.actionChangeRoutine(this.getResourceTransferRoutine(["Grain"]), () => this.cycleStage == AgriculturalCycleStage.Trading);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.TransformTile,\r\n                desc: "Reap grain on current tile",\r\n                actionBuilder: () => this.actionReap(),\r\n            },\r\n        ];\r\n    }\r\n    actionSow() {\r\n        return {\r\n            type: ACTIONS.TransformTile,\r\n            desc: "Sow grain on current tile",\r\n            advance: () => {\r\n                const tile = this.world.getCell(this.pos);\r\n                tile.changeType(TileId.Sprouts);\r\n                this.world.addTimedEffect(400, () => {\r\n                    tile.changeType(TileId.FieldGrown);\r\n                });\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionReap() {\r\n        return {\r\n            type: ACTIONS.TransformTile,\r\n            desc: "Reap grain on current tile",\r\n            advance: () => {\r\n                const tile = this.world.getCell(this.pos);\r\n                tile.changeType(TileId.Seeds);\r\n                this.inv.res.Grain.amount += 2;\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    getSatisfyingTiles(area, condition) {\r\n        return area.data\r\n            .map((c) => this.world.getCell(c))\r\n            .filter((t) => condition(t));\r\n    }\r\n    actionStore(resType, location) {\r\n        return {\r\n            type: ACTIONS.Store,\r\n            advance: () => {\r\n                AgentInventory.transferResource(resType, this.inv, location.inv);\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n    actionRetrieveResource(resType, location) {\r\n        return {\r\n            type: ACTIONS.Retrieve,\r\n            advance: () => {\r\n                AgentInventory.transferResource(resType, location.inv, this.inv);\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/agents/hero.ts\n\r\n\r\n\r\n\r\n\r\nconst MAX_STAMINA = 5;\r\nconst DEFAULT_STEP_TIME = 10; // same as TURN_DURATION\r\nclass Hero extends Agent {\r\n    constructor(world, type, tint) {\r\n        super(world, type, tint);\r\n        this.world = world;\r\n        this.home = null; // heroes are born homeless :-(\r\n        this.pos = { tx: 0, ty: 0 };\r\n        this.inv.money = 1000;\r\n        this.inv.items = [Item.Staff, Item.Knife];\r\n        this.energy = 0;\r\n        this.stepTime = DEFAULT_STEP_TIME;\r\n        this.facing = Direction.Right;\r\n        this.isSprinting = false;\r\n        this.stamina = {\r\n            current: MAX_STAMINA,\r\n            max: MAX_STAMINA,\r\n            sinceLastChange: 0,\r\n            recoveryTimeCost: TURN_DURATION * 2, // for one point\r\n        };\r\n        this.memorizedTiles = [];\r\n        this.visibleTiles = [];\r\n    }\r\n    attemptMove(deltaCoords) {\r\n        const newCoords = {\r\n            tx: this.pos.tx + deltaCoords.tx,\r\n            ty: this.pos.ty + deltaCoords.ty,\r\n        };\r\n        if (this.world.isValidToMoveTo(newCoords)) {\r\n            this.updateFacing(newCoords);\r\n            this.world.setAgentPosition(this, newCoords);\r\n            // Need to store step time before spending stamina\r\n            // As spending stamina can toggle off sprinting and change result of getStepTime()\r\n            const stepTime = this.getStepTime();\r\n            if (this.isSprinting) {\r\n                this.spendStamina();\r\n            }\r\n            if (LOG_SETTINGS.heroMovement) {\r\n                console.log("Hero has moved to: tx, ty, time taken", this.pos.tx, this.pos.ty, stepTime);\r\n            }\r\n            EventBus.emit(WorldEvents.UpdateRequested, stepTime);\r\n        }\r\n    }\r\n    mount() {\r\n        if (this.activeMount) {\r\n            console.error("Hero already mounted");\r\n            return;\r\n        }\r\n        if (!this.inv.mount) {\r\n            console.error("No mount to mount");\r\n            return;\r\n        }\r\n        this.activeMount = this.inv.mount;\r\n        console.log("Hero mounted", this.activeMount);\r\n    }\r\n    dismount() {\r\n        if (!this.activeMount) {\r\n            console.error("Hero isn\'t mounted");\r\n            return;\r\n        }\r\n        if (this.activeMount != this.inv.mount) {\r\n            console.error("Can\'t dismount: hero\'s mount is different");\r\n            return;\r\n        }\r\n        this.activeMount = null;\r\n        console.log("Hero dismounted");\r\n    }\r\n    // aka update timed effects\r\n    operate(dt) {\r\n        this.maybeRecoverStamina(dt);\r\n    }\r\n    updateVision() {\r\n        this.visibleTiles = this.world.getVisionArea(this.pos);\r\n        const newTiles = this.visibleTiles.filter((t) => !this.memorizedTiles.includes(t));\r\n        // Add newly seen locations to journal\r\n        newTiles.forEach((t) => {\r\n            for (const location of t.tileGates.values()) {\r\n                if (!this.journal.didSeeLocation(location)) {\r\n                    this.journal.seeLocation(location);\r\n                }\r\n            }\r\n        });\r\n        this.memorizedTiles = this.memorizedTiles.concat(newTiles);\r\n    }\r\n    updateSpriteVisibility() { }\r\n    /**\r\n     * Stop sprinting or start it if possible. Reads, but doesn\'t affect stamina.\r\n     */\r\n    toggleSprint() {\r\n        if (this.isSprinting) {\r\n            this.isSprinting = false;\r\n            console.log("Sprinting toggled off");\r\n        }\r\n        else {\r\n            if (this.stamina.current > 0) {\r\n                this.isSprinting = true;\r\n                console.log("Sprinting toggled on");\r\n            }\r\n            else {\r\n                console.error("No stamina to start sprinting");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Spend stamina point and toggle off sprinting if out of stamina.\r\n     * Stamina can\'t be negative (resets to zero).\r\n     */\r\n    spendStamina() {\r\n        this.stamina.current--;\r\n        this.stamina.sinceLastChange = 0;\r\n        if (this.stamina.current <= 0) {\r\n            this.stamina.current = 0;\r\n            // Toggle sprinting off if ran out of stamina\r\n            if (this.isSprinting) {\r\n                this.toggleSprint();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Restore one point of stamina for each _recoveryTimeCost_\r\n     * passed since last stamina change\r\n     * @param dt - delta time, amount of ticks the world has advanced\r\n     */\r\n    maybeRecoverStamina(dt) {\r\n        // Can\'t recover while sprinting\r\n        if (this.isSprinting)\r\n            return;\r\n        this.stamina.sinceLastChange += dt;\r\n        while (this.stamina.sinceLastChange >= this.stamina.recoveryTimeCost) {\r\n            if (this.stamina.current < this.stamina.max) {\r\n                this.stamina.current++;\r\n                this.stamina.sinceLastChange -= this.stamina.recoveryTimeCost;\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Return time (in ticks) it takes hero to make a step in the world\r\n     * Currently accounts for mount and sprint\r\n     */\r\n    getStepTime() {\r\n        const mountBonusMultiplier = 1 + (this.activeMount ? this.activeMount.speed / 10 : 0);\r\n        this.stepTime = Math.round(DEFAULT_STEP_TIME / mountBonusMultiplier / (this.isSprinting ? 2 : 1));\r\n        if (LOG_SETTINGS.heroMovement)\r\n            console.log("base step, mount multiplier, sprint, result", DEFAULT_STEP_TIME, mountBonusMultiplier, this.isSprinting, this.stepTime);\r\n        return this.stepTime;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/agents/miner.ts\n\r\n\r\n\r\nclass Miner extends Agent {\r\n    constructor(world, type) {\r\n        super(world, type);\r\n        this.inv.items = [Item.Pickaxe];\r\n    }\r\n    getDefaultRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.Gather,\r\n                desc: "Gather stone from quarry or bronze and iron from mine",\r\n                actionBuilder: () => {\r\n                    return this.actionGatherStoneOrBronzeAndIron();\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.ChangeRoutine,\r\n                desc: "Start transfer routine if enough mined resources are gathered",\r\n                actionBuilder: () => {\r\n                    const totalResources = this.home.getTotalResourceAmount();\r\n                    return this.actionChangeRoutine(this.getResourceTransferRoutine(this.home.getProducedResourceTypes()), () => totalResources >= 100);\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    actionGatherStoneOrBronzeAndIron() {\r\n        return {\r\n            type: ACTIONS.Gather,\r\n            advance: () => {\r\n                switch (this.home.type) {\r\n                    case LocationType.Quarry: {\r\n                        const quarry = this.home;\r\n                        quarry.produceResource();\r\n                        break;\r\n                    }\r\n                    case LocationType.Mine: {\r\n                        const mine = this.home;\r\n                        mine.produceResource();\r\n                        break;\r\n                    }\r\n                    default:\r\n                        console.log(this.info.occupation, this.info.name, "home is not a quarry", this.home);\r\n                        break;\r\n                }\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/agents/ruler.ts\n\r\n\r\n\r\nclass Ruler extends Agent {\r\n    constructor(world, type) {\r\n        super(world, type);\r\n    }\r\n    getDefaultRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.Wait,\r\n                desc: "Wait for some time",\r\n                actionBuilder: () => {\r\n                    return this.actionWait(getRandomInt(4) + 3);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Spawn,\r\n                desc: "Attempt to spawn an army",\r\n                actionBuilder: () => {\r\n                    return this.actionHireArmy();\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    actionHireArmy() {\r\n        return {\r\n            type: ACTIONS.Spawn,\r\n            advance: () => {\r\n                const realm = this.getHomeRealm();\r\n                const armyPrice = DEFAULT_POWER;\r\n                const treasury = Object.values(realm.capital.inv.res);\r\n                const total = treasury.reduce((sum, val) => sum + val.amount, 0);\r\n                const enoughResources = total >= armyPrice;\r\n                const maxArmies = realm.armies.length >= 3;\r\n                if (!maxArmies && enoughResources) {\r\n                    const army = this.world.spawnAgentAtHome("general", this.world, this.home);\r\n                    army.power = armyPrice;\r\n                    this.world.agents.push(army);\r\n                    realm.armies.push(army);\r\n                    let cost = armyPrice;\r\n                    const spendResources = () => {\r\n                        for (const res of treasury) {\r\n                            if (res.amount <= 0) {\r\n                                continue;\r\n                            }\r\n                            res.amount--;\r\n                            cost--;\r\n                            if (cost <= 0)\r\n                                return;\r\n                        }\r\n                    };\r\n                    while (cost > 0)\r\n                        spendResources();\r\n                    // console.log(realm.tag, \'hired an army\', army.name, army.power, army.pos, army)\r\n                    // console.log(realm.tag, \'treasury\', treasury)\r\n                    logger.logArmyCreation(army);\r\n                }\r\n                this.chooseNextAction();\r\n            },\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/model/agents/woodcutter.ts\n\r\n\r\n\r\nclass Woodcutter extends Agent {\r\n    constructor(world, type) {\r\n        super(world, type);\r\n        this.inv.items = [Item.Axe];\r\n    }\r\n    getDefaultRoutine() {\r\n        return [\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel to the nearest tree",\r\n                actionBuilder: () => {\r\n                    const dest = this.findNearestTree();\r\n                    return this.actionTravel(dest.pos);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Gather,\r\n                desc: "Gather wood",\r\n                actionBuilder: () => {\r\n                    return this.actionGather("Wood");\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Travel,\r\n                desc: "Travel home",\r\n                actionBuilder: () => {\r\n                    const dest = this.home.gates[0];\r\n                    return this.actionTravel(dest);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Store,\r\n                desc: "Store gathered resources",\r\n                actionBuilder: () => {\r\n                    return this.actionStore("Wood", this.home);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.Wait,\r\n                desc: "Wait for some time",\r\n                actionBuilder: () => {\r\n                    return this.actionWait(getRandomInt(4) + 3);\r\n                },\r\n            },\r\n            {\r\n                type: ACTIONS.ChangeRoutine,\r\n                desc: "Start transfer routine if enough wood is gathered",\r\n                actionBuilder: () => {\r\n                    return this.actionChangeRoutine(this.getResourceTransferRoutine(["Wood"]), () => this.home.inv.res.Wood.amount > 10);\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    findNearestTree() {\r\n        return this.world.findNearestTree(this.pos);\r\n    }\r\n    actionGather(resType) {\r\n        return {\r\n            type: ACTIONS.Gather,\r\n            advance: () => {\r\n                if (this.inv.res[resType].amount < 10) {\r\n                    this.inv.res[resType].amount++;\r\n                }\r\n                else {\r\n                    this.chooseNextAction();\r\n                }\r\n            },\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/configs/agents_data.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst AGENT_TYPES = (/* unused pure expression or super */ null && ([\r\n    "adventurer",\r\n    "general",\r\n    "bandit",\r\n    "farmer",\r\n    "guard",\r\n    "miner",\r\n    "ruler",\r\n    "trader",\r\n    "wizard",\r\n    "woodcutter",\r\n]));\r\nconst AGENTS_DATA = {\r\n    adventurer: {\r\n        occupation: "adeventurer",\r\n        spriteId: 41,\r\n        class: Hero,\r\n    },\r\n    bandit: {\r\n        occupation: "bandit",\r\n        spriteId: 46,\r\n        class: Agent,\r\n    },\r\n    farmer: {\r\n        occupation: "farmer",\r\n        spriteId: 52,\r\n        class: Farmer,\r\n    },\r\n    guard: {\r\n        occupation: "guard",\r\n        spriteId: 49,\r\n        class: Agent,\r\n    },\r\n    miner: {\r\n        occupation: "miner",\r\n        spriteId: 53,\r\n        class: Miner,\r\n    },\r\n    trader: {\r\n        occupation: "trader",\r\n        spriteId: 42,\r\n        class: Agent,\r\n    },\r\n    wizard: {\r\n        occupation: "wizard",\r\n        spriteId: 50,\r\n        class: Agent,\r\n    },\r\n    woodcutter: {\r\n        occupation: "woodcutter",\r\n        spriteId: 48,\r\n        class: Woodcutter,\r\n    },\r\n    ruler: {\r\n        occupation: "ruler",\r\n        spriteId: 48,\r\n        class: Ruler,\r\n    },\r\n    general: {\r\n        occupation: "general",\r\n        spriteId: 45,\r\n        class: Army,\r\n    },\r\n};\r\n\n;// CONCATENATED MODULE: ./ts/mechanisms/camera.ts\n\r\nclass Camera {\r\n    constructor(options, tx, ty) {\r\n        this.options = options;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n    }\r\n    resetTo(object) {\r\n        this.tx = object.pos.tx - Math.floor(this.options.width / 2);\r\n        this.ty = object.pos.ty - Math.floor(this.options.height / 2);\r\n    }\r\n    setTarget(target) {\r\n        this.target = target;\r\n        this.resetTo(target);\r\n    }\r\n    followTarget() {\r\n        this.follow(this.target);\r\n    }\r\n    follow(object) {\r\n        const pastScrollAreaRight = object.pos.tx >= this.tx + this.options.width - this.options.zone;\r\n        if (pastScrollAreaRight) {\r\n            this.scrollRight();\r\n        }\r\n        const pastScrollAreaBottom = object.pos.ty >= this.ty + this.options.height - this.options.zone;\r\n        if (pastScrollAreaBottom) {\r\n            this.scrollDown();\r\n        }\r\n        const pastScrollAreaLeft = object.pos.tx < this.tx + this.options.zone;\r\n        if (pastScrollAreaLeft) {\r\n            this.scrollLeft();\r\n        }\r\n        const pastScrollAreaTop = object.pos.ty < this.ty + this.options.zone;\r\n        if (pastScrollAreaTop) {\r\n            this.scrollUp();\r\n        }\r\n    }\r\n    scrollRight() {\r\n        if (this.tx < WORLD_WIDTH - this.options.width) {\r\n            this.tx++;\r\n        }\r\n    }\r\n    scrollDown() {\r\n        if (this.ty < WORLD_HEIGHT - this.options.height) {\r\n            this.ty++;\r\n        }\r\n    }\r\n    scrollLeft() {\r\n        if (this.tx > 0) {\r\n            this.tx--;\r\n        }\r\n    }\r\n    scrollUp() {\r\n        if (this.ty > 0) {\r\n            this.ty--;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/configs/dialogs/city.ts\nvar DialogIdCity;\r\n(function (DialogIdCity) {\r\n    DialogIdCity[DialogIdCity["Dialogue"] = 0] = "Dialogue";\r\n    DialogIdCity[DialogIdCity["Capital"] = 1] = "Capital";\r\n    DialogIdCity[DialogIdCity["Market"] = 2] = "Market";\r\n    DialogIdCity[DialogIdCity["Tavern"] = 3] = "Tavern";\r\n    DialogIdCity[DialogIdCity["Palace"] = 4] = "Palace";\r\n    DialogIdCity[DialogIdCity["HorseMerchant"] = 5] = "HorseMerchant";\r\n    DialogIdCity[DialogIdCity["ResourceTrader"] = 6] = "ResourceTrader";\r\n    DialogIdCity[DialogIdCity["Toolsmith"] = 7] = "Toolsmith";\r\n    DialogIdCity[DialogIdCity["TavernKeeper"] = 8] = "TavernKeeper";\r\n    DialogIdCity[DialogIdCity["Ruler"] = 9] = "Ruler";\r\n    DialogIdCity[DialogIdCity["Meal"] = 10] = "Meal";\r\n    DialogIdCity[DialogIdCity["News"] = 11] = "News";\r\n    DialogIdCity[DialogIdCity["Jobs"] = 12] = "Jobs";\r\n    DialogIdCity[DialogIdCity["Fealty"] = 13] = "Fealty";\r\n    DialogIdCity[DialogIdCity["TroopsPurchase"] = 14] = "TroopsPurchase";\r\n    DialogIdCity[DialogIdCity["GameOfUr"] = 15] = "GameOfUr";\r\n})(DialogIdCity || (DialogIdCity = {}));\r\nconst mainDesc = "The capital city. A lot of things could be found here.\\nEach for its own price, of course.";\r\nconst actionDesc = "\\nYou spend half an hour exploring the narrow streets.\\nAt least you\'ve found a tavern and a market.";\r\nconst promptDesc = "\\nWhat\'s your next step?";\r\nconst CITY_MESSAGES = {\r\n    [DialogIdCity.Capital]: {\r\n        id: DialogIdCity.Capital,\r\n        name: "The capital",\r\n        text: mainDesc + "\\n" + actionDesc + "\\n" + promptDesc,\r\n        options: [\r\n            { action: "Visit the market", id: DialogIdCity.Market },\r\n            { action: "Visit the tavern", id: DialogIdCity.Tavern },\r\n            { action: "Visit the palace", id: DialogIdCity.Palace },\r\n        ],\r\n    },\r\n    [DialogIdCity.Market]: {\r\n        id: DialogIdCity.Market,\r\n        name: "The market",\r\n        text: "The market looks quite modest.\\nYou notice just a few traders.",\r\n        options: [\r\n            { action: "Horse merchant", id: DialogIdCity.HorseMerchant },\r\n            { action: "Resource trader", id: DialogIdCity.ResourceTrader },\r\n            { action: "Toolsmith", id: DialogIdCity.Toolsmith },\r\n            { action: "Leave", id: DialogIdCity.Capital },\r\n        ],\r\n    },\r\n    [DialogIdCity.Tavern]: {\r\n        id: DialogIdCity.Tavern,\r\n        name: "The tavern",\r\n        text: "A tavern like many others you\'ve seen before.\\nMaybe just a little bit tidier.\\nMost tables aren\'t occupied.\\nThe tavern keeper looks at you appraisingly.",\r\n        options: [\r\n            { action: "Talk to tavern keeper", id: DialogIdCity.TavernKeeper },\r\n            { action: "Order a meal", id: DialogIdCity.Meal },\r\n            { action: "Play boardgames", id: DialogIdCity.GameOfUr },\r\n            { action: "Leave", id: DialogIdCity.Capital },\r\n        ],\r\n    },\r\n    [DialogIdCity.Palace]: {\r\n        id: DialogIdCity.Palace,\r\n        name: "A ruler\'s palace",\r\n        text: "A ruler\'s palace",\r\n        options: [\r\n            { action: "Talk to the ruler", id: DialogIdCity.Ruler },\r\n            { action: "Purchase troops", id: DialogIdCity.TroopsPurchase },\r\n            { action: "Leave", id: DialogIdCity.Capital },\r\n        ],\r\n    },\r\n    [DialogIdCity.HorseMerchant]: {\r\n        id: DialogIdCity.HorseMerchant,\r\n        name: "Horse merchant",\r\n        options: [\r\n            { action: "Purchase", id: DialogIdCity.Market },\r\n            { action: "Leave", id: DialogIdCity.Market },\r\n        ],\r\n    },\r\n    [DialogIdCity.ResourceTrader]: {\r\n        id: DialogIdCity.ResourceTrader,\r\n        name: "Resource trader",\r\n        options: [],\r\n    },\r\n    [DialogIdCity.Toolsmith]: {\r\n        id: DialogIdCity.Toolsmith,\r\n        name: "Toolsmith",\r\n        options: [\r\n            { action: "Purchase", id: DialogIdCity.Market },\r\n            { action: "Leave", id: DialogIdCity.Market },\r\n        ],\r\n    },\r\n    [DialogIdCity.TavernKeeper]: {\r\n        id: DialogIdCity.TavernKeeper,\r\n        name: "Tavern keeper",\r\n        text: "A bulky man in his late 40\'s. He welcomes you readily.",\r\n        options: [\r\n            /*{ action: \'Order a meal\', id: 5 },*/\r\n            { action: "Ask about recent news", id: DialogIdCity.News },\r\n            { action: "Ask about jobs", id: DialogIdCity.Jobs },\r\n            { action: "Leave", id: DialogIdCity.Capital },\r\n        ],\r\n    },\r\n    [DialogIdCity.Ruler]: {\r\n        id: DialogIdCity.Ruler,\r\n        name: "Ruler of this kingdom",\r\n        text: "Ruler of this kingdom",\r\n        options: [\r\n            { action: "Swear fealty", id: DialogIdCity.Fealty /* disabled: true */ },\r\n            { action: "Leave", id: DialogIdCity.Palace },\r\n        ],\r\n    },\r\n    [DialogIdCity.Fealty]: {\r\n        id: DialogIdCity.Fealty,\r\n        name: "An oath of fealty",\r\n        text: "You\'ve sworn fealty to this kingdom.",\r\n        options: [{ action: "Leave", id: DialogIdCity.Palace }],\r\n    },\r\n    [DialogIdCity.TroopsPurchase]: {\r\n        id: DialogIdCity.TroopsPurchase,\r\n        name: "Purchase troops",\r\n        text: "",\r\n        options: [],\r\n    },\r\n    [DialogIdCity.Meal]: {\r\n        id: DialogIdCity.Meal,\r\n        name: "A meal",\r\n        text: "You order a hearty meal.\\nSoon you are served a bowl of braised pork ribs with vegetables\\nand spicy herbs. Simple yet delicious.",\r\n        options: [{ action: "Eat your portion", id: DialogIdCity.Tavern }],\r\n    },\r\n    [DialogIdCity.News]: {\r\n        id: DialogIdCity.News,\r\n        name: "Recent news",\r\n        text: "There are rumors of runaway convicts hiding\\nin the forest across the river.\\nThe merchants are worried.",\r\n        options: [{ action: "Noted", id: DialogIdCity.TavernKeeper }],\r\n    },\r\n    [DialogIdCity.Jobs]: {\r\n        id: DialogIdCity.Jobs,\r\n        name: "Jobs",\r\n        text: "Some merchants might be willing to hire a guard.\\n\\nAlso, the fighters guild is recruiting new members.\\nAsk the guild master.",\r\n        options: [{ action: "Leave", id: DialogIdCity.TavernKeeper }],\r\n    },\r\n    [DialogIdCity.GameOfUr]: {\r\n        id: DialogIdCity.GameOfUr,\r\n        name: "The Game of Ur",\r\n        text: "",\r\n        options: [],\r\n    },\r\n};\r\n\n;// CONCATENATED MODULE: ./ts/views/components/option_list.ts\n\r\n\r\n\r\n\r\n\r\nclass OptionList extends Container/* Container */.W2 {\r\n    constructor(addToParent) {\r\n        super();\r\n        this.disabled = false;\r\n        this.actions = [];\r\n        this.selector = new Selection();\r\n        this.addChild(this.selector);\r\n        this.optionTexts = new Container/* Container */.W2();\r\n        this.addChild(this.optionTexts);\r\n        if (addToParent) {\r\n            addToParent.addChild(this);\r\n        }\r\n    }\r\n    disable() {\r\n        this.disabled = true;\r\n        this.selector.visible = false;\r\n    }\r\n    enable() {\r\n        this.disabled = false;\r\n        this.selector.visible = true;\r\n    }\r\n    addOptions(msgs) {\r\n        msgs.forEach((msg) => {\r\n            this.addOption(msg);\r\n        });\r\n        this.repositionSelector();\r\n    }\r\n    addOption(msg) {\r\n        const text = new StyledText(msg, fontStyleCenter);\r\n        text.position.x = (gameApp.renderer.width - text.width) / 2;\r\n        text.position.y = (this.optionTexts.children.length + 7) * STEP_SIZE;\r\n        this.optionTexts.addChild(text);\r\n    }\r\n    removeOption(option) {\r\n        throw new Error("Not implemented");\r\n    }\r\n    addActions(actions) {\r\n        this.actions = [...actions];\r\n    }\r\n    repositionSelector() {\r\n        if (this.optionTexts.children.length == 0) {\r\n            this.selector.visible = false;\r\n            return;\r\n        }\r\n        const line = this.optionTexts.children[this.selector.row];\r\n        this.selector.x = line.x - line.width / 2;\r\n        this.selector.y = STEP_SIZE * (7 + this.selector.row) - 20;\r\n    }\r\n    selectorUp() {\r\n        if (this.disabled)\r\n            return;\r\n        this.selector.row--;\r\n        if (this.selector.row < 0) {\r\n            this.selector.row = this.optionTexts.children.length - 1;\r\n        }\r\n        this.repositionSelector();\r\n    }\r\n    selectorDown() {\r\n        if (this.disabled)\r\n            return;\r\n        this.selector.row++;\r\n        if (this.selector.row >= this.optionTexts.children.length) {\r\n            this.selector.row = 0;\r\n        }\r\n        this.repositionSelector();\r\n    }\r\n    selectCurrent() {\r\n        const action = this.actions[this.selector.row];\r\n        if (!action) {\r\n            console.error(`No action matching option ${this.selector.row}`);\r\n            return;\r\n        }\r\n        action();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/traders/horse.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass HorseTrader extends BaseGameView {\r\n    constructor(client, market) {\r\n        super("Horse Trader");\r\n        new Background(this);\r\n        this.client = client;\r\n        this.market = market;\r\n        this.deals = new Container/* Container */.W2();\r\n        this.addChild(this.deals);\r\n        this.initTraderInterface();\r\n        // this.loadMessage(message)\r\n        this.goods = [];\r\n        this.goodProperties.visible = true;\r\n        const horseColors = [\r\n            PALETTE.GRAY,\r\n            PALETTE.ORANGE,\r\n            PALETTE.BROWN,\r\n            PALETTE.SEABLUE,\r\n        ];\r\n        const horseNames = ["gray", "chestnut", "bay", "black"];\r\n        for (let i = 0; i < 4; i++) {\r\n            const horse = new Sprite/* Sprite */.j(tileset[44]);\r\n            horse.tint = horseColors[i];\r\n            horse.scale.set(globals_SCALE);\r\n            horse.x = (6 + i) * (STEP_SIZE + 4) - 20;\r\n            horse.y = 4 * STEP_SIZE;\r\n            this.goods.push({\r\n                name: `A ${horseNames[i]} horse`,\r\n                cost: 800 + i * 200,\r\n                speed: 10 * i,\r\n                invSlot: "mount",\r\n            });\r\n            this.deals.addChild(horse);\r\n        }\r\n        this.repositionSelection();\r\n        this.updateGoodProperties();\r\n        new Instructions(INSTRUCTION_TEXT_DEFAULT, this);\r\n    }\r\n    purchase() {\r\n        const purchase = this.goods[this.itemSelector.col];\r\n        if (!purchase) {\r\n            console.error("Nothing to purchase in this slot");\r\n            return;\r\n        }\r\n        if (purchase.cost > this.client.inv.money) {\r\n            console.error("Not enough money");\r\n            return;\r\n        }\r\n        this.client.inv.money -= purchase.cost;\r\n        this.client.inv[purchase.invSlot] = purchase;\r\n        this.goods[this.itemSelector.col] = null;\r\n        this.deals.removeChildAt(this.itemSelector.col);\r\n        this.updateGoodProperties();\r\n    }\r\n    initTraderInterface() {\r\n        this.goodProperties = new Text("", fontStyleCenter);\r\n        this.addChild(this.goodProperties);\r\n        this.goodProperties.y = 2 * STEP_SIZE;\r\n        this.goodProperties.x = 8 * STEP_SIZE - this.goodProperties.width / 2;\r\n        this.itemSelector = new Selection(globals_battleset[7]);\r\n        this.addChild(this.itemSelector);\r\n    }\r\n    repositionSelection() {\r\n        this.itemSelector.x = (STEP_SIZE + 4) * (6 + this.itemSelector.col) - 20;\r\n        this.itemSelector.y = STEP_SIZE * 4;\r\n    }\r\n    updateGoodProperties() {\r\n        const good = this.goods[this.itemSelector.col];\r\n        if (good) {\r\n            const priceText = `${good.name}\\nPrice: ${good.cost}\\n`;\r\n            const speedText = good.speed ? "Speed: " + good.speed : "";\r\n            this.goodProperties.text = priceText + speedText;\r\n        }\r\n        else {\r\n            this.goodProperties.text = "";\r\n        }\r\n        this.goodProperties.x = 8 * STEP_SIZE - this.goodProperties.width / 2;\r\n    }\r\n    assignControls(controls) {\r\n        super.assignControls(controls);\r\n        this.clearControls(controls);\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n        const o = new OptionList(this);\r\n        o.addOptions([["Purchase"], ["Leave"]]);\r\n        controls.left.press = () => {\r\n            this.cursorLeft();\r\n        };\r\n        controls.right.press = () => {\r\n            this.cursorRight();\r\n        };\r\n        this.controls.up.press = () => {\r\n            o.selectorUp();\r\n        };\r\n        this.controls.down.press = () => {\r\n            o.selectorDown();\r\n        };\r\n        const actions = [this.purchase.bind(this), this.closeScene.bind(this)];\r\n        controls.space.press = () => {\r\n            actions[o.selector.row]();\r\n        };\r\n    }\r\n    cursorLeft() {\r\n        this.itemSelector.col--;\r\n        if (this.itemSelector.col < 0) {\r\n            this.itemSelector.col = this.goods.length - 1;\r\n        }\r\n        this.repositionSelection();\r\n        this.updateGoodProperties();\r\n    }\r\n    cursorRight() {\r\n        this.itemSelector.col++;\r\n        if (this.itemSelector.col >= this.goods.length) {\r\n            this.itemSelector.col = 0;\r\n        }\r\n        this.repositionSelection();\r\n        this.updateGoodProperties();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/price_label.ts\n\r\n\r\n\r\nclass PriceLabel extends Container/* Container */.W2 {\r\n    constructor(value = 0) {\r\n        super();\r\n        this.value = value;\r\n        this.text = new Text(value, fontStyleCenter);\r\n        this.text.style.fill = PALETTE.YELLOW;\r\n        this.icon = new Sprite/* Sprite */.j(resourceset[5]);\r\n        this.icon.tint = PALETTE.YELLOW;\r\n        Utils.alignCenterHoriz([this.icon, this.text]);\r\n        Utils.spaceHoriz([this.text, this.icon], 4);\r\n        this.addChild(this.text);\r\n        this.addChild(this.icon);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/resource_icon.ts\n\r\n\r\nclass ResourceIcon extends Sprite/* Sprite */.j {\r\n    constructor(type) {\r\n        super();\r\n        this.type = type;\r\n        const spriteData = RES_TILES[this.type];\r\n        this.texture = resourceset[spriteData.id];\r\n        this.tint = spriteData.color;\r\n        this.scale.set(globals_SCALE);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/client_resource.ts\n\r\n\r\n\r\n\r\n\r\n// ToDo: reactive label/value pair\r\nclass ClientResource extends Container/* Container */.W2 {\r\n    constructor(type, client, market) {\r\n        super();\r\n        this.amountInitial = 0;\r\n        this.amountUpdated = 0;\r\n        this.amountChanged = 0;\r\n        this.price = 0;\r\n        this.type = type;\r\n        this.amountInitial = client.inv.res[type].amount;\r\n        this.price = market.inv.res[type].buy;\r\n        this.amountInitialLabel = new Text(this.amountInitial, fontStyleCenter);\r\n        this.icon = new ResourceIcon(this.type);\r\n        this.priceLabel = new PriceLabel(this.price);\r\n        const objects = [this.amountInitialLabel, this.icon, this.priceLabel];\r\n        Utils.alignCenterVert(objects);\r\n        Utils.spaceVert(objects, 4);\r\n        objects.forEach((o) => this.addChild(o));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/market_resource.ts\n\r\n\r\n\r\n\r\n\r\nclass MarketResource extends Container/* Container */.W2 {\r\n    constructor(type, market) {\r\n        super();\r\n        this.amountInitial = 0;\r\n        this.amountUpdated = 0;\r\n        this.amountChanged = 0;\r\n        this.price = 0;\r\n        this.type = type;\r\n        this.amountInitial = market.inv.res[type].amount;\r\n        this.price = market.inv.res[type].sell;\r\n        this.amountInitialLabel = new Text(this.amountInitial, fontStyleCenter);\r\n        this.icon = new ResourceIcon(this.type);\r\n        this.priceLabel = new PriceLabel(this.price);\r\n        const objects = [this.amountInitialLabel, this.icon, this.priceLabel];\r\n        Utils.alignCenterVert(objects);\r\n        Utils.spaceVert(objects, 4);\r\n        objects.forEach((o) => this.addChild(o));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/transferred_resource.ts\n\r\n\r\n\r\n\r\n\r\n\r\nclass TransferredResource extends Container/* Container */.W2 {\r\n    constructor(type) {\r\n        super();\r\n        this.amount = 0;\r\n        this.price = 0;\r\n        this.direction = TradeDirection.NotTraded;\r\n        this.type = type;\r\n        this.amountLabel = new Text(this.amount, fontStyleCenter);\r\n        this.icon = new ResourceIcon(this.type);\r\n        this.priceLabel = new PriceLabel(this.price);\r\n        const objects = [this.amountLabel, this.icon, this.priceLabel];\r\n        Utils.alignCenterVert(objects);\r\n        Utils.spaceVert(objects, 4);\r\n        objects.forEach((o) => this.addChild(o));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/traded_resource.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar TradeDirection;\r\n(function (TradeDirection) {\r\n    TradeDirection[TradeDirection["NotTraded"] = 0] = "NotTraded";\r\n    TradeDirection[TradeDirection["ClientToMarket"] = 1] = "ClientToMarket";\r\n    TradeDirection[TradeDirection["MarketToClient"] = 2] = "MarketToClient";\r\n})(TradeDirection || (TradeDirection = {}));\r\nclass TradedResource extends Container/* Container */.W2 {\r\n    constructor(type, clientData, marketData) {\r\n        super();\r\n        this.type = type;\r\n        const client = new ClientResource(this.type, clientData, marketData);\r\n        const markerA = new DirectionMarker(TradeDirection.NotTraded);\r\n        const transfer = new TransferredResource(this.type);\r\n        const markerB = new DirectionMarker(TradeDirection.NotTraded);\r\n        const market = new MarketResource(this.type, marketData);\r\n        const objects = [client, markerA, transfer, markerB, market];\r\n        Utils.alignCenterHoriz(objects);\r\n        Utils.spaceHoriz(objects, STEP_SIZE * 1.5);\r\n        objects.forEach((o) => this.addChild(o));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/direction_marker.ts\n\r\n\r\n\r\nclass DirectionMarker extends Sprite/* Sprite */.j {\r\n    constructor(direciton) {\r\n        super();\r\n        switch (direciton) {\r\n            case TradeDirection.ClientToMarket:\r\n            case TradeDirection.MarketToClient:\r\n                this.texture = tileset[2];\r\n                break;\r\n            case TradeDirection.NotTraded:\r\n                this.texture = tileset[1];\r\n                break;\r\n        }\r\n        this.scale.set(globals_SCALE);\r\n        this.tint = PALETTE.GRAY;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/gold_trade.ts\n\r\n\r\n\r\n\r\n\r\nclass GoldTrade extends Container/* Container */.W2 {\r\n    constructor(clientData, marketData) {\r\n        super();\r\n        const client = this.createGoldDisplay(true, clientData);\r\n        const markerA = new DirectionMarker(TradeDirection.NotTraded);\r\n        const transfer = this.createTransferDisplay();\r\n        const markerB = new DirectionMarker(TradeDirection.NotTraded);\r\n        const market = this.createGoldDisplay(false, marketData);\r\n        const objects = [client, markerA, transfer, markerB, market];\r\n        Utils.alignCenterHoriz(objects);\r\n        Utils.spaceHoriz(objects, STEP_SIZE * 1.5);\r\n        objects.forEach((o) => this.addChild(o));\r\n    }\r\n    createTransferDisplay() {\r\n        const c = new Container/* Container */.W2();\r\n        const amount = new Text(0, fontStyleCenter);\r\n        amount.style.fill = PALETTE.YELLOW;\r\n        const bg = new Graphics/* Graphics */.T()\r\n            .beginFill(PALETTE.VOID)\r\n            .drawRect(0, 0, STEP_SIZE, STEP_SIZE)\r\n            .endFill();\r\n        c.addChild(bg);\r\n        c.addChild(amount);\r\n        Utils.alignCenterHoriz([amount, bg]);\r\n        Utils.alignCenterVert([amount, bg]);\r\n        return c;\r\n    }\r\n    createGoldDisplay(isClient, data) {\r\n        const c = new Container/* Container */.W2();\r\n        const labels = new Container/* Container */.W2();\r\n        const bg = new Graphics/* Graphics */.T()\r\n            .beginFill(PALETTE.VOID)\r\n            .drawRect(0, 0, STEP_SIZE * 3, STEP_SIZE);\r\n        const amount = new Text(data.inv.money, isClient ? fontStyleRight : fontStyleLeft);\r\n        const change = new Text(0, isClient ? fontStyleRight : fontStyleLeft);\r\n        isClient\r\n            ? Utils.alignRight([bg, amount, change])\r\n            : Utils.alignLeft([bg, amount, change]);\r\n        Utils.spaceVert([amount, change], 4);\r\n        labels.addChild(bg);\r\n        labels.addChild(amount);\r\n        labels.addChild(change);\r\n        const icon = new Sprite/* Sprite */.j(resourceset[5]);\r\n        icon.tint = PALETTE.YELLOW;\r\n        icon.scale.set(globals_SCALE);\r\n        c.addChild(icon);\r\n        c.addChild(labels);\r\n        Utils.spaceHoriz(isClient ? [labels, icon] : [icon, labels], 8);\r\n        Utils.alignCenterHoriz([icon, labels]);\r\n        return c;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/traders/resource.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ResourceTrader extends BaseGameView {\r\n    constructor(client, market) {\r\n        super("Trading");\r\n        this.client = client;\r\n        this.market = market;\r\n        console.log("Trading between", client, market);\r\n        const bg = new Background(this);\r\n        const gold = new GoldTrade(client, market);\r\n        Utils.centerHoriz(gold, this);\r\n        this.addChild(gold);\r\n        gold.y += STEP_SIZE / 2;\r\n        const rows = RESOURCE_TYPES.map((r) => {\r\n            const row = new TradedResource(r, client, market);\r\n            Utils.centerHoriz(row, bg);\r\n            this.addChild(row);\r\n            return row;\r\n        });\r\n        Utils.spaceVert([gold, ...rows], STEP_SIZE / 2);\r\n        this.scroll = new ScrollList(rows, rows[0].y, rows[3].y + rows[3].height);\r\n        this.scroll.positionArrows(bg);\r\n        this.addChild(this.scroll);\r\n    }\r\n    assignControls(controls) {\r\n        this.clearControls(controls);\r\n        controls.up.press = () => {\r\n            this.scroll.scrollUp();\r\n        };\r\n        controls.w.press = () => {\r\n            this.scroll.scrollUp();\r\n        };\r\n        controls.down.press = () => {\r\n            this.scroll.scrollDown();\r\n        };\r\n        controls.s.press = () => {\r\n            this.scroll.scrollDown();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/traders/tool.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst TOOL_SLOTS = ["axe", "pickaxe"];\r\nclass ToolTrader extends BaseGameView {\r\n    constructor(client, market) {\r\n        super("Tool Trader");\r\n        this.client = client;\r\n        this.market = market;\r\n        new Background(this);\r\n        this.deals = new Container/* Container */.W2();\r\n        this.addChild(this.deals);\r\n        this.initTraderInterface();\r\n        this.goods = [];\r\n        this.goodProperties.visible = true;\r\n        const itemNames = ["An axe", "A pickaxe"];\r\n        // Create goods and deals\r\n        for (let i = 0; i < TOOL_SLOTS.length; i++) {\r\n            if (client.inv[TOOL_SLOTS[i]])\r\n                continue;\r\n            this.goods.push({\r\n                name: `${itemNames[i]}`,\r\n                cost: 200,\r\n                invSlot: TOOL_SLOTS[i],\r\n            });\r\n            const tool = new Sprite/* Sprite */.j(tileset[55 + i]);\r\n            tool.tint = PALETTE.ORANGE;\r\n            tool.scale.set(globals_SCALE);\r\n            tool.x = (6 + i) * (STEP_SIZE + 4) - 20;\r\n            tool.y = 4 * STEP_SIZE;\r\n            this.deals.addChild(tool);\r\n        }\r\n        this.options = new OptionList(this);\r\n        if (this.deals.children.length > 0) {\r\n            this.options.addOptions([["Purchase"], ["Leave"]]);\r\n            this.actions = [this.purchase.bind(this), this.closeScene.bind(this)];\r\n        }\r\n        else {\r\n            this.options.addOptions([["Leave"]]);\r\n            this.actions = [this.closeScene.bind(this)];\r\n        }\r\n        this.updateCursor();\r\n        new Instructions(INSTRUCTION_TEXT_DEFAULT, this);\r\n    }\r\n    initTraderInterface() {\r\n        this.goodProperties = new Text("", fontStyleCenter);\r\n        this.addChild(this.goodProperties);\r\n        this.goodProperties.y = 2 * STEP_SIZE;\r\n        this.goodProperties.x = 8 * STEP_SIZE - this.goodProperties.width / 2;\r\n        this.itemSelector = new Selection(globals_battleset[7]);\r\n        this.addChild(this.itemSelector);\r\n    }\r\n    repositionSelection() {\r\n        const existingDeal = this.deals.children[this.itemSelector.col];\r\n        if (existingDeal)\r\n            this.itemSelector.x = existingDeal.x;\r\n        this.itemSelector.y = STEP_SIZE * 4;\r\n    }\r\n    updateGoodProperties() {\r\n        const good = this.goods[this.itemSelector.col];\r\n        if (good) {\r\n            const priceText = `${good.name}\\nPrice: ${good.cost}\\n`;\r\n            const speedText = good.speed ? "Speed: " + good.speed : "";\r\n            this.goodProperties.text = priceText + speedText;\r\n        }\r\n        else {\r\n            this.goodProperties.text = "";\r\n        }\r\n        this.goodProperties.x = 8 * STEP_SIZE - this.goodProperties.width / 2;\r\n    }\r\n    purchase() {\r\n        const purchase = this.goods[this.itemSelector.col];\r\n        if (!purchase) {\r\n            console.error("Nothing to purchase in this slot");\r\n            return;\r\n        }\r\n        if (purchase.cost > this.client.inv.money) {\r\n            console.error("Not enough money");\r\n            return;\r\n        }\r\n        this.client.inv.money -= purchase.cost;\r\n        this.client.inv[purchase.invSlot] = purchase;\r\n        this.goods.splice(this.itemSelector.col, 1);\r\n        this.deals.removeChildAt(this.itemSelector.col);\r\n        this.itemSelector.col = Math.min(this.itemSelector.col, this.goods.length - 1);\r\n        this.updateCursor();\r\n    }\r\n    assignControls(controls) {\r\n        super.assignControls(controls);\r\n        this.clearControls(controls);\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n        controls.left.press = () => {\r\n            this.cursorLeft();\r\n        };\r\n        controls.right.press = () => {\r\n            this.cursorRight();\r\n        };\r\n        this.controls.up.press = () => {\r\n            this.options.selectorUp();\r\n        };\r\n        this.controls.down.press = () => {\r\n            this.options.selectorDown();\r\n        };\r\n        controls.space.press = () => {\r\n            this.actions[this.options.selector.row]();\r\n        };\r\n    }\r\n    updateCursor() {\r\n        if (this.goods.length < 1) {\r\n            this.itemSelector.visible = false;\r\n            this.goodProperties.visible = false;\r\n            if (this.options.optionTexts.children.length > 1)\r\n                this.options.removeOption("Purchase");\r\n        }\r\n        else {\r\n            this.itemSelector.visible = true;\r\n            this.goodProperties.visible = true;\r\n        }\r\n        this.repositionSelection();\r\n        this.updateGoodProperties();\r\n    }\r\n    cursorLeft() {\r\n        this.itemSelector.col--;\r\n        if (this.itemSelector.col < 0) {\r\n            this.itemSelector.col = this.goods.length - 1;\r\n        }\r\n        this.updateCursor();\r\n    }\r\n    cursorRight() {\r\n        this.itemSelector.col++;\r\n        if (this.itemSelector.col >= this.goods.length) {\r\n            this.itemSelector.col = 0;\r\n        }\r\n        this.repositionSelection();\r\n        this.updateGoodProperties();\r\n        this.updateCursor();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/types.ts\nconst objectEntries = (obj) => {\r\n    return Object.entries(obj);\r\n};\r\n\n;// CONCATENATED MODULE: ./ts/views/components/panel.ts\n\r\n\r\n\r\nclass Panel extends Container/* Container */.W2 {\r\n    constructor(title, label) {\r\n        super({ label });\r\n        this.setWidthShare(1 / 3);\r\n        this.addTitle(title);\r\n    }\r\n    setWidthShare(share) {\r\n        this.widthShare = share;\r\n        // this.width = gameApp.screen.width * share;\r\n        this.boundsArea = new Rectangle/* Rectangle */.A(0, 0, gameApp.screen.width * share, gameApp.screen.height);\r\n        // console.log(gameApp.screen.width, this.width);\r\n    }\r\n    addTitle(text) {\r\n        this.title = new Text({ text, style: fontStyleCenter });\r\n        this.title.anchor.set(0.5, 0);\r\n        this.addChild(this.title);\r\n        this.title.position.set(this.width / 2, this.height * 0.2);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/counted_item.ts\n\r\n\r\nclass CountedItem extends Container/* Container */.W2 {\r\n    constructor(texture, amount) {\r\n        super();\r\n        this.sprite = new Sprite/* Sprite */.j(texture);\r\n        this.sprite.scale.set(globals_SCALE);\r\n        this.counter = new Text({ text: amount, style: fontStyleCenter });\r\n        this.counter.anchor.set(0.5, 0);\r\n        this.counter.position.set(this.sprite.width / 2, this.sprite.height + 6);\r\n        this.addChild(this.sprite);\r\n        this.addChild(this.counter);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/trading/troop_purchase_item.ts\n\r\n\r\n\r\n\r\nclass TroopPurchaseItem extends Container/* Container */.W2 {\r\n    constructor() {\r\n        super();\r\n        this.counterValue = 0;\r\n        this.icon = new AgentSprite(AGENTS_DATA.guard.spriteId, Direction.Left, 0xffffff);\r\n        this.addChild(this.icon);\r\n        this.counterLabel = new Text({\r\n            text: this.counterValue,\r\n            style: fontStyleRight,\r\n        });\r\n        this.addChild(this.counterLabel);\r\n        this.counterLabel.position.set(this.icon.x + this.icon.width, 0);\r\n    }\r\n    incrementCounter() {\r\n        this.counterValue++;\r\n        this.counterLabel.text = this.counterValue;\r\n    }\r\n    decrementCounter() {\r\n        this.counterValue = Math.max(0, this.counterValue - 1);\r\n        this.counterLabel.text = this.counterValue;\r\n    }\r\n    updateCounter(newValue) {\r\n        this.counterValue = newValue;\r\n        this.counterLabel.text = this.counterValue;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/troops_purchase.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TroopsPurchase extends BaseGameView {\r\n    constructor(hero) {\r\n        super("Troops Purchase");\r\n        this.activePanelIdx = 0;\r\n        this.roster = [];\r\n        new Background(this);\r\n        this.panels = {\r\n            actions: new OptionList(this),\r\n            inventory: new Panel("Your resources", "resources"),\r\n            roster: new Panel("Units", "roster"),\r\n            army: new Panel("Your troops", "army"),\r\n        };\r\n        this.panels.roster.x = (this.width - this.panels.roster.width) / 2; // center\r\n        this.panels.army.x = this.width - this.panels.army.width; // right border\r\n        const resources = [];\r\n        for (const [res, { amount }] of objectEntries(hero.inv.res)) {\r\n            const resItem = new CountedItem(resourceset[RES_TILES[res].id], amount);\r\n            resources.push(resItem);\r\n        }\r\n        const grid = Utils.arrangeInGrid(resources, this.panels.inventory, 16);\r\n        grid.position.set((this.panels.inventory.width - grid.width) / 2, this.panels.inventory.height * 0.3);\r\n        this.panels.inventory.addChild(grid);\r\n        const troopsList = new Container/* Container */.W2();\r\n        const troop = new TroopPurchaseItem();\r\n        troopsList.addChild(troop);\r\n        troopsList.position.set((this.panels.roster.width - troopsList.width) / 2, this.panels.roster.height * 0.3);\r\n        this.panels.roster.addChild(troopsList);\r\n        this.roster.push(troop);\r\n        this.activePanel = "actions";\r\n        this.addChild(this.panels.inventory);\r\n        this.addChild(this.panels.roster);\r\n        this.addChild(this.panels.army);\r\n    }\r\n    assignControls(controls) {\r\n        this.controls = controls;\r\n        this.clearControls(controls);\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n        this.panels.actions.addOptions([["Purchase"], ["Leave"]]);\r\n        this.controls.tab.press = () => {\r\n            this.activePanelIdx = (this.activePanelIdx + 1) % 2; // actions or roster\r\n            if (this.activePanelIdx == 0)\r\n                this.panels.actions.enable();\r\n            else\r\n                this.panels.actions.disable();\r\n            console.log(`Active panel: ${this.activePanelIdx}`);\r\n        };\r\n        this.controls.left.press = () => {\r\n            // this.cursorLeft();\r\n            if (this.activePanelIdx == 1) {\r\n                this.roster[0].decrementCounter();\r\n                console.log("decreased unit amount");\r\n            }\r\n        };\r\n        this.controls.right.press = () => {\r\n            // this.cursorRight();\r\n            if (this.activePanelIdx == 1) {\r\n                this.roster[0].incrementCounter();\r\n                console.log("increased unit amount");\r\n            }\r\n        };\r\n        this.controls.up.press = () => {\r\n            this.panels.actions.selectorUp();\r\n        };\r\n        this.controls.down.press = () => {\r\n            this.panels.actions.selectorDown();\r\n        };\r\n        const actions = [this.closeScene.bind(this), this.closeScene.bind(this)];\r\n        this.controls.space.press = () => {\r\n            actions[this.panels.actions.selector.row]();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/ur.ts\n/**\r\n * https://en.wikipedia.org/wiki/Royal_Game_of_Ur\r\n * https://www.youtube.com/watch?v=WZskjLq040I\r\n */\r\n\r\n\r\n\r\n\r\n\r\nclass GameOfUr extends Scene {\r\n    constructor(initialMessage) {\r\n        super(initialMessage);\r\n        new Background(this);\r\n        // Complex board\r\n        /*this.tiles = [\r\n                    5, 4, 3, 4, -1, -1, 5, 0, // p1\r\n                    2, 3, 0, 5, 3, 1, 4, 3, // common\r\n                    5, 4, 3, 4, -1, -1, 5, 0 // p2\r\n                ]*/\r\n        // Simple board\r\n        this.tiles = [\r\n            4,\r\n            1,\r\n            1,\r\n            1,\r\n            -1,\r\n            -1,\r\n            4,\r\n            1,\r\n            1,\r\n            1,\r\n            1,\r\n            4,\r\n            1,\r\n            1,\r\n            1,\r\n            1,\r\n            4,\r\n            1,\r\n            1,\r\n            1,\r\n            -1,\r\n            -1,\r\n            4,\r\n            1, // p2\r\n        ];\r\n        this.pieces = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\r\n        this.pieceGFX = [];\r\n        this.diceOverlay = [];\r\n        /**\r\n         * NOW ADD THE CURSOR\r\n         */\r\n        const xOffs = this.width / 2 - 3.5 * STEP_SIZE;\r\n        const yOffs = STEP_SIZE * 4.5;\r\n        for (let i = 0; i < this.tiles.length; i++) {\r\n            const field = this.tiles[i];\r\n            if (field != -1) {\r\n                // Add only existing fields\r\n                const tileSprite = new Sprite/* Sprite */.j(boardset[field]);\r\n                tileSprite.position.set((i % 8) * globals_SPACED_STEP + xOffs, Math.floor(i / 8) * globals_SPACED_STEP + yOffs);\r\n                tileSprite.scale.set(globals_SCALE);\r\n                this.addChild(tileSprite);\r\n            }\r\n        }\r\n        for (let i = 0; i < this.pieces.length; i++) {\r\n            const s = new Sprite/* Sprite */.j(boardset[i < 7 ? 7 : 8]); // first seven are dark, last seven are light\r\n            s.position.set((i % 7) * globals_SPACED_STEP + xOffs + globals_SPACED_STEP * 0.5, globals_SPACED_STEP + yOffs + (i < 7 ? STEP_SIZE * 2.5 : -STEP_SIZE * 2.5));\r\n            s.scale.set(globals_SCALE);\r\n            this.pieceGFX.push[s];\r\n            this.addChild(s);\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const diceX = xOffs - globals_SPACED_STEP * 2;\r\n            const diceY = yOffs + i * globals_SPACED_STEP - 0.5 * globals_SPACED_STEP;\r\n            const d = new Sprite/* Sprite */.j(boardset[9]);\r\n            d.scale.set(globals_SCALE);\r\n            d.position.set(diceX, diceY);\r\n            this.addChild(d);\r\n            const over = new Sprite/* Sprite */.j(boardset[9]); // Dice overlay\r\n            over.scale.set(globals_SCALE);\r\n            over.position.set(diceX, diceY);\r\n            this.addChild(over);\r\n            const over2 = new Sprite/* Sprite */.j(boardset[9]); // Dice overlay 2\r\n            over2.scale.set(globals_SCALE);\r\n            over2.position.set(diceX, diceY);\r\n            this.addChild(over2);\r\n            this.diceOverlay.push({ first: over, second: over2 });\r\n        }\r\n        this.instructions = new Message(this, 11 * STEP_SIZE);\r\n        this.instructions.addText(["Space to roll dice, Esc to leave"], fontStyleCenter);\r\n    }\r\n    assignControls(controls) {\r\n        controls.left.press = () => { };\r\n        controls.right.press = () => { };\r\n        controls.up.press = () => { };\r\n        controls.down.press = () => { };\r\n        controls.space.press = () => {\r\n            this.rollDice();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n        controls.m.press = () => { };\r\n    }\r\n    rollDice() {\r\n        let count = 0;\r\n        const pairs = [\r\n            [10, 11],\r\n            [10, 12],\r\n            [10, 13],\r\n            [11, 12],\r\n            [11, 13],\r\n            [12, 13],\r\n        ];\r\n        for (let i = 0; i < 4; i++) {\r\n            const pair = getRandomInt(pairs.length);\r\n            this.diceOverlay[i].first.texture = boardset[pairs[pair][0]];\r\n            this.diceOverlay[i].second.texture = boardset[pairs[pair][1]];\r\n            if (pair < 3) {\r\n                count++;\r\n            }\r\n        }\r\n        console.log("Moves", count);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/city.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass City extends Scene {\r\n    constructor(hero, location) {\r\n        super(CITY_MESSAGES[DialogIdCity.Capital], STEP_SIZE * 2);\r\n        this.hero = hero;\r\n        this.location = location;\r\n        this.initActionHandlers();\r\n    }\r\n    //#region Controls\r\n    assignControls(controls) {\r\n        super.assignControls(controls);\r\n        controls.space.press = () => {\r\n            this.select();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n    //#endregion\r\n    select() {\r\n        const options = this.message.options;\r\n        if (options.length > 0) {\r\n            const id = options[this.optionSelector.row].id;\r\n            const newMessage = CITY_MESSAGES[id];\r\n            if (this.actionHandlers[id]) {\r\n                this.actionHandlers[id](newMessage);\r\n            }\r\n            else {\r\n                // Default navigation\r\n                const sceneOptions = CITY_MESSAGES[id];\r\n                console.log("SceneId", id, "sceneOptions", sceneOptions);\r\n                this.loadMessage(sceneOptions);\r\n            }\r\n        }\r\n    }\r\n    initActionHandlers() {\r\n        this.actionHandlers = {\r\n            [DialogIdCity.ResourceTrader]: this.tradeResources.bind(this),\r\n            [DialogIdCity.Toolsmith]: this.tradeTools.bind(this),\r\n            [DialogIdCity.HorseMerchant]: this.tradeHorses.bind(this),\r\n            [DialogIdCity.Fealty]: this.swearFealty.bind(this),\r\n            [DialogIdCity.GameOfUr]: this.playGameOfUr.bind(this),\r\n            [DialogIdCity.TroopsPurchase]: this.purchaseTroops.bind(this),\r\n        };\r\n    }\r\n    tradeHorses(message) {\r\n        this.openScene(new HorseTrader(this.hero, this.location));\r\n    }\r\n    tradeTools(message) {\r\n        this.openScene(new ToolTrader(this.hero, this.location));\r\n    }\r\n    tradeResources(message) {\r\n        this.openScene(new ResourceTrader(this.hero, this.location));\r\n    }\r\n    swearFealty(message) {\r\n        this.loadMessage(message);\r\n        this.hero.home = this.location;\r\n        this.hero.info.allegiance = this.location.owner;\r\n        console.log("Hero\'s new home", this.hero.home);\r\n        CITY_MESSAGES[DialogIdCity.Ruler].options.find((option) => option.id == DialogIdCity.Fealty).disabled = true;\r\n    }\r\n    playGameOfUr(message) {\r\n        this.openScene(new GameOfUr(message));\r\n    }\r\n    purchaseTroops(message) {\r\n        this.openScene(new TroopsPurchase(this.hero));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/dialogue.ts\n\r\n\r\n\r\n\r\n\r\nvar DialogIdDialogue;\r\n(function (DialogIdDialogue) {\r\n    DialogIdDialogue[DialogIdDialogue["Intro"] = 0] = "Intro";\r\n    DialogIdDialogue[DialogIdDialogue["Name"] = 1] = "Name";\r\n    DialogIdDialogue[DialogIdDialogue["Occupation"] = 2] = "Occupation";\r\n    DialogIdDialogue[DialogIdDialogue["Home"] = 3] = "Home";\r\n})(DialogIdDialogue || (DialogIdDialogue = {}));\r\nclass Dialogue extends Scene {\r\n    constructor(hero, agent) {\r\n        super({\r\n            id: DialogIdDialogue.Intro,\r\n            name: "Dialogue intro",\r\n            options: [\r\n                {\r\n                    action: "Ask their name",\r\n                    id: DialogIdDialogue.Name,\r\n                    handler: () => {\r\n                        console.log("Asking agent their name");\r\n                        hero.journal.agents.get(agent).name = agent.info.name;\r\n                        this.clearInfo();\r\n                        this.displayInfo(hero, agent);\r\n                    },\r\n                },\r\n                {\r\n                    action: "Ask what they do",\r\n                    id: DialogIdDialogue.Occupation,\r\n                    handler: () => {\r\n                        console.log("Asking agent their occupation");\r\n                        hero.journal.agents.get(agent).occupation = agent.info.occupation;\r\n                        this.clearInfo();\r\n                        this.displayInfo(hero, agent);\r\n                    },\r\n                },\r\n                {\r\n                    action: "Ask about their home",\r\n                    id: DialogIdDialogue.Home,\r\n                    handler: () => {\r\n                        console.log("Asking agent their home");\r\n                        const home = agent.info.home;\r\n                        hero.journal.agents.get(agent).home = home;\r\n                        const homeInfo = hero.journal.getLocationInfo(home);\r\n                        if (!homeInfo.dwellers) {\r\n                            homeInfo.dwellers = new Set();\r\n                        }\r\n                        homeInfo.dwellers.add(agent);\r\n                        hero.journal.locations.get(home).owner = home.owner;\r\n                        this.clearInfo();\r\n                        this.displayInfo(hero, agent);\r\n                    },\r\n                },\r\n            ],\r\n        });\r\n        this.displayInfo(hero, agent);\r\n    }\r\n    clearInfo() {\r\n        if (this.infoContainer) {\r\n            this.removeChild(this.infoContainer);\r\n            this.infoContainer = null;\r\n        }\r\n    }\r\n    displayInfo(hero, agent) {\r\n        const info = hero.journal.getAgentInfo(agent);\r\n        const formatPos = (l) => {\r\n            const routeHome = hero.world.getNewRoute(hero, l.pos);\r\n            console.log("Route to agent\'s home", routeHome);\r\n            const routeLength = routeHome.path.length - 1;\r\n            const dx = routeHome.path[routeLength].tx - hero.pos.tx;\r\n            const dy = routeHome.path[routeLength].ty - hero.pos.ty;\r\n            const dirY = dy > 0 ? "south" : "north";\r\n            const dirX = dx > 0 ? "east" : "west";\r\n            const answer = `${routeLength} days away to the ${dirY}${dirX}`;\r\n            return answer; // + `\\nWhich belongs to the ${Realm.getName(l.owner)}`\r\n        };\r\n        const occ = info.occupation.length > 0\r\n            ? [\r\n                `They are a ${info.occupation}. `,\r\n                `They serve a `,\r\n                {\r\n                    msg: Realm.getName(agent.home.owner),\r\n                    color: Realm.getRealmColor(agent.home.owner),\r\n                },\r\n                ".",\r\n            ]\r\n            : [`You know nothing about them.`];\r\n        const homeInfo = info.home\r\n            ? `They live in a ` + info.home.name + " " + formatPos(info.home) + "."\r\n            : "";\r\n        this.infoContainer = new StyledText([\r\n            `You see `,\r\n            { msg: info.name, color: info.appearance.tint },\r\n            ".",\r\n            "\\n",\r\n            ...occ,\r\n            "\\n",\r\n            homeInfo,\r\n            // `They ignore you.`\r\n        ], fontStyleCenter);\r\n        this.infoContainer.position.set(gameApp.renderer.width / 2 - this.infoContainer.width / 2, gameApp.renderer.height / 3 - STEP_SIZE * 2);\r\n        this.addChild(this.infoContainer);\r\n    }\r\n    assignControls(controls) {\r\n        super.assignControls(controls);\r\n        controls.space.press = () => {\r\n            this.select();\r\n        };\r\n    }\r\n    select() {\r\n        const options = this.message.options;\r\n        if (options.length > 0) {\r\n            const option = options[this.optionSelector.row];\r\n            if (option.handler) {\r\n                option.handler();\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/configs/skills_data.ts\nconst ACTION = {\r\n    ADVANCE: "ADVANCE",\r\n    ATTACK: "ATTACK",\r\n    WAIT: "WAIT",\r\n    BLOCK: "BLOCK",\r\n};\r\nconst BASIC = [\r\n    {\r\n        id: 0,\r\n        data: [ACTION.ADVANCE],\r\n        stats: {},\r\n        name: "Movement",\r\n    },\r\n    {\r\n        id: 1,\r\n        data: [ACTION.WAIT, ACTION.ATTACK, ACTION.BLOCK],\r\n        stats: {},\r\n        name: "Stab",\r\n    },\r\n    {\r\n        id: 2,\r\n        data: [ACTION.BLOCK, ACTION.WAIT],\r\n        stats: {},\r\n        name: "Block",\r\n    },\r\n    {\r\n        id: 3,\r\n        data: [ACTION.WAIT],\r\n        stats: {},\r\n        name: "Wait",\r\n    },\r\n];\r\nconst FIGHTER = [\r\n    {\r\n        id: 0,\r\n        data: [ACTION.ADVANCE, ACTION.ATTACK, ACTION.WAIT],\r\n        stats: {},\r\n    },\r\n    {\r\n        id: 1,\r\n        data: [ACTION.ATTACK, ACTION.BLOCK],\r\n        stats: {},\r\n    },\r\n    {\r\n        id: 2,\r\n        data: [ACTION.ADVANCE, ACTION.WAIT],\r\n        stats: {},\r\n    },\r\n    {\r\n        id: 3,\r\n        data: [ACTION.WAIT],\r\n        stats: {},\r\n    },\r\n];\r\nconst GUARD = [\r\n    {\r\n        id: 0,\r\n        data: [ACTION.ATTACK, ACTION.WAIT, ACTION.ATTACK],\r\n        stats: {},\r\n    },\r\n    {\r\n        id: 1,\r\n        data: [ACTION.ADVANCE],\r\n        stats: {},\r\n    },\r\n    {\r\n        id: 2,\r\n        data: [ACTION.WAIT, ACTION.BLOCK],\r\n        stats: {},\r\n    },\r\n];\r\nfunction assessSkills(skillList) {\r\n    for (const skill of skillList) {\r\n        const skillStat = {\r\n            move: 0,\r\n            aggro: 0,\r\n            defence: 0,\r\n            duration: 0,\r\n            waiting: 0,\r\n            payload: 0,\r\n        };\r\n        for (const action of skill.data) {\r\n            skillStat.duration++;\r\n            switch (action) {\r\n                case ACTION.ATTACK:\r\n                    skillStat.aggro++;\r\n                    skillStat.payload++;\r\n                    break;\r\n                case ACTION.BLOCK:\r\n                    skillStat.defence++;\r\n                    skillStat.payload++;\r\n                    break;\r\n                case ACTION.WAIT:\r\n                    skillStat.waiting++;\r\n                    skillStat.payload--;\r\n                    break;\r\n                case ACTION.ADVANCE:\r\n                    skillStat.move++;\r\n                    break;\r\n                default:\r\n                    console.error("Unknown action!", action);\r\n                    break;\r\n            }\r\n        }\r\n        skill.stats = skillStat;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/battle.ts\n\r\n\r\n\r\n\r\n\r\n// NPC AI combat styles\r\nconst STYLES = {\r\n    AGGRO: "AGGRO",\r\n    DEFENCE: "DEFENCE",\r\n    RANDOM: "RANDOM",\r\n};\r\n// UI constants\r\nconst offsetX = STEP_SIZE * 2;\r\nconst offsetY = STEP_SIZE * 6;\r\nclass Battle extends BaseGameView {\r\n    constructor(hero) {\r\n        super("Battle");\r\n        // Some battle state\r\n        this.step = 0;\r\n        this.activeSkill = null;\r\n        // Background fill\r\n        const bg = new Graphics/* Graphics */.T();\r\n        bg.beginFill(PALETTE.VOID);\r\n        bg.drawRect(0, 0, 16 * STEP_SIZE, 12 * STEP_SIZE);\r\n        bg.endFill();\r\n        this.addChild(bg);\r\n        // Setup combat line\r\n        const LINE_LENGTH = 11;\r\n        this.cells = [];\r\n        for (let i = 0; i < LINE_LENGTH; i++) {\r\n            const cell = new Sprite/* Sprite */.j(globals_battleset[5]);\r\n            cell.x = offsetX + i * SPACED_STEP;\r\n            cell.y = 4 * STEP_SIZE;\r\n            cell.scale.set(globals_SCALE);\r\n            this.cells.push(cell);\r\n            this.addChild(cell);\r\n        }\r\n        // Setup fighters\r\n        this.player = new Container/* Container */.W2();\r\n        this.enemy = new Container/* Container */.W2();\r\n        const playerBody = new Sprite/* Sprite */.j(hero.sprite.texture);\r\n        playerBody.tint = PALETTE.RED;\r\n        const enemyBody = new Sprite/* Sprite */.j(tileset[13]);\r\n        this.player.addChild(playerBody);\r\n        this.enemy.addChild(enemyBody);\r\n        playerBody.scale.set(globals_SCALE);\r\n        enemyBody.anchor.set(1, 0);\r\n        enemyBody.scale.set(-globals_SCALE, globals_SCALE);\r\n        this.player.health = 5;\r\n        this.enemy.health = 5;\r\n        this.placeAtCell(this.player, 3);\r\n        this.placeAtCell(this.enemy, 7);\r\n        this.addChild(this.player);\r\n        this.addChild(this.enemy);\r\n        // Fighters skills data\r\n        this.player.skills = JSON.parse(JSON.stringify(BASIC)); // Making a deep copy\r\n        this.enemy.skills = JSON.parse(JSON.stringify(BASIC));\r\n        assessSkills(this.enemy.skills);\r\n        this.enemy.style = STYLES.AGGRO;\r\n        // UI elements\r\n        this.cursor = new Selection();\r\n        this.cursor.x = offsetX - SPACED_STEP;\r\n        this.cursor.y = offsetY;\r\n        this.addChild(this.cursor);\r\n        this.hintText = new Text("Up/Down to select skill\\nEnter to apply\\nSpace to retreat", fontStyleCenter);\r\n        this.hintText.position.set(8 * STEP_SIZE - this.hintText.width / 2, 10 * STEP_SIZE + 24);\r\n        this.addChild(this.hintText);\r\n        this.selection = new Sprite/* Sprite */.j(globals_battleset[7]);\r\n        this.selection.scale.set(globals_SCALE);\r\n        this.selection.alpha = 0;\r\n        // Health indicators\r\n        this.playerHealth = new Container/* Container */.W2();\r\n        this.enemyHealth = new Container/* Container */.W2();\r\n        this.playerHealth.x = this.player.x + 3;\r\n        this.playerHealth.y = this.player.y - 48 - 9 - 9;\r\n        this.player.healthUI = this.playerHealth;\r\n        this.enemyHealth.x = this.enemy.x + 3;\r\n        this.enemyHealth.y = this.enemy.y - 48 - 9 - 9;\r\n        this.enemy.healthUI = this.enemyHealth;\r\n        this.player.addChild(this.playerHealth);\r\n        this.enemy.addChild(this.enemyHealth);\r\n        for (let i = 0; i < this.player.health; i++) {\r\n            const g = new Graphics/* Graphics */.T();\r\n            g.beginFill(PALETTE.RED);\r\n            g.drawRect(9 * i, 50, 6, 6);\r\n            g.endFill();\r\n            this.playerHealth.addChild(g);\r\n        }\r\n        for (let i = 0; i < this.enemy.health; i++) {\r\n            const g = new Graphics/* Graphics */.T();\r\n            g.beginFill(PALETTE.RED);\r\n            g.drawRect(9 * i, 50, 6, 6);\r\n            g.endFill();\r\n            this.enemyHealth.addChild(g);\r\n        }\r\n        this.addChild(this.playerHealth);\r\n        this.addChild(this.enemyHealth);\r\n        // Skill icons\r\n        for (let row = 0; row < this.player.skills.length; row++) {\r\n            const s = this.player.skills[row];\r\n            for (let col = 0; col < s.data.length; col++) {\r\n                const action = s.data[col];\r\n                const icon = new Sprite/* Sprite */.j(this.getActionTexture(action));\r\n                icon.scale.set(globals_SCALE);\r\n                icon.x = offsetX + col * SPACED_STEP;\r\n                icon.y = offsetY + row * SPACED_STEP;\r\n                this.addChild(icon);\r\n            }\r\n        }\r\n        for (let row = 0; row < this.enemy.skills.length; row++) {\r\n            const s = this.enemy.skills[row];\r\n            for (let col = 0; col < s.data.length; col++) {\r\n                const action = s.data[col];\r\n                const icon = new Sprite/* Sprite */.j(globals_battleset[4]);\r\n                icon.scale.set(globals_SCALE);\r\n                // let icon = new PIXI.Sprite(battleset[action]);\r\n                // icon.anchor.set(1, 0);\r\n                // icon.scale.set(-3, 3);\r\n                icon.x = offsetX + (LINE_LENGTH - 1) * SPACED_STEP - col * SPACED_STEP;\r\n                icon.y = offsetY + row * SPACED_STEP;\r\n                this.addChild(icon);\r\n            }\r\n        }\r\n        this.player.lastAction = null;\r\n        this.enemy.lastAction = null;\r\n        this.player.lastActionGfx = new Sprite/* Sprite */.j(globals_battleset[5]);\r\n        this.player.lastActionGfx.scale.set(globals_SCALE);\r\n        this.enemy.lastActionGfx = new Sprite/* Sprite */.j(globals_battleset[5]);\r\n        this.enemy.lastActionGfx.anchor.set(1, 0);\r\n        this.enemy.lastActionGfx.scale.set(-globals_SCALE, globals_SCALE);\r\n        this.placeAtGrid(this.player.lastActionGfx, 4, 0);\r\n        this.placeAtGrid(this.enemy.lastActionGfx, 6, 0);\r\n        this.addChild(this.player.lastActionGfx);\r\n        this.addChild(this.enemy.lastActionGfx);\r\n        // This should be on top of skill icons\r\n        this.addChild(this.selection);\r\n    }\r\n    placeAtGrid(sprite, gx, gy) {\r\n        sprite.position.set(gx * SPACED_STEP + offsetX, gy * SPACED_STEP + offsetY);\r\n    }\r\n    assignControls(controls) {\r\n        this.clearControls(controls);\r\n        controls.up.press = () => {\r\n            this.cursorUp();\r\n        };\r\n        controls.down.press = () => {\r\n            this.cursorDown();\r\n        };\r\n        controls.enter.press = () => {\r\n            this.advance();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n    cursorUp() {\r\n        if (this.player.activeSkill)\r\n            return;\r\n        this.cursor.row--;\r\n        this.selection.alpha = 0;\r\n        if (this.cursor.row < 0) {\r\n            this.cursor.row = this.player.skills.length - 1;\r\n        }\r\n        this.cursor.y = offsetY + this.cursor.row * SPACED_STEP;\r\n    }\r\n    cursorDown() {\r\n        if (this.player.activeSkill)\r\n            return;\r\n        this.cursor.row++;\r\n        this.selection.alpha = 0;\r\n        if (this.cursor.row >= this.player.skills.length) {\r\n            this.cursor.row = 0;\r\n        }\r\n        this.cursor.y = offsetY + this.cursor.row * SPACED_STEP;\r\n    }\r\n    advance() {\r\n        if (this.isOver)\r\n            return;\r\n        this.step++;\r\n        console.group(`Turn ${this.step}`);\r\n        const skill = this.player.skills[this.cursor.row];\r\n        if (this.player.activeSkill) {\r\n            this.player.activeSkill.step++;\r\n            console.log(`Player continues skill: ${skill.name}, step ${this.player.activeSkill.step}`);\r\n            this.placeSelector(this.selection, this.player.activeSkill.step, this.cursor.row);\r\n            this.playerAction(skill, this.player.activeSkill.step);\r\n        }\r\n        else {\r\n            this.player.activeSkill = skill;\r\n            this.player.activeSkill.step = 0;\r\n            console.log(`Player starts skill: ${skill.name} (row ${this.cursor.row})`);\r\n            this.cursor.alpha = 0;\r\n            this.selection.alpha = 1;\r\n            this.placeSelector(this.selection, this.player.activeSkill.step, this.cursor.row);\r\n            this.playerAction(skill, this.player.activeSkill.step);\r\n        }\r\n        if (this.player.activeSkill.step == skill.data.length - 1) {\r\n            console.log(`Player finishes skill: ${skill.name} (row ${this.cursor.row})`);\r\n            this.player.activeSkill = null;\r\n            if (!this.isOver)\r\n                this.cursor.alpha = 1;\r\n        }\r\n        if (this.isOver)\r\n            return;\r\n        this.enemyThink();\r\n        this.enemyAct();\r\n        console.groupEnd();\r\n    }\r\n    getActionTexture(action) {\r\n        switch (action) {\r\n            case ACTION.ATTACK:\r\n                return globals_battleset[1];\r\n            case ACTION.BLOCK:\r\n                return globals_battleset[3];\r\n            case ACTION.WAIT:\r\n                return globals_battleset[2];\r\n            case ACTION.ADVANCE:\r\n                return globals_battleset[0];\r\n            default:\r\n                console.error("Unknown action!");\r\n        }\r\n    }\r\n    placeSelector(selector, gx, gy) {\r\n        selector.x = offsetX + gx * SPACED_STEP;\r\n        selector.y = offsetY + gy * SPACED_STEP;\r\n    }\r\n    enemyThink() {\r\n        if (this.enemy.activeSkill) {\r\n            console.log(`Enemy continues skill: ${this.enemy.activeSkill.name}, step ${this.enemy.activeSkill.step}`);\r\n            return;\r\n        }\r\n        const distance = this.enemy.cell - this.player.cell;\r\n        const hpDiff = this.enemy.health - this.player.health;\r\n        this.enemy.activeSkill = this.getBestSkill((skillStat) => {\r\n            //return getRandomInt(0, this.enemy.skills.length)\r\n            // return skillStat.defence * 10 - skillStat.duration\r\n            return (skillStat.move * (distance - getRandomIntFromRange(2, 3)) +\r\n                skillStat.aggro * (-(distance - 1) + getRandomIntFromRange(0, 2)) +\r\n                skillStat.defence * (-(distance - 1) + getRandomIntFromRange(1, 4)) -\r\n                skillStat.duration +\r\n                skillStat.payload);\r\n        });\r\n        this.enemy.activeSkill.step = 0;\r\n        console.log(`Enemy starts skill: ${this.enemy.activeSkill.name}`);\r\n        /*\r\n            if (distance > 2) {\r\n                this.enemy.activeSkill = this.getBestSkill(skillStat => {\r\n                    //return skillStat.move * 10 + skillStat.duration * -1\r\n                    return getRandomInt(0, this.enemy.skills.length)\r\n                });\r\n                console.log(`Best skill`, this.enemy.activeSkill);\r\n                this.enemy.activeSkill.step = 0;\r\n            } else {\r\n                this.enemy.activeSkill = this.enemy.skills[0];\r\n                this.enemy.activeSkill.step = 0;\r\n            }\r\n            */\r\n    }\r\n    getBestSkill(formula) {\r\n        let maxScore = -99;\r\n        const bestSkill = [this.enemy.skills[0]];\r\n        for (const skill of this.enemy.skills) {\r\n            const score = formula(skill.stats);\r\n            if (score > maxScore) {\r\n                maxScore = score;\r\n                bestSkill[0] = skill;\r\n            }\r\n            else if (score == maxScore) {\r\n                bestSkill.push(skill);\r\n            }\r\n            //console.log(`id: ${skill.name}, score: ${score}`)\r\n        }\r\n        return bestSkill[getRandomIntFromRange(0, bestSkill.length - 1)];\r\n    }\r\n    enemyAct() {\r\n        const action = this.enemy.activeSkill.data[this.enemy.activeSkill.step];\r\n        this.enemy.lastActionGfx.texture = this.getActionTexture(action);\r\n        this.enemy.lastAction = action;\r\n        console.log(`Enemy action: ${action}`);\r\n        switch (action) {\r\n            case ACTION.ATTACK:\r\n                this.attackCell(this.enemy, this.enemy.cell - 1);\r\n                break;\r\n            case ACTION.BLOCK:\r\n                break;\r\n            case ACTION.WAIT:\r\n                break;\r\n            case ACTION.ADVANCE:\r\n                this.placeAtCell(this.enemy, this.enemy.cell - 1);\r\n                break;\r\n            default:\r\n                console.error("Enemy: UNKNOWN ACTION!");\r\n                break;\r\n        }\r\n        if (this.enemy.activeSkill.step == this.enemy.activeSkill.data.length - 1) {\r\n            console.log(`Enemy finishes skill: ${this.enemy.activeSkill.name}`);\r\n            this.enemy.activeSkill = null;\r\n        }\r\n        else {\r\n            this.enemy.activeSkill.step++;\r\n        }\r\n    }\r\n    playerAction(skill, step) {\r\n        const action = skill.data[step];\r\n        this.player.lastActionGfx.texture = this.getActionTexture(action);\r\n        this.player.lastAction = action;\r\n        console.log(`Player action: ${action}`);\r\n        switch (action) {\r\n            case ACTION.ATTACK:\r\n                this.attackCell(this.player, this.player.cell + 1);\r\n                break;\r\n            case ACTION.BLOCK:\r\n                break;\r\n            case ACTION.WAIT:\r\n                break;\r\n            case ACTION.ADVANCE:\r\n                this.placeAtCell(this.player, this.player.cell + 1);\r\n                break;\r\n            default:\r\n                console.error("Player: UNKNOWN ACTION!");\r\n                break;\r\n        }\r\n    }\r\n    placeAtCell(actor, index) {\r\n        if (this.player.cell == index || this.enemy.cell == index)\r\n            // Occupied\r\n            return;\r\n        actor.x = this.cells[index].x + 3;\r\n        actor.y = this.cells[index].y + 3;\r\n        actor.cell = index;\r\n        if (actor.healthUI)\r\n            actor.healthUI.x = actor.x;\r\n    }\r\n    attackCell(actor, index) {\r\n        const targetIsEnemy = actor.cell == this.player.cell;\r\n        const target = targetIsEnemy ? this.enemy : this.player;\r\n        if (target.cell == index) {\r\n            if (target.lastAction == ACTION.BLOCK) {\r\n                console.log(targetIsEnemy\r\n                    ? "Your attack has been blocked"\r\n                    : "You block an attack");\r\n                return;\r\n            }\r\n            targetIsEnemy\r\n                ? this.enemyHealth.removeChildAt(0)\r\n                : this.playerHealth.removeChildAt(this.playerHealth.children.length - 1);\r\n            target.health--;\r\n            if (target.health <= 0) {\r\n                this.isOver = true;\r\n                this.cursor.alpha = 0;\r\n                this.selection.alpha = 0;\r\n                const overText = new Text(`YOU ${targetIsEnemy ? "WON" : "LOST"}`, fontStyleCenter);\r\n                this.hintText.text = "Press Esc to leave";\r\n                this.hintText.y += 24;\r\n                this.hintText.x = 8 * STEP_SIZE - this.hintText.width / 2;\r\n                overText.style.fontSize = 32;\r\n                overText.position.set(8 * STEP_SIZE - overText.width / 2, 2 * STEP_SIZE);\r\n                this.addChild(overText);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/choice_view.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ChoiceView extends BaseGameView {\r\n    constructor(options, actions) {\r\n        super("Choice");\r\n        new Background(this);\r\n        const m = new Message(this, STEP_SIZE * 3);\r\n        m.addText(["Multiple things you can do here.\\nWhat is your choice?"], fontStyleCenter);\r\n        this.options = new OptionList(this);\r\n        this.actions = actions;\r\n        this.options.addOptions(options);\r\n        new Instructions(INSTRUCTION_TEXT_DEFAULT, this);\r\n    }\r\n    assignControls(controls) {\r\n        this.clearControls(controls);\r\n        controls.up.press = () => {\r\n            this.options.selectorUp();\r\n        };\r\n        controls.down.press = () => {\r\n            this.options.selectorDown();\r\n        };\r\n        controls.w.press = () => {\r\n            this.options.selectorUp();\r\n        };\r\n        controls.s.press = () => {\r\n            this.options.selectorDown();\r\n        };\r\n        controls.space.press = () => {\r\n            this.selectCurrent();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n    selectCurrent() {\r\n        this.closeScene();\r\n        this.actions[this.options.selector.row]();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/components/tile_sprite.ts\n\r\n\r\n\r\n\r\nvar SpriteIds;\r\n(function (SpriteIds) {\r\n    SpriteIds[SpriteIds["Unknown"] = 54] = "Unknown";\r\n})(SpriteIds || (SpriteIds = {}));\r\nclass TileSprite extends Sprite/* Sprite */.j {\r\n    constructor(displayPos, initialSpriteId) {\r\n        super();\r\n        this.gateSprite = null;\r\n        this.displayPos = displayPos;\r\n        this.spriteId = initialSpriteId;\r\n        // Now works for debug but later might update with gameplay controls\r\n        this.interactive = true;\r\n        this.on("click", () => {\r\n            console.log("click on", this);\r\n        });\r\n        this.updateTexture(this.spriteId);\r\n    }\r\n    displayCell(cell, visibilityState) {\r\n        this.cell = cell;\r\n        this.spriteId = TILES_DATA[cell.typeId].spriteId;\r\n        this.tint = TILES_DATA[cell.typeId].tint;\r\n        this.alpha = 1;\r\n        switch (visibilityState) {\r\n            case VisualPerceptionState.NeverSeen:\r\n                this.spriteId = SpriteIds.Unknown;\r\n                break;\r\n            case VisualPerceptionState.Memorized:\r\n                this.alpha = 0.3;\r\n                break;\r\n            case VisualPerceptionState.BeingSeen:\r\n                break;\r\n            default:\r\n        }\r\n        this.updateTexture(this.spriteId);\r\n        if (cell.tileGates.size > 0) {\r\n            if (!this.gateSprite) {\r\n                this.gateSprite = new Sprite/* Sprite */.j(tileset[34]);\r\n                this.gateSprite.tint = PALETTE.GRAY;\r\n                this.addChild(this.gateSprite);\r\n            }\r\n            this.gateSprite.visible =\r\n                visibilityState != VisualPerceptionState.NeverSeen;\r\n        }\r\n        else {\r\n            if (this.gateSprite) {\r\n                this.gateSprite.visible = false;\r\n            }\r\n        }\r\n    }\r\n    updateTexture(spriteId) {\r\n        this.texture = tileset[spriteId];\r\n    }\r\n    static getCellTextureId(cell) {\r\n        return cell.typeId; // works as long as cell id (logical) matches sprite id from tileset\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/inventory_view.ts\n\r\n\r\n\r\n\r\nclass InventoryView extends BaseGameView {\r\n    constructor(inv) {\r\n        super("Inventory View");\r\n        new Background(this);\r\n        const labels = [];\r\n        const moneyText = new Text(this.getMoneyDescription(inv.money), fontStyleLeft);\r\n        this.addChild(moneyText);\r\n        labels.push(moneyText);\r\n        const rationsText = new Text(this.getRationsDescription(inv.rations), fontStyleLeft);\r\n        this.addChild(rationsText);\r\n        labels.push(rationsText);\r\n        if (inv.mount) {\r\n            const mountText = new Text(this.getMountDescription(inv.mount), fontStyleLeft);\r\n            this.addChild(mountText);\r\n            labels.push(mountText);\r\n        }\r\n        const itemsText = new Text(this.getItemsDescription(inv.items), fontStyleLeft);\r\n        this.addChild(itemsText);\r\n        labels.push(itemsText);\r\n        const res = this.getResourceEntries(inv.res);\r\n        if (res.length > 0) {\r\n            const resourcesText = new Text(this.getResourcesDescription(res), fontStyleLeft);\r\n            this.addChild(resourcesText);\r\n            labels.push(resourcesText);\r\n        }\r\n        labels.forEach((t, i) => (t.y = i * STEP_SIZE));\r\n    }\r\n    getMoneyDescription(money) {\r\n        return `Money: ${money}`;\r\n    }\r\n    getRationsDescription(rations) {\r\n        return `Rations: ${rations}`;\r\n    }\r\n    getMountDescription(mount) {\r\n        return `Mount: ${mount.name}`;\r\n    }\r\n    getItemsDescription(items) {\r\n        return `Items: ${items.join(", ")}`;\r\n    }\r\n    getResourcesDescription(resEntries) {\r\n        return `Resources: \\n${resEntries.join(", ")}`;\r\n    }\r\n    getResourceEntries(res) {\r\n        return Object.keys(res)\r\n            .filter((r) => res[r].amount > 0)\r\n            .map((r) => `${r}: ${res[r].amount}`);\r\n    }\r\n    assignControls(controls) {\r\n        this.controls = controls;\r\n        this.clearControls(controls);\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/journal/locations.ts\n\r\n\r\n\r\n\r\nclass LocationsJournal extends BaseGameView {\r\n    constructor(journal) {\r\n        super("Locations Journal");\r\n        this.journal = journal;\r\n        new Background(this);\r\n        this.locationRows = [];\r\n        const x = 50;\r\n        let y = 50;\r\n        for (const l of this.journal.locationsSeen) {\r\n            const row = new Container/* Container */.W2();\r\n            const locationSprite = new Sprite/* Sprite */.j(tileset[l.type]);\r\n            locationSprite.scale.set(globals_SCALE);\r\n            const locationDescText = new Text(l.desc, fontStyleLeft);\r\n            locationDescText.x += 50;\r\n            row.addChild(locationSprite, locationDescText);\r\n            this.locationRows.push(row);\r\n            this.addChild(row);\r\n            row.y = y;\r\n            row.x = x;\r\n            y += 100;\r\n        }\r\n    }\r\n    assignControls(controls) {\r\n        this.clearControls(controls);\r\n        controls.l.press = () => {\r\n            this.closeScene();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/journal/quests.ts\n\r\n\r\n\r\n\r\n\r\nclass QuestsJournal extends BaseGameView {\r\n    constructor(journal) {\r\n        super("Quests Journal");\r\n        this.journal = journal;\r\n        new Background(this);\r\n        // Main text\r\n        const mainText = new Message(this, 100);\r\n        mainText.addText(["Quests"], fontStyleCenter);\r\n        this.addChild(mainText);\r\n        this.questOptionList = new OptionList(this);\r\n        this.questOptionList.addOptions(this.journal.quests.map((q) => [q.description]));\r\n        /*\r\n        const xOffset = 96\r\n        let yOffset = 100\r\n        for (const q of this.journal.quests) {\r\n          const entry = new StyledText([\r\n            q.description\r\n          ], fontStyleLeft)\r\n          this.addChild(entry)\r\n          entry.position.set(xOffset, yOffset)\r\n          yOffset += entry.height + 20\r\n        }\r\n        */\r\n    }\r\n    assignControls(controls) {\r\n        this.clearControls(controls);\r\n        controls.q.press = () => {\r\n            this.closeScene();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n        controls.up.press = () => {\r\n            this.questOptionList.selectorUp();\r\n        };\r\n        controls.w.press = () => {\r\n            this.questOptionList.selectorUp();\r\n        };\r\n        controls.down.press = () => {\r\n            this.questOptionList.selectorDown();\r\n        };\r\n        controls.s.press = () => {\r\n            this.questOptionList.selectorDown();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/journal_view.ts\n\r\n\r\n\r\n\r\nclass JournalView extends BaseGameView {\r\n    constructor(journal) {\r\n        super("Journal");\r\n        this.journal = journal;\r\n        new Background(this);\r\n        this.sections = new OptionList(this);\r\n        this.sections.addOptions([["Locations"], ["Quests"]]);\r\n        this.sections.addActions([\r\n            undefined,\r\n            () => this.openScene(new QuestsJournal(journal)),\r\n        ]);\r\n    }\r\n    assignControls(controls) {\r\n        this.controls = controls;\r\n        this.clearControls(controls);\r\n        controls.j.press = () => {\r\n            this.closeScene();\r\n        };\r\n        controls.esc.press = () => {\r\n            this.closeScene();\r\n        };\r\n        controls.up.press = () => {\r\n            this.sections.selectorUp();\r\n        };\r\n        controls.w.press = () => {\r\n            this.sections.selectorUp();\r\n        };\r\n        controls.down.press = () => {\r\n            this.sections.selectorDown();\r\n        };\r\n        controls.s.press = () => {\r\n            this.sections.selectorDown();\r\n        };\r\n        controls.space.press = () => {\r\n            this.sections.selectCurrent();\r\n        };\r\n        controls.enter.press = () => {\r\n            this.sections.selectCurrent();\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/location_view.ts\n\r\n\r\n\r\nclass LocationView extends Scene {\r\n    constructor(location, info, hero) {\r\n        super({\r\n            text: `This is a ${location.name.toLowerCase()}.`,\r\n            id: 0,\r\n            name: "Location description",\r\n            options: [],\r\n        });\r\n        this.mainText.addText(this.getOwnerText(info), fontStyleCenter);\r\n        this.mainText.addText(this.getDwellersText(info, hero), fontStyleCenter);\r\n    }\r\n    getDwellersText(info, hero) {\r\n        if (!info.dwellers) {\r\n            return ["You don\'t know who lives here."];\r\n        }\r\n        else if (info.dwellers.size == 0) {\r\n            return ["No one lives here."];\r\n        }\r\n        else {\r\n            const names = Array.from(info.dwellers.values()).map((a) => {\r\n                const info = hero.journal.getAgentInfo(a);\r\n                return { msg: info.name, color: info.appearance.tint };\r\n            });\r\n            if (names.length > 1) {\r\n                return [...names, " live here."];\r\n            }\r\n            else {\r\n                return [...names, " lives here."];\r\n            }\r\n        }\r\n    }\r\n    getOwnerText(info) {\r\n        if (!info.owner) {\r\n            return ["You don\'t know who owns it."];\r\n        }\r\n        else {\r\n            return [\r\n                "It is owned by a ",\r\n                {\r\n                    msg: Realm.getName(info.owner),\r\n                    color: Realm.getRealmColor(info.owner),\r\n                },\r\n                ".",\r\n            ];\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./ts/views/world_view.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * This is the main game view(controller).\r\n * It presents game world state to the player\r\n * and manipulates game world in response to player actions\r\n */\r\nvar ViewMode;\r\n(function (ViewMode) {\r\n    ViewMode[ViewMode["God"] = 0] = "God";\r\n    ViewMode[ViewMode["Hero"] = 1] = "Hero";\r\n})(ViewMode || (ViewMode = {}));\r\nvar VisibilityMode;\r\n(function (VisibilityMode) {\r\n    VisibilityMode["Default"] = "Default";\r\n    VisibilityMode["Everything"] = "Everything";\r\n})(VisibilityMode || (VisibilityMode = {}));\r\nclass WorldView extends BaseGameView {\r\n    //ToDo: make a method to setup "follow target" and toggle camera following\r\n    constructor(world) {\r\n        super("Main world view");\r\n        this.gateSpritesPool = [];\r\n        this.agentsContainer = new Container/* Container */.W2();\r\n        this.pointerContainer = new Container/* Container */.W2();\r\n        this.world = world;\r\n        this.hero = this.world.hero;\r\n        this.options = {\r\n            tileset: tileset,\r\n            stepSize: STEP_SIZE,\r\n            scale: globals_SCALE,\r\n        };\r\n        // Create camera\r\n        const cameraOptions = {\r\n            step: this.options.stepSize,\r\n            width: Math.ceil(gameApp.renderer.width / STEP_SIZE),\r\n            height: Math.ceil(gameApp.renderer.height / STEP_SIZE) - 1,\r\n            zone: 0,\r\n        };\r\n        cameraOptions.zone = Math.floor(Math.min(cameraOptions.width, cameraOptions.height) / 3);\r\n        cameraOptions.width -= cameraOptions.zone;\r\n        console.log("Camera options", cameraOptions);\r\n        this.camera = new Camera(cameraOptions, 21, 18);\r\n        this.camera.setTarget(world.hero);\r\n        this.viewMode = ViewMode.Hero;\r\n        this.addTileSprites(this.camera);\r\n        this.agentSprites = new Map();\r\n        this.addChild(this.agentsContainer);\r\n        this.addChild(this.pointerContainer);\r\n        // Create UI layer\r\n        this.ui = new UI(cameraOptions.width + cameraOptions.zone, cameraOptions.width, cameraOptions.height + 1);\r\n        this.addChild(this.ui);\r\n        console.log("World view created");\r\n        this.pointerCursor = new Selection(tileset[TileId.Selection + 2], PALETTE.WHITE);\r\n        this.pointerContainer.addChild(this.pointerCursor);\r\n        this.interactive = true;\r\n        this.on("pointermove", (e) => this.onPointerMove(this.camera, e));\r\n    }\r\n    onPointerMove(camera, e) {\r\n        const localPos = e.getLocalPosition(this);\r\n        if (localPos.x > 0 &&\r\n            localPos.x < camera.options.width * STEP_SIZE &&\r\n            localPos.y > 0 &&\r\n            localPos.y < camera.options.height * STEP_SIZE) {\r\n            this.pointerCursor.visible = true;\r\n            this.pointerCursor.col = Math.floor(localPos.x / STEP_SIZE);\r\n            this.pointerCursor.row = Math.floor(localPos.y / STEP_SIZE);\r\n            this.updateCursor();\r\n        }\r\n        else {\r\n            this.pointerCursor.visible = false;\r\n        }\r\n    }\r\n    addTileSprites(camera) {\r\n        this.tileSprites = [];\r\n        for (let row = 0; row < camera.options.height; row++) {\r\n            for (let col = 0; col < camera.options.width; col++) {\r\n                const sprite = new TileSprite({ tx: col, ty: row }, SpriteIds.Unknown);\r\n                this.placeSpriteOnGrid(sprite, col, row);\r\n                sprite.scale.set(this.options.scale);\r\n                this.tileSprites.push(sprite);\r\n                this.addChild(sprite);\r\n            }\r\n        }\r\n    }\r\n    placeSpriteOnGrid(sprite, tx, ty) {\r\n        sprite.x = tx * this.options.stepSize;\r\n        sprite.y = ty * this.options.stepSize;\r\n    }\r\n    update() {\r\n        console.log("Updating view");\r\n        if (this.viewMode == ViewMode.Hero) {\r\n            this.camera.followTarget();\r\n        }\r\n        this.updateDisplay();\r\n        this.ui.updateStatusText(this.hero);\r\n        this.ui.updateInvTexts(this.world.hero.inv);\r\n        this.ui.updateDay(this.world.getDays());\r\n        this.contexts = this.world.getAvailableContexts(this.world.hero);\r\n        console.log("Available contexts updated", this.contexts.map((c) => {\r\n            const keyIndex = Object.values(Context).indexOf(c.context);\r\n            return Object.keys(Context)[keyIndex];\r\n        }));\r\n        this.ui.updateContextText(this.contexts.map((c) => c.context));\r\n        this.ui.updateHint(this.contexts.map((c) => c.context));\r\n    }\r\n    updateCursor() {\r\n        const tx = this.pointerCursor.col;\r\n        const ty = this.pointerCursor.row;\r\n        const cell = this.getCorrespondingCell({ tx: tx, ty: ty });\r\n        if (!cell)\r\n            return;\r\n        this.ui.updateCellInfo(cell, this.viewMode == ViewMode.Hero ? this.hero : null);\r\n        this.pointerCursor.position.set(tx * STEP_SIZE, ty * STEP_SIZE);\r\n    }\r\n    // Main rendering method\r\n    updateDisplay() {\r\n        this.tileSprites.forEach((ts) => {\r\n            const correspondingCell = this.getCorrespondingCell(ts.displayPos);\r\n            if (!correspondingCell)\r\n                return;\r\n            let visibilityState = VisualPerceptionState.BeingSeen;\r\n            if (this.viewMode == ViewMode.Hero) {\r\n                visibilityState = VisualPerceptionState.NeverSeen;\r\n                if (this.hero.visibleTiles.includes(correspondingCell)) {\r\n                    visibilityState = VisualPerceptionState.BeingSeen;\r\n                }\r\n                else if (this.hero.memorizedTiles.includes(correspondingCell)) {\r\n                    visibilityState = VisualPerceptionState.Memorized;\r\n                }\r\n            }\r\n            ts.displayCell(correspondingCell, visibilityState);\r\n            this.updateAgents(ts, Array.from(correspondingCell.agents), visibilityState);\r\n        });\r\n        for (const sprite of this.agentSprites.values()) {\r\n            if (sprite.needToDisplay) {\r\n                sprite.visible = true;\r\n            }\r\n            else {\r\n                sprite.visible = false;\r\n            }\r\n            sprite.needToDisplay = false;\r\n        }\r\n        this.updateCursor();\r\n    }\r\n    getCorrespondingCell(pos) {\r\n        return this.world.getCell({\r\n            tx: pos.tx + this.camera.tx,\r\n            ty: pos.ty + this.camera.ty,\r\n        });\r\n    }\r\n    updateAgents(tileSprite, list, visibilityState) {\r\n        for (const e of list) {\r\n            let sprite = this.agentSprites.get(e);\r\n            if (!sprite) {\r\n                sprite = this.getNewAgentSprite(e);\r\n                this.agentSprites.set(e, sprite);\r\n                this.agentsContainer.addChild(sprite);\r\n            }\r\n            if (e == this.hero) {\r\n                if (e.activeMount) {\r\n                    sprite.updateTexture(45);\r\n                }\r\n                else {\r\n                    sprite.updateTexture(41);\r\n                }\r\n            }\r\n            sprite.setDirection(e.facing);\r\n            sprite.position.set(tileSprite.position.x, tileSprite.position.y);\r\n            sprite.needToDisplay =\r\n                visibilityState == VisualPerceptionState.BeingSeen || e == this.hero;\r\n        }\r\n    }\r\n    getNewAgentSprite(agent) {\r\n        if (agent == this.world.hero) {\r\n            return new AgentSprite(41, Direction.Right, agent.info.appearance.tint);\r\n        }\r\n        else {\r\n            const spriteId = AGENTS_DATA[agent.info.appearance.type].spriteId;\r\n            return new AgentSprite(spriteId, Direction.Left, agent.info.appearance.tint);\r\n        }\r\n    }\r\n    assignControls(controls) {\r\n        controls.left.press = () => {\r\n            this.moveLeft();\r\n        };\r\n        controls.a.press = () => {\r\n            this.moveLeft();\r\n        };\r\n        controls.up.press = () => {\r\n            this.moveUp();\r\n        };\r\n        controls.w.press = () => {\r\n            this.moveUp();\r\n        };\r\n        controls.right.press = () => {\r\n            this.moveRight();\r\n        };\r\n        controls.d.press = () => {\r\n            this.moveRight();\r\n        };\r\n        controls.down.press = () => {\r\n            this.moveDown();\r\n        };\r\n        controls.s.press = () => {\r\n            this.moveDown();\r\n        };\r\n        controls.shift.press = () => {\r\n            this.toggleHeroSprint();\r\n        };\r\n        controls.m.press = () => {\r\n            this.toggleMount();\r\n        };\r\n        controls.j.press = () => {\r\n            this.openHeroJournal();\r\n        };\r\n        controls.l.press = () => {\r\n            this.openHeroLocations();\r\n        };\r\n        controls.q.press = () => {\r\n            this.openHeroQuests();\r\n        };\r\n        controls.i.press = () => {\r\n            this.openScene(new TroopsPurchase(this.hero));\r\n            // this.openHeroInventory();\r\n        };\r\n        controls.enter.press = () => {\r\n            this.skipTime(WAIT_DURATION);\r\n        };\r\n        controls.space.press = () => {\r\n            this.activateContext();\r\n        };\r\n        // Debug\r\n        controls.tab.press = () => {\r\n            this.toggleViewMode();\r\n        };\r\n        controls.e.press = () => {\r\n            this.openDebugEconomy();\r\n        };\r\n        controls.t.press = () => {\r\n            this.openDebugTrade();\r\n        };\r\n        controls.g.press = () => {\r\n            this.forceGameOver();\r\n        };\r\n    }\r\n    moveLeft() {\r\n        if (this.viewMode == ViewMode.Hero) {\r\n            this.hero.attemptMove({ tx: -1, ty: 0 });\r\n        }\r\n        else {\r\n            this.camera.scrollLeft();\r\n            this.updateDisplay();\r\n        }\r\n    }\r\n    moveUp() {\r\n        if (this.viewMode == ViewMode.Hero) {\r\n            this.hero.attemptMove({ tx: 0, ty: -1 });\r\n        }\r\n        else {\r\n            this.camera.scrollUp();\r\n            this.updateDisplay();\r\n        }\r\n    }\r\n    moveRight() {\r\n        if (this.viewMode == ViewMode.Hero) {\r\n            this.hero.attemptMove({ tx: 1, ty: 0 });\r\n        }\r\n        else {\r\n            this.camera.scrollRight();\r\n            this.updateDisplay();\r\n        }\r\n    }\r\n    moveDown() {\r\n        if (this.viewMode == ViewMode.Hero) {\r\n            this.hero.attemptMove({ tx: 0, ty: 1 });\r\n        }\r\n        else {\r\n            this.camera.scrollDown();\r\n            this.updateDisplay();\r\n        }\r\n    }\r\n    toggleHeroSprint() {\r\n        this.hero.toggleSprint();\r\n        this.ui.updateStatusText(this.hero);\r\n    }\r\n    toggleMount() {\r\n        this.hero.activeMount ? this.hero.dismount() : this.hero.mount();\r\n        EventBus.emit(WorldEvents.Updated);\r\n    }\r\n    openHeroJournal() {\r\n        this.openScene(new JournalView(this.hero.journal));\r\n    }\r\n    openHeroLocations() {\r\n        this.openScene(new LocationsJournal(this.hero.journal));\r\n    }\r\n    openHeroQuests() {\r\n        this.openScene(new QuestsJournal(this.hero.journal));\r\n    }\r\n    openHeroInventory() {\r\n        this.openScene(new InventoryView(this.hero.inv));\r\n        this.logHeroInventory();\r\n    }\r\n    logHeroInventory() {\r\n        console.log(this.hero.inv);\r\n    }\r\n    skipTime(amount) {\r\n        EventBus.emit(WorldEvents.UpdateRequested, amount);\r\n    }\r\n    activateContext() {\r\n        console.log("contexts", this.contexts);\r\n        if (this.contexts.length > 2) {\r\n            const options = [];\r\n            const actions = [];\r\n            this.contexts.forEach((c) => {\r\n                const [option, action] = this.getChoice(c);\r\n                options.push(option);\r\n                actions.push(action);\r\n            });\r\n            this.openScene(new ChoiceView(options, actions));\r\n        }\r\n        else if (this.contexts.length == 2) {\r\n            const [_, action] = this.getChoice(this.contexts[1]);\r\n            action();\r\n        }\r\n        // EventBus.emit(WorldEvents.UpdateRequested, TURN_DURATION)\r\n    }\r\n    getChoice(c) {\r\n        switch (c.context) {\r\n            case Context.World:\r\n                return [["Continue travelling"], () => { }];\r\n            case Context.Dialogue: {\r\n                const npc = c.data;\r\n                const info = this.hero.journal.getAgentInfo(npc);\r\n                return [\r\n                    ["Talk to ", { msg: info.name, color: info.appearance.tint }],\r\n                    () => {\r\n                        this.talkTo(npc);\r\n                    },\r\n                ];\r\n            }\r\n            case Context.Location: {\r\n                const location = c.data;\r\n                return [\r\n                    [\r\n                        "Enter the ",\r\n                        { msg: location.name, color: Realm.getRealmColor(location.owner) },\r\n                    ],\r\n                    () => {\r\n                        this.enterLocation(location, this.hero.journal.getLocationInfo(location));\r\n                    },\r\n                ];\r\n            }\r\n            case Context.Battle:\r\n                return [\r\n                    ["To battle"],\r\n                    () => {\r\n                        this.startBattle();\r\n                    },\r\n                ];\r\n            default:\r\n                console.warn("Unhadled context", c);\r\n                return [["Unhandled context"], () => { }];\r\n        }\r\n    }\r\n    startBattle() {\r\n        this.openScene(new Battle(this.hero));\r\n    }\r\n    talkTo(agent) {\r\n        this.openScene(new Dialogue(this.hero, agent));\r\n    }\r\n    enterLocation(location, info) {\r\n        if (location.type == LocationType.City) {\r\n            this.openScene(new City(this.hero, location));\r\n        }\r\n        else {\r\n            this.openScene(new LocationView(location, info, this.hero));\r\n        }\r\n    }\r\n    toggleViewMode() {\r\n        if (this.viewMode == ViewMode.Hero) {\r\n            this.viewMode = ViewMode.God;\r\n            // this.world.seeAllCells()\r\n        }\r\n        else {\r\n            this.viewMode = ViewMode.Hero;\r\n            this.camera.resetTo(this.hero);\r\n        }\r\n        this.updateDisplay();\r\n    }\r\n    openDebugTrade() {\r\n        const southCapital = this.world.realms[RealmTag.SouthEast].capital;\r\n        this.openScene(new ResourceTrader(this.hero, southCapital));\r\n    }\r\n    openDebugEconomy() {\r\n        // this.openScene(new Macro())\r\n    }\r\n    forceGameOver() {\r\n        EventBus.emit(WorldEvents.CapitalCaptured, this.world.realms[RealmTag.SouthEast].capital);\r\n    }\r\n}\r\nWorldView.VISIBILITY_MODE = VisibilityMode.Default;\r\n\n;// CONCATENATED MODULE: ./ts/main.ts\nvar main_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The journey starts here.\r\n *\r\n * This file has the higher-level technical / initialization layer.\r\n * It\'s responsible for setting up the game itself and its main systems.\r\n *\r\n * Game world simulation resides in the world.ts.\r\n * Presentation of the game world to the player is handled by world_view.ts\r\n * and other views.\r\n */\r\n// Entry point. Create, setup and link main systems\r\nmain();\r\nlet gameApp;\r\nfunction main() {\r\n    return main_awaiter(this, void 0, void 0, function* () {\r\n        yield loadAssets();\r\n        // Setup renderer\r\n        gameApp = new Application();\r\n        yield gameApp.init({\r\n            canvas: document.getElementById("game"),\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        });\r\n        gameApp.renderer.events.cursorStyles.default = "none";\r\n        // Disable interpolation when scaling to keep pixels crisp\r\n        TextureSource/* TextureSource.defaultOptions.scaleMode */.p.defaultOptions.scaleMode = "nearest";\r\n        registerPixiInspector(gameApp); // debug tool\r\n        const gameWorld = new World(WORLD_DATA);\r\n        // Different aspects of the game world are presented by different views (scenes).\r\n        // This manager controls them\r\n        const sceneManager = new SceneManager(gameApp.stage, controls);\r\n        // This is the main, or root, view\r\n        const gameWorldView = new WorldView(gameWorld);\r\n        sceneManager.setRoot(gameWorldView);\r\n        // Events may be dispatched by player actions or raised within the world simulation itslef\r\n        setupEventHandlers(gameWorld, gameWorldView, sceneManager);\r\n        EventBus.emit(WorldEvents.Updated);\r\n        // Start the game!\r\n        sceneManager.openScene(new Intro());\r\n    });\r\n}\r\nfunction registerPixiInspector(pixiApp) {\r\n    globalThis.__PIXI_APP__ = pixiApp;\r\n}\r\nfunction setupEventHandlers(world, view, sceneManager) {\r\n    EventBus.on(WorldEvents.UpdateRequested, (stepTime) => {\r\n        world.advanceState(stepTime);\r\n    });\r\n    EventBus.on(WorldEvents.Updated, () => {\r\n        view.update();\r\n    });\r\n    // Game is over when any of the capitals gets captured\r\n    EventBus.on(WorldEvents.CapitalCaptured, (capital) => {\r\n        sceneManager.openScene(new GameOver(world, capital));\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./ts/main.ts_+_114_modules?')},3806:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6659);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack:///../node_modules/eventemitter3/index.mjs?')},1778:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "C": () => (/* binding */ Cache)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6576);\n/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3268);\n\n\n\n"use strict";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertToList */ .S)(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)("[Cache] already has key:", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\n\n//# sourceMappingURL=Cache.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/assets/cache/Cache.mjs?')},9032:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Q": () => (/* binding */ LoaderParserPriority)\n/* harmony export */ });\n\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";\n  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";\n  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\n\n//# sourceMappingURL=LoaderParser.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs?')},8783:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"H\": () => (/* binding */ Resolver)\n});\n\n// UNUSED EXPORTS: getUrlExtension\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(6576);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(7381);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/utils/convertToList.mjs\nvar convertToList = __webpack_require__(3268);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs\n\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\n\n//# sourceMappingURL=createStringVariations.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs\nvar isSingleItem = __webpack_require__(2847);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/assets/resolver/Resolver.mjs\n\n\n\n\n\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = (0,convertToList/* convertToList */.S)(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      (0,warn/* warn */.Z)(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        (0,warn/* warn */.Z)(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = (0,convertToList/* convertToList */.S)(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = (0,convertToList/* convertToList */.S)(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(bundleIds);\n    bundleIds = (0,convertToList/* convertToList */.S)(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(keys);\n    keys = (0,convertToList/* convertToList */.S)(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path/* path.toAbsolute */.E.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\n\n//# sourceMappingURL=Resolver.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/assets/resolver/Resolver.mjs_+_1_modules?")},3268:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "S": () => (/* binding */ convertToList)\n/* harmony export */ });\n\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === "string" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\n\n//# sourceMappingURL=convertToList.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/assets/utils/convertToList.mjs?')},4154:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "u": () => (/* binding */ copySearchParams)\n/* harmony export */ });\n\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split("?")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\n\n//# sourceMappingURL=copySearchParams.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs?')},2847:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "X": () => (/* binding */ isSingleItem)\n/* harmony export */ });\n\nconst isSingleItem = (item) => !Array.isArray(item);\n\n\n//# sourceMappingURL=isSingleItem.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs?')},3294:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "I": () => (/* binding */ Color)\n});\n\n;// CONCATENATED MODULE: ../node_modules/@pixi/colord/index.mjs\nvar r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n;// CONCATENATED MODULE: ../node_modules/@pixi/colord/plugins/names.mjs\n/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/color/Color.mjs\n\n\n\n"use strict";\nk([names]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter\'s parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter\'s parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error("Cannot set Color#value to null");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._value = this._cloneSource(value);\n      this._normalize(this._value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === "object" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out = out || this._arrayRgba;\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexadecimal string.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHex(); // returns "#ffffff"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexadecimal string with alpha.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHexa(); // returns "#ffffffff"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === "string" || typeof value === "object") {\n      if (typeof value === "string") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = w(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === "number") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from \'pixi.js\';\n   * Color.isColorLike(\'white\'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from \'pixi.js\';\n * Color.shared.setValue(0xffffff).toHex(); // \'#ffffff\'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\n\n//# sourceMappingURL=Color.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/color/Color.mjs_+_2_modules?')},4598:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "z": () => (/* binding */ DOMAdapter)\n});\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs\n\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement("canvas");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, "text/xml");\n  }\n};\n\n\n//# sourceMappingURL=BrowserAdapter.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/environment/adapter.mjs\n\n\n"use strict";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\n\n//# sourceMappingURL=adapter.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/environment/adapter.mjs_+_1_modules?')},497:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Rw": () => (/* binding */ extensions),\n/* harmony export */   "nw": () => (/* binding */ ExtensionType)\n/* harmony export */ });\n/* unused harmony export normalizeExtensionPriority */\n\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2["Application"] = "application";\n  ExtensionType2["WebGLPipes"] = "webgl-pipes";\n  ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";\n  ExtensionType2["WebGLSystem"] = "webgl-system";\n  ExtensionType2["WebGPUPipes"] = "webgpu-pipes";\n  ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";\n  ExtensionType2["WebGPUSystem"] = "webgpu-system";\n  ExtensionType2["CanvasSystem"] = "canvas-system";\n  ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";\n  ExtensionType2["CanvasPipes"] = "canvas-pipes";\n  ExtensionType2["Asset"] = "asset";\n  ExtensionType2["LoadParser"] = "load-parser";\n  ExtensionType2["ResolveParser"] = "resolve-parser";\n  ExtensionType2["CacheParser"] = "cache-parser";\n  ExtensionType2["DetectionParser"] = "detection-parser";\n  ExtensionType2["MaskEffect"] = "mask-effect";\n  ExtensionType2["BlendMode"] = "blend-mode";\n  ExtensionType2["TextureSource"] = "texture-source";\n  ExtensionType2["Environment"] = "environment";\n  ExtensionType2["ShapeBuilder"] = "shape-builder";\n  ExtensionType2["Batcher"] = "batcher";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error("Extension class must have an extension object");\n    }\n    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === "object") {\n    ext = { ...ext };\n  } else {\n    throw new Error("Invalid extension type");\n  }\n  if (typeof ext.type === "string") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=Extensions.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/extensions/Extensions.mjs?')},4411:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "U": () => (/* binding */ FilterEffect)\n/* harmony export */ });\n\nclass FilterEffect {\n  constructor() {\n    /** the pipe that knows how to handle this effect */\n    this.pipe = "filter";\n    /** the priority of this effect */\n    this.priority = 1;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\n\n//# sourceMappingURL=FilterEffect.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/filters/FilterEffect.mjs?')},9959:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "y": () => (/* binding */ Matrix)\n/* harmony export */ });\n/* harmony import */ var _misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1674);\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2022);\n\n\n\n"use strict";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child\'s coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child\'s coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix\'s and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(_misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__/* .PI_2 */ ._b - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\n\n//# sourceMappingURL=Matrix.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/maths/matrix/Matrix.mjs?')},1674:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ZX": () => (/* binding */ DEG_TO_RAD),\n/* harmony export */   "_b": () => (/* binding */ PI_2),\n/* harmony export */   "jl": () => (/* binding */ RAD_TO_DEG)\n/* harmony export */ });\n\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\n\n//# sourceMappingURL=const.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/maths/misc/const.mjs?')},8295:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a9": () => (/* binding */ nextPow2),\n/* harmony export */   "wv": () => (/* binding */ isPow2)\n/* harmony export */ });\n/* unused harmony export log2 */\n\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\n\n//# sourceMappingURL=pow2.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/maths/misc/pow2.mjs?')},5446:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "A": () => (/* binding */ ObservablePoint)\n/* harmony export */ });\n\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point\'s x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ObservablePoint.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs?')},2022:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "E": () => (/* binding */ Point)\n/* harmony export */ });\n\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point\'s x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\n\n//# sourceMappingURL=Point.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/maths/point/Point.mjs?')},4860:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "A": () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2022);\n\n\n"use strict";\nconst tempPoints = [new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'rectangle\'\n     */\n    this.type = "rectangle";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can\'t intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Rectangle.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs?')},1884:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "N": () => (/* binding */ getMaxTexturesPerBatch)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs\nvar getTestContext = __webpack_require__(1493);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs\n\nconst fragTemplate = [\n  "precision mediump float;",\n  "void main(void){",\n  "float test = 0.1;",\n  "%forloop%",\n  "gl_FragColor = vec4(0.0);",\n  "}"\n].join("\\n");\nfunction generateIfTestSrc(maxIfs) {\n  let src = "";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += "\\nelse ";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\n\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs\n\n\n\n"use strict";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = (0,getTestContext/* getTestContext */.K)();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension("WEBGL_lose_context")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\n\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs_+_1_modules?')},9926:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Q": () => (/* binding */ getTextureBatchBindGroup)\n/* harmony export */ });\n/* harmony import */ var _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8517);\n/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1775);\n/* harmony import */ var _gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1884);\n\n\n\n\n"use strict";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 2166136261;\n  for (let i = 0; i < size; i++) {\n    uid ^= textures[i].uid;\n    uid = Math.imul(uid, 16777619);\n    uid >>>= 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\nlet maxTextures = 0;\nfunction generateTextureBatchBindGroup(textures, size, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  if (!maxTextures)\n    maxTextures = (0,_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__/* .getMaxTexturesPerBatch */ .N)();\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < size ? textures[i] : _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture.EMPTY.source */ .x.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\n\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs?')},4110:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "h": () => (/* binding */ DefaultBatcher)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(497);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(7321);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs\nvar ViewableBuffer = __webpack_require__(956);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs\nvar fastCopy = __webpack_require__(6419);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs\nvar getAdjustedBlendModeBlend = __webpack_require__(2592);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs + 1 modules\nvar maxRecommendedTextures = __webpack_require__(1884);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs\n\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs\n\n\n\n\n\n\n\n"use strict";\nclass Batch {\n  constructor() {\n    this.renderPipeId = "batch";\n    this.action = "startBatch";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = "normal";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    /** unique id for this batcher */\n    this.uid = (0,uid/* uid */.h)("batcher");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? (0,maxRecommendedTextures/* getMaxTexturesPerBatch */.N)();\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n    this.attributeBuffer = new ViewableBuffer/* ViewableBuffer */.R(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    } else {\n      this.packAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = (0,getAdjustedBlendModeBlend/* getAdjustedBlendModeBlend */.a)(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = "startBatch";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = (0,getAdjustedBlendModeBlend/* getAdjustedBlendModeBlend */.a)(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packQuadIndex(\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        } else {\n          this.packAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packIndex(\n            element,\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        }\n        element._batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = "renderBatch";\n        start = size;\n        blendMode = adjustedBlendMode;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packQuadIndex(\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      } else {\n        this.packAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packIndex(\n          element,\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer/* ViewableBuffer */.R(newSize);\n    (0,fastCopy/* fastCopy */.T)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      (0,fastCopy/* fastCopy */.T)(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\n\n\n//# sourceMappingURL=Batcher.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(7755);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(7253);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs + 2 modules\nvar Geometry = __webpack_require__(1585);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs\n\n\n\n\n"use strict";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry/* Geometry */.Z {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer/* Buffer */.l({\n      data: placeHolderBufferData,\n      label: "attribute-batch-buffer",\n      usage: buffer_const/* BufferUsage.VERTEX */.F.VERTEX | buffer_const/* BufferUsage.COPY_DST */.F.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer/* Buffer */.l({\n      data: placeHolderIndexData,\n      label: "index-batch-buffer",\n      usage: buffer_const/* BufferUsage.INDEX */.F.INDEX | buffer_const/* BufferUsage.COPY_DST */.F.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: "unorm8x4",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: "uint16x2",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(7330);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(1320);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(1082);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(1018);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs\nvar getBatchSamplersUniformGroup = __webpack_require__(6016);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(3965);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs\n\n\n\n\n\n\n\n"use strict";\nclass DefaultShader extends Shader/* Shader */.e {\n  constructor(maxTextures) {\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "batch",\n      bits: [\n        colorBit/* colorBitGl */.T,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.h)(maxTextures),\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "batch",\n      bits: [\n        colorBit/* colorBit */.M,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.m)(maxTextures),\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        batchSamplers: (0,getBatchSamplersUniformGroup/* getBatchSamplersUniformGroup */.O)(maxTextures)\n      }\n    });\n  }\n}\n\n\n//# sourceMappingURL=DefaultShader.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs\n\n\n\n\n\n"use strict";\nlet defaultShader = null;\nconst _DefaultBatcher = class _DefaultBatcher extends Batcher {\n  constructor() {\n    super(...arguments);\n    this.geometry = new BatchGeometry();\n    this.shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n    this.name = _DefaultBatcher.extension.name;\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    this.vertexSize = 6;\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n   * @param element - The DefaultBatchableMeshElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packAttributes(element, float32View, uint32View, index, textureId) {\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const { positions, uvs } = element;\n    const argb = element.color;\n    const offset = element.attributeOffset;\n    const end = offset + element.attributeSize;\n    for (let i = offset; i < end; i++) {\n      const i2 = i * 2;\n      const x = positions[i2];\n      const y = positions[i2 + 1];\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = d * y + b * x + ty;\n      float32View[index++] = uvs[i2];\n      float32View[index++] = uvs[i2 + 1];\n      uint32View[index++] = argb;\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n   * @param element - The DefaultBatchableQuadElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packQuadAttributes(element, float32View, uint32View, index, textureId) {\n    const texture = element.texture;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = element.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = element.color;\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n};\n/** @ignore */\n_DefaultBatcher.extension = {\n  type: [\n    Extensions/* ExtensionType.Batcher */.nw.Batcher\n  ],\n  name: "default"\n};\nlet DefaultBatcher = _DefaultBatcher;\n\n\n//# sourceMappingURL=DefaultBatcher.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs_+_4_modules?')},7330:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "o": () => (/* binding */ compileHighShaderGlProgram),\n  "d": () => (/* binding */ compileHighShaderGpuProgram)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs + 6 modules\nvar GlProgram = __webpack_require__(6272);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs + 6 modules\nvar GpuProgram = __webpack_require__(518);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(6576);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs\n\n\n"use strict";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === "header") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, "").replace(/@out\\s+[^;]+;\\s*/g, "");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        (0,warn/* warn */.Z)(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=addBits.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs\n\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\n\n//# sourceMappingURL=compileHooks.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs\n\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join("\\n");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, "");\n  cleanedString = cleanedString.replace("{{in}}", `\n${finalString}\n`);\n  return cleanedString;\n}\n\n\n//# sourceMappingURL=compileInputs.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs\n\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : "";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, "");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf("builtin") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(",\\n");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\\n");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\\n")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, "");\n  compiledCode = compiledCode.replace("{{struct}}", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace("{{start}}", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace("{{return}}", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\n\n//# sourceMappingURL=compileOutputs.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs\n\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join("\\n");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join("\\n")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, "");\n    }\n  }\n  return out;\n}\n\n\n//# sourceMappingURL=injectBits.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs\n\n\n\n\n\n\n"use strict";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join("-") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\n\n//# sourceMappingURL=compileHighShader.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs\n\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`\n);\n\n\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs\n\nconst globalUniformsBit = {\n  name: "global-uniforms-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: "global-uniforms-ubo-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: "global-uniforms-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=globalUniformsBit.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs\n\n\n\n\n\n\n"use strict";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram/* GpuProgram.from */.O.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: "main"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: "main"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram/* GlProgram */.J({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\n\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs_+_8_modules?')},1320:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "M": () => (/* binding */ colorBit),\n/* harmony export */   "T": () => (/* binding */ colorBitGl)\n/* harmony export */ });\n\nconst colorBit = {\n  name: "color-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: "color-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=colorBit.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs?')},1082:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": () => (/* binding */ generateTextureBatchBitGl),\n/* harmony export */   "m": () => (/* binding */ generateTextureBatchBit)\n/* harmony export */ });\n\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");\n    src.push("@group(1) @binding(1) var textureSampler1: sampler;");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join("\\n");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");\n  } else {\n    src.push("switch vTextureId {");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join("\\n");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: "texture-batch-bit",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push("else");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push("{");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push("}");\n  }\n  return src.join("\\n");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: "texture-batch-bit",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\n\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs?')},1018:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "X": () => (/* binding */ roundPixelsBitGl),\n/* harmony export */   "j": () => (/* binding */ roundPixelsBit)\n/* harmony export */ });\n\nconst roundPixelsBit = {\n  name: "round-pixels-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: "round-pixels-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=roundPixelsBit.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs?')},7764:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(497);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(7259);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(9460);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(7823);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs\n\n\n\n"use strict";\nconst tempBounds = new Bounds/* Bounds */.Y();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  (0,getGlobalBounds/* getGlobalBounds */.qW)(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\n\n//# sourceMappingURL=addMaskBounds.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(8251);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2249);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(6576);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs\n\n\n\n\n"use strict";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = matrixAndBoundsPool/* boundsPool.get */.W.get();\n  mask.measurable = true;\n  const tempMatrix = matrixAndBoundsPool/* matrixPool.get */.N.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  (0,getLocalBounds/* getLocalBounds */.a)(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixAndBoundsPool/* matrixPool.return */.N["return"](tempMatrix);\n  matrixAndBoundsPool/* boundsPool.return */.W["return"](boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    (0,warn/* warn */.Z)("Mask bounds, renderable is not inside the root container");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\n\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs\n\n\n\n\n\n"use strict";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.inverse = false;\n    this.pipe = "alphaMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite/* Sprite */.j);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    if (!this.inverse) {\n      addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite/* Sprite */.j;\n  }\n}\nAlphaMask.extension = Extensions/* ExtensionType.MaskEffect */.nw.MaskEffect;\n\n\n//# sourceMappingURL=AlphaMask.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs\n\n\n"use strict";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "colorMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === "number";\n  }\n}\nColorMask.extension = Extensions/* ExtensionType.MaskEffect */.nw.MaskEffect;\n\n\n//# sourceMappingURL=ColorMask.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(4383);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs\n\n\n\n\n\n"use strict";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "stencilMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container/* Container */.W2;\n  }\n}\nStencilMask.extension = Extensions/* ExtensionType.MaskEffect */.nw.MaskEffect;\n\n\n//# sourceMappingURL=StencilMask.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs\nvar BufferImageSource = __webpack_require__(398);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(3306);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(8360);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs\nvar VideoSource = __webpack_require__(4625);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4762);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/init.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions.add */.Rw.add(AlphaMask, ColorMask, StencilMask, VideoSource/* VideoSource */.L, ImageSource/* ImageSource */.c, CanvasSource/* CanvasSource */.D, BufferImageSource/* BufferImageSource */.A);\n//# sourceMappingURL=init.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/init.mjs_+_5_modules?')},259:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "E": () => (/* binding */ CLEAR)\n/* harmony export */ });\n\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2["NONE"] = 0] = "NONE";\n  CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";\n  CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";\n  CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";\n  CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";\n  CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";\n  CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";\n  CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";\n  return CLEAR2;\n})(CLEAR || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs?')},6272:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "J": () => (/* binding */ GlProgram)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs\nvar createIdFromString = __webpack_require__(4015);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs\nvar getTestContext = __webpack_require__(1493);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs\n\n\n"use strict";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = "mediump";\n    const gl = (0,getTestContext/* getTestContext */.K)();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\n\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs\n\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace("out vec4 finalColor;", "");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\n\n//# sourceMappingURL=addProgramDefines.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs\n\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== "precision") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === "highp" && maxSupportedPrecision !== "highp") {\n      precision = "mediump";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {\n    return src.replace("precision highp", "precision mediump");\n  }\n  return src;\n}\n\n\n//# sourceMappingURL=ensurePrecision.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs\n\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\n\n//# sourceMappingURL=insertVersion.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs\n\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, "-");\n  name += isFragment ? "-fragment" : "-vertex";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf("#define SHADER_NAME") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\n\n//# sourceMappingURL=setProgramName.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs\n\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace("#version 300 es", "");\n}\n\n\n//# sourceMappingURL=stripVersion.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst processes = {\n  // strips any version headers..\n  stripVersion: stripVersion,\n  // adds precision string if not already present\n  ensurePrecision: ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines: addProgramDefines,\n  // add the program name to the shader\n  setProgramName: setProgramName,\n  // add the version string to the shader header\n  insertVersion: insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf("#version 300 es") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: "highp",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this._key = (0,createIdFromString/* createIdFromString */.Z)(`${this.vertex}:${this.fragment}`, "gl-program");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: "highp",\n  preferredFragmentPrecision: "mediump"\n};\nlet GlProgram = _GlProgram;\n\n\n//# sourceMappingURL=GlProgram.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs_+_6_modules?')},6016:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "O": () => (/* binding */ getBatchSamplersUniformGroup)\n/* harmony export */ });\n/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7692);\n\n\n"use strict";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__/* .UniformGroup */ .o({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\n\n//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs?')},1493:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "K": () => (/* binding */ getTestContext)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4598);\n\n\n"use strict";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter.get */ .z.get().createCanvas();\n    context = canvas.getContext("webgl", {});\n  }\n  return context;\n}\n\n\n//# sourceMappingURL=getTestContext.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs?')},8517:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "v": () => (/* binding */ BindGroup)\n/* harmony export */ });\n\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join("|");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    resource.on?.("change", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to \'touch\' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\n\n//# sourceMappingURL=BindGroup.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs?')},518:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "O": () => (/* binding */ GpuProgram)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs\nvar createIdFromString = __webpack_require__(4015);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs\nvar getAttributeInfoFromFormat = __webpack_require__(9534);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs\n\n\n"use strict";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: "float32",\n  "vec2<f32>": "float32x2",\n  "vec3<f32>": "float32x3",\n  "vec4<f32>": "float32x4",\n  vec2f: "float32x2",\n  vec3f: "float32x3",\n  vec4f: "float32x4",\n  i32: "sint32",\n  "vec2<i32>": "sint32x2",\n  "vec3<i32>": "sint32x3",\n  "vec4<i32>": "sint32x4",\n  u32: "uint32",\n  "vec2<u32>": "uint32x2",\n  "vec3<u32>": "uint32x3",\n  "vec4<u32>": "uint32x4",\n  bool: "uint32",\n  "vec2<bool>": "uint32x2",\n  "vec3<bool>": "uint32x3",\n  "vec4<bool>": "uint32x4"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf("->", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: (0,getAttributeInfoFromFormat/* getAttributeInfoFromFormat */.v)(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\n\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs\n\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === "<uniform>",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(":");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\n\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs\n\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";\n  ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";\n  ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";\n  return ShaderStage2;\n})(ShaderStage || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs\n\n\n"use strict";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: "uniform"\n        }\n      });\n    } else if (group.type === "sampler") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: "filtering"\n        }\n      });\n    } else if (group.type === "texture_2d") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: "float",\n          viewDimension: "2d",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\n\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs\n\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\n\n//# sourceMappingURL=generateLayoutHash.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs\n\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\n\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs\n\n\n\n\n\n\n\n"use strict";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._attributeLocationsKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = (0,createIdFromString/* createIdFromString */.Z)(bigKey, "program");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\n\n//# sourceMappingURL=GpuProgram.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs_+_6_modules?')},7755:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "l": () => (/* binding */ Buffer)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3806);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7321);\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7253);\n\n\n\n\n"use strict";\nclass Buffer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("buffer");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = "buffer";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage.STATIC */ .F.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage.STATIC */ .F.STATIC;\n    } else {\n      this.descriptor.usage &= ~_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage.STATIC */ .F.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit("update", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit("update", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n        this.emit("change", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit("update", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit("update", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.emit("change", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\n\n//# sourceMappingURL=Buffer.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs?')},7253:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "F": () => (/* binding */ BufferUsage)\n/* harmony export */ });\n\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";\n  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";\n  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";\n  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";\n  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";\n  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";\n  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";\n  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";\n  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";\n  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";\n  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";\n  return BufferUsage2;\n})(BufferUsage || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs?')},6419:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "T": () => (/* binding */ fastCopy)\n/* harmony export */ });\n\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\n\n//# sourceMappingURL=fastCopy.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs?')},1585:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": () => (/* binding */ Geometry)\n});\n\n// EXTERNAL MODULE: ../node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(3806);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(9460);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(7321);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(7755);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(7253);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs\n\n\n\n"use strict";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer/* Buffer */.l)) {\n    let usage = index ? buffer_const/* BufferUsage.INDEX */.F.INDEX : buffer_const/* BufferUsage.VERTEX */.F.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = buffer_const/* BufferUsage.INDEX */.F.INDEX | buffer_const/* BufferUsage.COPY_DST */.F.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = buffer_const/* BufferUsage.VERTEX */.F.VERTEX | buffer_const/* BufferUsage.COPY_DST */.F.COPY_DST;\n      }\n    }\n    buffer = new Buffer/* Buffer */.l({\n      data: buffer,\n      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",\n      usage\n    });\n  }\n  return buffer;\n}\n\n\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs\n\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getGeometryBounds.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs\n\n\n\n\n\n\n\n"use strict";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer/* Buffer */.l || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends eventemitter3/* default */.Z {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options = {}) {\n    super();\n    /** The unique id of the geometry. */\n    this.uid = (0,uid/* uid */.h)("geometry");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n    const { attributes, indexBuffer, topology } = options;\n    this.buffers = [];\n    this.attributes = {};\n    if (attributes) {\n      for (const i in attributes) {\n        this.addAttribute(i, attributes[i]);\n      }\n    }\n    this.instanceCount = options.instanceCount || 1;\n    if (indexBuffer) {\n      this.addIndex(indexBuffer);\n    }\n    this.topology = topology || "triangle-list";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit("update", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /**\n   * Adds an attribute to the geometry.\n   * @param name - The name of the attribute to add.\n   * @param attributeOption - The attribute option to add.\n   */\n  addAttribute(name, attributeOption) {\n    const attribute = ensureIsAttribute(attributeOption);\n    const bufferIndex = this.buffers.indexOf(attribute.buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(attribute.buffer);\n      attribute.buffer.on("update", this.onBufferUpdate, this);\n      attribute.buffer.on("change", this.onBufferUpdate, this);\n    }\n    this.attributes[name] = attribute;\n  }\n  /**\n   * Adds an index buffer to the geometry.\n   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n   */\n  addIndex(indexBuffer) {\n    this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n    this.buffers.push(this.indexBuffer);\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, "aPosition", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\n\n//# sourceMappingURL=Geometry.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs_+_2_modules?')},9534:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "v": () => (/* binding */ getAttributeInfoFromFormat)\n/* harmony export */ });\n\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\n\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs?')},2344:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": () => (/* binding */ InstructionSet)\n/* harmony export */ });\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7321);\n\n\n"use strict";\nlet _tick = 0;\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("instructionSet");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n    this.renderables = [];\n    this.tick = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n    this.tick = _tick++;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, ["type", "action"]);\n  }\n}\n\n\n//# sourceMappingURL=InstructionSet.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs?')},3965:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "e": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3806);\n/* harmony import */ var _gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6272);\n/* harmony import */ var _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8517);\n/* harmony import */ var _gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(518);\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6035);\n/* harmony import */ var _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7692);\n\n\n\n\n\n\n\n"use strict";\nclass Shader extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  constructor(options) {\n    super();\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= _types_mjs__WEBPACK_IMPORTED_MODULE_1__/* .RendererType.WEBGPU */ .g.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= _types_mjs__WEBPACK_IMPORTED_MODULE_1__/* .RendererType.WEBGL */ .g.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error("[Shader] Cannot have both resources and groups");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      groups = {};\n      groupMap = {};\n      if (gpuProgram) {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      let bindTick = 0;\n      for (const i in resources) {\n        if (nameHash[i])\n          continue;\n        if (!groups[99]) {\n          groups[99] = new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v();\n          this._ownedBindGroups.push(groups[99]);\n        }\n        nameHash[i] = { group: 99, binding: bindTick, name: i };\n        groupMap[99] = groupMap[99] || {};\n        groupMap[99][bindTick] = i;\n        bindTick++;\n      }\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_3__/* .UniformGroup */ .o(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit("destroy", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = _gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__/* .GpuProgram.from */ .O.from(gpu);\n    }\n    if (gl) {\n      glProgram = _gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_5__/* .GlProgram.from */ .J.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\n\n//# sourceMappingURL=Shader.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs?')},7692:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "o": () => (/* binding */ UniformGroup)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(7321);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs\nvar createIdFromString = __webpack_require__(4015);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs\n\nconst UNIFORM_TYPES_VALUES = [\n  "f32",\n  "i32",\n  "vec2<f32>",\n  "vec3<f32>",\n  "vec4<f32>",\n  "mat2x2<f32>",\n  "mat3x3<f32>",\n  "mat4x4<f32>",\n  "mat3x2<f32>",\n  "mat4x2<f32>",\n  "mat2x3<f32>",\n  "mat4x3<f32>",\n  "mat2x4<f32>",\n  "mat3x4<f32>"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\n\n//# sourceMappingURL=types.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs\n\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case "f32":\n      return 0;\n    case "vec2<f32>":\n      return new Float32Array(2 * size);\n    case "vec3<f32>":\n      return new Float32Array(3 * size);\n    case "vec4<f32>":\n      return new Float32Array(4 * size);\n    case "mat2x2<f32>":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case "mat3x3<f32>":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case "mat4x4<f32>":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs\n\n\n\n\n\n"use strict";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = (0,uid/* uid */.h)("uniform");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = "uniformGroup";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!UNIFORM_TYPES_MAP[uniformData.type]) {\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = (0,createIdFromString/* createIdFromString */.Z)(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join("-"), "uniform-group");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\n\n//# sourceMappingURL=UniformGroup.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs_+_2_modules?')},4833:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "D": () => (/* binding */ STENCIL_MODES),\n/* harmony export */   "f": () => (/* binding */ BLEND_TO_NPM)\n/* harmony export */ });\n\nconst BLEND_TO_NPM = {\n  normal: "normal-npm",\n  add: "add-npm",\n  screen: "screen-npm"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";\n  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";\n  STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";\n  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs?')},2592:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ getAdjustedBlendModeBlend)\n/* harmony export */ });\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4833);\n\n\n"use strict";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === "no-premultiply-alpha") {\n    return _const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .BLEND_TO_NPM */ .f[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\n\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs?')},2687:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "I": () => (/* binding */ AbstractRenderer)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(3294);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(497);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs\n\n\n"use strict";\nconst environments = [];\nExtensions/* extensions.handleByNamedList */.Rw.handleByNamedList(Extensions/* ExtensionType.Environment */.nw.Environment, environments);\nasync function loadEnvironmentExtensions(skip) {\n  if (skip)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\nasync function autoDetectEnvironment(add) {\n  return loadEnvironmentExtensions(!add);\n}\n\n\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(4383);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs\nvar unsafeEvalSupported = __webpack_require__(8222);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(9885);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(259);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs\nvar SystemRunner = __webpack_require__(553);\n// EXTERNAL MODULE: ../node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(3806);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultRunners = [\n  "init",\n  "destroy",\n  "contextChange",\n  "resolutionChange",\n  "reset",\n  "renderEnd",\n  "renderStart",\n  "render",\n  "update",\n  "postrender",\n  "prerender"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends eventemitter3/* default */.Z {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    this.config = config;\n    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n    await loadEnvironmentExtensions(skip);\n    this._addSystems(this.config.systems);\n    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof Container/* Container */.W2) {\n      options = { container: options };\n      if (deprecated) {\n        (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "passing a second argument is deprecated, please use render options instead");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor = this.background.colorRgba;\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : Color/* Color.shared.setValue */.I.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    const previousResolution = this.view.resolution;\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);\n    if (resolution !== void 0 && resolution !== previousResolution) {\n      this.runners.resolutionChange.emit(resolution);\n    }\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = gl_const/* CLEAR.ALL */.E.ALL);\n    const { clear, clearColor, target } = options;\n    Color/* Color.shared.setValue */.I.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, Color/* Color.shared.toArray */.I.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new SystemRunner/* SystemRunner */.P(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn\'t collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name "${name}" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn\'t support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!(0,unsafeEvalSupported/* unsafeEvalSupported */.O)()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");\n    }\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\n\n//# sourceMappingURL=AbstractRenderer.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs_+_1_modules?')},553:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"P\": () => (/* binding */ SystemRunner)\n/* harmony export */ });\n\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\n\n//# sourceMappingURL=SystemRunner.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs?")},3282:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4598);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8295);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter.get */ .z.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    canvasAndContext.context.clearRect(0, 0, width, height);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs?')},1775:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "x": () => (/* binding */ Texture)\n});\n\n// EXTERNAL MODULE: ../node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(3806);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9959);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/maths/matrix/groupD8.mjs\n\n\n"use strict";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix/* Matrix */.y();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135/225 | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90/270  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45/315  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don\'t.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn\'t work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\n\n//# sourceMappingURL=groupD8.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(4860);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(7321);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(9885);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/utils/misc/NOOP.mjs\n\nconst NOOP = () => {\n};\n\n\n//# sourceMappingURL=NOOP.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs\nvar BufferImageSource = __webpack_require__(398);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 1 modules\nvar TextureSource = __webpack_require__(608);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs\nvar TextureMatrix = __webpack_require__(115);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass Texture extends eventemitter3/* default */.Z {\n  /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = (0,uid/* uid */.h)("texture");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle/* Rectangle */.A();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on(\'update\', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource/* TextureSource */.p();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off("resize", this.update, this);\n    }\n    this._source = value;\n    value.on("resize", this.update, this);\n    this.emit("update", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix/* TextureMatrix */.U(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n  }\n  /**\n   * Call this if you have modified the `texture outside` of the constructor.\n   *\n   * If you have modified this texture\'s source, you must separately call `texture.source.update()` to see those changes.\n   */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit("update", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "Texture.baseTexture is now Texture.source");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: "EMPTY",\n  source: new TextureSource/* TextureSource */.p({\n    label: "EMPTY"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource/* BufferImageSource */.A({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: "premultiply-alpha-on-upload",\n    label: "WHITE"\n  }),\n  label: "WHITE"\n});\nTexture.WHITE.destroy = NOOP;\n\n\n//# sourceMappingURL=Texture.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs_+_2_modules?')},115:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "U": () => (/* binding */ TextureMatrix)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9959);\n\n\n"use strict";\nconst tempMat = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === "undefined") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener("update", this.update, this);\n    this._texture = value;\n    this._texture.addListener("update", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset / texBase._resolution;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=TextureMatrix.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs?')},9421:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "L": () => (/* binding */ TextureStyle)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3806);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7321);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9885);\n\n\n\n\n"use strict";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = "textureSampler";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "TextureStyle.wrapMode is now TextureStyle.addressMode");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = "linear";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit("change", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.emit("change", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: "clamp-to-edge",\n  scaleMode: "linear"\n};\nlet TextureStyle = _TextureStyle;\n\n\n//# sourceMappingURL=TextureStyle.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs?')},398:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "A": () => (/* binding */ BufferImageSource)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(497);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(608);\n\n\n\n"use strict";\nclass BufferImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = "rgba32float";\n      } else if (buffer instanceof Int32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Uint32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Int16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Uint16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Int8Array) {\n        format = "bgra8unorm";\n      } else {\n        format = "bgra8unorm";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = "buffer";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__/* .ExtensionType.TextureSource */ .nw.TextureSource;\n\n\n//# sourceMappingURL=BufferImageSource.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs?')},3306:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "D": () => (/* binding */ CanvasSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4598);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(497);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(608);\n\n\n\n\n"use strict";\nclass CanvasSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter.get */ .z.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoDensity = options.autoDensity;\n    const canvas = options.resource;\n    if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {\n      this.resizeCanvas();\n    }\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n  /**\n   * Returns the 2D rendering context for the canvas.\n   * Caches the context after creating it.\n   * @returns The 2D rendering context of the canvas.\n   */\n  get context2D() {\n    return this._context2D || (this._context2D = this.resource.getContext("2d"));\n  }\n}\nCanvasSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ExtensionType.TextureSource */ .nw.TextureSource;\n\n\n//# sourceMappingURL=CanvasSource.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs?')},8360:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ ImageSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4598);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(497);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6576);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(608);\n\n\n\n\n\n"use strict";\nclass ImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter.get */ .z.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext("2d");\n      context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n      options.resource = canvas;\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__/* .warn */ .Z)("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n}\nImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__/* .ExtensionType.TextureSource */ .nw.TextureSource;\n\n\n//# sourceMappingURL=ImageSource.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs?')},608:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "p": () => (/* binding */ TextureSource)\n});\n\n// EXTERNAL MODULE: ../node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(3806);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(8295);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs\n\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=definedProps.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(7321);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs\nvar TextureStyle = __webpack_require__(9421);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs\n\n\n\n\n\n\n"use strict";\nconst _TextureSource = class _TextureSource extends eventemitter3/* default */.Z {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = (0,uid/* uid */.h)("textureSource");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = "textureSource";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = "unknown";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = "rgba8unorm";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = "2d";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? "";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle/* TextureStyle */.L(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off("change", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on("change", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit("styleChange", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit("update", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.emit("change", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    this.emit("unload", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit("resize", this);\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don\'t want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit("updateMipmaps", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = (0,pow2/* isPow2 */.wv)(this.pixelWidth) && (0,pow2/* isPow2 */.wv)(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error("Unimplemented");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: "bgra8unorm",\n  alphaMode: "premultiply-alpha-on-upload",\n  dimensions: "2d",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\n\n//# sourceMappingURL=TextureSource.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs_+_1_modules?')},4625:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "L": () => (/* binding */ VideoSource)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(497);\n/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5883);\n/* harmony import */ var _utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6886);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(608);\n\n\n\n\n\n"use strict";\nconst _VideoSource = class _VideoSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = "video";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker.shared.elapsedMS */ .v.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener("play", this._onPlayStart);\n    source.addEventListener("pause", this._onPlayStop);\n    source.addEventListener("seeked", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener("canplay", this._onCanPlay);\n      }\n      source.addEventListener("canplaythrough", this._onCanPlayThrough);\n      source.addEventListener("error", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await (0,_utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_2__/* .detectVideoAlphaMode */ .D)();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener("error", this._onError, true);\n    this.emit("error", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener("canplay", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener("canplaythrough", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener("play", this._onPlayStart);\n      source.removeEventListener("pause", this._onPlayStop);\n      source.removeEventListener("seeked", this._onSeeked);\n      source.removeEventListener("canplay", this._onCanPlay);\n      source.removeEventListener("canplaythrough", this._onCanPlayThrough);\n      source.removeEventListener("error", this._onError, true);\n      source.pause();\n      source.src = "";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser\'s native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video\'s state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn\'t playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker.shared.remove */ .v.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker.shared.add */ .v.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker.shared.remove */ .v.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n  }\n};\n_VideoSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__/* .ExtensionType.TextureSource */ .nw.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ..._TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource.defaultOptions */ .p.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can\'t be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: "video/ogg",\n  mov: "video/quicktime",\n  m4v: "video/mp4"\n};\nlet VideoSource = _VideoSource;\n\n\n//# sourceMappingURL=VideoSource.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs?')},4762:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* unused harmony exports autoDetectSource, resourceToTexture, textureFrom */\n/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1778);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(497);\n/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(608);\n/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1775);\n\n\n\n\n\n"use strict";\nconst sources = [];\n_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .extensions.handleByList */ .Rw.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ExtensionType.TextureSource */ .nw.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache.has */ .C.has(resource)) {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache.get */ .C.get(resource);\n  }\n  const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: textureSourceFrom(opts) });\n  texture.on("destroy", () => {\n    if (_assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache.has */ .C.has(resource)) {\n      _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache.remove */ .C.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache.set */ .C.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === "string") {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache.get */ .C.get(id);\n  } else if (id instanceof _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__/* .TextureSource */ .p) {\n    return new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\n_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture.from */ .x.from = textureFrom;\n_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__/* .TextureSource.from */ .p.from = textureSourceFrom;\n\n\n//# sourceMappingURL=textureFrom.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs?')},4015:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (/* binding */ createIdFromString)\n/* harmony export */ });\n\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\n\n//# sourceMappingURL=createIdFromString.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs?')},6035:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "g": () => (/* binding */ RendererType)\n/* harmony export */ });\n\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";\n  RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";\n  RendererType2[RendererType2["BOTH"] = 3] = "BOTH";\n  return RendererType2;\n})(RendererType || {});\n\n\n//# sourceMappingURL=types.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/rendering/renderers/types.mjs?')},4383:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "W2": () => (/* binding */ Container),\n  "pA": () => (/* binding */ UPDATE_BLEND),\n  "wO": () => (/* binding */ UPDATE_COLOR),\n  "Jm": () => (/* binding */ UPDATE_VISIBLE)\n});\n\n// UNUSED EXPORTS: UPDATE_TRANSFORM\n\n// EXTERNAL MODULE: ../node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(3806);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(3294);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/culling/cullingMixin.mjs\n\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\n\n//# sourceMappingURL=cullingMixin.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9959);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/misc/const.mjs\nvar misc_const = __webpack_require__(1674);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs\nvar ObservablePoint = __webpack_require__(5446);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(7321);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(9885);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(4398);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/removeItems.mjs\nvar removeItems = __webpack_require__(5460);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs\n\n\n\n"use strict";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        removed.push(child);\n        child.parent = null;\n      }\n      (0,removeItems/* removeItems */.E)(this.children, beginIndex, end);\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.removeChildren(removed);\n      }\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit("childRemoved", removed[i], this, i);\n        removed[i].emit("removed", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error("The supplied Container must be a child of the caller");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "addChildAt: Only Containers will be allowed to add children in v8.0.0");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit("childAdded", child, this, index);\n    child.emit("added", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   * @memberof scene.Container#\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._didContainerChangeTick++;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  },\n  /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */\n  reparentChild(...child) {\n    if (child.length === 1) {\n      return this.reparentChildAt(child[0], this.children.length);\n    }\n    child.forEach((c) => this.reparentChildAt(c, this.children.length));\n    return child[0];\n  },\n  /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */\n  reparentChildAt(child, index) {\n    if (child.parent === this) {\n      this.setChildIndex(child, index);\n      return child;\n    }\n    const childMat = child.worldTransform.clone();\n    child.removeFromParent();\n    this.addChildAt(child, index);\n    const newMatrix = this.worldTransform.clone();\n    newMatrix.invert();\n    childMat.prepend(newMatrix);\n    child.setFromMatrix(childMat);\n    return child;\n  }\n};\n\n\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/filters/FilterEffect.mjs\nvar FilterEffect = __webpack_require__(4411);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(497);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs\n\n\n\n"use strict";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return PoolGroup/* BigPool.get */.u.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    PoolGroup/* BigPool.return */.u["return"](effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nExtensions/* extensions.handleByList */.Rw.handleByList(Extensions/* ExtensionType.MaskEffect */.nw.MaskEffect, MaskEffectManager._effectClasses);\n\n\n//# sourceMappingURL=MaskEffectManager.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs\n\n\n\n"use strict";\nconst effectsMixin = {\n  _maskEffect: null,\n  _maskOptions: {\n    inverse: false\n  },\n  _filterEffect: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value)\n      return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.returnMaskEffect(effect);\n      this._maskEffect = null;\n    }\n    if (value === null || value === void 0)\n      return;\n    this._maskEffect = MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  /**\n   * Used to set mask and control mask options.\n   * @param options\n   * @example\n   * import { Graphics, Sprite } from \'pixi.js\';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.setMask({\n   *     mask: graphics,\n   *     inverse: true,\n   * });\n   * @memberof scene.Container#\n   */\n  setMask(options) {\n    this._maskOptions = {\n      ...this._maskOptions,\n      ...options\n    };\n    if (options.mask) {\n      this.mask = options.mask;\n    }\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container\'s width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from \'pixi.js\';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect/* FilterEffect */.U());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `\'null\'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect/* FilterEffect */.U());\n    this._filterEffect.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\n\n\n//# sourceMappingURL=effectsMixin.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs\n\n\n"use strict";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "Container.name property has been removed, use Container.label instead");\n    return this.label;\n  },\n  set name(value) {\n    (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "Container.name property has been removed, use Container.label instead");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\n\n//# sourceMappingURL=findMixin.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(9460);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(7823);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(8251);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs\n\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const uid = child.uid;\n    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n    const index = previousData.index;\n    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n      previousData.data[previousData.index] = uid;\n      previousData.data[previousData.index + 1] = didChange;\n      previousData.didChange = true;\n    }\n    previousData.index = index + 2;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\n\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs\n\n\n\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds/* Bounds */.Y()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didViewChangeTick;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      (0,getLocalBounds/* getLocalBounds */.a)(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return (0,getGlobalBounds/* getGlobalBounds */.qW)(this, skipUpdate, bounds || new Bounds/* Bounds */.Y());\n  }\n};\n\n\n//# sourceMappingURL=measureMixin.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs\n\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and "updateTransform" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\n\n//# sourceMappingURL=onRenderMixin.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs\n\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child\'s zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\n\n//# sourceMappingURL=sortMixin.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(2022);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs\n\n\n\n\n"use strict";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point/* Point */.E(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\n\n\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(2344);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/RenderGroup.mjs\n\n\n\n"use strict";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = "renderGroup";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix/* Matrix */.y();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet/* InstructionSet */.h();\n    this._onRenderContainers = [];\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender)\n      this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender)\n      this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  updateRenderable(renderable) {\n    if (renderable.globalDisplayStatus < 7)\n      return;\n    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n    renderable.didViewUpdate = false;\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined \'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n  destroy() {\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup)\n      return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n}\n\n\n//# sourceMappingURL=RenderGroup.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs\n\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\n\n//# sourceMappingURL=assignWithIgnore.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/Container.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultSkew = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultPivot = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultScale = new ObservablePoint/* ObservablePoint */.A(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends eventemitter3/* default */.Z {\n  constructor(options = {}) {\n    super();\n    /** unique id for this container */\n    this.uid = (0,uid/* uid */.h)("renderable");\n    /** @private */\n    this._updateFlags = 15;\n    // the render group this container owns\n    /** @private */\n    this.renderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    this.parentRenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    this.parentRenderGroupIndex = 0;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix/* Matrix */.y();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix/* Matrix */.y();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = "inherit";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = "normal";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    this._didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    this._didViewChangeTick = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    this.effects = [];\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */\n  set _didChangeId(value) {\n    this._didViewChangeTick = value >> 12 & 4095;\n    this._didContainerChangeTick = value & 4095;\n  }\n  get _didChangeId() {\n    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "addChild: Only Containers will be allowed to add children in v8.0.0");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.parentRenderGroup) {\n        this.parentRenderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    this.emit("childAdded", child, this, this.children.length - 1);\n    child.emit("added", this);\n    this._didViewChangeTick++;\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this._didViewChangeTick++;\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      } else if (this.parentRenderGroup) {\n        this.parentRenderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit("childRemoved", child, this, index);\n      child.emit("removed", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didContainerChangeTick++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (!!this.renderGroup === value)\n      return;\n    if (value) {\n      this.enableRenderGroup();\n    } else {\n      this.disableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return !!this.renderGroup;\n  }\n  /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   */\n  enableRenderGroup() {\n    if (this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    this.renderGroup = PoolGroup/* BigPool.get */.u.get(RenderGroup, this);\n    this.groupTransform = Matrix/* Matrix.IDENTITY */.y.IDENTITY;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** This will disable the render group for this container. */\n  disableRenderGroup() {\n    if (!this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    PoolGroup/* BigPool.return */.u["return"](this.renderGroup);\n    this.renderGroup = null;\n    this.groupTransform = this.relativeGroupTransform;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.renderGroup && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix/* Matrix */.y());\n    if (this.renderGroup) {\n      this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n    } else if (this.parentRenderGroup) {\n      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * misc_const/* RAD_TO_DEG */.jl;\n  }\n  set angle(value) {\n    this.rotation = value * misc_const/* DEG_TO_RAD */.ZX;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent\'s local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    if (typeof value === "object") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, size.width);\n    height !== void 0 && this._setHeight(height, size.height);\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === "number" ? opts.x : this.position.x,\n      typeof opts.y === "number" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === "number" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === "number" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    const localTransformChangeId = this._didContainerChangeTick;\n    if (this._didLocalTransformChangeId === localTransformChangeId)\n      return;\n    this._didLocalTransformChangeId = localTransformChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color/* Color.shared.setValue */.I.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `\'normal\'` to reset the blend mode.\n   * @default \'normal\'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 2 : 0;\n    if ((this.localDisplayStatus & 2) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 0 : 4;\n    if ((this.localDisplayStatus & 4) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    let oldChildren;\n    if (this.children.length) {\n      oldChildren = this.removeChildren(0, this.children.length);\n    }\n    this.removeFromParent();\n    this.parent = null;\n    this._maskEffect = null;\n    this._filterEffect = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit("destroyed", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === "boolean" ? options : options?.children;\n    if (destroyChildren && oldChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n    this.renderGroup?.destroy();\n    this.renderGroup = null;\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n\n\n//# sourceMappingURL=Container.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/container/Container.mjs_+_12_modules?')},9460:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Y": () => (/* binding */ Bounds)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9959);\n/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4860);\n\n\n\n"use strict";\nconst defaultMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Rectangle */ .A();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Bounds.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs?')},7823:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "I_": () => (/* binding */ updateTransformBackwards),\n/* harmony export */   "qW": () => (/* binding */ getGlobalBounds)\n/* harmony export */ });\n/* unused harmony export _getGlobalBounds */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9959);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2249);\n\n\n\n"use strict";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool.get */ .N.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix.IDENTITY */ .y.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool["return"] */ .N["return"](pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool.get */ .N.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool.get */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix.IDENTITY */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool["return"] */ .W["return"](bounds);\n  }\n  if (!skipUpdateTransform) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool["return"] */ .N["return"](worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\n\n//# sourceMappingURL=getGlobalBounds.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs?')},8251:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ getLocalBounds)\n/* harmony export */ });\n/* unused harmony export getParent */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9959);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2249);\n\n\n\n\n"use strict";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix.IDENTITY */ .y.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool.get */ .N.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool.get */ .N.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool.get */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      target.addBounds(bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix.IDENTITY */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool["return"] */ .W["return"](bounds);\n  }\n  _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool["return"] */ .N["return"](relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn("Item is not inside the root container");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\n\n//# sourceMappingURL=getLocalBounds.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs?')},2249:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "N": () => (/* binding */ matrixPool),\n/* harmony export */   "W": () => (/* binding */ boundsPool)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9959);\n/* harmony import */ var _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1105);\n/* harmony import */ var _Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9460);\n\n\n\n\n"use strict";\nconst matrixPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y);\nconst boundsPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Bounds */ .Y);\n\n\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs?')},7383:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "I": () => (/* binding */ BatchableGraphics)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9959);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs\n\nfunction multiplyHexColors(color1, color2) {\n  if (color1 === 16777215 || !color2)\n    return color2;\n  if (color2 === 16777215 || !color1)\n    return color1;\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 * r2 / 255;\n  const g = g1 * g2 / 255;\n  const b = b1 * b2 / 255;\n  return (r << 16) + (g << 8) + b;\n}\n\n\n//# sourceMappingURL=multiplyHexColors.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\n\n\n\n"use strict";\nconst identityMatrix = new Matrix/* Matrix */.y();\nclass BatchableGraphics {\n  constructor() {\n    this.packAsQuad = false;\n    this.batcherName = "default";\n    this.applyTransform = true;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n  }\n  get uvs() {\n    return this.geometryData.uvs;\n  }\n  get positions() {\n    return this.geometryData.vertices;\n  }\n  get indices() {\n    return this.geometryData.indices;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return "normal";\n  }\n  get color() {\n    const rgb = this.baseColor;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    const renderable = this.renderable;\n    if (renderable) {\n      return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);\n    }\n    return bgr + (this.alpha * 255 << 24);\n  }\n  get transform() {\n    return this.renderable?.groupTransform || identityMatrix;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.attributeOffset = this.attributeOffset;\n    gpuBuffer.attributeSize = this.attributeSize;\n    gpuBuffer.baseColor = this.baseColor;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n    this.renderable = null;\n  }\n}\n\n\n//# sourceMappingURL=BatchableGraphics.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs_+_1_modules?')},8401:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "T": () => (/* binding */ Graphics)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9885);\n/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1372);\n/* harmony import */ var _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5986);\n\n\n\n\n"use strict";\nclass Graphics extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ViewContainer */ .$ {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: "Graphics",\n      ...rest\n    });\n    this.renderPipeId = "graphics";\n    if (!context) {\n      this._context = this._ownedContext = new _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g();\n    } else {\n      this._context = context;\n    }\n    this._context.on("update", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off("update", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on("update", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod("setFillStyle", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod("setStrokeStyle", args);\n  }\n  fill(...args) {\n    return this._callContextMethod("fill", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyle parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod("stroke", args);\n  }\n  texture(...args) {\n    return this._callContextMethod("texture", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod("beginPath", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod("cut", []);\n  }\n  arc(...args) {\n    return this._callContextMethod("arc", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod("arcTo", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod("arcToSvg", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod("bezierCurveTo", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod("closePath", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod("ellipse", args);\n  }\n  circle(...args) {\n    return this._callContextMethod("circle", args);\n  }\n  path(...args) {\n    return this._callContextMethod("path", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod("lineTo", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod("moveTo", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod("quadraticCurveTo", args);\n  }\n  rect(...args) {\n    return this._callContextMethod("rect", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod("roundRect", args);\n  }\n  poly(...args) {\n    return this._callContextMethod("poly", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod("regularPoly", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod("roundPoly", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod("roundShape", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod("filletRect", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod("chamferRect", args);\n  }\n  star(...args) {\n    return this._callContextMethod("star", args);\n  }\n  svg(...args) {\n    return this._callContextMethod("svg", args);\n  }\n  restore(...args) {\n    return this._callContextMethod("restore", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod("save", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod("resetTransform", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod("rotate", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod("scale", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod("setTransform", args);\n  }\n  transform(...args) {\n    return this._callContextMethod("transform", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod("translate", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod("clear", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultStrokeStyle.width */ .g.defaultStrokeStyle.width || strokeStyle.color !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultStrokeStyle.color */ .g.defaultStrokeStyle.color || strokeStyle.alpha !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultStrokeStyle.alpha */ .g.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#drawCircle has been renamed to Graphics#circle");\n    return this._callContextMethod("circle", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#drawEllipse has been renamed to Graphics#ellipse");\n    return this._callContextMethod("ellipse", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#drawPolygon has been renamed to Graphics#poly");\n    return this._callContextMethod("poly", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#drawRect has been renamed to Graphics#rect");\n    return this._callContextMethod("rect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");\n    return this._callContextMethod("roundRect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .PD, "Graphics#drawStar has been renamed to Graphics#star");\n    return this._callContextMethod("star", args);\n  }\n}\n\n\n//# sourceMappingURL=Graphics.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs?')},5986:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "g": () => (/* binding */ GraphicsContext)\n});\n\n// EXTERNAL MODULE: ../node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(3806);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(3294);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9959);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(2022);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(1775);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(7321);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(9885);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(9460);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(6576);\n// EXTERNAL MODULE: ../node_modules/parse-svg-path/index.js\nvar parse_svg_path = __webpack_require__(7981);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs\n\n\n\n"use strict";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse_svg_path(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case "M":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "m":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "H":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "h":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "V":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "v":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "L":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "l":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "C":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case "c":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case "S":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "s":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "Q":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "q":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "T":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "t":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "A":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "a":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "Z":\n      case "z":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        (0,warn/* warn */.Z)(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== "Z" && type !== "z") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\n\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(4860);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/maths/shapes/Circle.mjs\n\n\n"use strict";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'circle\'\n     */\n    this.type = "circle";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs\n\n\n"use strict";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'ellipse\'\n     */\n    this.type = "ellipse";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x - this.halfWidth;\n    out.y = this.y - this.halfHeight;\n    out.width = this.halfWidth * 2;\n    out.height = this.halfHeight * 2;\n    return out;\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs\n\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\n\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/maths/shapes/Polygon.mjs\n\n\n\n"use strict";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'polygon\'\n     */\n    this.type = "polygon";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs\n\n\n"use strict";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'roundedRectangle\'\n     */\n    this.type = "roundedRectangle";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(3907);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs\n\n\n"use strict";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem.defaultOptions.bezierSmoothness */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs\n\n\n"use strict";\nconst buildAdaptiveQuadratic_RECURSION_LIMIT = 8;\nconst buildAdaptiveQuadratic_FLT_EPSILON = 11920929e-14;\nconst buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON = 1;\nconst buildAdaptiveQuadratic_curveAngleToleranceEpsilon = 0.01;\nconst buildAdaptiveQuadratic_mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem.defaultOptions.bezierSmoothness */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  buildAdaptiveQuadratic_recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction buildAdaptiveQuadratic_recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > buildAdaptiveQuadratic_RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > buildAdaptiveQuadratic_FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (buildAdaptiveQuadratic_mAngleTolerance < buildAdaptiveQuadratic_curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < buildAdaptiveQuadratic_mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  buildAdaptiveQuadratic_recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  buildAdaptiveQuadratic_recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs\n\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\n\n//# sourceMappingURL=buildArc.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs\n\n\n"use strict";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\n\n//# sourceMappingURL=buildArcTo.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs\n\n\n"use strict";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\n\n//# sourceMappingURL=buildArcToSvg.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs\n\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\n\n//# sourceMappingURL=roundShape.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempRectangle = new Rectangle/* Rectangle */.A();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle/* Rectangle */.A(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\n\n//# sourceMappingURL=ShapePath.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = (0,uid/* uid */.h)("graphicsPath");\n    this._dirty = true;\n    if (typeof instructions === "string") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: "addPath", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: "arc", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: "arcTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: "arcToSvg", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: "bezierCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point.shared */.E.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== "bezierCurveTo") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: "closePath", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: "ellipse", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: "lineTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: "moveTo", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: "quadraticCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point.shared */.E.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== "quadraticCurveTo") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: "circle", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: "roundRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: "poly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: "regularPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: "roundPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: "roundShape", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: "filletRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: "chamferRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path\'s geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation\'s effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path\'s appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case "moveTo":\n        case "lineTo":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case "bezierCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case "quadraticCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case "arcToSvg":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case "circle":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case "rect":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case "ellipse":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case "roundRect":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case "addPath":\n          data[0].transform(matrix);\n          break;\n        case "poly":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          (0,warn/* warn */.Z)("unknown transform action", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path\'s current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point\'s position is accurately determined regardless of the path\'s complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point\'s coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point\'s coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === "closePath") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case "moveTo":\n      case "lineTo":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case "quadraticCurveTo":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case "bezierCurveTo":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case "arc":\n      case "arcToSvg":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case "addPath":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\n\n//# sourceMappingURL=GraphicsPath.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs\n\n\n\n"use strict";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === "string") {\n    const div = document.createElement("div");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector("svg");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case "path":\n      d = svg.getAttribute("d");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "circle":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      r = parseFloatAttribute(svg, "r", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "rect":\n      x = parseFloatAttribute(svg, "x", 0);\n      y = parseFloatAttribute(svg, "y", 0);\n      width = parseFloatAttribute(svg, "width", 0);\n      height = parseFloatAttribute(svg, "height", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "ellipse":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "line":\n      x1 = parseFloatAttribute(svg, "x1", 0);\n      y1 = parseFloatAttribute(svg, "y1", 0);\n      x2 = parseFloatAttribute(svg, "x2", 0);\n      y2 = parseFloatAttribute(svg, "y2", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polygon":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polyline":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "g":\n    case "svg":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute("style");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(";");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(":");\n      switch (key) {\n        case "stroke":\n          if (value !== "none") {\n            strokeStyle.color = Color/* Color.shared.setValue */.I.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case "stroke-width":\n          strokeStyle.width = Number(value);\n          break;\n        case "fill":\n          if (value !== "none") {\n            useFill = true;\n            fillStyle.color = Color/* Color.shared.setValue */.I.shared.setValue(value).toNumber();\n          }\n          break;\n        case "fill-opacity":\n          fillStyle.alpha = Number(value);\n          break;\n        case "stroke-opacity":\n          strokeStyle.alpha = Number(value);\n          break;\n        case "opacity":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute("stroke");\n    if (stroke && stroke !== "none") {\n      useStroke = true;\n      strokeStyle.color = Color/* Color.shared.setValue */.I.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);\n    }\n    const fill = svg.getAttribute("fill");\n    if (fill && fill !== "none") {\n      useFill = true;\n      fillStyle.color = Color/* Color.shared.setValue */.I.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\n\n//# sourceMappingURL=SVGParser.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs\nvar convertFillInputToFillStyle = __webpack_require__(4450);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tmpPoint = new Point/* Point */.E();\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst _GraphicsContext = class _GraphicsContext extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    /** unique id for this graphics context */\n    this.uid = (0,uid/* uid */.h)("graphicsContext");\n    this.dirty = true;\n    this.batchMode = "auto";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix/* Matrix */.y();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* toStrokeStyle */.m)(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: "texture",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color/* Color.shared.setValue */.I.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === "number") {\n        (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = (0,convertFillInputToFillStyle/* toFillStyle */.f)(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: "fill",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point/* Point.shared */.E.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = (0,convertFillInputToFillStyle/* toStrokeStyle */.m)(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: "stroke",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The arc\'s radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc\'s radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === "moveTo") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit("update", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === "fill") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === "texture") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === "stroke") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it\'s contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === "fill") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture.WHITE */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: "butt",\n  /** The line join style to use. */\n  join: "miter",\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture.WHITE */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\n\n//# sourceMappingURL=GraphicsContext.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs_+_15_modules?')},3907:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "hJ": () => (/* binding */ GraphicsContextSystem)\n});\n\n// UNUSED EXPORTS: GpuGraphicsContext, GraphicsContextRenderData\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(497);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs\nvar getTextureBatchBindGroup = __webpack_require__(9926);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs + 4 modules\nvar DefaultBatcher = __webpack_require__(4110);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(2344);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(9885);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(4398);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(4860);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs\n\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=buildUvs.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs\n\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\n\n//# sourceMappingURL=transformVertices.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(1775);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs + 1 modules\nvar BatchableGraphics = __webpack_require__(7383);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs\n\n\n"use strict";\nconst buildCircle = {\n  extension: {\n    type: Extensions/* ExtensionType.ShapeBuilder */.nw.ShapeBuilder,\n    name: "circle"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === "circle") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === "ellipse") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };\nconst buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };\n\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(2022);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/const.mjs\n\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs\n\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\n\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs\n\n\n\n\n"use strict";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point/* Point */.E(points[0], points[1]);\n  const lastPoint = new Point/* Point */.E(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === "round") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === "round") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === "round") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\n\n//# sourceMappingURL=buildLine.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(1106);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs\n\n\n"use strict";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\n\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs\n\n\n\n"use strict";\nconst emptyArray = [];\nconst buildPolygon = {\n  extension: {\n    type: Extensions/* ExtensionType.ShapeBuilder */.nw.ShapeBuilder,\n    name: "polygon"\n  },\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\n\n//# sourceMappingURL=buildPolygon.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs\n\n\n"use strict";\nconst buildRectangle = {\n  extension: {\n    type: Extensions/* ExtensionType.ShapeBuilder */.nw.ShapeBuilder,\n    name: "rectangle"\n  },\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs\n\n\n"use strict";\nconst buildTriangle = {\n  extension: {\n    type: Extensions/* ExtensionType.ShapeBuilder */.nw.ShapeBuilder,\n    name: "triangle"\n  },\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildTriangle.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst shapeBuilders = {};\nExtensions/* extensions.handleByMap */.Rw.handleByMap(Extensions/* ExtensionType.ShapeBuilder */.nw.ShapeBuilder, shapeBuilders);\nExtensions/* extensions.add */.Rw.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle/* Rectangle */.A();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === "texture") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === "fill" || instruction.action === "stroke") {\n      const isStroke = instruction.action === "stroke";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = PoolGroup/* BigPool.get */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.attributeOffset = vertOffset;\n  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.baseColor = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn("[Pixi Graphics] only the last shape have be cut out");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture/* Texture.WHITE */.x.WHITE) {\n      const textureMatrix = style.matrix;\n      if (textureMatrix) {\n        if (matrix) {\n          textureMatrix.append(matrix.clone().invert());\n        }\n        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n      }\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = PoolGroup/* BigPool.get */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\n\n//# sourceMappingURL=buildContextBatches.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.batcher = new DefaultBatcher/* DefaultBatcher */.h();\n    this.instructions = new InstructionSet/* InstructionSet */.h();\n  }\n  init() {\n    this.instructions.reset();\n  }\n  /**\n   * @deprecated since version 8.0.0\n   * Use `batcher.geometry` instead.\n   * @see {Batcher#geometry}\n   */\n  get geometry() {\n    (0,deprecation/* deprecation */.a1)(deprecation/* v8_3_4 */.$q, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");\n    return this.batcher.geometry;\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor(renderer) {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    renderer.renderableGC.addManagedHash(this, "_gpuContextHash");\n    renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === "no-batch") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === "auto") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = PoolGroup/* BigPool.get */.u.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = graphicsData.batcher;\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = batcher.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.Q)(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on("destroy", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off("destroy", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        PoolGroup/* BigPool.return */.u["return"](this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        PoolGroup/* BigPool.return */.u["return"](batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType.WebGLSystem */.nw.WebGLSystem,\n    Extensions/* ExtensionType.WebGPUSystem */.nw.WebGPUSystem,\n    Extensions/* ExtensionType.CanvasSystem */.nw.CanvasSystem\n  ],\n  name: "graphicsContext"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\n\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs_+_11_modules?')},2958:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "f": () => (/* binding */ FillGradient)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3294);\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4598);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9959);\n/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8360);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1775);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7321);\n\n\n\n\n\n\n\n"use strict";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    /** unique id for this fill gradient */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillGradient");\n    this.type = "linear";\n    this.gradientStops = [];\n    this._styleKey = null;\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color.shared.setValue */ .I.shared.setValue(color).toHexa() });\n    this._styleKey = null;\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__/* .DOMAdapter.get */ .z.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext("2d");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture */ .x({\n      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__/* .ImageSource */ .c({\n        resource: canvas,\n        addressModeU: "clamp-to-edge",\n        addressModeV: "repeat"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__/* .Matrix */ .y();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey) {\n      return this._styleKey;\n    }\n    const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join("-");\n    const texture = this.texture.uid;\n    const transform = this.transform.toArray().join("-");\n    return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\n\n//# sourceMappingURL=FillGradient.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs?')},2301:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": () => (/* binding */ FillPattern)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9959);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7321);\n\n\n\n"use strict";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: "repeat",\n    addressModeV: "repeat"\n  },\n  "repeat-x": {\n    addressModeU: "repeat",\n    addressModeV: "clamp-to-edge"\n  },\n  "repeat-y": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "repeat"\n  },\n  "no-repeat": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "clamp-to-edge"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    /** unique id for this fill pattern */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillPattern");\n    this.transform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y();\n    this._styleKey = null;\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey)\n      return this._styleKey;\n    this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;\n    return this._styleKey;\n  }\n}\n\n\n//# sourceMappingURL=FillPattern.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs?')},4450:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "f": () => (/* binding */ toFillStyle),\n/* harmony export */   "m": () => (/* binding */ toStrokeStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3294);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9959);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1775);\n/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2958);\n/* harmony import */ var _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2301);\n\n\n\n\n\n\n"use strict";\nfunction isColorLike(value) {\n  return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color.isColorLike */ .I.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_1__/* .FillPattern */ .h;\n}\nfunction isFillGradient(value) {\n  return value instanceof _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__/* .FillGradient */ .f;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color.shared.setValue */ .I.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture.WHITE */ .x.WHITE;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildLinearGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture.WHITE */ .x.WHITE) {\n      const m = style.matrix?.invert() || new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Matrix */ .y();\n      m.translate(style.texture.frame.x, style.texture.frame.y);\n      m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === "clamp-to-edge") {\n      sourceStyle.addressMode = "repeat";\n      sourceStyle.update();\n    }\n  }\n  const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color.shared.setValue */ .I.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    ...fill\n  };\n}\n\n\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs?')},7259:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "j": () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5446);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1775);\n/* harmony import */ var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6988);\n/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1372);\n\n\n\n\n\n"use strict";\nclass Sprite extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ViewContainer */ .$ {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture.EMPTY */ .x.EMPTY) {\n    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      options = { texture: options };\n    }\n    const { texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture.EMPTY */ .x.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: "Sprite",\n      ...rest\n    });\n    this.renderPipeId = "sprite";\n    this.batched = true;\n    this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._sourceBoundsDirty = true;\n    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ObservablePoint */ .A(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      return new Sprite(source);\n    }\n    return new Sprite(_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture.from */ .x.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture.EMPTY */ .x.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off("update", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on("update", this.onViewUpdate, this);\n    this._texture = value;\n    if (this._width) {\n      this._setWidth(this._width, this._texture.orig.width);\n    }\n    if (this._height) {\n      this._setHeight(this._height, this._texture.orig.height);\n    }\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture\'s trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    super.onViewUpdate();\n  }\n  _updateBounds() {\n    (0,_utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__/* .updateQuadBounds */ .w)(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const { width, height } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite\'s origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite\'s origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite\'s origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n    this._width = value;\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n    this._height = value;\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === "object") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this._texture.orig.width);\n    height !== void 0 && this._setHeight(height, this._texture.orig.height);\n  }\n}\n\n\n//# sourceMappingURL=Sprite.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/sprite/Sprite.mjs?')},9442:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "M": () => (/* binding */ AbstractBitmapFont)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3806);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9885);\n\n\n\n"use strict";\nclass AbstractBitmapFont extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = "";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: "none", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    this.applyFillAsTint = true;\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .PD, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .PD, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .PD, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or "none".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .PD, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .PD, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture?.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\n\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs?')},9159:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "W": () => (/* binding */ BitmapFontManager)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(1778);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(9885);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(6576);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(2624);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(3294);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(4860);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(3282);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(8360);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(1775);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(6858);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(2076);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(6973);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs\nvar AbstractBitmapFont = __webpack_require__(9442);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs\n\nfunction resolveCharacters(chars) {\n  if (chars === "") {\n    return [];\n  }\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error("[BitmapFont]: Invalid character delimiter.");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst _DynamicBitmapFont = class _DynamicBitmapFont extends AbstractBitmapFont/* AbstractBitmapFont */.M {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 0;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = { ..._DynamicBitmapFont.defaultOptions, ...options };\n    this._textureSize = dynamicOptions.textureSize;\n    this._mipmap = dynamicOptions.mipmap;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture/* Texture.WHITE */.x.WHITE;\n      style._fill.fill = null;\n    }\n    this.applyFillAsTint = dynamicOptions.overrideFill;\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics/* CanvasTextMetrics.measureFont */.c.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics/* CanvasTextMetrics.measureText */.c.measureText(char, style, canvas, false);\n      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * metrics.width);\n      metrics.lineHeight = metrics.height;\n      const width = metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = textureGlyphWidth + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== "\\n" && char !== "\\r" && char !== "\t" && char !== " ") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > this._textureSize) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > this._textureSize) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle/* Rectangle */.A(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture/* Texture */.x({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool/* CanvasPool.getOptimalCanvasAndContext */.h.getOptimalCanvasAndContext(\n      this._textureSize,\n      this._textureSize,\n      textureResolution\n    );\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture/* Texture */.x({\n      source: new ImageSource/* ImageSource */.c({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: "premultiply-alpha-on-upload",\n        autoGenerateMipmaps: this._mipmap\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color/* Color.shared.setValue */.I.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = "black";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool/* CanvasPool.returnCanvasAndContext */.h.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n};\n_DynamicBitmapFont.defaultOptions = {\n  textureSize: 512,\n  style: new TextStyle/* TextStyle */.p(),\n  mipmap: true\n};\nlet DynamicBitmapFont = _DynamicBitmapFont;\n\n\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs\nvar getBitmapTextLayout = __webpack_require__(7331);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs\n\n\n\n\n\n\n\n\n"use strict";\nlet fontCount = 0;\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [["a", "z"], ["A", "Z"], " "];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [["0", "9"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[" ", "~"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill && !style._stroke) {\n      fontFamilyKey += style._fill.fill.styleKey;\n      overrideFill = false;\n    } else if (style._stroke || style.dropShadow) {\n      let key = style.styleKey;\n      key = key.substring(0, key.lastIndexOf("-"));\n      fontFamilyKey = `${key}-bitmap`;\n      overrideFill = false;\n    }\n    if (!Cache/* Cache.has */.C.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fontCount++;\n      if (fontCount > 50) {\n        (0,warn/* warn */.Z)("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:"style1", style})\\``);\n      }\n      fnt.once("destroy", () => {\n        fontCount--;\n        Cache/* Cache.remove */.C.remove(fontFamilyKey);\n      });\n      Cache/* Cache.set */.C.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache/* Cache.get */.C.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  getLayout(text, style, trimEnd = true) {\n    const bitmapFont = this.getFont(text, style);\n    return (0,getBitmapTextLayout/* getBitmapTextLayout */._)([...text], style, bitmapFont, trimEnd);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  measureText(text, style, trimEnd = true) {\n    return this.getLayout(text, style, trimEnd);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === "string") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      (0,deprecation/* deprecation */.a1)(deprecation/* v8_0_0 */.PD, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error("[BitmapFontManager] Property `name` is required.");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle/* TextStyle */.p ? textStyle : new TextStyle/* TextStyle */.p(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(""));\n    Cache/* Cache.set */.C.set(`${name}-bitmap`, font);\n    font.once("destroy", () => Cache/* Cache.remove */.C.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache/* Cache.get */.C.get(cacheKey);\n    if (font) {\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\n\n//# sourceMappingURL=BitmapFontManager.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs_+_2_modules?')},7331:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "_": () => (/* binding */ getBitmapTextLayout)\n/* harmony export */ });\n\nfunction getBitmapTextLayout(chars, style, font, trimEnd) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    if (trimEnd) {\n      let lastChar = currentLine.chars[index];\n      while (lastChar === " ") {\n        currentLine.width -= font.chars[lastChar].xAdvance;\n        lastChar = currentLine.chars[--index];\n      }\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[" "];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === "\\r" || char === "\\n" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === "\\r" || char === "\\n") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === "center") {\n    alignCenter(layoutData);\n  } else if (style.align === "right") {\n    alignRight(layoutData);\n  } else if (style.align === "justify") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\n\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs?')},2624:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"p\": () => (/* binding */ TextStyle)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3806);\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3294);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9885);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2958);\n/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2301);\n/* harmony import */ var _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5986);\n/* harmony import */ var _graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4450);\n/* harmony import */ var _utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9528);\n\n\n\n\n\n\n\n\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Z {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = this._createProxy({ ..._TextStyle.defaultDropShadow, ...value });\n    } else {\n      this._dropShadow = value ? this._createProxy({ ..._TextStyle.defaultDropShadow }) : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value.toLowerCase();\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    if (this._isFillStyle(value)) {\n      this._originalFill = this._createProxy({ ..._graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultFillStyle */ .g.defaultFillStyle, ...value }, () => {\n        this._fill = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__/* .toFillStyle */ .f)(\n          { ...this._originalFill },\n          _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultFillStyle */ .g.defaultFillStyle\n        );\n      });\n    }\n    this._fill = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__/* .toFillStyle */ .f)(\n      value === 0 ? \"black\" : value,\n      _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultFillStyle */ .g.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    if (this._isFillStyle(value)) {\n      this._originalStroke = this._createProxy({ ..._graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultStrokeStyle */ .g.defaultStrokeStyle, ...value }, () => {\n        this._stroke = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__/* .toStrokeStyle */ .m)(\n          { ...this._originalStroke },\n          _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultStrokeStyle */ .g.defaultStrokeStyle\n        );\n      });\n    }\n    this._stroke = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__/* .toStrokeStyle */ .m)(value, _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext.defaultStrokeStyle */ .g.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = (0,_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__/* .generateTextStyleKey */ .L)(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n  _createProxy(value, cb) {\n    return new Proxy(value, {\n      set: (target, property, newValue) => {\n        target[property] = newValue;\n        cb?.(property, newValue);\n        this.update();\n        return true;\n      }\n    });\n  }\n  _isFillStyle(value) {\n    return (value ?? null) !== null && !(_color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Color.isColorLike */ .I.isColorLike(value) || value instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__/* .FillGradient */ .f || value instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__/* .FillPattern */ .h);\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness !== void 0) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__/* .v8_0_0 */ .PD, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    let obj = {};\n    if (_color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Color.isColorLike */ .I.isColorLike(color)) {\n      obj.color = color;\n    } else if (color instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__/* .FillGradient */ .f || color instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__/* .FillPattern */ .h) {\n      obj.fill = color;\n    } else if (Object.hasOwnProperty.call(color, \"color\") || Object.hasOwnProperty.call(color, \"fill\")) {\n      obj = color;\n    } else {\n      throw new Error(\"Invalid stroke value.\");\n    }\n    style.stroke = {\n      ...obj,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fillGradientStops)) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__/* .deprecation */ .a1)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__/* .v8_0_0 */ .PD, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    let fontSize;\n    if (style.fontSize == null) {\n      style.fontSize = TextStyle.defaultTextStyle.fontSize;\n    } else if (typeof style.fontSize === \"string\") {\n      fontSize = parseInt(style.fontSize, 10);\n    } else {\n      fontSize = style.fontSize;\n    }\n    const gradientFill = new _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__/* .FillGradient */ .f(0, 0, 0, fontSize * 1.7);\n    const fills = oldStyle.fillGradientStops.map((color) => _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Color.shared.setValue */ .I.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = index / (fills.length - 1);\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\n\n//# sourceMappingURL=TextStyle.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text/TextStyle.mjs?")},6858:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ CanvasTextMetrics)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4598);\n/* harmony import */ var _utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2076);\n\n\n\n"use strict";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter.get */ .z.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = " ", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = (0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .fontStringFromTextStyle */ .M)(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    const metrics = context.measureText(text);\n    let metricWidth = metrics.width;\n    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n    if (metricWidth > 0) {\n      if (useExperimentalLetterSpacing) {\n        metricWidth -= letterSpacing;\n        boundsWidth -= letterSpacing;\n      } else {\n        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        metricWidth += val;\n        boundsWidth += val;\n      }\n    }\n    return Math.max(metricWidth, boundsWidth);\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object\'s wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0;\n    let line = "";\n    let lines = "";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = "";\n          width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== "") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = "";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = "";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = "";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== "number") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== "string") {\n      return "";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text !== "string") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== "") {\n          tokens.push(token);\n          token = "";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== "") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = "") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext("2d", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter.get */ .z.get().createCanvas();\n      } catch (ex) {\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter.get */ .z.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = "|\\xC9q\\xC5";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = "M";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `\'\\u0065\\u0301\'`, letter e with acute)\n * or emojis with modifiers (e.g. `\'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don\'t support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won\'t use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome\'s new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\n\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs?')},2076:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "M": () => (/* binding */ fontStringFromTextStyle)\n/* harmony export */ });\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(",");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `"${fontFamily}"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n}\n\n\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs?')},6973:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "m": () => (/* binding */ getCanvasFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3294);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9959);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1775);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6576);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2958);\n/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2301);\n\n\n\n\n\n\n\n"use strict";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Texture.WHITE */ .x.WHITE && !fillStyle.fill) {\n    return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color.shared.setValue */ .I.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");\n    const tempMatrix = fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix.shared */ .y.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillPattern */ .h) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");\n    const tempMatrix = fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix.shared */ .y.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__/* .FillGradient */ .f) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === "linear") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color.shared.setValue */ .I.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__/* .warn */ .Z)("FillStyle not recognised", fillStyle);\n  return "red";\n}\n\n\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs?')},9528:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "L": () => (/* binding */ generateTextStyleKey)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3294);\n\n\n"use strict";\nconst valuesToIterateForKeys = [\n  "align",\n  "breakWords",\n  "cssOverrides",\n  "fontVariant",\n  "fontWeight",\n  "leading",\n  "letterSpacing",\n  "lineHeight",\n  "padding",\n  "textBaseline",\n  "trim",\n  "whiteSpace",\n  "wordWrap",\n  "wordWrapWidth",\n  "fontFamily",\n  "fontStyle",\n  "fontSize"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = `_${valuesToIterateForKeys[i]}`;\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  index = addDropShadowKey(style.dropShadow, key, index);\n  return key.join("-");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.styleKey;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\nfunction addDropShadowKey(dropShadow, key, index) {\n  if (!dropShadow)\n    return index;\n  key[index++] = dropShadow.alpha;\n  key[index++] = dropShadow.angle;\n  key[index++] = dropShadow.blur;\n  key[index++] = dropShadow.distance;\n  key[index++] = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color.shared.setValue */ .I.shared.setValue(dropShadow.color).toNumber();\n  return index;\n}\n\n\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs?')},1372:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "$": () => (/* binding */ ViewContainer)\n/* harmony export */ });\n/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9460);\n/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4383);\n\n\n\n"use strict";\nclass ViewContainer extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Container */ .W2 {\n  constructor() {\n    super(...arguments);\n    /** @private */\n    this.canBundle = true;\n    /** @private */\n    this.allowChildren = false;\n    /** @private */\n    this._roundPixels = 0;\n    /** @private */\n    this._lastUsed = 0;\n    /** @private */\n    this._lastInstructionTick = -1;\n    this._bounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Bounds */ .Y(0, 1, 0, 0);\n    this._boundsDirty = true;\n  }\n  /** @private */\n  _updateBounds() {\n  }\n  /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    const { x, y } = point;\n    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n  }\n  /** @private */\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._bounds = null;\n  }\n}\n\n\n//# sourceMappingURL=ViewContainer.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/scene/view/ViewContainer.mjs?')},7736:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(497);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(9032);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/resolver/Resolver.mjs + 1 modules\nvar Resolver = __webpack_require__(8783);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(4154);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(1775);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(7381);\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(4860);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs\n\n\n\n"use strict";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture/* Texture */.x ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle/* Rectangle */.A(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle/* Rectangle */.A(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture/* Texture */.x({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don\'t use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\n\n//# sourceMappingURL=Spritesheet.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst validImages = [\n  "jpg",\n  "png",\n  "jpeg",\n  "avif",\n  "webp",\n  "basis",\n  "etc2",\n  "bc7",\n  "bc6h",\n  "bc5",\n  "bc4",\n  "bc3",\n  "bc2",\n  "bc1",\n  "eac",\n  "astc"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path/* path.dirname */.E.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: Extensions/* ExtensionType.Asset */.nw.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    extension: {\n      type: Extensions/* ExtensionType.ResolveParser */.nw.ResolveParser,\n      name: "resolveSpritesheet"\n    },\n    test: (value) => {\n      const tempURL = value.split("?")[0];\n      const split = tempURL.split(".");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === "json" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(".");\n      return {\n        resolution: parseFloat(Resolver/* Resolver.RETINA_PREFIX.exec */.H.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: "spritesheetLoader",\n    extension: {\n      type: Extensions/* ExtensionType.LoadParser */.nw.LoadParser,\n      priority: LoaderParser/* LoaderParserPriority.Normal */.Q.Normal,\n      name: "spritesheetLoader"\n    },\n    async testParse(asset, options) {\n      return path/* path.extname */.E.extname(options.src).toLowerCase() === ".json" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path/* path.dirname */.E.dirname(options.src);\n      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {\n        basePath += "/";\n      }\n      let texture;\n      if (imageTexture instanceof Texture/* Texture */.x) {\n        texture = imageTexture;\n      } else {\n        const imagePath = (0,copySearchParams/* copySearchParams */.u)(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== "string") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = (0,copySearchParams/* copySearchParams */.u)(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\n\n//# sourceMappingURL=spritesheetAsset.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/spritesheet/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions.add */.Rw.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/spritesheet/init.mjs_+_2_modules?')},5883:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"v\": () => (/* binding */ Ticker)\n});\n\n// EXTERNAL MODULE: ../node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(3860);\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/ticker/TickerListener.mjs\n\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\n\n//# sourceMappingURL=TickerListener.mjs.map\n\n;// CONCATENATED MODULE: ../node_modules/pixi.js/lib/ticker/Ticker.mjs\n\n\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = ticker_const/* UPDATE_PRIORITY.NORMAL */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = ticker_const/* UPDATE_PRIORITY.NORMAL */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\n\n//# sourceMappingURL=Ticker.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/ticker/Ticker.mjs_+_1_modules?")},3860:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "u": () => (/* binding */ UPDATE_PRIORITY)\n/* harmony export */ });\n\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/ticker/const.mjs?')},6886:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "D": () => (/* binding */ detectVideoAlphaMode)\n/* harmony export */ });\n\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement("canvas");\n    const gl = canvas.getContext("webgl");\n    if (!gl) {\n      return "premultiply-alpha-on-upload";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement("video");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = "anonymous";\n      video2.preload = "auto";\n      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";\n      video2.load();\n    });\n    if (!video) {\n      return "premultiply-alpha-on-upload";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension("WEBGL_lose_context")?.loseContext();\n    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";\n  })());\n  return promise;\n}\n\n\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs?')},8222:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "O": () => (/* binding */ unsafeEvalSupported)\n/* harmony export */ });\n\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === "boolean") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");\n    unsafeEval = func({ a: "b" }, "a", "b") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\n\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs?')},1092:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "q4": () => (/* binding */ VERSION)\n/* harmony export */ });\n/* unused harmony export DATA_URI */\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3806);\n\n\n"use strict";\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\nconst VERSION = "8.5.2";\n\n\n//# sourceMappingURL=const.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/const.mjs?')},956:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "R": () => (/* binding */ ViewableBuffer)\n/* harmony export */ });\n\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === "number") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs?')},5460:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "E": () => (/* binding */ removeItems)\n/* harmony export */ });\n\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\n\n//# sourceMappingURL=removeItems.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/data/removeItems.mjs?')},7321:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": () => (/* binding */ uid)\n/* harmony export */ });\n/* unused harmony export resetUids */\n\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = "default") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\n\n//# sourceMappingURL=uid.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/data/uid.mjs?')},6988:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "w": () => (/* binding */ updateQuadBounds)\n/* harmony export */ });\n\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\n\n//# sourceMappingURL=updateQuadBounds.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs?')},3587:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "C": () => (/* binding */ RendererInitHook),\n/* harmony export */   "l": () => (/* binding */ ApplicationInitHook)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(497);\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1092);\n\n\n\n"use strict";\nclass ApplicationInitHook {\n  static init() {\n    globalThis.__PIXI_APP_INIT__?.(this, _const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .VERSION */ .q4);\n  }\n  static destroy() {\n  }\n}\n/** @ignore */\nApplicationInitHook.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__/* .ExtensionType.Application */ .nw.Application;\nclass RendererInitHook {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  init() {\n    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, _const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .VERSION */ .q4);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRendererInitHook.extension = {\n  type: [\n    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__/* .ExtensionType.WebGLSystem */ .nw.WebGLSystem,\n    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__/* .ExtensionType.WebGPUSystem */ .nw.WebGPUSystem\n  ],\n  name: "initHook",\n  priority: -10\n};\n\n\n//# sourceMappingURL=globalHooks.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/global/globalHooks.mjs?')},9885:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "$q": () => (/* binding */ v8_3_4),\n/* harmony export */   "PD": () => (/* binding */ v8_0_0),\n/* harmony export */   "a1": () => (/* binding */ deprecation)\n/* harmony export */ });\n\nconst warnings = {};\nconst v8_0_0 = "8.0.0";\nconst v8_3_4 = "8.3.4";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === "undefined") {\n    console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split("\\n").splice(ignoreDepth).join("\\n");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        "%cPixiJS Deprecation Warning: %c%s",\n        "color:#614108;background:#fffbe6",\n        "font-weight:normal;color:#614108;background:#fffbe6",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\n\n//# sourceMappingURL=deprecation.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/logging/deprecation.mjs?')},6576:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (/* binding */ warn)\n/* harmony export */ });\n\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");\n  } else {\n    console.warn("PixiJS Warning: ", ...args);\n  }\n}\n\n\n//# sourceMappingURL=warn.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/logging/warn.mjs?')},7381:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "E": () => (/* binding */ path)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4598);\n\n\n"use strict";\nfunction assertPath(path2) {\n  if (typeof path2 !== "string") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split("?")[0];\n  return re.split("#")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = "";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf("/");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = "";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = "";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += "/..";\n          } else {\n            res = "..";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, "\\\\", "/");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&\',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith("blob:");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return "";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it\'s not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter.get */ .z.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith("/")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving \'..\' and \'.\' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = "";\n    const isAbsolute = path2.startsWith("/");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith("/");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += "/";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith("/");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return ".";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? "";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return ".";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return "//";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = "";\n    if (path2.startsWith("/"))\n      root = "/";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf("/", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith("/"))\n        root += "/";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return "";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return "";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return "";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the \'root\', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: "", dir: "", base: "", ext: "", name: "" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = "";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: "/",\n  delimiter: ":",\n  joinExtensions: [".html"]\n};\n\n\n//# sourceMappingURL=path.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/path.mjs?')},1105:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"K\": () => (/* binding */ Pool)\n/* harmony export */ });\n\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n  /** clears the pool - mainly used for debugging! */\n  clear() {\n    this._pool.length = 0;\n    this._index = 0;\n  }\n}\n\n\n//# sourceMappingURL=Pool.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/pool/Pool.mjs?")},4398:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "u": () => (/* binding */ BigPool)\n/* harmony export */ });\n/* unused harmony export PoolGroupClass */\n/* harmony import */ var _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1105);\n\n\n"use strict";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item\'s constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\n\n//# sourceMappingURL=PoolGroup.mjs.map\n\n\n//# sourceURL=webpack:///../node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs?')}},__webpack_module_cache__={},inProgress;function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.d=(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},__webpack_require__.f={},__webpack_require__.e=n=>Promise.all(Object.keys(__webpack_require__.f).reduce(((e,t)=>(__webpack_require__.f[t](n,e),e)),[])),__webpack_require__.u=n=>n+".game.min."+__webpack_require__.h().slice(0,8)+".js",__webpack_require__.h=()=>"3e4266602d1b0077ad64",__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),inProgress={},__webpack_require__.l=(n,e,t,r)=>{if(inProgress[n])inProgress[n].push(e);else{var s,i;if(void 0!==t)for(var a=document.getElementsByTagName("script"),o=0;o<a.length;o++){var l=a[o];if(l.getAttribute("src")==n){s=l;break}}s||(i=!0,(s=document.createElement("script")).charset="utf-8",s.timeout=120,__webpack_require__.nc&&s.setAttribute("nonce",__webpack_require__.nc),s.src=n),inProgress[n]=[e];var c=(e,t)=>{s.onerror=s.onload=null,clearTimeout(h);var r=inProgress[n];if(delete inProgress[n],s.parentNode&&s.parentNode.removeChild(s),r&&r.forEach((n=>n(t))),e)return e(t)},h=setTimeout(c.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=c.bind(null,s.onerror),s.onload=c.bind(null,s.onload),i&&document.head.appendChild(s)}},__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{var n;__webpack_require__.g.importScripts&&(n=__webpack_require__.g.location+"");var e=__webpack_require__.g.document;if(!n&&e&&(e.currentScript&&(n=e.currentScript.src),!n)){var t=e.getElementsByTagName("script");t.length&&(n=t[t.length-1].src)}if(!n)throw new Error("Automatic publicPath is not supported in this browser");n=n.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=n})(),(()=>{var n={179:0};__webpack_require__.f.j=(e,t)=>{var r=__webpack_require__.o(n,e)?n[e]:void 0;if(0!==r)if(r)t.push(r[2]);else{var s=new Promise(((t,s)=>r=n[e]=[t,s]));t.push(r[2]=s);var i=__webpack_require__.p+__webpack_require__.u(e),a=new Error;__webpack_require__.l(i,(t=>{if(__webpack_require__.o(n,e)&&(0!==(r=n[e])&&(n[e]=void 0),r)){var s=t&&("load"===t.type?"missing":t.type),i=t&&t.target&&t.target.src;a.message="Loading chunk "+e+" failed.\n("+s+": "+i+")",a.name="ChunkLoadError",a.type=s,a.request=i,r[1](a)}}),"chunk-"+e,e)}};var e=(e,t)=>{var r,s,[i,a,o]=t,l=0;if(i.some((e=>0!==n[e]))){for(r in a)__webpack_require__.o(a,r)&&(__webpack_require__.m[r]=a[r]);if(o)o(__webpack_require__)}for(e&&e(t);l<i.length;l++)s=i[l],__webpack_require__.o(n,s)&&n[s]&&n[s][0](),n[s]=0},t=self.webpackChunk=self.webpackChunk||[];t.forEach(e.bind(null,0)),t.push=e.bind(null,t.push.bind(t))})();var __webpack_exports__=__webpack_require__(860)})();